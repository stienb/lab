<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Playable Ad</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no">
    <meta name="HandheldFriendly" content="True">
    <meta http-equiv="cleartype" content="on">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta http-equiv="X-UA-Compatible" content="IE=10">
    <style>body,html{margin:0;padding:0}html{background-color:#000;overflow:hidden;width:100%;height:100%}body{height:inherit;width:inherit}*{-webkit-tap-highlight-color:transparent}</style>
</head>

<body>
    <script>new EventSource('/esbuild').addEventListener('change', () => location.reload());"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b2)) {
        if (__propIsEnum.call(b2, prop))
          __defNormalProp(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
  var __objRest = (source11, exclude) => {
    var target = {};
    for (var prop in source11)
      if (__hasOwnProp.call(source11, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source11[prop];
    if (source11 != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source11)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source11, prop))
          target[prop] = source11[prop];
      }
    return target;
  };
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __toBinary = Uint8Array.fromBase64 || /* @__PURE__ */ (() => {
    var table = new Uint8Array(128);
    for (var i3 = 0; i3 < 64; i3++) table[i3 < 26 ? i3 + 65 : i3 < 52 ? i3 + 71 : i3 < 62 ? i3 - 4 : i3 * 4 - 205] = i3;
    return (base64) => {
      var n2 = base64.length, bytes = new Uint8Array((n2 - (base64[n2 - 1] == "=") - (base64[n2 - 2] == "=")) * 3 / 4 | 0);
      for (var i4 = 0, j2 = 0; i4 < n2; ) {
        var c0 = table[base64.charCodeAt(i4++)], c1 = table[base64.charCodeAt(i4++)];
        var c2 = table[base64.charCodeAt(i4++)], c3 = table[base64.charCodeAt(i4++)];
        bytes[j2++] = c0 << 2 | c1 >> 4;
        bytes[j2++] = c1 << 4 | c2 >> 2;
        bytes[j2++] = c2 << 6 | c3;
      }
      return bytes;
    };
  })();

  // node_modules/pixi.js/lib/extensions/Extensions.mjs
  var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
  var init_Extensions = __esm({
    "node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
      "use strict";
      ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
        ExtensionType2["Application"] = "application";
        ExtensionType2["WebGLPipes"] = "webgl-pipes";
        ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
        ExtensionType2["WebGLSystem"] = "webgl-system";
        ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
        ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
        ExtensionType2["WebGPUSystem"] = "webgpu-system";
        ExtensionType2["CanvasSystem"] = "canvas-system";
        ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
        ExtensionType2["CanvasPipes"] = "canvas-pipes";
        ExtensionType2["Asset"] = "asset";
        ExtensionType2["LoadParser"] = "load-parser";
        ExtensionType2["ResolveParser"] = "resolve-parser";
        ExtensionType2["CacheParser"] = "cache-parser";
        ExtensionType2["DetectionParser"] = "detection-parser";
        ExtensionType2["MaskEffect"] = "mask-effect";
        ExtensionType2["BlendMode"] = "blend-mode";
        ExtensionType2["TextureSource"] = "texture-source";
        ExtensionType2["Environment"] = "environment";
        ExtensionType2["ShapeBuilder"] = "shape-builder";
        ExtensionType2["Batcher"] = "batcher";
        return ExtensionType2;
      })(ExtensionType || {});
      normalizeExtension = (ext) => {
        if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
          if (!ext.extension) {
            throw new Error("Extension class must have an extension object");
          }
          const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
          ext = __spreadProps(__spreadValues({}, metadata), { ref: ext });
        }
        if (typeof ext === "object") {
          ext = __spreadValues({}, ext);
        } else {
          throw new Error("Invalid extension type");
        }
        if (typeof ext.type === "string") {
          ext.type = [ext.type];
        }
        return ext;
      };
      normalizeExtensionPriority = (ext, defaultPriority) => {
        var _a2;
        return (_a2 = normalizeExtension(ext).priority) != null ? _a2 : defaultPriority;
      };
      extensions = {
        /** @ignore */
        _addHandlers: {},
        /** @ignore */
        _removeHandlers: {},
        /** @ignore */
        _queue: {},
        /**
         * Remove extensions from PixiJS.
         * @param extensions - Extensions to be removed. Can be:
         * - Extension class with static `extension` property
         * - Extension format object with `type` and `ref`
         * - Multiple extensions as separate arguments
         * @returns {extensions} this for chaining
         * @example
         * ```ts
         * // Remove a single extension
         * extensions.remove(MyRendererPlugin);
         *
         * // Remove multiple extensions
         * extensions.remove(
         *     MyRendererPlugin,
         *     MySystemPlugin
         * );
         * ```
         * @see {@link ExtensionType} For available extension types
         * @see {@link ExtensionFormat} For extension format details
         */
        remove(...extensions2) {
          extensions2.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => {
              var _a2, _b;
              return (_b = (_a2 = this._removeHandlers)[type]) == null ? void 0 : _b.call(_a2, ext);
            });
          });
          return this;
        },
        /**
         * Register new extensions with PixiJS. Extensions can be registered in multiple formats:
         * - As a class with a static `extension` property
         * - As an extension format object
         * - As multiple extensions passed as separate arguments
         * @param extensions - Extensions to add to PixiJS. Each can be:
         * - A class with static `extension` property
         * - An extension format object with `type` and `ref`
         * - Multiple extensions as separate arguments
         * @returns This extensions instance for chaining
         * @example
         * ```ts
         * // Register a simple extension
         * extensions.add(MyRendererPlugin);
         *
         * // Register multiple extensions
         * extensions.add(
         *     MyRendererPlugin,
         *     MySystemPlugin,
         * });
         * ```
         * @see {@link ExtensionType} For available extension types
         * @see {@link ExtensionFormat} For extension format details
         * @see {@link extensions.remove} For removing registered extensions
         */
        add(...extensions2) {
          extensions2.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => {
              var _a2, _b;
              const handlers = this._addHandlers;
              const queue = this._queue;
              if (!handlers[type]) {
                queue[type] = queue[type] || [];
                (_a2 = queue[type]) == null ? void 0 : _a2.push(ext);
              } else {
                (_b = handlers[type]) == null ? void 0 : _b.call(handlers, ext);
              }
            });
          });
          return this;
        },
        /**
         * Internal method to handle extensions by name.
         * @param type - The extension type.
         * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
         * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
         * @returns this for chaining.
         * @internal
         * @ignore
         */
        handle(type, onAdd, onRemove) {
          var _a2;
          const addHandlers = this._addHandlers;
          const removeHandlers = this._removeHandlers;
          if (addHandlers[type] || removeHandlers[type]) {
            throw new Error(`Extension type ${type} already has a handler`);
          }
          addHandlers[type] = onAdd;
          removeHandlers[type] = onRemove;
          const queue = this._queue;
          if (queue[type]) {
            (_a2 = queue[type]) == null ? void 0 : _a2.forEach((ext) => onAdd(ext));
            delete queue[type];
          }
          return this;
        },
        /**
         * Handle a type, but using a map by `name` property.
         * @param type - Type of extension to handle.
         * @param map - The object map of named extensions.
         * @returns this for chaining.
         * @ignore
         */
        handleByMap(type, map) {
          return this.handle(
            type,
            (extension) => {
              if (extension.name) {
                map[extension.name] = extension.ref;
              }
            },
            (extension) => {
              if (extension.name) {
                delete map[extension.name];
              }
            }
          );
        },
        /**
         * Handle a type, but using a list of extensions with a `name` property.
         * @param type - Type of extension to handle.
         * @param map - The array of named extensions.
         * @param defaultPriority - Fallback priority if none is defined.
         * @returns this for chaining.
         * @ignore
         */
        handleByNamedList(type, map, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              const index = map.findIndex((item) => item.name === extension.name);
              if (index >= 0)
                return;
              map.push({ name: extension.name, value: extension.ref });
              map.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
            },
            (extension) => {
              const index = map.findIndex((item) => item.name === extension.name);
              if (index !== -1) {
                map.splice(index, 1);
              }
            }
          );
        },
        /**
         * Handle a type, but using a list of extensions.
         * @param type - Type of extension to handle.
         * @param list - The list of extensions.
         * @param defaultPriority - The default priority to use if none is specified.
         * @returns this for chaining.
         * @ignore
         */
        handleByList(type, list, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              if (list.includes(extension.ref)) {
                return;
              }
              list.push(extension.ref);
              list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
            },
            (extension) => {
              const index = list.indexOf(extension.ref);
              if (index !== -1) {
                list.splice(index, 1);
              }
            }
          );
        },
        /**
         * Mixin the source object(s) properties into the target class's prototype.
         * Copies all property descriptors from source objects to the target's prototype.
         * @param Target - The target class to mix properties into
         * @param sources - One or more source objects containing properties to mix in
         * @example
         * ```ts
         * // Create a mixin with shared properties
         * const moveable = {
         *     x: 0,
         *     y: 0,
         *     move(x: number, y: number) {
         *         this.x += x;
         *         this.y += y;
         *     }
         * };
         *
         * // Create a mixin with computed properties
         * const scalable = {
         *     scale: 1,
         *     get scaled() {
         *         return this.scale > 1;
         *     }
         * };
         *
         * // Apply mixins to a class
         * extensions.mixin(Sprite, moveable, scalable);
         *
         * // Use mixed-in properties
         * const sprite = new Sprite();
         * sprite.move(10, 20);
         * console.log(sprite.x, sprite.y); // 10, 20
         * ```
         * @remarks
         * - Copies all properties including getters/setters
         * - Does not modify source objects
         * - Preserves property descriptors
         * @see {@link Object.defineProperties} For details on property descriptors
         * @see {@link Object.getOwnPropertyDescriptors} For details on property copying
         */
        mixin(Target, ...sources2) {
          for (const source11 of sources2) {
            Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source11));
          }
        }
      };
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context4, once) {
        this.fn = fn;
        this.context = context4;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context4, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context4 || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i3 = 0, l2 = handlers.length, ee = new Array(l2); i3 < l2; i3++) {
          ee[i3] = handlers[i3].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i3;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
            args[i3 - 1] = arguments[i3];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i3 = 0; i3 < length; i3++) {
            if (listeners[i3].once) this.removeListener(event, listeners[i3].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i3].fn.call(listeners[i3].context);
                break;
              case 2:
                listeners[i3].fn.call(listeners[i3].context, a1);
                break;
              case 3:
                listeners[i3].fn.call(listeners[i3].context, a1, a2);
                break;
              case 4:
                listeners[i3].fn.call(listeners[i3].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                  args[j2 - 1] = arguments[j2];
                }
                listeners[i3].fn.apply(listeners[i3].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context4) {
        return addListener(this, event, fn, context4, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context4) {
        return addListener(this, event, fn, context4, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context4, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context4 || listeners.context === context4)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
            if (listeners[i3].fn !== fn || once && !listeners[i3].once || context4 && listeners[i3].context !== context4) {
              events.push(listeners[i3]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/eventemitter3/index.mjs
  var import_index, eventemitter3_default;
  var init_eventemitter3 = __esm({
    "node_modules/eventemitter3/index.mjs"() {
      import_index = __toESM(require_eventemitter3(), 1);
      eventemitter3_default = import_index.default;
    }
  });

  // node_modules/@pixi/colord/index.mjs
  var r, t, n, e, u, a, o, i2, s, h, b, g, d, f, c, l, p2, v, m, y, N, x, M, H, $, j, w, S, k;
  var init_colord = __esm({
    "node_modules/@pixi/colord/index.mjs"() {
      r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
      t = function(r2) {
        return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
      };
      n = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
      };
      e = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
      };
      u = function(r2) {
        return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
      };
      a = function(r2) {
        return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
      };
      o = function(r2) {
        return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
      };
      i2 = /^#([0-9a-f]{3,8})$/i;
      s = function(r2) {
        var t2 = r2.toString(16);
        return t2.length < 2 ? "0" + t2 : t2;
      };
      h = function(r2) {
        var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i3 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
        return { h: 60 * (i3 < 0 ? i3 + 6 : i3), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
      };
      b = function(r2) {
        var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
        t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
        var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i3 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
        return { r: 255 * [e2, i3, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i3, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i3][h2], a: u2 };
      };
      g = function(r2) {
        return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
      };
      d = function(r2) {
        return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
      };
      f = function(r2) {
        return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
        var t2, n2, e2;
      };
      c = function(r2) {
        return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
        var t2, n2, e2, u2;
      };
      l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      p2 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      y = { string: [[function(r2) {
        var t2 = i2.exec(r2);
        return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
      }, "hex"], [function(r2) {
        var t2 = v.exec(r2) || m.exec(r2);
        return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
      }, "rgb"], [function(t2) {
        var n2 = l.exec(t2) || p2.exec(t2);
        if (!n2) return null;
        var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
        return f(a2);
      }, "hsl"]], object: [[function(r2) {
        var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i3 = void 0 === o2 ? 1 : o2;
        return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i3) }) : null;
      }, "rgb"], [function(r2) {
        var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
        if (!t(n2) || !t(e2) || !t(u2)) return null;
        var i3 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
        return f(i3);
      }, "hsl"], [function(r2) {
        var n2 = r2.h, a2 = r2.s, o2 = r2.v, i3 = r2.a, s2 = void 0 === i3 ? 1 : i3;
        if (!t(n2) || !t(a2) || !t(o2)) return null;
        var h2 = (function(r3) {
          return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
        })({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
        return b(h2);
      }, "hsv"]] };
      N = function(r2, t2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var e2 = t2[n2][0](r2);
          if (e2) return [e2, t2[n2][1]];
        }
        return [null, void 0];
      };
      x = function(r2) {
        return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
      };
      M = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
      };
      H = function(r2) {
        return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
      };
      $ = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
      };
      j = (function() {
        function r2(r3) {
          this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
        }
        return r2.prototype.isValid = function() {
          return null !== this.parsed;
        }, r2.prototype.brightness = function() {
          return n(H(this.rgba), 2);
        }, r2.prototype.isDark = function() {
          return H(this.rgba) < 0.5;
        }, r2.prototype.isLight = function() {
          return H(this.rgba) >= 0.5;
        }, r2.prototype.toHex = function() {
          return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i3 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i3;
          var r3, t2, e2, u2, a2, i3;
        }, r2.prototype.toRgb = function() {
          return o(this.rgba);
        }, r2.prototype.toRgbString = function() {
          return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsl = function() {
          return d(c(this.rgba));
        }, r2.prototype.toHslString = function() {
          return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsv = function() {
          return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
          var r3;
        }, r2.prototype.invert = function() {
          return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
          var r3;
        }, r2.prototype.saturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
        }, r2.prototype.desaturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
        }, r2.prototype.grayscale = function() {
          return w(M(this.rgba, -1));
        }, r2.prototype.lighten = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
        }, r2.prototype.darken = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
        }, r2.prototype.rotate = function(r3) {
          return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
        }, r2.prototype.alpha = function(r3) {
          return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
          var t2;
        }, r2.prototype.hue = function(r3) {
          var t2 = c(this.rgba);
          return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
        }, r2.prototype.isEqual = function(r3) {
          return this.toHex() === w(r3).toHex();
        }, r2;
      })();
      w = function(r2) {
        return r2 instanceof j ? r2 : new j(r2);
      };
      S = [];
      k = function(r2) {
        r2.forEach(function(r3) {
          S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
        });
      };
    }
  });

  // node_modules/@pixi/colord/plugins/names.mjs
  function names_default(e2, f2) {
    var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
    for (var d2 in a2) r2[a2[d2]] = d2;
    var l2 = {};
    e2.prototype.toName = function(f3) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var d3, i3, n2 = r2[this.toHex()];
      if (n2) return n2;
      if (null == f3 ? void 0 : f3.closest) {
        var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
        if (!l2.length) for (var c2 in a2) l2[c2] = new e2(a2[c2]).toRgb();
        for (var g2 in a2) {
          var u2 = (d3 = o2, i3 = l2[g2], Math.pow(d3.r - i3.r, 2) + Math.pow(d3.g - i3.g, 2) + Math.pow(d3.b - i3.b, 2));
          u2 < t2 && (t2 = u2, b2 = g2);
        }
        return b2;
      }
    };
    f2.string.push([function(f3) {
      var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
      return d3 ? new e2(d3).toRgb() : null;
    }, "name"]);
  }
  var init_names = __esm({
    "node_modules/@pixi/colord/plugins/names.mjs"() {
    }
  });

  // node_modules/pixi.js/lib/color/Color.mjs
  var _Color, Color;
  var init_Color = __esm({
    "node_modules/pixi.js/lib/color/Color.mjs"() {
      init_colord();
      init_names();
      k([names_default]);
      _Color = class _Color2 {
        /**
         * @param {ColorSource} value - Optional value to use, if not provided, white is used.
         */
        constructor(value = 16777215) {
          this._value = null;
          this._components = new Float32Array(4);
          this._components.fill(1);
          this._int = 16777215;
          this.value = value;
        }
        /**
         * Get the red component of the color, normalized between 0 and 1.
         * @example
         * ```ts
         * const color = new Color('red');
         * console.log(color.red); // 1
         *
         * const green = new Color('#00ff00');
         * console.log(green.red); // 0
         * ```
         */
        get red() {
          return this._components[0];
        }
        /**
         * Get the green component of the color, normalized between 0 and 1.
         * @example
         * ```ts
         * const color = new Color('lime');
         * console.log(color.green); // 1
         *
         * const red = new Color('#ff0000');
         * console.log(red.green); // 0
         * ```
         */
        get green() {
          return this._components[1];
        }
        /**
         * Get the blue component of the color, normalized between 0 and 1.
         * @example
         * ```ts
         * const color = new Color('blue');
         * console.log(color.blue); // 1
         *
         * const yellow = new Color('#ffff00');
         * console.log(yellow.blue); // 0
         * ```
         */
        get blue() {
          return this._components[2];
        }
        /**
         * Get the alpha component of the color, normalized between 0 and 1.
         * @example
         * ```ts
         * const color = new Color('red');
         * console.log(color.alpha); // 1 (fully opaque)
         *
         * const transparent = new Color('rgba(255, 0, 0, 0.5)');
         * console.log(transparent.alpha); // 0.5 (semi-transparent)
         * ```
         */
        get alpha() {
          return this._components[3];
        }
        /**
         * Sets the color value and returns the instance for chaining.
         *
         * This is a chainable version of setting the `value` property.
         * @param value - The color to set. Accepts various formats:
         * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
         * - RGB/RGBA values (arrays, objects)
         * - CSS color names
         * - HSL/HSLA values
         * - HSV/HSVA values
         * @returns The Color instance for chaining
         * @example
         * ```ts
         * // Basic usage
         * const color = new Color();
         * color.setValue('#ff0000')
         *     .setAlpha(0.5)
         *     .premultiply(0.8);
         *
         * // Different formats
         * color.setValue(0xff0000);          // Hex number
         * color.setValue('#ff0000');         // Hex string
         * color.setValue([1, 0, 0]);         // RGB array
         * color.setValue([1, 0, 0, 0.5]);    // RGBA array
         * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object
         *
         * // Copy from another color
         * const red = new Color('red');
         * color.setValue(red);
         * ```
         * @throws {Error} If the color value is invalid or null
         * @see {@link Color.value} For the underlying value property
         */
        setValue(value) {
          this.value = value;
          return this;
        }
        /**
         * The current color source. This property allows getting and setting the color value
         * while preserving the original format where possible.
         * @remarks
         * When setting:
         * - Setting to a `Color` instance copies its source and components
         * - Setting to other valid sources normalizes and stores the value
         * - Setting to `null` throws an Error
         * - The color remains unchanged if normalization fails
         *
         * When getting:
         * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}
         * - Otherwise returns the original color source
         * @example
         * ```ts
         * // Setting different color formats
         * const color = new Color();
         *
         * color.value = 0xff0000;         // Hex number
         * color.value = '#ff0000';        // Hex string
         * color.value = [1, 0, 0];        // RGB array
         * color.value = [1, 0, 0, 0.5];   // RGBA array
         * color.value = { r: 1, g: 0, b: 0 }; // RGB object
         *
         * // Copying from another color
         * const red = new Color('red');
         * color.value = red;  // Copies red's components
         *
         * // Getting the value
         * console.log(color.value);  // Returns original format
         *
         * // After modifications
         * color.multiply([0.5, 0.5, 0.5]);
         * console.log(color.value);  // Returns null
         * ```
         * @throws {Error} When attempting to set `null`
         */
        set value(value) {
          if (value instanceof _Color2) {
            this._value = this._cloneSource(value._value);
            this._int = value._int;
            this._components.set(value._components);
          } else if (value === null) {
            throw new Error("Cannot set Color#value to null");
          } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
            this._value = this._cloneSource(value);
            this._normalize(this._value);
          }
        }
        get value() {
          return this._value;
        }
        /**
         * Copy a color source internally.
         * @param value - Color source
         */
        _cloneSource(value) {
          if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
            return value;
          } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
            return value.slice(0);
          } else if (typeof value === "object" && value !== null) {
            return __spreadValues({}, value);
          }
          return value;
        }
        /**
         * Equality check for color sources.
         * @param value1 - First color source
         * @param value2 - Second color source
         * @returns `true` if the color sources are equal, `false` otherwise.
         */
        _isSourceEqual(value1, value2) {
          const type1 = typeof value1;
          const type2 = typeof value2;
          if (type1 !== type2) {
            return false;
          } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
            return value1 === value2;
          } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
            if (value1.length !== value2.length) {
              return false;
            }
            return value1.every((v2, i3) => v2 === value2[i3]);
          } else if (value1 !== null && value2 !== null) {
            const keys1 = Object.keys(value1);
            const keys2 = Object.keys(value2);
            if (keys1.length !== keys2.length) {
              return false;
            }
            return keys1.every((key) => value1[key] === value2[key]);
          }
          return value1 === value2;
        }
        /**
         * Convert to a RGBA color object with normalized components (0-1).
         * @example
         * ```ts
         * import { Color } from 'pixi.js';
         *
         * // Convert colors to RGBA objects
         * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }
         * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }
         *
         * // With transparency
         * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }
         * ```
         * @returns An RGBA object with normalized components
         */
        toRgba() {
          const [r2, g2, b2, a2] = this._components;
          return { r: r2, g: g2, b: b2, a: a2 };
        }
        /**
         * Convert to a RGB color object with normalized components (0-1).
         *
         * Alpha component is omitted in the output.
         * @example
         * ```ts
         * import { Color } from 'pixi.js';
         *
         * // Convert colors to RGB objects
         * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }
         * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }
         *
         * // Alpha is ignored
         * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }
         * ```
         * @returns An RGB object with normalized components
         */
        toRgb() {
          const [r2, g2, b2] = this._components;
          return { r: r2, g: g2, b: b2 };
        }
        /**
         * Convert to a CSS-style rgba string representation.
         *
         * RGB components are scaled to 0-255 range, alpha remains 0-1.
         * @example
         * ```ts
         * import { Color } from 'pixi.js';
         *
         * // Convert colors to RGBA strings
         * new Color('white').toRgbaString();     // returns "rgba(255,255,255,1)"
         * new Color('#ff0000').toRgbaString();   // returns "rgba(255,0,0,1)"
         *
         * // With transparency
         * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns "rgba(255,0,0,0.5)"
         * ```
         * @returns A CSS-compatible rgba string
         */
        toRgbaString() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return `rgba(${r2},${g2},${b2},${this.alpha})`;
        }
        /**
         * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).
         * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,
         * a cached array will be used and returned.
         * @returns Array containing RGB components as integers between 0-255
         * @example
         * ```ts
         * // Basic usage
         * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]
         * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]
         *
         * // Using custom output array
         * const rgb = new Uint8Array(3);
         * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]
         *
         * // Using different array types
         * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]
         * new Color('red').toUint8RgbArray([]); // [255, 0, 0]
         * ```
         * @remarks
         * - Output values are always clamped between 0-255
         * - Alpha component is not included in output
         * - Reuses internal cache array if no output array provided
         */
        toUint8RgbArray(out2) {
          const [r2, g2, b2] = this._components;
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 || (out2 = this._arrayRgb);
          out2[0] = Math.round(r2 * 255);
          out2[1] = Math.round(g2 * 255);
          out2[2] = Math.round(b2 * 255);
          return out2;
        }
        /**
         * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).
         * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
         * a cached array will be used and returned.
         * @returns Array containing RGBA components as floats between 0-1
         * @example
         * ```ts
         * // Basic usage
         * new Color('white').toArray();  // returns [1, 1, 1, 1]
         * new Color('red').toArray();    // returns [1, 0, 0, 1]
         *
         * // With alpha
         * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]
         *
         * // Using custom output array
         * const rgba = new Float32Array(4);
         * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]
         * ```
         * @remarks
         * - Output values are normalized between 0-1
         * - Includes alpha component as the fourth value
         * - Reuses internal cache array if no output array provided
         */
        toArray(out2) {
          if (!this._arrayRgba) {
            this._arrayRgba = [];
          }
          out2 || (out2 = this._arrayRgba);
          const [r2, g2, b2, a2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          out2[3] = a2;
          return out2;
        }
        /**
         * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
         * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
         * a cached array will be used and returned.
         * @returns Array containing RGB components as floats between 0-1
         * @example
         * ```ts
         * // Basic usage
         * new Color('white').toRgbArray(); // returns [1, 1, 1]
         * new Color('red').toRgbArray();   // returns [1, 0, 0]
         *
         * // Using custom output array
         * const rgb = new Float32Array(3);
         * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]
         * ```
         * @remarks
         * - Output values are normalized between 0-1
         * - Alpha component is omitted from output
         * - Reuses internal cache array if no output array provided
         */
        toRgbArray(out2) {
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 || (out2 = this._arrayRgb);
          const [r2, g2, b2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          return out2;
        }
        /**
         * Convert to a hexadecimal number.
         * @returns The color as a 24-bit RGB integer
         * @example
         * ```ts
         * // Basic usage
         * new Color('white').toNumber(); // returns 0xffffff
         * new Color('red').toNumber();   // returns 0xff0000
         *
         * // Store as hex
         * const color = new Color('blue');
         * const hex = color.toNumber(); // 0x0000ff
         * ```
         */
        toNumber() {
          return this._int;
        }
        /**
         * Convert to a BGR number.
         *
         * Useful for platforms that expect colors in BGR format.
         * @returns The color as a 24-bit BGR integer
         * @example
         * ```ts
         * // Convert RGB to BGR
         * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
         *
         * // Common use case: platform-specific color format
         * const color = new Color('orange');
         * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels
         * ```
         * @remarks
         * This swaps the red and blue channels compared to the normal RGB format:
         * - RGB 0xRRGGBB becomes BGR 0xBBGGRR
         */
        toBgrNumber() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return (b2 << 16) + (g2 << 8) + r2;
        }
        /**
         * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
         *
         * Useful for platforms that expect colors in little endian byte order.
         * @example
         * ```ts
         * import { Color } from 'pixi.js';
         *
         * // Convert RGB color to little endian format
         * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
         *
         * // Common use cases:
         * const color = new Color('orange');
         * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems
         *
         * // Multiple conversions
         * const colors = {
         *     normal: 0xffcc99,
         *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff
         *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99
         * };
         * ```
         * @remarks
         * - Swaps R and B channels in the color value
         * - RGB 0xRRGGBB becomes 0xBBGGRR
         * - Useful for systems that use little endian byte order
         * - Can be used to convert back and forth between formats
         * @returns The color as a number in little endian format (BBGGRR)
         * @see {@link Color.toBgrNumber} For BGR format without byte swapping
         */
        toLittleEndianNumber() {
          const value = this._int;
          return (value >> 16) + (value & 65280) + ((value & 255) << 16);
        }
        /**
         * Multiply with another color.
         *
         * This action is destructive and modifies the original color.
         * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:
         * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
         * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])
         * - Color objects ({ r: 1, g: 0, b: 0 })
         * - CSS color names ('red', 'blue')
         * @returns this - The Color instance for chaining
         * @example
         * ```ts
         * // Basic multiplication
         * const color = new Color('#ff0000');
         * color.multiply(0x808080); // 50% darker red
         *
         * // With transparency
         * color.multiply([1, 1, 1, 0.5]); // 50% transparent
         *
         * // Chain operations
         * color
         *     .multiply('#808080')
         *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });
         * ```
         * @remarks
         * - Multiplies each RGB component and alpha separately
         * - Values are clamped between 0-1
         * - Original color format is lost (value becomes null)
         * - Operation cannot be undone
         */
        multiply(value) {
          const [r2, g2, b2, a2] = _Color2._temp.setValue(value)._components;
          this._components[0] *= r2;
          this._components[1] *= g2;
          this._components[2] *= b2;
          this._components[3] *= a2;
          this._refreshInt();
          this._value = null;
          return this;
        }
        /**
         * Converts color to a premultiplied alpha format.
         *
         * This action is destructive and modifies the original color.
         * @param alpha - The alpha value to multiply by (0-1)
         * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
         * @returns {Color} The Color instance for chaining
         * @example
         * ```ts
         * // Basic premultiplication
         * const color = new Color('red');
         * color.premultiply(0.5); // 50% transparent red with premultiplied RGB
         *
         * // Alpha only (RGB unchanged)
         * color.premultiply(0.5, false); // 50% transparent, original RGB
         *
         * // Chain with other operations
         * color
         *     .multiply(0x808080)
         *     .premultiply(0.5)
         *     .toNumber();
         * ```
         * @remarks
         * - RGB channels are multiplied by alpha when applyToRGB is true
         * - Alpha is always set to the provided value
         * - Values are clamped between 0-1
         * - Original color format is lost (value becomes null)
         * - Operation cannot be undone
         */
        premultiply(alpha, applyToRGB = true) {
          if (applyToRGB) {
            this._components[0] *= alpha;
            this._components[1] *= alpha;
            this._components[2] *= alpha;
          }
          this._components[3] = alpha;
          this._refreshInt();
          this._value = null;
          return this;
        }
        /**
         * Returns the color as a 32-bit premultiplied alpha integer.
         *
         * Format: 0xAARRGGBB
         * @param {number} alpha - The alpha value to multiply by (0-1)
         * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
         * @returns {number} The premultiplied color as a 32-bit integer
         * @example
         * ```ts
         * // Convert to premultiplied format
         * const color = new Color('red');
         *
         * // Full opacity (0xFFRRGGBB)
         * color.toPremultiplied(1.0); // 0xFFFF0000
         *
         * // 50% transparency with premultiplied RGB
         * color.toPremultiplied(0.5); // 0x7F7F0000
         *
         * // 50% transparency without RGB premultiplication
         * color.toPremultiplied(0.5, false); // 0x7FFF0000
         * ```
         * @remarks
         * - Returns full opacity (0xFF000000) when alpha is 1.0
         * - Returns 0 when alpha is 0.0 and applyToRGB is true
         * - RGB values are rounded during premultiplication
         */
        toPremultiplied(alpha, applyToRGB = true) {
          if (alpha === 1) {
            return (255 << 24) + this._int;
          }
          if (alpha === 0) {
            return applyToRGB ? 0 : this._int;
          }
          let r2 = this._int >> 16 & 255;
          let g2 = this._int >> 8 & 255;
          let b2 = this._int & 255;
          if (applyToRGB) {
            r2 = r2 * alpha + 0.5 | 0;
            g2 = g2 * alpha + 0.5 | 0;
            b2 = b2 * alpha + 0.5 | 0;
          }
          return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
        }
        /**
         * Convert to a hexadecimal string (6 characters).
         * @returns A CSS-compatible hex color string (e.g., "#ff0000")
         * @example
         * ```ts
         * import { Color } from 'pixi.js';
         *
         * // Basic colors
         * new Color('red').toHex();    // returns "#ff0000"
         * new Color('white').toHex();  // returns "#ffffff"
         * new Color('black').toHex();  // returns "#000000"
         *
         * // From different formats
         * new Color(0xff0000).toHex(); // returns "#ff0000"
         * new Color([1, 0, 0]).toHex(); // returns "#ff0000"
         * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns "#ff0000"
         * ```
         * @remarks
         * - Always returns a 6-character hex string
         * - Includes leading "#" character
         * - Alpha channel is ignored
         * - Values are rounded to nearest hex value
         */
        toHex() {
          const hexString = this._int.toString(16);
          return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
        }
        /**
         * Convert to a hexadecimal string with alpha (8 characters).
         * @returns A CSS-compatible hex color string with alpha (e.g., "#ff0000ff")
         * @example
         * ```ts
         * import { Color } from 'pixi.js';
         *
         * // Fully opaque colors
         * new Color('red').toHexa();   // returns "#ff0000ff"
         * new Color('white').toHexa(); // returns "#ffffffff"
         *
         * // With transparency
         * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns "#ff00007f"
         * new Color([1, 0, 0, 0]).toHexa(); // returns "#ff000000"
         * ```
         * @remarks
         * - Returns an 8-character hex string
         * - Includes leading "#" character
         * - Alpha is encoded in last two characters
         * - Values are rounded to nearest hex value
         */
        toHexa() {
          const alphaValue = Math.round(this._components[3] * 255);
          const alphaString = alphaValue.toString(16);
          return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
        }
        /**
         * Set alpha (transparency) value while preserving color components.
         *
         * Provides a chainable interface for setting alpha.
         * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)
         * @returns The Color instance for chaining
         * @example
         * ```ts
         * // Basic alpha setting
         * const color = new Color('red');
         * color.setAlpha(0.5);  // 50% transparent red
         *
         * // Chain with other operations
         * color
         *     .setValue('#ff0000')
         *     .setAlpha(0.8)    // 80% opaque
         *     .premultiply(0.5); // Further modify alpha
         *
         * // Reset to fully opaque
         * color.setAlpha(1);
         * ```
         * @remarks
         * - Alpha value is clamped between 0-1
         * - Can be chained with other color operations
         */
        setAlpha(alpha) {
          this._components[3] = this._clamp(alpha);
          return this;
        }
        /**
         * Normalize the input value into rgba
         * @param value - Input value
         */
        _normalize(value) {
          let r2;
          let g2;
          let b2;
          let a2;
          if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
            const int = value;
            r2 = (int >> 16 & 255) / 255;
            g2 = (int >> 8 & 255) / 255;
            b2 = (int & 255) / 255;
            a2 = 1;
          } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value);
            [r2, g2, b2, a2 = 1] = value;
          } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value, 0, 255);
            [r2, g2, b2, a2 = 255] = value;
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
            a2 /= 255;
          } else if (typeof value === "string" || typeof value === "object") {
            if (typeof value === "string") {
              const match = _Color2.HEX_PATTERN.exec(value);
              if (match) {
                value = `#${match[2]}`;
              }
            }
            const color = w(value);
            if (color.isValid()) {
              ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
              r2 /= 255;
              g2 /= 255;
              b2 /= 255;
            }
          }
          if (r2 !== void 0) {
            this._components[0] = r2;
            this._components[1] = g2;
            this._components[2] = b2;
            this._components[3] = a2;
            this._refreshInt();
          } else {
            throw new Error(`Unable to convert color ${value}`);
          }
        }
        /** Refresh the internal color rgb number */
        _refreshInt() {
          this._clamp(this._components);
          const [r2, g2, b2] = this._components;
          this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
        }
        /**
         * Clamps values to a range. Will override original values
         * @param value - Value(s) to clamp
         * @param min - Minimum value
         * @param max - Maximum value
         */
        _clamp(value, min = 0, max = 1) {
          if (typeof value === "number") {
            return Math.min(Math.max(value, min), max);
          }
          value.forEach((v2, i3) => {
            value[i3] = Math.min(Math.max(v2, min), max);
          });
          return value;
        }
        /**
         * Check if a value can be interpreted as a valid color format.
         * Supports all color formats that can be used with the Color class.
         * @param value - Value to check
         * @returns True if the value can be used as a color
         * @example
         * ```ts
         * import { Color } from 'pixi.js';
         *
         * // CSS colors and hex values
         * Color.isColorLike('red');          // true
         * Color.isColorLike('#ff0000');      // true
         * Color.isColorLike(0xff0000);       // true
         *
         * // Arrays (RGB/RGBA)
         * Color.isColorLike([1, 0, 0]);      // true
         * Color.isColorLike([1, 0, 0, 0.5]); // true
         *
         * // TypedArrays
         * Color.isColorLike(new Float32Array([1, 0, 0]));          // true
         * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true
         * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true
         *
         * // Object formats
         * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)
         * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)
         * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)
         * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)
         * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)
         * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)
         *
         * // Color instances
         * Color.isColorLike(new Color('red')); // true
         *
         * // Invalid values
         * Color.isColorLike(null);           // false
         * Color.isColorLike(undefined);      // false
         * Color.isColorLike({});             // false
         * Color.isColorLike([]);             // false
         * Color.isColorLike('not-a-color');  // false
         * ```
         * @remarks
         * Checks for the following formats:
         * - Numbers (0x000000 to 0xffffff)
         * - CSS color strings
         * - RGB/RGBA arrays and objects
         * - HSL/HSLA objects
         * - HSV/HSVA objects
         * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)
         * - Color instances
         * @see {@link ColorSource} For supported color format types
         * @see {@link Color.setValue} For setting color values
         * @category utility
         */
        static isColorLike(value) {
          return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color2 || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
        }
      };
      _Color.shared = new _Color();
      _Color._temp = new _Color();
      _Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
      Color = _Color;
    }
  });

  // node_modules/pixi.js/lib/culling/cullingMixin.mjs
  var cullingMixin;
  var init_cullingMixin = __esm({
    "node_modules/pixi.js/lib/culling/cullingMixin.mjs"() {
      "use strict";
      cullingMixin = {
        cullArea: null,
        cullable: false,
        cullableChildren: true
      };
    }
  });

  // node_modules/pixi.js/lib/maths/misc/const.mjs
  var PI_2, RAD_TO_DEG, DEG_TO_RAD;
  var init_const = __esm({
    "node_modules/pixi.js/lib/maths/misc/const.mjs"() {
      "use strict";
      PI_2 = Math.PI * 2;
      RAD_TO_DEG = 180 / Math.PI;
      DEG_TO_RAD = Math.PI / 180;
    }
  });

  // node_modules/pixi.js/lib/maths/point/Point.mjs
  var Point, tempPoint;
  var init_Point = __esm({
    "node_modules/pixi.js/lib/maths/point/Point.mjs"() {
      "use strict";
      Point = class _Point {
        /**
         * Creates a new `Point`
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        constructor(x2 = 0, y2 = 0) {
          this.x = 0;
          this.y = 0;
          this.x = x2;
          this.y = y2;
        }
        /**
         * Creates a clone of this point, which is a new instance with the same `x` and `y` values.
         * @example
         * ```ts
         * // Basic point cloning
         * const original = new Point(100, 200);
         * const copy = original.clone();
         *
         * // Clone and modify
         * const modified = original.clone();
         * modified.set(300, 400);
         *
         * // Verify independence
         * console.log(original); // Point(100, 200)
         * console.log(modified); // Point(300, 400)
         * ```
         * @remarks
         * - Creates new Point instance
         * - Deep copies x and y values
         * - Independent from original
         * - Useful for preserving values
         * @returns A clone of this point
         * @see {@link Point.copyFrom} For copying into existing point
         * @see {@link Point.copyTo} For copying to existing point
         */
        clone() {
          return new _Point(this.x, this.y);
        }
        /**
         * Copies x and y from the given point into this point.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Point(100, 200);
         * const target = new Point();
         * target.copyFrom(source);
         *
         * // Copy and chain operations
         * const point = new Point()
         *     .copyFrom(source)
         *     .set(x + 50, y + 50);
         *
         * // Copy from any PointData
         * const data = { x: 10, y: 20 };
         * point.copyFrom(data);
         * ```
         * @param p - The point to copy from
         * @returns The point instance itself
         * @see {@link Point.copyTo} For copying to another point
         * @see {@link Point.clone} For creating new point copy
         */
        copyFrom(p3) {
          this.set(p3.x, p3.y);
          return this;
        }
        /**
         * Copies this point's x and y into the given point.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Point(100, 200);
         * const target = new Point();
         * source.copyTo(target);
         * ```
         * @param p - The point to copy to. Can be any type that is or extends `PointLike`
         * @returns The point (`p`) with values updated
         * @see {@link Point.copyFrom} For copying from another point
         * @see {@link Point.clone} For creating new point copy
         */
        copyTo(p3) {
          p3.set(this.x, this.y);
          return p3;
        }
        /**
         * Checks if another point is equal to this point.
         *
         * Compares x and y values using strict equality.
         * @example
         * ```ts
         * // Basic equality check
         * const p1 = new Point(100, 200);
         * const p2 = new Point(100, 200);
         * console.log(p1.equals(p2)); // true
         *
         * // Compare with PointData
         * const data = { x: 100, y: 200 };
         * console.log(p1.equals(data)); // true
         *
         * // Check different points
         * const p3 = new Point(200, 300);
         * console.log(p1.equals(p3)); // false
         * ```
         * @param p - The point to check
         * @returns `true` if both `x` and `y` are equal
         * @see {@link Point.copyFrom} For making points equal
         * @see {@link PointData} For point data interface
         */
        equals(p3) {
          return p3.x === this.x && p3.y === this.y;
        }
        /**
         * Sets the point to a new x and y position.
         *
         * If y is omitted, both x and y will be set to x.
         * @example
         * ```ts
         * // Basic position setting
         * const point = new Point();
         * point.set(100, 200);
         *
         * // Set both x and y to same value
         * point.set(50); // x=50, y=50
         *
         * // Chain with other operations
         * point
         *     .set(10, 20)
         *     .copyTo(otherPoint);
         * ```
         * @param x - Position on the x axis
         * @param y - Position on the y axis, defaults to x
         * @returns The point instance itself
         * @see {@link Point.copyFrom} For copying from another point
         * @see {@link Point.equals} For comparing positions
         */
        set(x2 = 0, y2 = x2) {
          this.x = x2;
          this.y = y2;
          return this;
        }
        toString() {
          return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
        }
        /**
         * A static Point object with `x` and `y` values of `0`.
         *
         * This shared instance is reset to zero values when accessed.
         *
         * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.
         * @example
         * ```ts
         * // Use for temporary calculations
         * const tempPoint = Point.shared;
         * tempPoint.set(100, 200);
         * matrix.apply(tempPoint);
         *
         * // Will be reset to (0,0) on next access
         * const fresh = Point.shared; // x=0, y=0
         * ```
         * @readonly
         * @returns A fresh zeroed point for temporary use
         * @see {@link Point.constructor} For creating new points
         * @see {@link PointData} For basic point interface
         */
        static get shared() {
          tempPoint.x = 0;
          tempPoint.y = 0;
          return tempPoint;
        }
      };
      tempPoint = new Point();
    }
  });

  // node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
  var Matrix, tempMatrix, identityMatrix;
  var init_Matrix = __esm({
    "node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"() {
      init_const();
      init_Point();
      Matrix = class _Matrix {
        /**
         * @param a - x scale
         * @param b - y skew
         * @param c - x skew
         * @param d - y scale
         * @param tx - x translation
         * @param ty - y translation
         */
        constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
          this.array = null;
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
        }
        /**
         * Creates a Matrix object based on the given array.
         * Populates matrix components from a flat array in column-major order.
         *
         * > [!NOTE] Array mapping order:
         * > ```
         * > array[0] = a  (x scale)
         * > array[1] = b  (y skew)
         * > array[2] = tx (x translation)
         * > array[3] = c  (x skew)
         * > array[4] = d  (y scale)
         * > array[5] = ty (y translation)
         * > ```
         * @example
         * ```ts
         * // Create matrix from array
         * const matrix = new Matrix();
         * matrix.fromArray([
         *     2, 0,  100,  // a, b, tx
         *     0, 2,  100   // c, d, ty
         * ]);
         *
         * // Create matrix from typed array
         * const float32Array = new Float32Array([
         *     1, 0, 0,     // Scale x1, no skew
         *     0, 1, 0      // No skew, scale x1
         * ]);
         * matrix.fromArray(float32Array);
         * ```
         * @param array - The array to populate the matrix from
         * @see {@link Matrix.toArray} For converting matrix to array
         * @see {@link Matrix.set} For setting values directly
         */
        fromArray(array) {
          this.a = array[0];
          this.b = array[1];
          this.c = array[3];
          this.d = array[4];
          this.tx = array[2];
          this.ty = array[5];
        }
        /**
         * Sets the matrix properties directly.
         * All matrix components can be set in one call.
         * @example
         * ```ts
         * // Set to identity matrix
         * matrix.set(1, 0, 0, 1, 0, 0);
         *
         * // Set to scale matrix
         * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x
         *
         * // Set to translation matrix
         * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50
         * ```
         * @param a - Scale on x axis
         * @param b - Shear on y axis
         * @param c - Shear on x axis
         * @param d - Scale on y axis
         * @param tx - Translation on x axis
         * @param ty - Translation on y axis
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.identity} For resetting to identity
         * @see {@link Matrix.fromArray} For setting from array
         */
        set(a2, b2, c2, d2, tx, ty) {
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
          return this;
        }
        /**
         * Creates an array from the current Matrix object.
         *
         * > [!NOTE] The array format is:
         * > ```
         * > Non-transposed:
         * > [a, c, tx,
         * > b, d, ty,
         * > 0, 0, 1]
         * >
         * > Transposed:
         * > [a, b, 0,
         * > c, d, 0,
         * > tx,ty,1]
         * > ```
         * @example
         * ```ts
         * // Basic array conversion
         * const matrix = new Matrix(2, 0, 0, 2, 100, 100);
         * const array = matrix.toArray();
         *
         * // Using existing array
         * const float32Array = new Float32Array(9);
         * matrix.toArray(false, float32Array);
         *
         * // Get transposed array
         * const transposed = matrix.toArray(true);
         * ```
         * @param transpose - Whether to transpose the matrix
         * @param out - Optional Float32Array to store the result
         * @returns The array containing the matrix values
         * @see {@link Matrix.fromArray} For creating matrix from array
         * @see {@link Matrix.array} For cached array storage
         */
        toArray(transpose, out2) {
          if (!this.array) {
            this.array = new Float32Array(9);
          }
          const array = out2 || this.array;
          if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
          } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
          }
          return array;
        }
        /**
         * Get a new position with the current transformation applied.
         *
         * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
         * @example
         * ```ts
         * // Basic point transformation
         * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
         * const point = new Point(10, 20);
         * const transformed = matrix.apply(point);
         *
         * // Reuse existing point
         * const output = new Point();
         * matrix.apply(point, output);
         * ```
         * @param pos - The origin point to transform
         * @param newPos - Optional point to store the result
         * @returns The transformed point
         * @see {@link Matrix.applyInverse} For inverse transformation
         * @see {@link Point} For point operations
         */
        apply(pos, newPos) {
          newPos = newPos || new Point();
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = this.a * x2 + this.c * y2 + this.tx;
          newPos.y = this.b * x2 + this.d * y2 + this.ty;
          return newPos;
        }
        /**
         * Get a new position with the inverse of the current transformation applied.
         *
         * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
         * @example
         * ```ts
         * // Basic inverse transformation
         * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
         * const worldPoint = new Point(150, 100);
         * const localPoint = matrix.applyInverse(worldPoint);
         *
         * // Reuse existing point
         * const output = new Point();
         * matrix.applyInverse(worldPoint, output);
         *
         * // Convert mouse position to local space
         * const mousePoint = new Point(mouseX, mouseY);
         * const localMouse = matrix.applyInverse(mousePoint);
         * ```
         * @param pos - The origin point to inverse-transform
         * @param newPos - Optional point to store the result
         * @returns The inverse-transformed point
         * @see {@link Matrix.apply} For forward transformation
         * @see {@link Matrix.invert} For getting inverse matrix
         */
        applyInverse(pos, newPos) {
          newPos = newPos || new Point();
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const tx = this.tx;
          const ty = this.ty;
          const id = 1 / (a2 * d2 + c2 * -b2);
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = d2 * id * x2 + -c2 * id * y2 + (ty * c2 - tx * d2) * id;
          newPos.y = a2 * id * y2 + -b2 * id * x2 + (-ty * a2 + tx * b2) * id;
          return newPos;
        }
        /**
         * Translates the matrix on the x and y axes.
         * Adds to the position values while preserving scale, rotation and skew.
         * @example
         * ```ts
         * // Basic translation
         * const matrix = new Matrix();
         * matrix.translate(100, 50); // Move right 100, down 50
         *
         * // Chain with other transformations
         * matrix
         *     .scale(2, 2)
         *     .translate(100, 0)
         *     .rotate(Math.PI / 4);
         * ```
         * @param x - How much to translate on the x axis
         * @param y - How much to translate on the y axis
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.set} For setting position directly
         * @see {@link Matrix.setTransform} For complete transform setup
         */
        translate(x2, y2) {
          this.tx += x2;
          this.ty += y2;
          return this;
        }
        /**
         * Applies a scale transformation to the matrix.
         * Multiplies the scale values with existing matrix components.
         * @example
         * ```ts
         * // Basic scaling
         * const matrix = new Matrix();
         * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically
         *
         * // Chain with other transformations
         * matrix
         *     .translate(100, 100)
         *     .scale(2, 2)     // Scales after translation
         *     .rotate(Math.PI / 4);
         * ```
         * @param x - The amount to scale horizontally
         * @param y - The amount to scale vertically
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.setTransform} For setting scale directly
         * @see {@link Matrix.append} For combining transformations
         */
        scale(x2, y2) {
          this.a *= x2;
          this.d *= y2;
          this.c *= x2;
          this.b *= y2;
          this.tx *= x2;
          this.ty *= y2;
          return this;
        }
        /**
         * Applies a rotation transformation to the matrix.
         *
         * Rotates around the origin (0,0) by the given angle in radians.
         * @example
         * ```ts
         * // Basic rotation
         * const matrix = new Matrix();
         * matrix.rotate(Math.PI / 4); // Rotate 45 degrees
         *
         * // Chain with other transformations
         * matrix
         *     .translate(100, 100) // Move to rotation center
         *     .rotate(Math.PI)     // Rotate 180 degrees
         *     .scale(2, 2);        // Scale after rotation
         *
         * // Common angles
         * matrix.rotate(Math.PI / 2);  // 90 degrees
         * matrix.rotate(Math.PI);      // 180 degrees
         * matrix.rotate(Math.PI * 2);  // 360 degrees
         * ```
         * @remarks
         * - Rotates around origin point (0,0)
         * - Affects position if translation was set
         * - Uses counter-clockwise rotation
         * - Order of operations matters when chaining
         * @param angle - The angle in radians
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.setTransform} For setting rotation directly
         * @see {@link Matrix.append} For combining transformations
         */
        rotate(angle) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          const a1 = this.a;
          const c1 = this.c;
          const tx1 = this.tx;
          this.a = a1 * cos - this.b * sin;
          this.b = a1 * sin + this.b * cos;
          this.c = c1 * cos - this.d * sin;
          this.d = c1 * sin + this.d * cos;
          this.tx = tx1 * cos - this.ty * sin;
          this.ty = tx1 * sin + this.ty * cos;
          return this;
        }
        /**
         * Appends the given Matrix to this Matrix.
         * Combines two matrices by multiplying them together: this = this * matrix
         * @example
         * ```ts
         * // Basic matrix combination
         * const matrix = new Matrix();
         * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);
         * matrix.append(other);
         * ```
         * @remarks
         * - Order matters: A.append(B) !== B.append(A)
         * - Modifies current matrix
         * - Preserves transformation order
         * - Commonly used for combining transforms
         * @param matrix - The matrix to append
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.prepend} For prepending transformations
         * @see {@link Matrix.appendFrom} For appending two external matrices
         */
        append(matrix) {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          this.a = matrix.a * a1 + matrix.b * c1;
          this.b = matrix.a * b1 + matrix.b * d1;
          this.c = matrix.c * a1 + matrix.d * c1;
          this.d = matrix.c * b1 + matrix.d * d1;
          this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
          this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
          return this;
        }
        /**
         * Appends two matrices and sets the result to this matrix.
         * Performs matrix multiplication: this = A * B
         * @example
         * ```ts
         * // Basic matrix multiplication
         * const result = new Matrix();
         * const matrixA = new Matrix().scale(2, 2);
         * const matrixB = new Matrix().rotate(Math.PI / 4);
         * result.appendFrom(matrixA, matrixB);
         * ```
         * @remarks
         * - Order matters: A * B !== B * A
         * - Creates a new transformation from two others
         * - More efficient than append() for multiple operations
         * - Does not modify input matrices
         * @param a - The first matrix to multiply
         * @param b - The second matrix to multiply
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.append} For single matrix combination
         * @see {@link Matrix.prepend} For reverse order multiplication
         */
        appendFrom(a2, b2) {
          const a1 = a2.a;
          const b1 = a2.b;
          const c1 = a2.c;
          const d1 = a2.d;
          const tx = a2.tx;
          const ty = a2.ty;
          const a22 = b2.a;
          const b22 = b2.b;
          const c2 = b2.c;
          const d2 = b2.d;
          this.a = a1 * a22 + b1 * c2;
          this.b = a1 * b22 + b1 * d2;
          this.c = c1 * a22 + d1 * c2;
          this.d = c1 * b22 + d1 * d2;
          this.tx = tx * a22 + ty * c2 + b2.tx;
          this.ty = tx * b22 + ty * d2 + b2.ty;
          return this;
        }
        /**
         * Sets the matrix based on all the available properties.
         * Combines position, scale, rotation, skew and pivot in a single operation.
         * @example
         * ```ts
         * // Basic transform setup
         * const matrix = new Matrix();
         * matrix.setTransform(
         *     100, 100,    // position
         *     0, 0,        // pivot
         *     2, 2,        // scale
         *     Math.PI / 4, // rotation (45 degrees)
         *     0, 0         // skew
         * );
         * ```
         * @remarks
         * - Updates all matrix components at once
         * - More efficient than separate transform calls
         * - Uses radians for rotation and skew
         * - Pivot affects rotation center
         * @param x - Position on the x axis
         * @param y - Position on the y axis
         * @param pivotX - Pivot on the x axis
         * @param pivotY - Pivot on the y axis
         * @param scaleX - Scale on the x axis
         * @param scaleY - Scale on the y axis
         * @param rotation - Rotation in radians
         * @param skewX - Skew on the x axis
         * @param skewY - Skew on the y axis
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.decompose} For extracting transform properties
         * @see {@link TransformableObject} For transform data structure
         */
        setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
          this.a = Math.cos(rotation + skewY) * scaleX;
          this.b = Math.sin(rotation + skewY) * scaleX;
          this.c = -Math.sin(rotation - skewX) * scaleY;
          this.d = Math.cos(rotation - skewX) * scaleY;
          this.tx = x2 - (pivotX * this.a + pivotY * this.c);
          this.ty = y2 - (pivotX * this.b + pivotY * this.d);
          return this;
        }
        /**
         * Prepends the given Matrix to this Matrix.
         * Combines two matrices by multiplying them together: this = matrix * this
         * @example
         * ```ts
         * // Basic matrix prepend
         * const matrix = new Matrix().scale(2, 2);
         * const other = new Matrix().translate(100, 0);
         * matrix.prepend(other); // Translation happens before scaling
         * ```
         * @remarks
         * - Order matters: A.prepend(B) !== B.prepend(A)
         * - Modifies current matrix
         * - Reverses transformation order compared to append()
         * @param matrix - The matrix to prepend
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.append} For appending transformations
         * @see {@link Matrix.appendFrom} For combining external matrices
         */
        prepend(matrix) {
          const tx1 = this.tx;
          if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            const a1 = this.a;
            const c1 = this.c;
            this.a = a1 * matrix.a + this.b * matrix.c;
            this.b = a1 * matrix.b + this.b * matrix.d;
            this.c = c1 * matrix.a + this.d * matrix.c;
            this.d = c1 * matrix.b + this.d * matrix.d;
          }
          this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
          this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
          return this;
        }
        /**
         * Decomposes the matrix into its individual transform components.
         * Extracts position, scale, rotation and skew values from the matrix.
         * @example
         * ```ts
         * // Basic decomposition
         * const matrix = new Matrix()
         *     .translate(100, 100)
         *     .rotate(Math.PI / 4)
         *     .scale(2, 2);
         *
         * const transform = {
         *     position: new Point(),
         *     scale: new Point(),
         *     pivot: new Point(),
         *     skew: new Point(),
         *     rotation: 0
         * };
         *
         * matrix.decompose(transform);
         * console.log(transform.position); // Point(100, 100)
         * console.log(transform.rotation); // ~0.785 (PI/4)
         * console.log(transform.scale); // Point(2, 2)
         * ```
         * @remarks
         * - Handles combined transformations
         * - Accounts for pivot points
         * - Chooses between rotation/skew based on transform type
         * - Uses radians for rotation and skew
         * @param transform - The transform object to store the decomposed values
         * @returns The transform with the newly applied properties
         * @see {@link Matrix.setTransform} For composing from components
         * @see {@link TransformableObject} For transform structure
         */
        decompose(transform2) {
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const pivot = transform2.pivot;
          const skewX = -Math.atan2(-c2, d2);
          const skewY = Math.atan2(b2, a2);
          const delta = Math.abs(skewX + skewY);
          if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
            transform2.rotation = skewY;
            transform2.skew.x = transform2.skew.y = 0;
          } else {
            transform2.rotation = 0;
            transform2.skew.x = skewX;
            transform2.skew.y = skewY;
          }
          transform2.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
          transform2.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
          transform2.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
          transform2.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
          return transform2;
        }
        /**
         * Inverts this matrix.
         * Creates the matrix that when multiplied with this matrix results in an identity matrix.
         * @example
         * ```ts
         * // Basic matrix inversion
         * const matrix = new Matrix()
         *     .translate(100, 50)
         *     .scale(2, 2);
         *
         * matrix.invert(); // Now transforms in opposite direction
         *
         * // Verify inversion
         * const point = new Point(50, 50);
         * const transformed = matrix.apply(point);
         * const original = matrix.invert().apply(transformed);
         * // original  point
         * ```
         * @remarks
         * - Modifies the current matrix
         * - Useful for reversing transformations
         * - Cannot invert matrices with zero determinant
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.identity} For resetting to identity
         * @see {@link Matrix.applyInverse} For inverse transformations
         */
        invert() {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          const tx1 = this.tx;
          const n2 = a1 * d1 - b1 * c1;
          this.a = d1 / n2;
          this.b = -b1 / n2;
          this.c = -c1 / n2;
          this.d = a1 / n2;
          this.tx = (c1 * this.ty - d1 * tx1) / n2;
          this.ty = -(a1 * this.ty - b1 * tx1) / n2;
          return this;
        }
        /**
         * Checks if this matrix is an identity matrix.
         *
         * An identity matrix has no transformations applied (default state).
         * @example
         * ```ts
         * // Check if matrix is identity
         * const matrix = new Matrix();
         * console.log(matrix.isIdentity()); // true
         *
         * // Check after transformations
         * matrix.translate(100, 0);
         * console.log(matrix.isIdentity()); // false
         *
         * // Reset and verify
         * matrix.identity();
         * console.log(matrix.isIdentity()); // true
         * ```
         * @remarks
         * - Verifies a = 1, d = 1 (no scale)
         * - Verifies b = 0, c = 0 (no skew)
         * - Verifies tx = 0, ty = 0 (no translation)
         * @returns True if matrix has no transformations
         * @see {@link Matrix.identity} For resetting to identity
         * @see {@link Matrix.IDENTITY} For constant identity matrix
         */
        isIdentity() {
          return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
        }
        /**
         * Resets this Matrix to an identity (default) matrix.
         * Sets all components to their default values: scale=1, no skew, no translation.
         * @example
         * ```ts
         * // Reset transformed matrix
         * const matrix = new Matrix()
         *     .scale(2, 2)
         *     .rotate(Math.PI / 4);
         * matrix.identity(); // Back to default state
         *
         * // Chain after reset
         * matrix
         *     .identity()
         *     .translate(100, 100)
         *     .scale(2, 2);
         *
         * // Compare with identity constant
         * const isDefault = matrix.equals(Matrix.IDENTITY);
         * ```
         * @remarks
         * - Sets a=1, d=1 (default scale)
         * - Sets b=0, c=0 (no skew)
         * - Sets tx=0, ty=0 (no translation)
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.IDENTITY} For constant identity matrix
         * @see {@link Matrix.isIdentity} For checking identity state
         */
        identity() {
          this.a = 1;
          this.b = 0;
          this.c = 0;
          this.d = 1;
          this.tx = 0;
          this.ty = 0;
          return this;
        }
        /**
         * Creates a new Matrix object with the same values as this one.
         * @returns A copy of this matrix. Good for chaining method calls.
         */
        clone() {
          const matrix = new _Matrix();
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        /**
         * Creates a new Matrix object with the same values as this one.
         * @param matrix
         * @example
         * ```ts
         * // Basic matrix cloning
         * const matrix = new Matrix()
         *     .translate(100, 100)
         *     .rotate(Math.PI / 4);
         * const copy = matrix.clone();
         *
         * // Clone and modify
         * const modified = matrix.clone()
         *     .scale(2, 2);
         *
         * // Compare matrices
         * console.log(matrix.equals(copy));     // true
         * console.log(matrix.equals(modified)); // false
         * ```
         * @returns A copy of this matrix. Good for chaining method calls.
         * @see {@link Matrix.copyTo} For copying to existing matrix
         * @see {@link Matrix.copyFrom} For copying from another matrix
         */
        copyTo(matrix) {
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        /**
         * Changes the values of the matrix to be the same as the ones in given matrix.
         * @example
         * ```ts
         * // Basic matrix copying
         * const source = new Matrix()
         *     .translate(100, 100)
         *     .rotate(Math.PI / 4);
         * const target = new Matrix();
         * target.copyFrom(source);
         * ```
         * @param matrix - The matrix to copy from
         * @returns This matrix. Good for chaining method calls.
         * @see {@link Matrix.clone} For creating new matrix copy
         * @see {@link Matrix.copyTo} For copying to another matrix
         */
        copyFrom(matrix) {
          this.a = matrix.a;
          this.b = matrix.b;
          this.c = matrix.c;
          this.d = matrix.d;
          this.tx = matrix.tx;
          this.ty = matrix.ty;
          return this;
        }
        /**
         * Checks if this matrix equals another matrix.
         * Compares all components for exact equality.
         * @example
         * ```ts
         * // Basic equality check
         * const m1 = new Matrix();
         * const m2 = new Matrix();
         * console.log(m1.equals(m2)); // true
         *
         * // Compare transformed matrices
         * const transform = new Matrix()
         *     .translate(100, 100)
         * const clone = new Matrix()
         *     .scale(2, 2);
         * console.log(transform.equals(clone)); // false
         * ```
         * @param matrix - The matrix to compare to
         * @returns True if matrices are identical
         * @see {@link Matrix.copyFrom} For copying matrix values
         * @see {@link Matrix.isIdentity} For identity comparison
         */
        equals(matrix) {
          return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
        }
        toString() {
          return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
        }
        /**
         * A default (identity) matrix with no transformations applied.
         *
         * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.
         * @example
         * ```ts
         * // Get identity matrix reference
         * const identity = Matrix.IDENTITY;
         * console.log(identity.isIdentity()); // true
         *
         * // Compare with identity
         * const matrix = new Matrix();
         * console.log(matrix.equals(Matrix.IDENTITY)); // true
         *
         * // Create new matrix instead of modifying IDENTITY
         * const transform = new Matrix()
         *     .copyFrom(Matrix.IDENTITY)
         *     .translate(100, 100);
         * ```
         * @readonly
         * @returns A read-only identity matrix
         * @see {@link Matrix.shared} For temporary calculations
         * @see {@link Matrix.identity} For resetting matrices
         */
        static get IDENTITY() {
          return identityMatrix.identity();
        }
        /**
         * A static Matrix that can be used to avoid creating new objects.
         * Will always ensure the matrix is reset to identity when requested.
         *
         * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.
         * @example
         * ```ts
         * // Use for temporary calculations
         * const tempMatrix = Matrix.shared;
         * tempMatrix.translate(100, 100).rotate(Math.PI / 4);
         * const point = tempMatrix.apply({ x: 10, y: 20 });
         *
         * // Will be reset to identity on next access
         * const fresh = Matrix.shared; // Back to identity
         * ```
         * @remarks
         * - Always returns identity matrix
         * - Safe to modify temporarily
         * - Not safe to store references
         * - Useful for one-off calculations
         * @readonly
         * @returns A fresh identity matrix for temporary use
         * @see {@link Matrix.IDENTITY} For immutable identity matrix
         * @see {@link Matrix.identity} For resetting matrices
         */
        static get shared() {
          return tempMatrix.identity();
        }
      };
      tempMatrix = new Matrix();
      identityMatrix = new Matrix();
    }
  });

  // node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
  var ObservablePoint;
  var init_ObservablePoint = __esm({
    "node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs"() {
      "use strict";
      ObservablePoint = class _ObservablePoint {
        /**
         * Creates a new `ObservablePoint`
         * @param observer - Observer to pass to listen for change events.
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        constructor(observer, x2, y2) {
          this._x = x2 || 0;
          this._y = y2 || 0;
          this._observer = observer;
        }
        /**
         * Creates a clone of this point.
         * @example
         * ```ts
         * // Basic cloning
         * const point = new ObservablePoint(observer, 100, 200);
         * const copy = point.clone();
         *
         * // Clone with new observer
         * const newObserver = {
         *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)
         * };
         * const watched = point.clone(newObserver);
         *
         * // Verify independence
         * watched.set(300, 400); // Only triggers new observer
         * ```
         * @param observer - Optional observer to pass to the new observable point
         * @returns A copy of this observable point
         * @see {@link ObservablePoint.copyFrom} For copying into existing point
         * @see {@link Observer} For observer interface details
         */
        clone(observer) {
          return new _ObservablePoint(observer != null ? observer : this._observer, this._x, this._y);
        }
        /**
         * Sets the point to a new x and y position.
         *
         * If y is omitted, both x and y will be set to x.
         * @example
         * ```ts
         * // Basic position setting
         * const point = new ObservablePoint(observer);
         * point.set(100, 200);
         *
         * // Set both x and y to same value
         * point.set(50); // x=50, y=50
         * ```
         * @param x - Position on the x axis
         * @param y - Position on the y axis, defaults to x
         * @returns The point instance itself
         * @see {@link ObservablePoint.copyFrom} For copying from another point
         * @see {@link ObservablePoint.equals} For comparing positions
         */
        set(x2 = 0, y2 = x2) {
          if (this._x !== x2 || this._y !== y2) {
            this._x = x2;
            this._y = y2;
            this._observer._onUpdate(this);
          }
          return this;
        }
        /**
         * Copies x and y from the given point into this point.
         * @example
         * ```ts
         * // Basic copying
         * const source = new ObservablePoint(observer, 100, 200);
         * const target = new ObservablePoint();
         * target.copyFrom(source);
         *
         * // Copy and chain operations
         * const point = new ObservablePoint()
         *     .copyFrom(source)
         *     .set(x + 50, y + 50);
         *
         * // Copy from any PointData
         * const data = { x: 10, y: 20 };
         * point.copyFrom(data);
         * ```
         * @param p - The point to copy from
         * @returns The point instance itself
         * @see {@link ObservablePoint.copyTo} For copying to another point
         * @see {@link ObservablePoint.clone} For creating new point copy
         */
        copyFrom(p3) {
          if (this._x !== p3.x || this._y !== p3.y) {
            this._x = p3.x;
            this._y = p3.y;
            this._observer._onUpdate(this);
          }
          return this;
        }
        /**
         * Copies this point's x and y into the given point.
         * @example
         * ```ts
         * // Basic copying
         * const source = new ObservablePoint(100, 200);
         * const target = new ObservablePoint();
         * source.copyTo(target);
         * ```
         * @param p - The point to copy to. Can be any type that is or extends `PointLike`
         * @returns The point (`p`) with values updated
         * @see {@link ObservablePoint.copyFrom} For copying from another point
         * @see {@link ObservablePoint.clone} For creating new point copy
         */
        copyTo(p3) {
          p3.set(this._x, this._y);
          return p3;
        }
        /**
         * Checks if another point is equal to this point.
         *
         * Compares x and y values using strict equality.
         * @example
         * ```ts
         * // Basic equality check
         * const p1 = new ObservablePoint(100, 200);
         * const p2 = new ObservablePoint(100, 200);
         * console.log(p1.equals(p2)); // true
         *
         * // Compare with PointData
         * const data = { x: 100, y: 200 };
         * console.log(p1.equals(data)); // true
         *
         * // Check different points
         * const p3 = new ObservablePoint(200, 300);
         * console.log(p1.equals(p3)); // false
         * ```
         * @param p - The point to check
         * @returns `true` if both `x` and `y` are equal
         * @see {@link ObservablePoint.copyFrom} For making points equal
         * @see {@link PointData} For point data interface
         */
        equals(p3) {
          return p3.x === this._x && p3.y === this._y;
        }
        toString() {
          return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
        }
        /**
         * Position of the observable point on the x axis.
         * Triggers observer callback when value changes.
         * @example
         * ```ts
         * // Basic x position
         * const point = new ObservablePoint(observer);
         * point.x = 100; // Triggers observer
         *
         * // Use in calculations
         * const width = rightPoint.x - leftPoint.x;
         * ```
         * @default 0
         */
        get x() {
          return this._x;
        }
        set x(value) {
          if (this._x !== value) {
            this._x = value;
            this._observer._onUpdate(this);
          }
        }
        /**
         * Position of the observable point on the y axis.
         * Triggers observer callback when value changes.
         * @example
         * ```ts
         * // Basic y position
         * const point = new ObservablePoint(observer);
         * point.y = 200; // Triggers observer
         *
         * // Use in calculations
         * const height = bottomPoint.y - topPoint.y;
         * ```
         * @default 0
         */
        get y() {
          return this._y;
        }
        set y(value) {
          if (this._y !== value) {
            this._y = value;
            this._observer._onUpdate(this);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/utils/data/uid.mjs
  function uid2(name = "default") {
    if (uidCache[name] === void 0) {
      uidCache[name] = -1;
    }
    return ++uidCache[name];
  }
  function resetUids() {
    for (const key in uidCache) {
      delete uidCache[key];
    }
  }
  var uidCache;
  var init_uid = __esm({
    "node_modules/pixi.js/lib/utils/data/uid.mjs"() {
      "use strict";
      uidCache = {
        default: -1
      };
    }
  });

  // node_modules/pixi.js/lib/utils/logging/deprecation.mjs
  var warnings, v8_0_0, v8_3_4, deprecationState, deprecation;
  var init_deprecation = __esm({
    "node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
      "use strict";
      warnings = /* @__PURE__ */ new Set();
      v8_0_0 = "8.0.0";
      v8_3_4 = "8.3.4";
      deprecationState = {
        quiet: false,
        noColor: false
      };
      deprecation = (version, message, ignoreDepth = 3) => {
        if (deprecationState.quiet || warnings.has(message))
          return;
        let stack = new Error().stack;
        const deprecationMessage = `${message}
Deprecated since v${version}`;
        const useGroup = typeof console.groupCollapsed === "function" && !deprecationState.noColor;
        if (typeof stack === "undefined") {
          console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
        } else {
          stack = stack.split("\n").splice(ignoreDepth).join("\n");
          if (useGroup) {
            console.groupCollapsed(
              "%cPixiJS Deprecation Warning: %c%s",
              "color:#614108;background:#fffbe6",
              "font-weight:normal;color:#614108;background:#fffbe6",
              deprecationMessage
            );
            console.warn(stack);
            console.groupEnd();
          } else {
            console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
            console.warn(stack);
          }
        }
        warnings.add(message);
      };
      Object.defineProperties(deprecation, {
        quiet: {
          get: () => deprecationState.quiet,
          set: (value) => {
            deprecationState.quiet = value;
          },
          enumerable: true,
          configurable: false
        },
        noColor: {
          get: () => deprecationState.noColor,
          set: (value) => {
            deprecationState.noColor = value;
          },
          enumerable: true,
          configurable: false
        }
      });
    }
  });

  // node_modules/pixi.js/lib/utils/logging/warn.mjs
  function warn(...args) {
    if (warnCount === maxWarnings)
      return;
    warnCount++;
    if (warnCount === maxWarnings) {
      console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
    } else {
      console.warn("PixiJS Warning: ", ...args);
    }
  }
  var warnCount, maxWarnings;
  var init_warn = __esm({
    "node_modules/pixi.js/lib/utils/logging/warn.mjs"() {
      "use strict";
      warnCount = 0;
      maxWarnings = 500;
    }
  });

  // node_modules/pixi.js/lib/utils/pool/GlobalResourceRegistry.mjs
  var GlobalResourceRegistry;
  var init_GlobalResourceRegistry = __esm({
    "node_modules/pixi.js/lib/utils/pool/GlobalResourceRegistry.mjs"() {
      "use strict";
      GlobalResourceRegistry = {
        /**
         * Set of registered pools and cleanable objects.
         * @private
         */
        _registeredResources: /* @__PURE__ */ new Set(),
        /**
         * Registers a pool or cleanable object for cleanup.
         * @param {Cleanable} pool - The pool or object to register.
         */
        register(pool) {
          this._registeredResources.add(pool);
        },
        /**
         * Unregisters a pool or cleanable object from cleanup.
         * @param {Cleanable} pool - The pool or object to unregister.
         */
        unregister(pool) {
          this._registeredResources.delete(pool);
        },
        /** Clears all registered pools and cleanable objects. This will call clear() on each registered item. */
        release() {
          this._registeredResources.forEach((pool) => pool.clear());
        },
        /**
         * Gets the number of registered pools and cleanable objects.
         * @returns {number} The count of registered items.
         */
        get registeredCount() {
          return this._registeredResources.size;
        },
        /**
         * Checks if a specific pool or cleanable object is registered.
         * @param {Cleanable} pool - The pool or object to check.
         * @returns {boolean} True if the item is registered, false otherwise.
         */
        isRegistered(pool) {
          return this._registeredResources.has(pool);
        },
        /**
         * Removes all registrations without clearing the pools.
         * Useful if you want to reset the collector without affecting the pools.
         */
        reset() {
          this._registeredResources.clear();
        }
      };
    }
  });

  // node_modules/pixi.js/lib/utils/pool/Pool.mjs
  var Pool;
  var init_Pool = __esm({
    "node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
      "use strict";
      Pool = class {
        /**
         * Constructs a new Pool.
         * @param ClassType - The constructor of the items in the pool.
         * @param {number} [initialSize] - The initial size of the pool.
         */
        constructor(ClassType, initialSize) {
          this._pool = [];
          this._count = 0;
          this._index = 0;
          this._classType = ClassType;
          if (initialSize) {
            this.prepopulate(initialSize);
          }
        }
        /**
         * Prepopulates the pool with a given number of items.
         * @param total - The number of items to add to the pool.
         */
        prepopulate(total) {
          for (let i3 = 0; i3 < total; i3++) {
            this._pool[this._index++] = new this._classType();
          }
          this._count += total;
        }
        /**
         * Gets an item from the pool. Calls the item's `init` method if it exists.
         * If there are no items left in the pool, a new one will be created.
         * @param {unknown} [data] - Optional data to pass to the item's constructor.
         * @returns {T} The item from the pool.
         */
        get(data) {
          var _a2;
          let item;
          if (this._index > 0) {
            item = this._pool[--this._index];
          } else {
            item = new this._classType();
            this._count++;
          }
          (_a2 = item.init) == null ? void 0 : _a2.call(item, data);
          return item;
        }
        /**
         * Returns an item to the pool. Calls the item's `reset` method if it exists.
         * @param {T} item - The item to return to the pool.
         */
        return(item) {
          var _a2;
          (_a2 = item.reset) == null ? void 0 : _a2.call(item);
          this._pool[this._index++] = item;
        }
        /**
         * Gets the number of items in the pool.
         * @readonly
         */
        get totalSize() {
          return this._count;
        }
        /**
         * Gets the number of items in the pool that are free to use without needing to create more.
         * @readonly
         */
        get totalFree() {
          return this._index;
        }
        /**
         * Gets the number of items in the pool that are currently in use.
         * @readonly
         */
        get totalUsed() {
          return this._count - this._index;
        }
        /** clears the pool */
        clear() {
          if (this._pool.length > 0 && this._pool[0].destroy) {
            for (let i3 = 0; i3 < this._index; i3++) {
              this._pool[i3].destroy();
            }
          }
          this._pool.length = 0;
          this._count = 0;
          this._index = 0;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
  var PoolGroupClass, BigPool;
  var init_PoolGroup = __esm({
    "node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
      init_GlobalResourceRegistry();
      init_Pool();
      PoolGroupClass = class {
        constructor() {
          this._poolsByClass = /* @__PURE__ */ new Map();
        }
        /**
         * Prepopulates a specific pool with a given number of items.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
         * @param {number} total - The number of items to add to the pool.
         */
        prepopulate(Class, total) {
          const classPool = this.getPool(Class);
          classPool.prepopulate(total);
        }
        /**
         * Gets an item from a specific pool.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
         * @param {unknown} [data] - Optional data to pass to the item's constructor.
         * @returns {T} The item from the pool.
         */
        get(Class, data) {
          const pool = this.getPool(Class);
          return pool.get(data);
        }
        /**
         * Returns an item to its respective pool.
         * @param {PoolItem} item - The item to return to the pool.
         */
        return(item) {
          const pool = this.getPool(item.constructor);
          pool.return(item);
        }
        /**
         * Gets a specific pool based on the class type.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
         * @returns {Pool<T>} The pool of the given class type.
         */
        getPool(ClassType) {
          if (!this._poolsByClass.has(ClassType)) {
            this._poolsByClass.set(ClassType, new Pool(ClassType));
          }
          return this._poolsByClass.get(ClassType);
        }
        /** gets the usage stats of each pool in the system */
        stats() {
          const stats = {};
          this._poolsByClass.forEach((pool) => {
            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
            stats[name] = {
              free: pool.totalFree,
              used: pool.totalUsed,
              size: pool.totalSize
            };
          });
          return stats;
        }
        /** Clears all pools in the group. This will reset all pools and free their resources. */
        clear() {
          this._poolsByClass.forEach((pool) => pool.clear());
          this._poolsByClass.clear();
        }
      };
      BigPool = new PoolGroupClass();
      GlobalResourceRegistry.register(BigPool);
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs
  var cacheAsTextureMixin;
  var init_cacheAsTextureMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs"() {
      init_deprecation();
      cacheAsTextureMixin = {
        get isCachedAsTexture() {
          var _a2;
          return !!((_a2 = this.renderGroup) == null ? void 0 : _a2.isCachedAsTexture);
        },
        cacheAsTexture(val) {
          if (typeof val === "boolean" && val === false) {
            this.disableRenderGroup();
          } else {
            this.enableRenderGroup();
            this.renderGroup.enableCacheAsTexture(val === true ? {} : val);
          }
        },
        updateCacheTexture() {
          var _a2;
          (_a2 = this.renderGroup) == null ? void 0 : _a2.updateCacheTexture();
        },
        get cacheAsBitmap() {
          return this.isCachedAsTexture;
        },
        set cacheAsBitmap(val) {
          deprecation("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead.");
          this.cacheAsTexture(val);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/utils/data/removeItems.mjs
  function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i3;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for (i3 = startIdx; i3 < len; ++i3) {
      arr[i3] = arr[i3 + removeCount];
    }
    arr.length = len;
  }
  var init_removeItems = __esm({
    "node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
  var childrenHelperMixin;
  var init_childrenHelperMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
      init_removeItems();
      init_deprecation();
      childrenHelperMixin = {
        allowChildren: true,
        removeChildren(beginIndex = 0, endIndex) {
          var _a2;
          const end = endIndex != null ? endIndex : this.children.length;
          const range = end - beginIndex;
          const removed = [];
          if (range > 0 && range <= end) {
            for (let i3 = end - 1; i3 >= beginIndex; i3--) {
              const child = this.children[i3];
              if (!child)
                continue;
              removed.push(child);
              child.parent = null;
            }
            removeItems(this.children, beginIndex, end);
            const renderGroup = this.renderGroup || this.parentRenderGroup;
            if (renderGroup) {
              renderGroup.removeChildren(removed);
            }
            for (let i3 = 0; i3 < removed.length; ++i3) {
              const child = removed[i3];
              (_a2 = child.parentRenderLayer) == null ? void 0 : _a2.detach(child);
              this.emit("childRemoved", child, this, i3);
              removed[i3].emit("removed", this);
            }
            if (removed.length > 0) {
              this._didViewChangeTick++;
            }
            return removed;
          } else if (range === 0 && this.children.length === 0) {
            return removed;
          }
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        },
        removeChildAt(index) {
          const child = this.getChildAt(index);
          return this.removeChild(child);
        },
        getChildAt(index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error(`getChildAt: Index (${index}) does not exist.`);
          }
          return this.children[index];
        },
        setChildIndex(child, index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
          }
          this.getChildIndex(child);
          this.addChildAt(child, index);
        },
        getChildIndex(child) {
          const index = this.children.indexOf(child);
          if (index === -1) {
            throw new Error("The supplied Container must be a child of the caller");
          }
          return index;
        },
        addChildAt(child, index) {
          if (!this.allowChildren) {
            deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
          }
          const { children } = this;
          if (index < 0 || index > children.length) {
            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
          }
          if (child.parent) {
            const currentIndex = child.parent.children.indexOf(child);
            if (child.parent === this && currentIndex === index) {
              return child;
            }
            if (currentIndex !== -1) {
              child.parent.children.splice(currentIndex, 1);
            }
          }
          if (index === children.length) {
            children.push(child);
          } else {
            children.splice(index, 0, child);
          }
          child.parent = this;
          child.didChange = true;
          child._updateFlags = 15;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.addChild(child);
          }
          if (this.sortableChildren)
            this.sortDirty = true;
          this.emit("childAdded", child, this, index);
          child.emit("added", this);
          return child;
        },
        swapChildren(child, child2) {
          if (child === child2) {
            return;
          }
          const index1 = this.getChildIndex(child);
          const index2 = this.getChildIndex(child2);
          this.children[index1] = child2;
          this.children[index2] = child;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
          this._didContainerChangeTick++;
        },
        removeFromParent() {
          var _a2;
          (_a2 = this.parent) == null ? void 0 : _a2.removeChild(this);
        },
        reparentChild(...child) {
          if (child.length === 1) {
            return this.reparentChildAt(child[0], this.children.length);
          }
          child.forEach((c2) => this.reparentChildAt(c2, this.children.length));
          return child[0];
        },
        reparentChildAt(child, index) {
          if (child.parent === this) {
            this.setChildIndex(child, index);
            return child;
          }
          const childMat = child.worldTransform.clone();
          child.removeFromParent();
          this.addChildAt(child, index);
          const newMatrix = this.worldTransform.clone();
          newMatrix.invert();
          childMat.prepend(newMatrix);
          child.setFromMatrix(childMat);
          return child;
        },
        replaceChild(oldChild, newChild) {
          oldChild.updateLocalTransform();
          this.addChildAt(newChild, this.getChildIndex(oldChild));
          newChild.setFromMatrix(oldChild.localTransform);
          newChild.updateLocalTransform();
          this.removeChild(oldChild);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs
  var collectRenderablesMixin;
  var init_collectRenderablesMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs"() {
      "use strict";
      collectRenderablesMixin = {
        collectRenderables(instructionSet, renderer, currentLayer) {
          if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild)
            return;
          if (this.sortableChildren) {
            this.sortChildren();
          }
          if (this.isSimple) {
            this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
          } else if (this.renderGroup) {
            renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);
          } else {
            this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);
          }
        },
        collectRenderablesSimple(instructionSet, renderer, currentLayer) {
          const children = this.children;
          const length = children.length;
          for (let i3 = 0; i3 < length; i3++) {
            children[i3].collectRenderables(instructionSet, renderer, currentLayer);
          }
        },
        collectRenderablesWithEffects(instructionSet, renderer, currentLayer) {
          const { renderPipes: renderPipes3 } = renderer;
          for (let i3 = 0; i3 < this.effects.length; i3++) {
            const effect = this.effects[i3];
            const pipe3 = renderPipes3[effect.pipe];
            pipe3.push(effect, this, instructionSet);
          }
          this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
          for (let i3 = this.effects.length - 1; i3 >= 0; i3--) {
            const effect = this.effects[i3];
            const pipe3 = renderPipes3[effect.pipe];
            pipe3.pop(effect, this, instructionSet);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/filters/FilterEffect.mjs
  var FilterEffect;
  var init_FilterEffect = __esm({
    "node_modules/pixi.js/lib/filters/FilterEffect.mjs"() {
      "use strict";
      FilterEffect = class {
        constructor() {
          this.pipe = "filter";
          this.priority = 1;
        }
        destroy() {
          for (let i3 = 0; i3 < this.filters.length; i3++) {
            this.filters[i3].destroy();
          }
          this.filters = null;
          this.filterArea = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
  var MaskEffectManagerClass, MaskEffectManager;
  var init_MaskEffectManager = __esm({
    "node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs"() {
      init_Extensions();
      init_PoolGroup();
      MaskEffectManagerClass = class {
        constructor() {
          this._effectClasses = [];
          this._tests = [];
          this._initialized = false;
        }
        init() {
          if (this._initialized)
            return;
          this._initialized = true;
          this._effectClasses.forEach((test) => {
            this.add({
              test: test.test,
              maskClass: test
            });
          });
        }
        add(test) {
          this._tests.push(test);
        }
        getMaskEffect(item) {
          if (!this._initialized)
            this.init();
          for (let i3 = 0; i3 < this._tests.length; i3++) {
            const test = this._tests[i3];
            if (test.test(item)) {
              return BigPool.get(test.maskClass, item);
            }
          }
          return item;
        }
        returnMaskEffect(effect) {
          BigPool.return(effect);
        }
      };
      MaskEffectManager = new MaskEffectManagerClass();
      extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
  var effectsMixin;
  var init_effectsMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs"() {
      init_FilterEffect();
      init_MaskEffectManager();
      effectsMixin = {
        _maskEffect: null,
        _maskOptions: {
          inverse: false
        },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged() {
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
        },
        addEffect(effect) {
          const index = this.effects.indexOf(effect);
          if (index !== -1)
            return;
          this.effects.push(effect);
          this.effects.sort((a2, b2) => a2.priority - b2.priority);
          this._markStructureAsChanged();
          this._updateIsSimple();
        },
        removeEffect(effect) {
          const index = this.effects.indexOf(effect);
          if (index === -1)
            return;
          this.effects.splice(index, 1);
          this._markStructureAsChanged();
          this._updateIsSimple();
        },
        set mask(value) {
          const effect = this._maskEffect;
          if ((effect == null ? void 0 : effect.mask) === value)
            return;
          if (effect) {
            this.removeEffect(effect);
            MaskEffectManager.returnMaskEffect(effect);
            this._maskEffect = null;
          }
          if (value === null || value === void 0)
            return;
          this._maskEffect = MaskEffectManager.getMaskEffect(value);
          this.addEffect(this._maskEffect);
        },
        get mask() {
          var _a2;
          return (_a2 = this._maskEffect) == null ? void 0 : _a2.mask;
        },
        setMask(options) {
          this._maskOptions = __spreadValues(__spreadValues({}, this._maskOptions), options);
          if (options.mask) {
            this.mask = options.mask;
          }
          this._markStructureAsChanged();
        },
        set filters(value) {
          var _a2;
          if (!Array.isArray(value) && value)
            value = [value];
          const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
          value = value;
          const hasFilters = (value == null ? void 0 : value.length) > 0;
          const hadFilters = ((_a2 = effect.filters) == null ? void 0 : _a2.length) > 0;
          const didChange = hasFilters !== hadFilters;
          value = Array.isArray(value) ? value.slice(0) : value;
          effect.filters = Object.freeze(value);
          if (didChange) {
            if (hasFilters) {
              this.addEffect(effect);
            } else {
              this.removeEffect(effect);
              effect.filters = value != null ? value : null;
            }
          }
        },
        get filters() {
          var _a2;
          return (_a2 = this._filterEffect) == null ? void 0 : _a2.filters;
        },
        set filterArea(value) {
          this._filterEffect || (this._filterEffect = new FilterEffect());
          this._filterEffect.filterArea = value;
        },
        get filterArea() {
          var _a2;
          return (_a2 = this._filterEffect) == null ? void 0 : _a2.filterArea;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
  var findMixin;
  var init_findMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs"() {
      init_deprecation();
      findMixin = {
        label: null,
        get name() {
          deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
          return this.label;
        },
        set name(value) {
          deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
          this.label = value;
        },
        getChildByName(name, deep = false) {
          return this.getChildByLabel(name, deep);
        },
        getChildByLabel(label, deep = false) {
          const children = this.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            const child = children[i3];
            if (child.label === label || label instanceof RegExp && label.test(child.label))
              return child;
          }
          if (deep) {
            for (let i3 = 0; i3 < children.length; i3++) {
              const child = children[i3];
              const found = child.getChildByLabel(label, true);
              if (found) {
                return found;
              }
            }
          }
          return null;
        },
        getChildrenByLabel(label, deep = false, out2 = []) {
          const children = this.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            const child = children[i3];
            if (child.label === label || label instanceof RegExp && label.test(child.label)) {
              out2.push(child);
            }
          }
          if (deep) {
            for (let i3 = 0; i3 < children.length; i3++) {
              children[i3].getChildrenByLabel(label, true, out2);
            }
          }
          return out2;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
  var tempPoints, Rectangle;
  var init_Rectangle = __esm({
    "node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
      init_Point();
      tempPoints = [new Point(), new Point(), new Point(), new Point()];
      Rectangle = class _Rectangle {
        /**
         * @param x - The X coordinate of the upper-left corner of the rectangle
         * @param y - The Y coordinate of the upper-left corner of the rectangle
         * @param width - The overall width of the rectangle
         * @param height - The overall height of the rectangle
         */
        constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
          this.type = "rectangle";
          this.x = Number(x2);
          this.y = Number(y2);
          this.width = Number(width);
          this.height = Number(height);
        }
        /**
         * Returns the left edge (x-coordinate) of the rectangle.
         * @example
         * ```ts
         * // Get left edge position
         * const rect = new Rectangle(100, 100, 200, 150);
         * console.log(rect.left); // 100
         *
         * // Use in alignment calculations
         * sprite.x = rect.left + padding;
         *
         * // Compare positions
         * if (point.x > rect.left) {
         *     console.log('Point is right of rectangle');
         * }
         * ```
         * @readonly
         * @returns The x-coordinate of the left edge
         * @see {@link Rectangle.right} For right edge position
         * @see {@link Rectangle.x} For direct x-coordinate access
         */
        get left() {
          return this.x;
        }
        /**
         * Returns the right edge (x + width) of the rectangle.
         * @example
         * ```ts
         * // Get right edge position
         * const rect = new Rectangle(100, 100, 200, 150);
         * console.log(rect.right); // 300
         *
         * // Align to right edge
         * sprite.x = rect.right - sprite.width;
         *
         * // Check boundaries
         * if (point.x < rect.right) {
         *     console.log('Point is inside right bound');
         * }
         * ```
         * @readonly
         * @returns The x-coordinate of the right edge
         * @see {@link Rectangle.left} For left edge position
         * @see {@link Rectangle.width} For width value
         */
        get right() {
          return this.x + this.width;
        }
        /**
         * Returns the top edge (y-coordinate) of the rectangle.
         * @example
         * ```ts
         * // Get top edge position
         * const rect = new Rectangle(100, 100, 200, 150);
         * console.log(rect.top); // 100
         *
         * // Position above rectangle
         * sprite.y = rect.top - sprite.height;
         *
         * // Check vertical position
         * if (point.y > rect.top) {
         *     console.log('Point is below top edge');
         * }
         * ```
         * @readonly
         * @returns The y-coordinate of the top edge
         * @see {@link Rectangle.bottom} For bottom edge position
         * @see {@link Rectangle.y} For direct y-coordinate access
         */
        get top() {
          return this.y;
        }
        /**
         * Returns the bottom edge (y + height) of the rectangle.
         * @example
         * ```ts
         * // Get bottom edge position
         * const rect = new Rectangle(100, 100, 200, 150);
         * console.log(rect.bottom); // 250
         *
         * // Stack below rectangle
         * sprite.y = rect.bottom + margin;
         *
         * // Check vertical bounds
         * if (point.y < rect.bottom) {
         *     console.log('Point is above bottom edge');
         * }
         * ```
         * @readonly
         * @returns The y-coordinate of the bottom edge
         * @see {@link Rectangle.top} For top edge position
         * @see {@link Rectangle.height} For height value
         */
        get bottom() {
          return this.y + this.height;
        }
        /**
         * Determines whether the Rectangle is empty (has no area).
         * @example
         * ```ts
         * // Check zero dimensions
         * const rect = new Rectangle(100, 100, 0, 50);
         * console.log(rect.isEmpty()); // true
         * ```
         * @returns True if the rectangle has no area
         * @see {@link Rectangle.width} For width value
         * @see {@link Rectangle.height} For height value
         */
        isEmpty() {
          return this.left === this.right || this.top === this.bottom;
        }
        /**
         * A constant empty rectangle. This is a new object every time the property is accessed.
         * @example
         * ```ts
         * // Get fresh empty rectangle
         * const empty = Rectangle.EMPTY;
         * console.log(empty.isEmpty()); // true
         * ```
         * @returns A new empty rectangle instance
         * @see {@link Rectangle.isEmpty} For empty state testing
         */
        static get EMPTY() {
          return new _Rectangle(0, 0, 0, 0);
        }
        /**
         * Creates a clone of this Rectangle
         * @example
         * ```ts
         * // Basic cloning
         * const original = new Rectangle(100, 100, 200, 150);
         * const copy = original.clone();
         *
         * // Clone and modify
         * const modified = original.clone();
         * modified.width *= 2;
         * modified.height += 50;
         *
         * // Verify independence
         * console.log(original.width);  // 200
         * console.log(modified.width);  // 400
         * ```
         * @returns A copy of the rectangle
         * @see {@link Rectangle.copyFrom} For copying into existing rectangle
         * @see {@link Rectangle.copyTo} For copying to another rectangle
         */
        clone() {
          return new _Rectangle(this.x, this.y, this.width, this.height);
        }
        /**
         * Converts a Bounds object to a Rectangle object.
         * @example
         * ```ts
         * // Convert bounds to rectangle
         * const bounds = container.getBounds();
         * const rect = new Rectangle().copyFromBounds(bounds);
         * ```
         * @param bounds - The bounds to copy and convert to a rectangle
         * @returns Returns itself
         * @see {@link Bounds} For bounds object structure
         * @see {@link Rectangle.getBounds} For getting rectangle bounds
         */
        copyFromBounds(bounds) {
          this.x = bounds.minX;
          this.y = bounds.minY;
          this.width = bounds.maxX - bounds.minX;
          this.height = bounds.maxY - bounds.minY;
          return this;
        }
        /**
         * Copies another rectangle to this one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Rectangle(100, 100, 200, 150);
         * const target = new Rectangle();
         * target.copyFrom(source);
         *
         * // Chain with other operations
         * const rect = new Rectangle()
         *     .copyFrom(source)
         *     .pad(10);
         * ```
         * @param rectangle - The rectangle to copy from
         * @returns Returns itself
         * @see {@link Rectangle.copyTo} For copying to another rectangle
         * @see {@link Rectangle.clone} For creating new rectangle copy
         */
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        /**
         * Copies this rectangle to another one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Rectangle(100, 100, 200, 150);
         * const target = new Rectangle();
         * source.copyTo(target);
         *
         * // Chain with other operations
         * const result = source
         *     .copyTo(new Rectangle())
         *     .getBounds();
         * ```
         * @param rectangle - The rectangle to copy to
         * @returns Returns given parameter
         * @see {@link Rectangle.copyFrom} For copying from another rectangle
         * @see {@link Rectangle.clone} For creating new rectangle copy
         */
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this Rectangle
         * @example
         * ```ts
         * // Basic containment check
         * const rect = new Rectangle(100, 100, 200, 150);
         * const isInside = rect.contains(150, 125); // true
         * // Check edge cases
         * console.log(rect.contains(100, 100)); // true (on edge)
         * console.log(rect.contains(300, 250)); // false (outside)
         * ```
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Rectangle
         * @see {@link Rectangle.containsRect} For rectangle containment
         * @see {@link Rectangle.strokeContains} For checking stroke intersection
         */
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 < this.x + this.width) {
            if (y2 >= this.y && y2 < this.y + this.height) {
              return true;
            }
          }
          return false;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
         * @example
         * ```ts
         * // Basic stroke check
         * const rect = new Rectangle(100, 100, 200, 150);
         * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
         *
         * // Check with different alignments
         * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
         * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
         * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
         * ```
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
         * @returns Whether the x/y coordinates are within this rectangle's stroke
         * @see {@link Rectangle.contains} For checking fill containment
         * @see {@link Rectangle.getBounds} For getting stroke bounds
         */
        strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
          const { width, height } = this;
          if (width <= 0 || height <= 0)
            return false;
          const _x = this.x;
          const _y = this.y;
          const strokeWidthOuter = strokeWidth * (1 - alignment);
          const strokeWidthInner = strokeWidth - strokeWidthOuter;
          const outerLeft = _x - strokeWidthOuter;
          const outerRight = _x + width + strokeWidthOuter;
          const outerTop = _y - strokeWidthOuter;
          const outerBottom = _y + height + strokeWidthOuter;
          const innerLeft = _x + strokeWidthInner;
          const innerRight = _x + width - strokeWidthInner;
          const innerTop = _y + strokeWidthInner;
          const innerBottom = _y + height - strokeWidthInner;
          return x2 >= outerLeft && x2 <= outerRight && y2 >= outerTop && y2 <= outerBottom && !(x2 > innerLeft && x2 < innerRight && y2 > innerTop && y2 < innerBottom);
        }
        /**
         * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
         * Returns true only if the area of the intersection is >0, this means that Rectangles
         * sharing a side are not overlapping. Another side effect is that an arealess rectangle
         * (width or height equal to zero) can't intersect any other rectangle.
         * @param {Rectangle} other - The Rectangle to intersect with `this`.
         * @param {Matrix} transform - The transformation matrix of `other`.
         * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
         */
        /**
         * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
         *
         * Returns true only if the area of the intersection is greater than 0.
         * This means that rectangles sharing only a side are not considered intersecting.
         * @example
         * ```ts
         * // Basic intersection check
         * const rect1 = new Rectangle(0, 0, 100, 100);
         * const rect2 = new Rectangle(50, 50, 100, 100);
         * console.log(rect1.intersects(rect2)); // true
         *
         * // With transformation matrix
         * const matrix = new Matrix();
         * matrix.rotate(Math.PI / 4); // 45 degrees
         * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation
         *
         * // Edge cases
         * const zeroWidth = new Rectangle(0, 0, 0, 100);
         * console.log(rect1.intersects(zeroWidth)); // false (no area)
         * ```
         * @remarks
         * - Returns true only if intersection area is > 0
         * - Rectangles sharing only a side are not intersecting
         * - Zero-area rectangles cannot intersect anything
         * - Supports optional transformation matrix
         * @param other - The Rectangle to intersect with `this`
         * @param transform - Optional transformation matrix of `other`
         * @returns True if the transformed `other` Rectangle intersects with `this`
         * @see {@link Rectangle.containsRect} For containment testing
         * @see {@link Rectangle.contains} For point testing
         */
        intersects(other, transform2) {
          if (!transform2) {
            const x02 = this.x < other.x ? other.x : this.x;
            const x12 = this.right > other.right ? other.right : this.right;
            if (x12 <= x02) {
              return false;
            }
            const y02 = this.y < other.y ? other.y : this.y;
            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
            return y12 > y02;
          }
          const x0 = this.left;
          const x1 = this.right;
          const y0 = this.top;
          const y1 = this.bottom;
          if (x1 <= x0 || y1 <= y0) {
            return false;
          }
          const lt = tempPoints[0].set(other.left, other.top);
          const lb = tempPoints[1].set(other.left, other.bottom);
          const rt = tempPoints[2].set(other.right, other.top);
          const rb = tempPoints[3].set(other.right, other.bottom);
          if (rt.x <= lt.x || lb.y <= lt.y) {
            return false;
          }
          const s2 = Math.sign(transform2.a * transform2.d - transform2.b * transform2.c);
          if (s2 === 0) {
            return false;
          }
          transform2.apply(lt, lt);
          transform2.apply(lb, lb);
          transform2.apply(rt, rt);
          transform2.apply(rb, rb);
          if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
            return false;
          }
          const nx = s2 * (lb.y - lt.y);
          const ny = s2 * (lt.x - lb.x);
          const n00 = nx * x0 + ny * y0;
          const n10 = nx * x1 + ny * y0;
          const n01 = nx * x0 + ny * y1;
          const n11 = nx * x1 + ny * y1;
          if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
            return false;
          }
          const mx = s2 * (lt.y - rt.y);
          const my = s2 * (rt.x - lt.x);
          const m00 = mx * x0 + my * y0;
          const m10 = mx * x1 + my * y0;
          const m01 = mx * x0 + my * y1;
          const m11 = mx * x1 + my * y1;
          if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
            return false;
          }
          return true;
        }
        /**
         * Pads the rectangle making it grow in all directions.
         *
         * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
         * @example
         * ```ts
         * // Basic padding
         * const rect = new Rectangle(100, 100, 200, 150);
         * rect.pad(10); // Adds 10px padding on all sides
         *
         * // Different horizontal and vertical padding
         * const uiRect = new Rectangle(0, 0, 100, 50);
         * uiRect.pad(20, 10); // 20px horizontal, 10px vertical
         * ```
         * @remarks
         * - Adjusts x/y by subtracting padding
         * - Increases width/height by padding * 2
         * - Common in UI layout calculations
         * - Chainable with other methods
         * @param paddingX - The horizontal padding amount
         * @param paddingY - The vertical padding amount
         * @returns Returns itself
         * @see {@link Rectangle.enlarge} For growing to include another rectangle
         * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
         */
        pad(paddingX = 0, paddingY = paddingX) {
          this.x -= paddingX;
          this.y -= paddingY;
          this.width += paddingX * 2;
          this.height += paddingY * 2;
          return this;
        }
        /**
         * Fits this rectangle around the passed one.
         * @example
         * ```ts
         * // Basic fitting
         * const container = new Rectangle(0, 0, 100, 100);
         * const content = new Rectangle(25, 25, 200, 200);
         * content.fit(container); // Clips to container bounds
         * ```
         * @param rectangle - The rectangle to fit around
         * @returns Returns itself
         * @see {@link Rectangle.enlarge} For growing to include another rectangle
         * @see {@link Rectangle.pad} For adding padding around the rectangle
         */
        fit(rectangle) {
          const x1 = Math.max(this.x, rectangle.x);
          const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.max(this.y, rectangle.y);
          const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = Math.max(x2 - x1, 0);
          this.y = y1;
          this.height = Math.max(y2 - y1, 0);
          return this;
        }
        /**
         * Enlarges rectangle so that its corners lie on a grid defined by resolution.
         * @example
         * ```ts
         * // Basic grid alignment
         * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);
         * rect.ceil(); // Aligns to whole pixels
         *
         * // Custom resolution grid
         * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);
         * uiRect.ceil(0.5); // Aligns to half pixels
         *
         * // Use with precision value
         * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);
         * preciseRect.ceil(1, 0.01); // Handles small decimal variations
         * ```
         * @param resolution - The grid size to align to (1 = whole pixels)
         * @param eps - Small number to prevent floating point errors
         * @returns Returns itself
         * @see {@link Rectangle.fit} For constraining to bounds
         * @see {@link Rectangle.enlarge} For growing dimensions
         */
        ceil(resolution = 1, eps = 1e-3) {
          const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
          const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
          this.x = Math.floor((this.x + eps) * resolution) / resolution;
          this.y = Math.floor((this.y + eps) * resolution) / resolution;
          this.width = x2 - this.x;
          this.height = y2 - this.y;
          return this;
        }
        /**
         * Scales the rectangle's dimensions and position by the specified factors.
         * @example
         * ```ts
         * const rect = new Rectangle(50, 50, 100, 100);
         *
         * // Scale uniformly
         * rect.scale(0.5, 0.5);
         * // rect is now: x=25, y=25, width=50, height=50
         *
         * // non-uniformly
         * rect.scale(0.5, 1);
         * // rect is now: x=25, y=50, width=50, height=100
         * ```
         * @param x - The factor by which to scale the horizontal properties (x, width).
         * @param y - The factor by which to scale the vertical properties (y, height).
         * @returns Returns itself
         */
        scale(x2, y2 = x2) {
          this.x *= x2;
          this.y *= y2;
          this.width *= x2;
          this.height *= y2;
          return this;
        }
        /**
         * Enlarges this rectangle to include the passed rectangle.
         * @example
         * ```ts
         * // Basic enlargement
         * const rect = new Rectangle(50, 50, 100, 100);
         * const other = new Rectangle(0, 0, 200, 75);
         * rect.enlarge(other);
         * // rect is now: x=0, y=0, width=200, height=150
         *
         * // Use for bounding box calculation
         * const bounds = new Rectangle();
         * objects.forEach((obj) => {
         *     bounds.enlarge(obj.getBounds());
         * });
         * ```
         * @param rectangle - The rectangle to include
         * @returns Returns itself
         * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
         * @see {@link Rectangle.pad} For adding padding around the rectangle
         */
        enlarge(rectangle) {
          const x1 = Math.min(this.x, rectangle.x);
          const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.min(this.y, rectangle.y);
          const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = x2 - x1;
          this.y = y1;
          this.height = y2 - y1;
          return this;
        }
        /**
         * Returns the framing rectangle of the rectangle as a Rectangle object
         * @example
         * ```ts
         * // Basic bounds retrieval
         * const rect = new Rectangle(100, 100, 200, 150);
         * const bounds = rect.getBounds();
         *
         * // Reuse existing rectangle
         * const out = new Rectangle();
         * rect.getBounds(out);
         * ```
         * @param out - Optional rectangle to store the result
         * @returns The framing rectangle
         * @see {@link Rectangle.copyFrom} For direct copying
         * @see {@link Rectangle.clone} For creating new copy
         */
        getBounds(out2) {
          out2 || (out2 = new _Rectangle());
          out2.copyFrom(this);
          return out2;
        }
        /**
         * Determines whether another Rectangle is fully contained within this Rectangle.
         *
         * Rectangles that occupy the same space are considered to be containing each other.
         *
         * Rectangles without area (width or height equal to zero) can't contain anything,
         * not even other arealess rectangles.
         * @example
         * ```ts
         * // Check if one rectangle contains another
         * const container = new Rectangle(0, 0, 100, 100);
         * const inner = new Rectangle(25, 25, 50, 50);
         *
         * console.log(container.containsRect(inner)); // true
         *
         * // Check overlapping rectangles
         * const partial = new Rectangle(75, 75, 50, 50);
         * console.log(container.containsRect(partial)); // false
         *
         * // Zero-area rectangles
         * const empty = new Rectangle(0, 0, 0, 100);
         * console.log(container.containsRect(empty)); // false
         * ```
         * @param other - The Rectangle to check for containment
         * @returns True if other is fully contained within this Rectangle
         * @see {@link Rectangle.contains} For point containment
         * @see {@link Rectangle.intersects} For overlap testing
         */
        containsRect(other) {
          if (this.width <= 0 || this.height <= 0)
            return false;
          const x1 = other.x;
          const y1 = other.y;
          const x2 = other.x + other.width;
          const y2 = other.y + other.height;
          return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
        }
        /**
         * Sets the position and dimensions of the rectangle.
         * @example
         * ```ts
         * // Basic usage
         * const rect = new Rectangle();
         * rect.set(100, 100, 200, 150);
         *
         * // Chain with other operations
         * const bounds = new Rectangle()
         *     .set(0, 0, 100, 100)
         *     .pad(10);
         * ```
         * @param x - The X coordinate of the upper-left corner of the rectangle
         * @param y - The Y coordinate of the upper-left corner of the rectangle
         * @param width - The overall width of the rectangle
         * @param height - The overall height of the rectangle
         * @returns Returns itself for method chaining
         * @see {@link Rectangle.copyFrom} For copying from another rectangle
         * @see {@link Rectangle.clone} For creating a new copy
         */
        set(x2, y2, width, height) {
          this.x = x2;
          this.y = y2;
          this.width = width;
          this.height = height;
          return this;
        }
        toString() {
          return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
  var defaultMatrix, Bounds;
  var init_Bounds = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"() {
      init_Matrix();
      init_Rectangle();
      defaultMatrix = new Matrix();
      Bounds = class _Bounds {
        /**
         * Creates a new Bounds object.
         * @param minX - The minimum X coordinate of the bounds.
         * @param minY - The minimum Y coordinate of the bounds.
         * @param maxX - The maximum X coordinate of the bounds.
         * @param maxY - The maximum Y coordinate of the bounds.
         */
        constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this.matrix = defaultMatrix;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Checks if bounds are empty, meaning either width or height is zero or negative.
         * Empty bounds occur when min values exceed max values on either axis.
         * @example
         * ```ts
         * const bounds = new Bounds();
         *
         * // Check if newly created bounds are empty
         * console.log(bounds.isEmpty()); // true, default bounds are empty
         *
         * // Add frame and check again
         * bounds.addFrame(0, 0, 100, 100);
         * console.log(bounds.isEmpty()); // false, bounds now have area
         *
         * // Clear bounds
         * bounds.clear();
         * console.log(bounds.isEmpty()); // true, bounds are empty again
         * ```
         * @returns True if bounds are empty (have no area)
         * @see {@link Bounds#clear} For resetting bounds
         * @see {@link Bounds#isValid} For checking validity
         */
        isEmpty() {
          return this.minX > this.maxX || this.minY > this.maxY;
        }
        /**
         * The bounding rectangle representation of these bounds.
         * Lazily creates and updates a Rectangle instance based on the current bounds.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         *
         * // Get rectangle representation
         * const rect = bounds.rectangle;
         * console.log(rect.x, rect.y, rect.width, rect.height);
         *
         * // Use for hit testing
         * if (bounds.rectangle.contains(mouseX, mouseY)) {
         *     console.log('Mouse is inside bounds!');
         * }
         * ```
         * @see {@link Rectangle} For rectangle methods
         * @see {@link Bounds.isEmpty} For bounds validation
         */
        get rectangle() {
          if (!this._rectangle) {
            this._rectangle = new Rectangle();
          }
          const rectangle = this._rectangle;
          if (this.minX > this.maxX || this.minY > this.maxY) {
            rectangle.x = 0;
            rectangle.y = 0;
            rectangle.width = 0;
            rectangle.height = 0;
          } else {
            rectangle.copyFromBounds(this);
          }
          return rectangle;
        }
        /**
         * Clears the bounds and resets all coordinates to their default values.
         * Resets the transformation matrix back to identity.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * console.log(bounds.isEmpty()); // false
         * // Clear the bounds
         * bounds.clear();
         * console.log(bounds.isEmpty()); // true
         * ```
         * @returns This bounds object for chaining
         */
        clear() {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this.matrix = defaultMatrix;
          return this;
        }
        /**
         * Sets the bounds directly using coordinate values.
         * Provides a way to set all bounds values at once.
         * @example
         * ```ts
         * const bounds = new Bounds();
         * bounds.set(0, 0, 100, 100);
         * ```
         * @param x0 - Left X coordinate of frame
         * @param y0 - Top Y coordinate of frame
         * @param x1 - Right X coordinate of frame
         * @param y1 - Bottom Y coordinate of frame
         * @see {@link Bounds#addFrame} For matrix-aware bounds setting
         * @see {@link Bounds#clear} For resetting bounds
         */
        set(x0, y0, x1, y1) {
          this.minX = x0;
          this.minY = y0;
          this.maxX = x1;
          this.maxY = y1;
        }
        /**
         * Adds a rectangular frame to the bounds, optionally transformed by a matrix.
         * Updates the bounds to encompass the new frame coordinates.
         * @example
         * ```ts
         * const bounds = new Bounds();
         * bounds.addFrame(0, 0, 100, 100);
         *
         * // Add transformed frame
         * const matrix = new Matrix()
         *     .translate(50, 50)
         *     .rotate(Math.PI / 4);
         * bounds.addFrame(0, 0, 100, 100, matrix);
         * ```
         * @param x0 - Left X coordinate of frame
         * @param y0 - Top Y coordinate of frame
         * @param x1 - Right X coordinate of frame
         * @param y1 - Bottom Y coordinate of frame
         * @param matrix - Optional transformation matrix
         * @see {@link Bounds#addRect} For adding Rectangle objects
         * @see {@link Bounds#addBounds} For adding other Bounds
         */
        addFrame(x0, y0, x1, y1, matrix) {
          matrix || (matrix = this.matrix);
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          let x2 = a2 * x0 + c2 * y0 + tx;
          let y2 = b2 * x0 + d2 * y0 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x1 + c2 * y0 + tx;
          y2 = b2 * x1 + d2 * y0 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x0 + c2 * y1 + tx;
          y2 = b2 * x0 + d2 * y1 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x1 + c2 * y1 + tx;
          y2 = b2 * x1 + d2 * y1 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Adds a rectangle to the bounds, optionally transformed by a matrix.
         * Updates the bounds to encompass the given rectangle.
         * @example
         * ```ts
         * const bounds = new Bounds();
         * // Add simple rectangle
         * const rect = new Rectangle(0, 0, 100, 100);
         * bounds.addRect(rect);
         *
         * // Add transformed rectangle
         * const matrix = new Matrix()
         *     .translate(50, 50)
         *     .rotate(Math.PI / 4);
         * bounds.addRect(rect, matrix);
         * ```
         * @param rect - The rectangle to be added
         * @param matrix - Optional transformation matrix
         * @see {@link Bounds#addFrame} For adding raw coordinates
         * @see {@link Bounds#addBounds} For adding other bounds
         */
        addRect(rect, matrix) {
          this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
        }
        /**
         * Adds another bounds object to this one, optionally transformed by a matrix.
         * Expands the bounds to include the given bounds' area.
         * @example
         * ```ts
         * const bounds = new Bounds();
         *
         * // Add child bounds
         * const childBounds = sprite.getBounds();
         * bounds.addBounds(childBounds);
         *
         * // Add transformed bounds
         * const matrix = new Matrix()
         *     .scale(2, 2);
         * bounds.addBounds(childBounds, matrix);
         * ```
         * @param bounds - The bounds to be added
         * @param matrix - Optional transformation matrix
         * @see {@link Bounds#addFrame} For adding raw coordinates
         * @see {@link Bounds#addRect} For adding rectangles
         */
        addBounds(bounds, matrix) {
          this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
        }
        /**
         * Adds other Bounds as a mask, creating an intersection of the two bounds.
         * Only keeps the overlapping region between current bounds and mask bounds.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * // Create mask bounds
         * const mask = new Bounds();
         * mask.addFrame(50, 50, 150, 150);
         * // Apply mask - results in bounds of (50,50,100,100)
         * bounds.addBoundsMask(mask);
         * ```
         * @param mask - The Bounds to use as a mask
         * @see {@link Bounds#addBounds} For union operation
         * @see {@link Bounds#fit} For fitting to rectangle
         */
        addBoundsMask(mask) {
          this.minX = this.minX > mask.minX ? this.minX : mask.minX;
          this.minY = this.minY > mask.minY ? this.minY : mask.minY;
          this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
          this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
        }
        /**
         * Applies a transformation matrix to the bounds, updating its coordinates.
         * Transforms all corners of the bounds using the given matrix.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * // Apply translation
         * const translateMatrix = new Matrix()
         *     .translate(50, 50);
         * bounds.applyMatrix(translateMatrix);
         * ```
         * @param matrix - The matrix to apply to the bounds
         * @see {@link Matrix} For matrix operations
         * @see {@link Bounds#addFrame} For adding transformed frames
         */
        applyMatrix(matrix) {
          const minX = this.minX;
          const minY = this.minY;
          const maxX = this.maxX;
          const maxY = this.maxY;
          const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix;
          let x2 = a2 * minX + c2 * minY + tx;
          let y2 = b2 * minX + d2 * minY + ty;
          this.minX = x2;
          this.minY = y2;
          this.maxX = x2;
          this.maxY = y2;
          x2 = a2 * maxX + c2 * minY + tx;
          y2 = b2 * maxX + d2 * minY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * minX + c2 * maxY + tx;
          y2 = b2 * minX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * maxX + c2 * maxY + tx;
          y2 = b2 * maxX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
        }
        /**
         * Resizes the bounds object to fit within the given rectangle.
         * Clips the bounds if they extend beyond the rectangle's edges.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 200, 200);
         * // Fit within viewport
         * const viewport = new Rectangle(50, 50, 100, 100);
         * bounds.fit(viewport);
         * // bounds are now (50, 50, 150, 150)
         * ```
         * @param rect - The rectangle to fit within
         * @returns This bounds object for chaining
         * @see {@link Bounds#addBoundsMask} For intersection
         * @see {@link Bounds#pad} For expanding bounds
         */
        fit(rect) {
          if (this.minX < rect.left)
            this.minX = rect.left;
          if (this.maxX > rect.right)
            this.maxX = rect.right;
          if (this.minY < rect.top)
            this.minY = rect.top;
          if (this.maxY > rect.bottom)
            this.maxY = rect.bottom;
          return this;
        }
        /**
         * Resizes the bounds object to include the given bounds.
         * Similar to fit() but works with raw coordinate values instead of a Rectangle.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 200, 200);
         * // Fit to specific coordinates
         * bounds.fitBounds(50, 150, 50, 150);
         * // bounds are now (50, 50, 150, 150)
         * ```
         * @param left - The left value of the bounds
         * @param right - The right value of the bounds
         * @param top - The top value of the bounds
         * @param bottom - The bottom value of the bounds
         * @returns This bounds object for chaining
         * @see {@link Bounds#fit} For fitting to Rectangle
         * @see {@link Bounds#addBoundsMask} For intersection
         */
        fitBounds(left, right, top, bottom) {
          if (this.minX < left)
            this.minX = left;
          if (this.maxX > right)
            this.maxX = right;
          if (this.minY < top)
            this.minY = top;
          if (this.maxY > bottom)
            this.maxY = bottom;
          return this;
        }
        /**
         * Pads bounds object, making it grow in all directions.
         * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         *
         * // Add equal padding
         * bounds.pad(10);
         * // bounds are now (-10, -10, 110, 110)
         *
         * // Add different padding for x and y
         * bounds.pad(20, 10);
         * // bounds are now (-30, -20, 130, 120)
         * ```
         * @param paddingX - The horizontal padding amount
         * @param paddingY - The vertical padding amount
         * @returns This bounds object for chaining
         * @see {@link Bounds#fit} For constraining bounds
         * @see {@link Bounds#scale} For uniform scaling
         */
        pad(paddingX, paddingY = paddingX) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
          return this;
        }
        /**
         * Ceils the bounds by rounding up max values and rounding down min values.
         * Useful for pixel-perfect calculations and avoiding fractional pixels.
         * @example
         * ```ts
         * const bounds = new Bounds();
         * bounds.set(10.2, 10.9, 50.1, 50.8);
         *
         * // Round to whole pixels
         * bounds.ceil();
         * // bounds are now (10, 10, 51, 51)
         * ```
         * @returns This bounds object for chaining
         * @see {@link Bounds#scale} For size adjustments
         * @see {@link Bounds#fit} For constraining bounds
         */
        ceil() {
          this.minX = Math.floor(this.minX);
          this.minY = Math.floor(this.minY);
          this.maxX = Math.ceil(this.maxX);
          this.maxY = Math.ceil(this.maxY);
          return this;
        }
        /**
         * Creates a new Bounds instance with the same values.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         *
         * // Create a copy
         * const copy = bounds.clone();
         *
         * // Original and copy are independent
         * bounds.pad(10);
         * console.log(copy.width === bounds.width); // false
         * ```
         * @returns A new Bounds instance with the same values
         * @see {@link Bounds#copyFrom} For reusing existing bounds
         */
        clone() {
          return new _Bounds(this.minX, this.minY, this.maxX, this.maxY);
        }
        /**
         * Scales the bounds by the given values, adjusting all edges proportionally.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         *
         * // Scale uniformly
         * bounds.scale(2);
         * // bounds are now (0, 0, 200, 200)
         *
         * // Scale non-uniformly
         * bounds.scale(0.5, 2);
         * // bounds are now (0, 0, 100, 400)
         * ```
         * @param x - The X value to scale by
         * @param y - The Y value to scale by (defaults to x)
         * @returns This bounds object for chaining
         * @see {@link Bounds#pad} For adding padding
         * @see {@link Bounds#fit} For constraining size
         */
        scale(x2, y2 = x2) {
          this.minX *= x2;
          this.minY *= y2;
          this.maxX *= x2;
          this.maxY *= y2;
          return this;
        }
        /**
         * The x position of the bounds in local space.
         * Setting this value will move the bounds while maintaining its width.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * // Get x position
         * console.log(bounds.x); // 0
         *
         * // Move bounds horizontally
         * bounds.x = 50;
         * console.log(bounds.minX, bounds.maxX); // 50, 150
         *
         * // Width stays the same
         * console.log(bounds.width); // Still 100
         * ```
         */
        get x() {
          return this.minX;
        }
        set x(value) {
          const width = this.maxX - this.minX;
          this.minX = value;
          this.maxX = value + width;
        }
        /**
         * The y position of the bounds in local space.
         * Setting this value will move the bounds while maintaining its height.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * // Get y position
         * console.log(bounds.y); // 0
         *
         * // Move bounds vertically
         * bounds.y = 50;
         * console.log(bounds.minY, bounds.maxY); // 50, 150
         *
         * // Height stays the same
         * console.log(bounds.height); // Still 100
         * ```
         */
        get y() {
          return this.minY;
        }
        set y(value) {
          const height = this.maxY - this.minY;
          this.minY = value;
          this.maxY = value + height;
        }
        /**
         * The width value of the bounds.
         * Represents the distance between minX and maxX coordinates.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * // Get width
         * console.log(bounds.width); // 100
         * // Resize width
         * bounds.width = 200;
         * console.log(bounds.maxX - bounds.minX); // 200
         * ```
         */
        get width() {
          return this.maxX - this.minX;
        }
        set width(value) {
          this.maxX = this.minX + value;
        }
        /**
         * The height value of the bounds.
         * Represents the distance between minY and maxY coordinates.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * // Get height
         * console.log(bounds.height); // 100
         * // Resize height
         * bounds.height = 150;
         * console.log(bounds.maxY - bounds.minY); // 150
         * ```
         */
        get height() {
          return this.maxY - this.minY;
        }
        set height(value) {
          this.maxY = this.minY + value;
        }
        /**
         * The left edge coordinate of the bounds.
         * Alias for minX.
         * @example
         * ```ts
         * const bounds = new Bounds(50, 0, 150, 100);
         * console.log(bounds.left); // 50
         * console.log(bounds.left === bounds.minX); // true
         * ```
         * @readonly
         */
        get left() {
          return this.minX;
        }
        /**
         * The right edge coordinate of the bounds.
         * Alias for maxX.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * console.log(bounds.right); // 100
         * console.log(bounds.right === bounds.maxX); // true
         * ```
         * @readonly
         */
        get right() {
          return this.maxX;
        }
        /**
         * The top edge coordinate of the bounds.
         * Alias for minY.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 25, 100, 125);
         * console.log(bounds.top); // 25
         * console.log(bounds.top === bounds.minY); // true
         * ```
         * @readonly
         */
        get top() {
          return this.minY;
        }
        /**
         * The bottom edge coordinate of the bounds.
         * Alias for maxY.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 200);
         * console.log(bounds.bottom); // 200
         * console.log(bounds.bottom === bounds.maxY); // true
         * ```
         * @readonly
         */
        get bottom() {
          return this.maxY;
        }
        /**
         * Whether the bounds has positive width and height.
         * Checks if both dimensions are greater than zero.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * // Check if bounds are positive
         * console.log(bounds.isPositive); // true
         *
         * // Negative bounds
         * bounds.maxX = bounds.minX;
         * console.log(bounds.isPositive); // false, width is 0
         * ```
         * @readonly
         * @see {@link Bounds#isEmpty} For checking empty state
         * @see {@link Bounds#isValid} For checking validity
         */
        get isPositive() {
          return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
        }
        /**
         * Whether the bounds has valid coordinates.
         * Checks if the bounds has been initialized with real values.
         * @example
         * ```ts
         * const bounds = new Bounds();
         * console.log(bounds.isValid); // false, default state
         *
         * // Set valid bounds
         * bounds.addFrame(0, 0, 100, 100);
         * console.log(bounds.isValid); // true
         * ```
         * @readonly
         * @see {@link Bounds#isEmpty} For checking empty state
         * @see {@link Bounds#isPositive} For checking dimensions
         */
        get isValid() {
          return this.minX + this.minY !== Infinity;
        }
        /**
         * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.
         * Used for efficiently updating bounds from raw vertex data.
         * @example
         * ```ts
         * const bounds = new Bounds();
         *
         * // Add vertices from geometry
         * const vertices = new Float32Array([
         *     0, 0,    // Vertex 1
         *     100, 0,  // Vertex 2
         *     100, 100 // Vertex 3
         * ]);
         * bounds.addVertexData(vertices, 0, 6);
         *
         * // Add transformed vertices
         * const matrix = new Matrix()
         *     .translate(50, 50)
         *     .rotate(Math.PI / 4);
         * bounds.addVertexData(vertices, 0, 6, matrix);
         *
         * // Add subset of vertices
         * bounds.addVertexData(vertices, 2, 4); // Only second vertex
         * ```
         * @param vertexData - The array of vertices to add
         * @param beginOffset - Starting index in the vertex array
         * @param endOffset - Ending index in the vertex array (excluded)
         * @param matrix - Optional transformation matrix
         * @see {@link Bounds#addFrame} For adding rectangular frames
         * @see {@link Matrix} For transformation details
         */
        addVertexData(vertexData, beginOffset, endOffset, matrix) {
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          matrix || (matrix = this.matrix);
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          for (let i3 = beginOffset; i3 < endOffset; i3 += 2) {
            const localX = vertexData[i3];
            const localY = vertexData[i3 + 1];
            const x2 = a2 * localX + c2 * localY + tx;
            const y2 = b2 * localX + d2 * localY + ty;
            minX = x2 < minX ? x2 : minX;
            minY = y2 < minY ? y2 : minY;
            maxX = x2 > maxX ? x2 : maxX;
            maxY = y2 > maxY ? y2 : maxY;
          }
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Checks if a point is contained within the bounds.
         * Returns true if the point's coordinates fall within the bounds' area.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * // Basic point check
         * console.log(bounds.containsPoint(50, 50)); // true
         * console.log(bounds.containsPoint(150, 150)); // false
         *
         * // Check edges
         * console.log(bounds.containsPoint(0, 0));   // true, includes edges
         * console.log(bounds.containsPoint(100, 100)); // true, includes edges
         * ```
         * @param x - x coordinate to check
         * @param y - y coordinate to check
         * @returns True if the point is inside the bounds
         * @see {@link Bounds#isPositive} For valid bounds check
         * @see {@link Bounds#rectangle} For Rectangle representation
         */
        containsPoint(x2, y2) {
          if (this.minX <= x2 && this.minY <= y2 && this.maxX >= x2 && this.maxY >= y2) {
            return true;
          }
          return false;
        }
        /**
         * Returns a string representation of the bounds.
         * Useful for debugging and logging bounds information.
         * @example
         * ```ts
         * const bounds = new Bounds(0, 0, 100, 100);
         * console.log(bounds.toString()); // "[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]"
         * ```
         * @returns A string describing the bounds
         * @see {@link Bounds#copyFrom} For copying bounds
         * @see {@link Bounds#clone} For creating a new instance
         */
        toString() {
          return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
        }
        /**
         * Copies the bounds from another bounds object.
         * Useful for reusing bounds objects and avoiding allocations.
         * @example
         * ```ts
         * const sourceBounds = new Bounds(0, 0, 100, 100);
         * // Copy bounds
         * const targetBounds = new Bounds();
         * targetBounds.copyFrom(sourceBounds);
         * ```
         * @param bounds - The bounds to copy from
         * @returns This bounds object for chaining
         * @see {@link Bounds#clone} For creating new instances
         */
        copyFrom(bounds) {
          this.minX = bounds.minX;
          this.minY = bounds.minY;
          this.maxX = bounds.maxX;
          this.maxY = bounds.maxY;
          return this;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs
  var matrixPool, boundsPool;
  var init_matrixAndBoundsPool = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs"() {
      init_Matrix();
      init_PoolGroup();
      init_Bounds();
      matrixPool = BigPool.getPool(Matrix);
      boundsPool = BigPool.getPool(Bounds);
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs
  var tempMatrix2, getFastGlobalBoundsMixin;
  var init_getFastGlobalBoundsMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs"() {
      init_Matrix();
      init_Bounds();
      init_matrixAndBoundsPool();
      tempMatrix2 = new Matrix();
      getFastGlobalBoundsMixin = {
        getFastGlobalBounds(factorRenderLayers, bounds) {
          bounds || (bounds = new Bounds());
          bounds.clear();
          this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);
          if (!bounds.isValid) {
            bounds.set(0, 0, 0, 0);
          }
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          bounds.applyMatrix(renderGroup.worldTransform);
          return bounds;
        },
        _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {
          let localBounds = bounds;
          if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer)
            return;
          if (this.localDisplayStatus !== 7 || !this.measurable) {
            return;
          }
          const manageEffects = !!this.effects.length;
          if (this.renderGroup || manageEffects) {
            localBounds = boundsPool.get().clear();
          }
          if (this.boundsArea) {
            bounds.addRect(this.boundsArea, this.worldTransform);
          } else {
            if (this.renderPipeId) {
              const viewBounds = this.bounds;
              localBounds.addFrame(
                viewBounds.minX,
                viewBounds.minY,
                viewBounds.maxX,
                viewBounds.maxY,
                this.groupTransform
              );
            }
            const children = this.children;
            for (let i3 = 0; i3 < children.length; i3++) {
              children[i3]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);
            }
          }
          if (manageEffects) {
            let advanced = false;
            const renderGroup = this.renderGroup || this.parentRenderGroup;
            for (let i3 = 0; i3 < this.effects.length; i3++) {
              if (this.effects[i3].addBounds) {
                if (!advanced) {
                  advanced = true;
                  localBounds.applyMatrix(renderGroup.worldTransform);
                }
                this.effects[i3].addBounds(localBounds, true);
              }
            }
            if (advanced) {
              localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix2).invert());
            }
            bounds.addBounds(localBounds);
            boundsPool.return(localBounds);
          } else if (this.renderGroup) {
            bounds.addBounds(localBounds, this.relativeGroupTransform);
            boundsPool.return(localBounds);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
  function getGlobalBounds(target, skipUpdateTransform, bounds) {
    bounds.clear();
    let parentTransform;
    let pooledMatrix;
    if (target.parent) {
      if (!skipUpdateTransform) {
        pooledMatrix = matrixPool.get().identity();
        parentTransform = updateTransformBackwards(target, pooledMatrix);
      } else {
        parentTransform = target.parent.worldTransform;
      }
    } else {
      parentTransform = Matrix.IDENTITY;
    }
    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
    if (pooledMatrix) {
      matrixPool.return(pooledMatrix);
    }
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
    var _a2, _b;
    if (!target.visible || !target.measurable)
      return;
    let worldTransform;
    if (!skipUpdateTransform) {
      target.updateLocalTransform();
      worldTransform = matrixPool.get();
      worldTransform.appendFrom(target.localTransform, parentTransform);
    } else {
      worldTransform = target.worldTransform;
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, worldTransform);
    } else {
      const renderableBounds = target.bounds;
      if (renderableBounds && !renderableBounds.isEmpty()) {
        bounds.matrix = worldTransform;
        bounds.addBounds(renderableBounds);
      }
      for (let i3 = 0; i3 < target.children.length; i3++) {
        _getGlobalBounds(target.children[i3], bounds, worldTransform, skipUpdateTransform);
      }
    }
    if (preserveBounds) {
      for (let i3 = 0; i3 < target.effects.length; i3++) {
        (_b = (_a2 = target.effects[i3]).addBounds) == null ? void 0 : _b.call(_a2, bounds);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    if (!skipUpdateTransform) {
      matrixPool.return(worldTransform);
    }
  }
  function updateTransformBackwards(target, parentTransform) {
    const parent = target.parent;
    if (parent) {
      updateTransformBackwards(parent, parentTransform);
      parent.updateLocalTransform();
      parentTransform.append(parent.localTransform);
    }
    return parentTransform;
  }
  var init_getGlobalBounds = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"() {
      init_Matrix();
      init_matrixAndBoundsPool();
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs
  function multiplyHexColors(color1, color2) {
    if (color1 === 16777215 || !color2)
      return color2;
    if (color2 === 16777215 || !color1)
      return color1;
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r3 = r1 * r2 / 255 | 0;
    const g3 = g1 * g2 / 255 | 0;
    const b3 = b1 * b2 / 255 | 0;
    return (r3 << 16) + (g3 << 8) + b3;
  }
  var init_multiplyHexColors = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs
  function multiplyColors(localBGRColor, parentBGRColor) {
    if (localBGRColor === WHITE_BGR) {
      return parentBGRColor;
    }
    if (parentBGRColor === WHITE_BGR) {
      return localBGRColor;
    }
    return multiplyHexColors(localBGRColor, parentBGRColor);
  }
  var WHITE_BGR;
  var init_multiplyColors = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs"() {
      init_multiplyHexColors();
      WHITE_BGR = 16777215;
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs
  function bgr2rgb(color) {
    return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);
  }
  var getGlobalMixin;
  var init_getGlobalMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs"() {
      init_Matrix();
      init_getGlobalBounds();
      init_matrixAndBoundsPool();
      init_multiplyColors();
      getGlobalMixin = {
        getGlobalAlpha(skipUpdate) {
          if (skipUpdate) {
            if (this.renderGroup) {
              return this.renderGroup.worldAlpha;
            }
            if (this.parentRenderGroup) {
              return this.parentRenderGroup.worldAlpha * this.alpha;
            }
            return this.alpha;
          }
          let alpha = this.alpha;
          let current = this.parent;
          while (current) {
            alpha *= current.alpha;
            current = current.parent;
          }
          return alpha;
        },
        getGlobalTransform(matrix = new Matrix(), skipUpdate) {
          if (skipUpdate) {
            return matrix.copyFrom(this.worldTransform);
          }
          this.updateLocalTransform();
          const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());
          matrix.appendFrom(this.localTransform, parentTransform);
          matrixPool.return(parentTransform);
          return matrix;
        },
        getGlobalTint(skipUpdate) {
          if (skipUpdate) {
            if (this.renderGroup) {
              return bgr2rgb(this.renderGroup.worldColor);
            }
            if (this.parentRenderGroup) {
              return bgr2rgb(
                multiplyColors(this.localColor, this.parentRenderGroup.worldColor)
              );
            }
            return this.tint;
          }
          let color = this.localColor;
          let parent = this.parent;
          while (parent) {
            color = multiplyColors(color, parent.localColor);
            parent = parent.parent;
          }
          return bgr2rgb(color);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
  function getLocalBounds(target, bounds, relativeMatrix) {
    bounds.clear();
    relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
    _getLocalBounds(target, bounds, relativeMatrix, target, true);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
    var _a2, _b;
    let relativeTransform;
    if (!isRoot) {
      if (!target.visible || !target.measurable)
        return;
      target.updateLocalTransform();
      const localTransform = target.localTransform;
      relativeTransform = matrixPool.get();
      relativeTransform.appendFrom(localTransform, parentTransform);
    } else {
      relativeTransform = matrixPool.get();
      relativeTransform = parentTransform.copyTo(relativeTransform);
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, relativeTransform);
    } else {
      if (target.renderPipeId) {
        bounds.matrix = relativeTransform;
        bounds.addBounds(target.bounds);
      }
      const children = target.children;
      for (let i3 = 0; i3 < children.length; i3++) {
        _getLocalBounds(children[i3], bounds, relativeTransform, rootContainer, false);
      }
    }
    if (preserveBounds) {
      for (let i3 = 0; i3 < target.effects.length; i3++) {
        (_b = (_a2 = target.effects[i3]).addLocalBounds) == null ? void 0 : _b.call(_a2, bounds, rootContainer);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    matrixPool.return(relativeTransform);
  }
  var init_getLocalBounds = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"() {
      init_Matrix();
      init_matrixAndBoundsPool();
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs
  function checkChildrenDidChange(container, previousData) {
    const children = container.children;
    for (let i3 = 0; i3 < children.length; i3++) {
      const child = children[i3];
      const uid4 = child.uid;
      const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
      const index = previousData.index;
      if (previousData.data[index] !== uid4 || previousData.data[index + 1] !== didChange) {
        previousData.data[previousData.index] = uid4;
        previousData.data[previousData.index + 1] = didChange;
        previousData.didChange = true;
      }
      previousData.index = index + 2;
      if (child.children.length) {
        checkChildrenDidChange(child, previousData);
      }
    }
    return previousData.didChange;
  }
  var init_checkChildrenDidChange = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
  var tempMatrix3, measureMixin;
  var init_measureMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs"() {
      init_Matrix();
      init_Bounds();
      init_getGlobalBounds();
      init_getLocalBounds();
      init_checkChildrenDidChange();
      tempMatrix3 = new Matrix();
      measureMixin = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(value, localWidth) {
          const sign2 = Math.sign(this.scale.x) || 1;
          if (localWidth !== 0) {
            this.scale.x = value / localWidth * sign2;
          } else {
            this.scale.x = sign2;
          }
        },
        _setHeight(value, localHeight) {
          const sign2 = Math.sign(this.scale.y) || 1;
          if (localHeight !== 0) {
            this.scale.y = value / localHeight * sign2;
          } else {
            this.scale.y = sign2;
          }
        },
        getLocalBounds() {
          if (!this._localBoundsCacheData) {
            this._localBoundsCacheData = {
              data: [],
              index: 1,
              didChange: false,
              localBounds: new Bounds()
            };
          }
          const localBoundsCacheData = this._localBoundsCacheData;
          localBoundsCacheData.index = 1;
          localBoundsCacheData.didChange = false;
          if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
            localBoundsCacheData.didChange = true;
            localBoundsCacheData.data[0] = this._didViewChangeTick;
          }
          checkChildrenDidChange(this, localBoundsCacheData);
          if (localBoundsCacheData.didChange) {
            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix3);
          }
          return localBoundsCacheData.localBounds;
        },
        getBounds(skipUpdate, bounds) {
          return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
  var onRenderMixin;
  var init_onRenderMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
      "use strict";
      onRenderMixin = {
        _onRender: null,
        set onRender(func) {
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (!func) {
            if (this._onRender) {
              renderGroup == null ? void 0 : renderGroup.removeOnRender(this);
            }
            this._onRender = null;
            return;
          }
          if (!this._onRender) {
            renderGroup == null ? void 0 : renderGroup.addOnRender(this);
          }
          this._onRender = func;
        },
        get onRender() {
          return this._onRender;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
  function sortChildren(a2, b2) {
    return a2._zIndex - b2._zIndex;
  }
  var sortMixin;
  var init_sortMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs"() {
      "use strict";
      sortMixin = {
        _zIndex: 0,
        sortDirty: false,
        sortableChildren: false,
        get zIndex() {
          return this._zIndex;
        },
        set zIndex(value) {
          if (this._zIndex === value)
            return;
          this._zIndex = value;
          this.depthOfChildModified();
        },
        depthOfChildModified() {
          if (this.parent) {
            this.parent.sortableChildren = true;
            this.parent.sortDirty = true;
          }
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
        },
        sortChildren() {
          if (!this.sortDirty)
            return;
          this.sortDirty = false;
          this.children.sort(sortChildren);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
  var toLocalGlobalMixin;
  var init_toLocalGlobalMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
      init_Point();
      init_matrixAndBoundsPool();
      toLocalGlobalMixin = {
        getGlobalPosition(point = new Point(), skipUpdate = false) {
          if (this.parent) {
            this.parent.toGlobal(this._position, point, skipUpdate);
          } else {
            point.x = this._position.x;
            point.y = this._position.y;
          }
          return point;
        },
        toGlobal(position, point, skipUpdate = false) {
          const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
          point = globalMatrix.apply(position, point);
          matrixPool.return(globalMatrix);
          return point;
        },
        toLocal(position, from, point, skipUpdate) {
          if (from) {
            position = from.toGlobal(position, point, skipUpdate);
          }
          const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
          point = globalMatrix.applyInverse(position, point);
          matrixPool.return(globalMatrix);
          return point;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
  var InstructionSet;
  var init_InstructionSet = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
      init_uid();
      InstructionSet = class {
        constructor() {
          this.uid = uid2("instructionSet");
          this.instructions = [];
          this.instructionSize = 0;
          this.renderables = [];
          this.gcTick = 0;
        }
        /** reset the instruction set so it can be reused set size back to 0 */
        reset() {
          this.instructionSize = 0;
        }
        /**
         * Destroy the instruction set, clearing the instructions and renderables.
         * @internal
         */
        destroy() {
          this.instructions.length = 0;
          this.renderables.length = 0;
          this.renderPipes = null;
          this.gcTick = 0;
        }
        /**
         * Add an instruction to the set
         * @param instruction - add an instruction to the set
         */
        add(instruction) {
          this.instructions[this.instructionSize++] = instruction;
        }
        /**
         * Log the instructions to the console (for debugging)
         * @internal
         */
        log() {
          this.instructions.length = this.instructionSize;
          console.table(this.instructions, ["type", "action"]);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/maths/misc/pow2.mjs
  function nextPow2(v2) {
    v2 += v2 === 0 ? 1 : 0;
    --v2;
    v2 |= v2 >>> 1;
    v2 |= v2 >>> 2;
    v2 |= v2 >>> 4;
    v2 |= v2 >>> 8;
    v2 |= v2 >>> 16;
    return v2 + 1;
  }
  function isPow2(v2) {
    return !(v2 & v2 - 1) && !!v2;
  }
  function log2(v2) {
    let r2 = (v2 > 65535 ? 1 : 0) << 4;
    v2 >>>= r2;
    let shift = (v2 > 255 ? 1 : 0) << 3;
    v2 >>>= shift;
    r2 |= shift;
    shift = (v2 > 15 ? 1 : 0) << 2;
    v2 >>>= shift;
    r2 |= shift;
    shift = (v2 > 3 ? 1 : 0) << 1;
    v2 >>>= shift;
    r2 |= shift;
    return r2 | v2 >> 1;
  }
  var init_pow2 = __esm({
    "node_modules/pixi.js/lib/maths/misc/pow2.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
  function definedProps(obj) {
    const result = {};
    for (const key in obj) {
      if (obj[key] !== void 0) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  var init_definedProps = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
  function createResourceIdFromString(value) {
    const id = idHash[value];
    if (id === void 0) {
      idHash[value] = uid2("resource");
    }
    return id;
  }
  var idHash, _TextureStyle, TextureStyle;
  var init_TextureStyle = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
      init_eventemitter3();
      init_uid();
      init_deprecation();
      idHash = /* @__PURE__ */ Object.create(null);
      _TextureStyle = class _TextureStyle2 extends eventemitter3_default {
        /**
         * @param options - options for the style
         */
        constructor(options = {}) {
          var _a2, _b, _c, _d, _e, _f, _g;
          super();
          this._resourceType = "textureSampler";
          this._touched = 0;
          this._maxAnisotropy = 1;
          this.destroyed = false;
          options = __spreadValues(__spreadValues({}, _TextureStyle2.defaultOptions), options);
          this.addressMode = options.addressMode;
          this.addressModeU = (_a2 = options.addressModeU) != null ? _a2 : this.addressModeU;
          this.addressModeV = (_b = options.addressModeV) != null ? _b : this.addressModeV;
          this.addressModeW = (_c = options.addressModeW) != null ? _c : this.addressModeW;
          this.scaleMode = options.scaleMode;
          this.magFilter = (_d = options.magFilter) != null ? _d : this.magFilter;
          this.minFilter = (_e = options.minFilter) != null ? _e : this.minFilter;
          this.mipmapFilter = (_f = options.mipmapFilter) != null ? _f : this.mipmapFilter;
          this.lodMinClamp = options.lodMinClamp;
          this.lodMaxClamp = options.lodMaxClamp;
          this.compare = options.compare;
          this.maxAnisotropy = (_g = options.maxAnisotropy) != null ? _g : 1;
        }
        set addressMode(value) {
          this.addressModeU = value;
          this.addressModeV = value;
          this.addressModeW = value;
        }
        /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
        get addressMode() {
          return this.addressModeU;
        }
        set wrapMode(value) {
          deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
          this.addressMode = value;
        }
        get wrapMode() {
          return this.addressMode;
        }
        set scaleMode(value) {
          this.magFilter = value;
          this.minFilter = value;
          this.mipmapFilter = value;
        }
        /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
        get scaleMode() {
          return this.magFilter;
        }
        /** Specifies the maximum anisotropy value clamp used by the sampler. */
        set maxAnisotropy(value) {
          this._maxAnisotropy = Math.min(value, 16);
          if (this._maxAnisotropy > 1) {
            this.scaleMode = "linear";
          }
        }
        get maxAnisotropy() {
          return this._maxAnisotropy;
        }
        // TODO - move this to WebGL?
        get _resourceId() {
          return this._sharedResourceId || this._generateResourceId();
        }
        update() {
          this._sharedResourceId = null;
          this.emit("change", this);
        }
        _generateResourceId() {
          const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
          this._sharedResourceId = createResourceIdFromString(bigKey);
          return this._resourceId;
        }
        /** Destroys the style */
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          this.removeAllListeners();
        }
      };
      _TextureStyle.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
      };
      TextureStyle = _TextureStyle;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
  var _TextureSource, TextureSource;
  var init_TextureSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
      init_eventemitter3();
      init_pow2();
      init_definedProps();
      init_uid();
      init_TextureStyle();
      _TextureSource = class _TextureSource2 extends eventemitter3_default {
        /**
         * @param options - options for creating a new TextureSource
         */
        constructor(options = {}) {
          var _a2, _b, _c;
          super();
          this.options = options;
          this._gpuData = /* @__PURE__ */ Object.create(null);
          this._gcLastUsed = -1;
          this.uid = uid2("textureSource");
          this._resourceType = "textureSource";
          this._resourceId = uid2("resource");
          this.uploadMethodId = "unknown";
          this._resolution = 1;
          this.pixelWidth = 1;
          this.pixelHeight = 1;
          this.width = 1;
          this.height = 1;
          this.sampleCount = 1;
          this.mipLevelCount = 1;
          this.autoGenerateMipmaps = false;
          this.format = "rgba8unorm";
          this.dimension = "2d";
          this.antialias = false;
          this._touched = 0;
          this._batchTick = -1;
          this._textureBindLocation = -1;
          options = __spreadValues(__spreadValues({}, _TextureSource2.defaultOptions), options);
          this.label = (_a2 = options.label) != null ? _a2 : "";
          this.resource = options.resource;
          this.autoGarbageCollect = options.autoGarbageCollect;
          this._resolution = options.resolution;
          if (options.width) {
            this.pixelWidth = options.width * this._resolution;
          } else {
            this.pixelWidth = this.resource ? (_b = this.resourceWidth) != null ? _b : 1 : 1;
          }
          if (options.height) {
            this.pixelHeight = options.height * this._resolution;
          } else {
            this.pixelHeight = this.resource ? (_c = this.resourceHeight) != null ? _c : 1 : 1;
          }
          this.width = this.pixelWidth / this._resolution;
          this.height = this.pixelHeight / this._resolution;
          this.format = options.format;
          this.dimension = options.dimensions;
          this.mipLevelCount = options.mipLevelCount;
          this.autoGenerateMipmaps = options.autoGenerateMipmaps;
          this.sampleCount = options.sampleCount;
          this.antialias = options.antialias;
          this.alphaMode = options.alphaMode;
          this.style = new TextureStyle(definedProps(options));
          this.destroyed = false;
          this._refreshPOT();
        }
        /** returns itself */
        get source() {
          return this;
        }
        /** the style of the texture */
        get style() {
          return this._style;
        }
        set style(value) {
          var _a2, _b;
          if (this.style === value)
            return;
          (_a2 = this._style) == null ? void 0 : _a2.off("change", this._onStyleChange, this);
          this._style = value;
          (_b = this._style) == null ? void 0 : _b.on("change", this._onStyleChange, this);
          this._onStyleChange();
        }
        /** Specifies the maximum anisotropy value clamp used by the sampler. */
        set maxAnisotropy(value) {
          this._style.maxAnisotropy = value;
        }
        get maxAnisotropy() {
          return this._style.maxAnisotropy;
        }
        /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
        get addressMode() {
          return this._style.addressMode;
        }
        set addressMode(value) {
          this._style.addressMode = value;
        }
        /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
        get repeatMode() {
          return this._style.addressMode;
        }
        set repeatMode(value) {
          this._style.addressMode = value;
        }
        /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
        get magFilter() {
          return this._style.magFilter;
        }
        set magFilter(value) {
          this._style.magFilter = value;
        }
        /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
        get minFilter() {
          return this._style.minFilter;
        }
        set minFilter(value) {
          this._style.minFilter = value;
        }
        /** Specifies behavior for sampling between mipmap levels. */
        get mipmapFilter() {
          return this._style.mipmapFilter;
        }
        set mipmapFilter(value) {
          this._style.mipmapFilter = value;
        }
        /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
        get lodMinClamp() {
          return this._style.lodMinClamp;
        }
        set lodMinClamp(value) {
          this._style.lodMinClamp = value;
        }
        /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
        get lodMaxClamp() {
          return this._style.lodMaxClamp;
        }
        set lodMaxClamp(value) {
          this._style.lodMaxClamp = value;
        }
        _onStyleChange() {
          this.emit("styleChange", this);
        }
        /** call this if you have modified the texture outside of the constructor */
        update() {
          if (this.resource) {
            const resolution = this._resolution;
            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
            if (didResize)
              return;
          }
          this.emit("update", this);
        }
        /** Destroys this texture source */
        destroy() {
          this.destroyed = true;
          this.unload();
          this.emit("destroy", this);
          if (this._style) {
            this._style.destroy();
            this._style = null;
          }
          this.uploadMethodId = null;
          this.resource = null;
          this.removeAllListeners();
        }
        /**
         * This will unload the Texture source from the GPU. This will free up the GPU memory
         * As soon as it is required fore rendering, it will be re-uploaded.
         */
        unload() {
          var _a2, _b;
          this._resourceId = uid2("resource");
          this.emit("change", this);
          this.emit("unload", this);
          for (const key in this._gpuData) {
            (_b = (_a2 = this._gpuData[key]) == null ? void 0 : _a2.destroy) == null ? void 0 : _b.call(_a2);
          }
          this._gpuData = /* @__PURE__ */ Object.create(null);
        }
        /** the width of the resource. This is the REAL pure number, not accounting resolution   */
        get resourceWidth() {
          const { resource } = this;
          return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
        }
        /** the height of the resource. This is the REAL pure number, not accounting resolution */
        get resourceHeight() {
          const { resource } = this;
          return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
        }
        /**
         * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
         * but will the size of the texture when rendered.
         *
         * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
         * density will have increased)
         */
        get resolution() {
          return this._resolution;
        }
        set resolution(resolution) {
          if (this._resolution === resolution)
            return;
          this._resolution = resolution;
          this.width = this.pixelWidth / resolution;
          this.height = this.pixelHeight / resolution;
        }
        /**
         * Resize the texture, this is handy if you want to use the texture as a render texture
         * @param width - the new width of the texture
         * @param height - the new height of the texture
         * @param resolution - the new resolution of the texture
         * @returns - if the texture was resized
         */
        resize(width, height, resolution) {
          resolution || (resolution = this._resolution);
          width || (width = this.width);
          height || (height = this.height);
          const newPixelWidth = Math.round(width * resolution);
          const newPixelHeight = Math.round(height * resolution);
          this.width = newPixelWidth / resolution;
          this.height = newPixelHeight / resolution;
          this._resolution = resolution;
          if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
            return false;
          }
          this._refreshPOT();
          this.pixelWidth = newPixelWidth;
          this.pixelHeight = newPixelHeight;
          this.emit("resize", this);
          this._resourceId = uid2("resource");
          this.emit("change", this);
          return true;
        }
        /**
         * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
         * This is only important for RenderTexture instances, as standard Texture instances will have their
         * mipmaps generated on upload. You should call this method after you make any change to the texture
         *
         * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
         * We want you, the developer to specify when this action should happen.
         *
         * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
         */
        updateMipmaps() {
          if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
            this.emit("updateMipmaps", this);
          }
        }
        set wrapMode(value) {
          this._style.wrapMode = value;
        }
        get wrapMode() {
          return this._style.wrapMode;
        }
        set scaleMode(value) {
          this._style.scaleMode = value;
        }
        /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
        get scaleMode() {
          return this._style.scaleMode;
        }
        /**
         * Refresh check for isPowerOfTwo texture based on size
         * @private
         */
        _refreshPOT() {
          this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
        }
        static test(_resource) {
          throw new Error("Unimplemented");
        }
      };
      _TextureSource.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: false,
        sampleCount: 1,
        antialias: false,
        autoGarbageCollect: false
      };
      TextureSource = _TextureSource;
    }
  });

  // node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
  function init5() {
    for (let i3 = 0; i3 < 16; i3++) {
      const row = [];
      rotationCayley.push(row);
      for (let j2 = 0; j2 < 16; j2++) {
        const _ux = signum(ux[i3] * ux[j2] + vx[i3] * uy[j2]);
        const _uy = signum(uy[i3] * ux[j2] + vy[i3] * uy[j2]);
        const _vx = signum(ux[i3] * vx[j2] + vx[i3] * vy[j2]);
        const _vy = signum(uy[i3] * vx[j2] + vy[i3] * vy[j2]);
        for (let k2 = 0; k2 < 16; k2++) {
          if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
            row.push(k2);
            break;
          }
        }
      }
    }
    for (let i3 = 0; i3 < 16; i3++) {
      const mat = new Matrix();
      mat.set(ux[i3], uy[i3], vx[i3], vy[i3], 0, 0);
      rotationMatrices.push(mat);
    }
  }
  var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
  var init_groupD8 = __esm({
    "node_modules/pixi.js/lib/maths/matrix/groupD8.mjs"() {
      init_Matrix();
      ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
      uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
      vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
      vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
      rotationCayley = [];
      rotationMatrices = [];
      signum = Math.sign;
      init5();
      groupD8 = {
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 0       | East      |
         * @group groupD8
         * @type {GD8Symmetry}
         */
        E: 0,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 45     | Southeast |
         * @group groupD8
         * @type {GD8Symmetry}
         */
        SE: 1,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 90     | South     |
         * @group groupD8
         * @type {GD8Symmetry}
         */
        S: 2,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 135    | Southwest |
         * @group groupD8
         * @type {GD8Symmetry}
         */
        SW: 3,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 180     | West      |
         * @group groupD8
         * @type {GD8Symmetry}
         */
        W: 4,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -135/225 | Northwest    |
         * @group groupD8
         * @type {GD8Symmetry}
         */
        NW: 5,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -90/270  | North        |
         * @group groupD8
         * @type {GD8Symmetry}
         */
        N: 6,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -45/315  | Northeast    |
         * @group groupD8
         * @type {GD8Symmetry}
         */
        NE: 7,
        /**
         * Reflection about Y-axis.
         * @group groupD8
         * @type {GD8Symmetry}
         */
        MIRROR_VERTICAL: 8,
        /**
         * Reflection about the main diagonal.
         * @group groupD8
         * @type {GD8Symmetry}
         */
        MAIN_DIAGONAL: 10,
        /**
         * Reflection about X-axis.
         * @group groupD8
         * @type {GD8Symmetry}
         */
        MIRROR_HORIZONTAL: 12,
        /**
         * Reflection about reverse diagonal.
         * @group groupD8
         * @type {GD8Symmetry}
         */
        REVERSE_DIAGONAL: 14,
        /**
         * @group groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The X-component of the U-axis
         *    after rotating the axes.
         */
        uX: (ind) => ux[ind],
        /**
         * @group groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The Y-component of the U-axis
         *    after rotating the axes.
         */
        uY: (ind) => uy[ind],
        /**
         * @group groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The X-component of the V-axis
         *    after rotating the axes.
         */
        vX: (ind) => vx[ind],
        /**
         * @group groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The Y-component of the V-axis
         *    after rotating the axes.
         */
        vY: (ind) => vy[ind],
        /**
         * @group groupD8
         * @param {GD8Symmetry} rotation - symmetry whose opposite
         *   is needed. Only rotations have opposite symmetries while
         *   reflections don't.
         * @returns {GD8Symmetry} The opposite symmetry of `rotation`
         */
        inv: (rotation) => {
          if (rotation & 8) {
            return rotation & 15;
          }
          return -rotation & 7;
        },
        /**
         * Composes the two D8 operations.
         *
         * Taking `^` as reflection:
         *
         * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
         * |-------|-----|-----|-----|-----|------|-------|-------|-------|
         * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
         * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
         * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
         * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
         * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
         * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
         * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
         * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
         *
         * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
         * @group groupD8
         * @param {GD8Symmetry} rotationSecond - Second operation, which
         *   is the row in the above cayley table.
         * @param {GD8Symmetry} rotationFirst - First operation, which
         *   is the column in the above cayley table.
         * @returns {GD8Symmetry} Composed operation
         */
        add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
        /**
         * Reverse of `add`.
         * @group groupD8
         * @param {GD8Symmetry} rotationSecond - Second operation
         * @param {GD8Symmetry} rotationFirst - First operation
         * @returns {GD8Symmetry} Result
         */
        sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
        /**
         * Adds 180 degrees to rotation, which is a commutative
         * operation.
         * @group groupD8
         * @param {number} rotation - The number to rotate.
         * @returns {number} Rotated number
         */
        rotate180: (rotation) => rotation ^ 4,
        /**
         * Checks if the rotation angle is vertical, i.e. south
         * or north. It doesn't work for reflections.
         * @group groupD8
         * @param {GD8Symmetry} rotation - The number to check.
         * @returns {boolean} Whether or not the direction is vertical
         */
        isVertical: (rotation) => (rotation & 3) === 2,
        // rotation % 4 === 2
        /**
         * Approximates the vector `V(dx,dy)` into one of the
         * eight directions provided by `groupD8`.
         * @group groupD8
         * @param {number} dx - X-component of the vector
         * @param {number} dy - Y-component of the vector
         * @returns {GD8Symmetry} Approximation of the vector into
         *  one of the eight symmetries.
         */
        byDirection: (dx, dy) => {
          if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
              return groupD8.S;
            }
            return groupD8.N;
          } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
              return groupD8.E;
            }
            return groupD8.W;
          } else if (dy > 0) {
            if (dx > 0) {
              return groupD8.SE;
            }
            return groupD8.SW;
          } else if (dx > 0) {
            return groupD8.NE;
          }
          return groupD8.NW;
        },
        /**
         * Helps sprite to compensate texture packer rotation.
         * @group groupD8
         * @param {Matrix} matrix - sprite world matrix
         * @param {GD8Symmetry} rotation - The rotation factor to use.
         * @param {number} tx - sprite anchoring
         * @param {number} ty - sprite anchoring
         */
        matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
          const mat = rotationMatrices[groupD8.inv(rotation)];
          mat.tx = tx;
          mat.ty = ty;
          matrix.append(mat);
        },
        /**
         * Transforms rectangle coordinates based on texture packer rotation.
         * Used when texture atlas pages are rotated and coordinates need to be adjusted.
         * @group groupD8
         * @param {RectangleLike} rect - Rectangle with original coordinates to transform
         * @param {RectangleLike} sourceFrame - Source texture frame (includes offset and dimensions)
         * @param {GD8Symmetry} rotation - The groupD8 rotation value
         * @param {Rectangle} out - Rectangle to store the result
         * @returns {Rectangle} Transformed coordinates (includes source frame offset)
         */
        transformRectCoords: (rect, sourceFrame, rotation, out2) => {
          const { x: x2, y: y2, width, height } = rect;
          const { x: frameX, y: frameY, width: frameWidth, height: frameHeight } = sourceFrame;
          if (rotation === groupD8.E) {
            out2.set(x2 + frameX, y2 + frameY, width, height);
            return out2;
          } else if (rotation === groupD8.S) {
            return out2.set(
              frameWidth - y2 - height + frameX,
              x2 + frameY,
              height,
              width
            );
          } else if (rotation === groupD8.W) {
            return out2.set(
              frameWidth - x2 - width + frameX,
              frameHeight - y2 - height + frameY,
              width,
              height
            );
          } else if (rotation === groupD8.N) {
            return out2.set(
              y2 + frameX,
              frameHeight - x2 - width + frameY,
              height,
              width
            );
          }
          return out2.set(x2 + frameX, y2 + frameY, width, height);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/utils/misc/NOOP.mjs
  var NOOP;
  var init_NOOP = __esm({
    "node_modules/pixi.js/lib/utils/misc/NOOP.mjs"() {
      "use strict";
      NOOP = () => {
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
  var BufferImageSource;
  var init_BufferImageSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
      init_Extensions();
      init_TextureSource();
      BufferImageSource = class extends TextureSource {
        constructor(options) {
          const buffer = options.resource || new Float32Array(options.width * options.height * 4);
          let format = options.format;
          if (!format) {
            if (buffer instanceof Float32Array) {
              format = "rgba32float";
            } else if (buffer instanceof Int32Array) {
              format = "rgba32uint";
            } else if (buffer instanceof Uint32Array) {
              format = "rgba32uint";
            } else if (buffer instanceof Int16Array) {
              format = "rgba16uint";
            } else if (buffer instanceof Uint16Array) {
              format = "rgba16uint";
            } else if (buffer instanceof Int8Array) {
              format = "bgra8unorm";
            } else {
              format = "bgra8unorm";
            }
          }
          super(__spreadProps(__spreadValues({}, options), {
            resource: buffer,
            format
          }));
          this.uploadMethodId = "buffer";
        }
        static test(resource) {
          return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
        }
      };
      BufferImageSource.extension = ExtensionType.TextureSource;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
  var tempMat, TextureMatrix;
  var init_TextureMatrix = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
      init_Matrix();
      tempMat = new Matrix();
      TextureMatrix = class {
        /**
         * @param texture - observed texture
         * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
         */
        constructor(texture, clampMargin) {
          this.mapCoord = new Matrix();
          this.uClampFrame = new Float32Array(4);
          this.uClampOffset = new Float32Array(2);
          this._textureID = -1;
          this._updateID = 0;
          this.clampOffset = 0;
          if (typeof clampMargin === "undefined") {
            this.clampMargin = texture.width < 10 ? 0 : 0.5;
          } else {
            this.clampMargin = clampMargin;
          }
          this.isSimple = false;
          this.texture = texture;
        }
        /** Texture property. */
        get texture() {
          return this._texture;
        }
        set texture(value) {
          var _a2;
          if (this.texture === value)
            return;
          (_a2 = this._texture) == null ? void 0 : _a2.removeListener("update", this.update, this);
          this._texture = value;
          this._texture.addListener("update", this.update, this);
          this.update();
        }
        /**
         * Multiplies uvs array to transform
         * @param uvs - mesh uvs
         * @param [out=uvs] - output
         * @returns - output
         */
        multiplyUvs(uvs, out2) {
          if (out2 === void 0) {
            out2 = uvs;
          }
          const mat = this.mapCoord;
          for (let i3 = 0; i3 < uvs.length; i3 += 2) {
            const x2 = uvs[i3];
            const y2 = uvs[i3 + 1];
            out2[i3] = x2 * mat.a + y2 * mat.c + mat.tx;
            out2[i3 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
          }
          return out2;
        }
        /**
         * Updates matrices if texture was changed
         * @returns - whether or not it was updated
         */
        update() {
          const tex = this._texture;
          this._updateID++;
          const uvs = tex.uvs;
          this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
          const orig = tex.orig;
          const trim = tex.trim;
          if (trim) {
            tempMat.set(
              orig.width / trim.width,
              0,
              0,
              orig.height / trim.height,
              -trim.x / trim.width,
              -trim.y / trim.height
            );
            this.mapCoord.append(tempMat);
          }
          const texBase = tex.source;
          const frame = this.uClampFrame;
          const margin = this.clampMargin / texBase._resolution;
          const offset = this.clampOffset / texBase._resolution;
          frame[0] = (tex.frame.x + margin + offset) / texBase.width;
          frame[1] = (tex.frame.y + margin + offset) / texBase.height;
          frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
          frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
          this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
          this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
          this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
          return true;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
  var Texture;
  var init_Texture = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
      init_eventemitter3();
      init_groupD8();
      init_Rectangle();
      init_uid();
      init_deprecation();
      init_NOOP();
      init_BufferImageSource();
      init_TextureSource();
      init_TextureMatrix();
      Texture = class extends eventemitter3_default {
        /**
         * @param {TextureOptions} options - Options for the texture
         */
        constructor({
          source: source11,
          label,
          frame,
          orig,
          trim,
          defaultAnchor,
          defaultBorders,
          rotate,
          dynamic
        } = {}) {
          var _a2;
          super();
          this.uid = uid2("texture");
          this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
          this.frame = new Rectangle();
          this.noFrame = false;
          this.dynamic = false;
          this.isTexture = true;
          this.label = label;
          this.source = (_a2 = source11 == null ? void 0 : source11.source) != null ? _a2 : new TextureSource();
          this.noFrame = !frame;
          if (frame) {
            this.frame.copyFrom(frame);
          } else {
            const { width, height } = this._source;
            this.frame.width = width;
            this.frame.height = height;
          }
          this.orig = orig || this.frame;
          this.trim = trim;
          this.rotate = rotate != null ? rotate : 0;
          this.defaultAnchor = defaultAnchor;
          this.defaultBorders = defaultBorders;
          this.destroyed = false;
          this.dynamic = dynamic || false;
          this.updateUvs();
        }
        set source(value) {
          if (this._source) {
            this._source.off("resize", this.update, this);
          }
          this._source = value;
          value.on("resize", this.update, this);
          this.emit("update", this);
        }
        /** the underlying source of the texture (equivalent of baseTexture in v7) */
        get source() {
          return this._source;
        }
        /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
        get textureMatrix() {
          if (!this._textureMatrix) {
            this._textureMatrix = new TextureMatrix(this);
          }
          return this._textureMatrix;
        }
        /** The width of the Texture in pixels. */
        get width() {
          return this.orig.width;
        }
        /** The height of the Texture in pixels. */
        get height() {
          return this.orig.height;
        }
        /** Call this function when you have modified the frame of this texture. */
        updateUvs() {
          const { uvs, frame } = this;
          const { width, height } = this._source;
          const nX = frame.x / width;
          const nY = frame.y / height;
          const nW = frame.width / width;
          const nH = frame.height / height;
          let rotate = this.rotate;
          if (rotate) {
            const w2 = nW / 2;
            const h2 = nH / 2;
            const cX = nX + w2;
            const cY = nY + h2;
            rotate = groupD8.add(rotate, groupD8.NW);
            uvs.x0 = cX + w2 * groupD8.uX(rotate);
            uvs.y0 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x1 = cX + w2 * groupD8.uX(rotate);
            uvs.y1 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x2 = cX + w2 * groupD8.uX(rotate);
            uvs.y2 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x3 = cX + w2 * groupD8.uX(rotate);
            uvs.y3 = cY + h2 * groupD8.uY(rotate);
          } else {
            uvs.x0 = nX;
            uvs.y0 = nY;
            uvs.x1 = nX + nW;
            uvs.y1 = nY;
            uvs.x2 = nX + nW;
            uvs.y2 = nY + nH;
            uvs.x3 = nX;
            uvs.y3 = nY + nH;
          }
        }
        /**
         * Destroys this texture
         * @param destroySource - Destroy the source when the texture is destroyed.
         */
        destroy(destroySource = false) {
          if (this._source) {
            this._source.off("resize", this.update, this);
            if (destroySource) {
              this._source.destroy();
              this._source = null;
            }
          }
          this._textureMatrix = null;
          this.destroyed = true;
          this.emit("destroy", this);
          this.removeAllListeners();
        }
        /**
         * Call this if you have modified the `texture outside` of the constructor.
         *
         * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
         */
        update() {
          if (this.noFrame) {
            this.frame.width = this._source.width;
            this.frame.height = this._source.height;
          }
          this.updateUvs();
          this.emit("update", this);
        }
        /** @deprecated since 8.0.0 */
        get baseTexture() {
          deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
          return this._source;
        }
      };
      Texture.EMPTY = new Texture({
        label: "EMPTY",
        source: new TextureSource({
          label: "EMPTY"
        })
      });
      Texture.EMPTY.destroy = NOOP;
      Texture.WHITE = new Texture({
        source: new BufferImageSource({
          resource: new Uint8Array([255, 255, 255, 255]),
          width: 1,
          height: 1,
          alphaMode: "premultiply-alpha-on-upload",
          label: "WHITE"
        }),
        label: "WHITE"
      });
      Texture.WHITE.destroy = NOOP;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
  var count, TexturePoolClass, TexturePool;
  var init_TexturePool = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
      init_pow2();
      init_GlobalResourceRegistry();
      init_TextureSource();
      init_Texture();
      init_TextureStyle();
      count = 0;
      TexturePoolClass = class {
        /**
         * @param textureOptions - options that will be passed to BaseRenderTexture constructor
         * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
         */
        constructor(textureOptions) {
          this._poolKeyHash = /* @__PURE__ */ Object.create(null);
          this._texturePool = {};
          this.textureOptions = textureOptions || {};
          this.enableFullScreen = false;
          this.textureStyle = new TextureStyle(this.textureOptions);
        }
        /**
         * Creates texture with params that were specified in pool constructor.
         * @param pixelWidth - Width of texture in pixels.
         * @param pixelHeight - Height of texture in pixels.
         * @param antialias
         */
        createTexture(pixelWidth, pixelHeight, antialias) {
          const textureSource = new TextureSource(__spreadProps(__spreadValues({}, this.textureOptions), {
            width: pixelWidth,
            height: pixelHeight,
            resolution: 1,
            antialias,
            autoGarbageCollect: false
          }));
          return new Texture({
            source: textureSource,
            label: `texturePool_${count++}`
          });
        }
        /**
         * Gets a Power-of-Two render texture or fullScreen texture
         * @param frameWidth - The minimum width of the render texture.
         * @param frameHeight - The minimum height of the render texture.
         * @param resolution - The resolution of the render texture.
         * @param antialias
         * @returns The new render texture.
         */
        getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
          let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
          let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
          po2Width = nextPow2(po2Width);
          po2Height = nextPow2(po2Height);
          const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
          if (!this._texturePool[key]) {
            this._texturePool[key] = [];
          }
          let texture = this._texturePool[key].pop();
          if (!texture) {
            texture = this.createTexture(po2Width, po2Height, antialias);
          }
          texture.source._resolution = resolution;
          texture.source.width = po2Width / resolution;
          texture.source.height = po2Height / resolution;
          texture.source.pixelWidth = po2Width;
          texture.source.pixelHeight = po2Height;
          texture.frame.x = 0;
          texture.frame.y = 0;
          texture.frame.width = frameWidth;
          texture.frame.height = frameHeight;
          texture.updateUvs();
          this._poolKeyHash[texture.uid] = key;
          return texture;
        }
        /**
         * Gets extra texture of the same size as input renderTexture
         * @param texture - The texture to check what size it is.
         * @param antialias - Whether to use antialias.
         * @returns A texture that is a power of two
         */
        getSameSizeTexture(texture, antialias = false) {
          const source11 = texture.source;
          return this.getOptimalTexture(texture.width, texture.height, source11._resolution, antialias);
        }
        /**
         * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.
         * useful if you modified the style of the texture after getting it from the pool.
         * @param renderTexture - The renderTexture to free
         * @param resetStyle - Whether to reset the style of the texture to the default texture style
         */
        returnTexture(renderTexture, resetStyle = false) {
          const key = this._poolKeyHash[renderTexture.uid];
          if (resetStyle) {
            renderTexture.source.style = this.textureStyle;
          }
          this._texturePool[key].push(renderTexture);
        }
        /**
         * Clears the pool.
         * @param destroyTextures - Destroy all stored textures.
         */
        clear(destroyTextures) {
          destroyTextures = destroyTextures !== false;
          if (destroyTextures) {
            for (const i3 in this._texturePool) {
              const textures = this._texturePool[i3];
              if (textures) {
                for (let j2 = 0; j2 < textures.length; j2++) {
                  textures[j2].destroy(true);
                }
              }
            }
          }
          this._texturePool = {};
        }
      };
      TexturePool = new TexturePoolClass();
      GlobalResourceRegistry.register(TexturePool);
    }
  });

  // node_modules/pixi.js/lib/scene/container/RenderGroup.mjs
  var RenderGroup;
  var init_RenderGroup = __esm({
    "node_modules/pixi.js/lib/scene/container/RenderGroup.mjs"() {
      init_Matrix();
      init_InstructionSet();
      init_TexturePool();
      RenderGroup = class {
        constructor() {
          this.renderPipeId = "renderGroup";
          this.root = null;
          this.canBundle = false;
          this.renderGroupParent = null;
          this.renderGroupChildren = [];
          this.worldTransform = new Matrix();
          this.worldColorAlpha = 4294967295;
          this.worldColor = 16777215;
          this.worldAlpha = 1;
          this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
          this.updateTick = 0;
          this.gcTick = 0;
          this.childrenRenderablesToUpdate = { list: [], index: 0 };
          this.structureDidChange = true;
          this.instructionSet = new InstructionSet();
          this._onRenderContainers = [];
          this.textureNeedsUpdate = true;
          this.isCachedAsTexture = false;
          this._matrixDirty = 7;
        }
        init(root) {
          this.root = root;
          if (root._onRender)
            this.addOnRender(root);
          root.didChange = true;
          const children = root.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            const child = children[i3];
            child._updateFlags = 15;
            this.addChild(child);
          }
        }
        enableCacheAsTexture(options = {}) {
          this.textureOptions = options;
          this.isCachedAsTexture = true;
          this.textureNeedsUpdate = true;
        }
        disableCacheAsTexture() {
          this.isCachedAsTexture = false;
          if (this.texture) {
            TexturePool.returnTexture(this.texture, true);
            this.texture = null;
          }
        }
        updateCacheTexture() {
          this.textureNeedsUpdate = true;
          const cachedParent = this._parentCacheAsTextureRenderGroup;
          if (cachedParent && !cachedParent.textureNeedsUpdate) {
            cachedParent.updateCacheTexture();
          }
        }
        reset() {
          this.renderGroupChildren.length = 0;
          for (const i3 in this.childrenToUpdate) {
            const childrenAtDepth = this.childrenToUpdate[i3];
            childrenAtDepth.list.fill(null);
            childrenAtDepth.index = 0;
          }
          this.childrenRenderablesToUpdate.index = 0;
          this.childrenRenderablesToUpdate.list.fill(null);
          this.root = null;
          this.updateTick = 0;
          this.structureDidChange = true;
          this._onRenderContainers.length = 0;
          this.renderGroupParent = null;
          this.disableCacheAsTexture();
        }
        get localTransform() {
          return this.root.localTransform;
        }
        addRenderGroupChild(renderGroupChild) {
          if (renderGroupChild.renderGroupParent) {
            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
          }
          renderGroupChild.renderGroupParent = this;
          this.renderGroupChildren.push(renderGroupChild);
        }
        _removeRenderGroupChild(renderGroupChild) {
          const index = this.renderGroupChildren.indexOf(renderGroupChild);
          if (index > -1) {
            this.renderGroupChildren.splice(index, 1);
          }
          renderGroupChild.renderGroupParent = null;
        }
        addChild(child) {
          this.structureDidChange = true;
          child.parentRenderGroup = this;
          child.updateTick = -1;
          if (child.parent === this.root) {
            child.relativeRenderGroupDepth = 1;
          } else {
            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
          }
          child.didChange = true;
          this.onChildUpdate(child);
          if (child.renderGroup) {
            this.addRenderGroupChild(child.renderGroup);
            return;
          }
          if (child._onRender)
            this.addOnRender(child);
          const children = child.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this.addChild(children[i3]);
          }
        }
        removeChild(child) {
          this.structureDidChange = true;
          if (child._onRender) {
            if (!child.renderGroup) {
              this.removeOnRender(child);
            }
          }
          child.parentRenderGroup = null;
          if (child.renderGroup) {
            this._removeRenderGroupChild(child.renderGroup);
            return;
          }
          const children = child.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this.removeChild(children[i3]);
          }
        }
        removeChildren(children) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this.removeChild(children[i3]);
          }
        }
        onChildUpdate(child) {
          let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
          if (!childrenToUpdate) {
            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
              index: 0,
              list: []
            };
          }
          childrenToUpdate.list[childrenToUpdate.index++] = child;
        }
        updateRenderable(renderable) {
          if (renderable.globalDisplayStatus < 7)
            return;
          this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
          renderable.didViewUpdate = false;
        }
        onChildViewUpdate(child) {
          this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
        }
        get isRenderable() {
          return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
        }
        /**
         * adding a container to the onRender list will make sure the user function
         * passed in to the user defined 'onRender` callBack
         * @param container - the container to add to the onRender list
         */
        addOnRender(container) {
          this._onRenderContainers.push(container);
        }
        removeOnRender(container) {
          this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
        }
        runOnRender(renderer) {
          for (let i3 = 0; i3 < this._onRenderContainers.length; i3++) {
            this._onRenderContainers[i3]._onRender(renderer);
          }
        }
        destroy() {
          this.disableCacheAsTexture();
          this.renderGroupParent = null;
          this.root = null;
          this.childrenRenderablesToUpdate = null;
          this.childrenToUpdate = null;
          this.renderGroupChildren = null;
          this._onRenderContainers = null;
          this.instructionSet = null;
        }
        getChildren(out2 = []) {
          const children = this.root.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this._getChildren(children[i3], out2);
          }
          return out2;
        }
        _getChildren(container, out2 = []) {
          out2.push(container);
          if (container.renderGroup)
            return out2;
          const children = container.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this._getChildren(children[i3], out2);
          }
          return out2;
        }
        invalidateMatrices() {
          this._matrixDirty = 7;
        }
        /**
         * Returns the inverse of the world transform matrix.
         * @returns {Matrix} The inverse of the world transform matrix.
         */
        get inverseWorldTransform() {
          if ((this._matrixDirty & 1) === 0)
            return this._inverseWorldTransform;
          this._matrixDirty &= ~1;
          this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix());
          return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();
        }
        /**
         * Returns the inverse of the texture offset transform matrix.
         * @returns {Matrix} The inverse of the texture offset transform matrix.
         */
        get textureOffsetInverseTransform() {
          if ((this._matrixDirty & 2) === 0)
            return this._textureOffsetInverseTransform;
          this._matrixDirty &= ~2;
          this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix());
          return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(
            -this._textureBounds.x,
            -this._textureBounds.y
          );
        }
        /**
         * Returns the inverse of the parent texture transform matrix.
         * This is used to properly transform coordinates when rendering into cached textures.
         * @returns {Matrix} The inverse of the parent texture transform matrix.
         */
        get inverseParentTextureTransform() {
          if ((this._matrixDirty & 4) === 0)
            return this._inverseParentTextureTransform;
          this._matrixDirty &= ~4;
          const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;
          if (parentCacheAsTexture) {
            this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix());
            return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(
              -parentCacheAsTexture._textureBounds.x,
              -parentCacheAsTexture._textureBounds.y
            );
          }
          return this.worldTransform;
        }
        /**
         * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.
         * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.
         * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,
         * or null if no parent is cached as texture.
         */
        get cacheToLocalTransform() {
          if (this.isCachedAsTexture) {
            return this.textureOffsetInverseTransform;
          }
          if (!this._parentCacheAsTextureRenderGroup)
            return null;
          return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs
  function assignWithIgnore(target, options, ignore = {}) {
    for (const key in options) {
      if (!ignore[key] && options[key] !== void 0) {
        target[key] = options[key];
      }
    }
  }
  var init_assignWithIgnore = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/Container.mjs
  var defaultSkew, defaultPivot, defaultScale, defaultOrigin, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, UPDATE_TRANSFORM, Container;
  var init_Container = __esm({
    "node_modules/pixi.js/lib/scene/container/Container.mjs"() {
      init_eventemitter3();
      init_Color();
      init_cullingMixin();
      init_Extensions();
      init_Matrix();
      init_const();
      init_ObservablePoint();
      init_uid();
      init_deprecation();
      init_warn();
      init_PoolGroup();
      init_cacheAsTextureMixin();
      init_childrenHelperMixin();
      init_collectRenderablesMixin();
      init_effectsMixin();
      init_findMixin();
      init_getFastGlobalBoundsMixin();
      init_getGlobalMixin();
      init_measureMixin();
      init_onRenderMixin();
      init_sortMixin();
      init_toLocalGlobalMixin();
      init_RenderGroup();
      init_assignWithIgnore();
      defaultSkew = new ObservablePoint(null);
      defaultPivot = new ObservablePoint(null);
      defaultScale = new ObservablePoint(null, 1, 1);
      defaultOrigin = new ObservablePoint(null);
      UPDATE_COLOR = 1;
      UPDATE_BLEND = 2;
      UPDATE_VISIBLE = 4;
      UPDATE_TRANSFORM = 8;
      Container = class _Container extends eventemitter3_default {
        constructor(options = {}) {
          var _a2, _b;
          super();
          this.uid = uid2("renderable");
          this._updateFlags = 15;
          this.renderGroup = null;
          this.parentRenderGroup = null;
          this.parentRenderGroupIndex = 0;
          this.didChange = false;
          this.didViewUpdate = false;
          this.relativeRenderGroupDepth = 0;
          this.children = [];
          this.parent = null;
          this.includeInBuild = true;
          this.measurable = true;
          this.isSimple = true;
          this.parentRenderLayer = null;
          this.updateTick = -1;
          this.localTransform = new Matrix();
          this.relativeGroupTransform = new Matrix();
          this.groupTransform = this.relativeGroupTransform;
          this.destroyed = false;
          this._position = new ObservablePoint(this, 0, 0);
          this._scale = defaultScale;
          this._pivot = defaultPivot;
          this._origin = defaultOrigin;
          this._skew = defaultSkew;
          this._cx = 1;
          this._sx = 0;
          this._cy = 0;
          this._sy = 1;
          this._rotation = 0;
          this.localColor = 16777215;
          this.localAlpha = 1;
          this.groupAlpha = 1;
          this.groupColor = 16777215;
          this.groupColorAlpha = 4294967295;
          this.localBlendMode = "inherit";
          this.groupBlendMode = "normal";
          this.localDisplayStatus = 7;
          this.globalDisplayStatus = 7;
          this._didContainerChangeTick = 0;
          this._didViewChangeTick = 0;
          this._didLocalTransformChangeId = -1;
          this.effects = [];
          assignWithIgnore(this, options, {
            children: true,
            parent: true,
            effects: true
          });
          (_a2 = options.children) == null ? void 0 : _a2.forEach((child) => this.addChild(child));
          (_b = options.parent) == null ? void 0 : _b.addChild(this);
        }
        /**
         * Mixes all enumerable properties and methods from a source object to Container.
         * @param source - The source of properties and methods to mix in.
         * @deprecated since 8.8.0
         */
        static mixin(source11) {
          deprecation("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead.");
          extensions.mixin(_Container, source11);
        }
        // = 'default';
        /**
         * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
         * @deprecated since 8.2.6
         * @ignore
         */
        set _didChangeId(value) {
          this._didViewChangeTick = value >> 12 & 4095;
          this._didContainerChangeTick = value & 4095;
        }
        /** @ignore */
        get _didChangeId() {
          return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
        }
        /**
         * Adds one or more children to the container.
         * The children will be rendered as part of this container's display list.
         * @example
         * ```ts
         * // Add a single child
         * container.addChild(sprite);
         *
         * // Add multiple children
         * container.addChild(background, player, foreground);
         *
         * // Add with type checking
         * const sprite = container.addChild<Sprite>(new Sprite(texture));
         * sprite.tint = 'red';
         * ```
         * @param children - The Container(s) to add to the container
         * @returns The first child that was added
         * @see {@link Container#removeChild} For removing children
         * @see {@link Container#addChildAt} For adding at specific index
         */
        addChild(...children) {
          if (!this.allowChildren) {
            deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
          }
          if (children.length > 1) {
            for (let i3 = 0; i3 < children.length; i3++) {
              this.addChild(children[i3]);
            }
            return children[0];
          }
          const child = children[0];
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (child.parent === this) {
            this.children.splice(this.children.indexOf(child), 1);
            this.children.push(child);
            if (renderGroup) {
              renderGroup.structureDidChange = true;
            }
            return child;
          }
          if (child.parent) {
            child.parent.removeChild(child);
          }
          this.children.push(child);
          if (this.sortableChildren)
            this.sortDirty = true;
          child.parent = this;
          child.didChange = true;
          child._updateFlags = 15;
          if (renderGroup) {
            renderGroup.addChild(child);
          }
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
          this._didViewChangeTick++;
          if (child._zIndex !== 0) {
            child.depthOfChildModified();
          }
          return child;
        }
        /**
         * Removes one or more children from the container.
         * When removing multiple children, events will be triggered for each child in sequence.
         * @example
         * ```ts
         * // Remove a single child
         * const removed = container.removeChild(sprite);
         *
         * // Remove multiple children
         * const bg = container.removeChild(background, player, userInterface);
         *
         * // Remove with type checking
         * const sprite = container.removeChild<Sprite>(childSprite);
         * sprite.texture = newTexture;
         * ```
         * @param children - The Container(s) to remove
         * @returns The first child that was removed
         * @see {@link Container#addChild} For adding children
         * @see {@link Container#removeChildren} For removing multiple children
         */
        removeChild(...children) {
          if (children.length > 1) {
            for (let i3 = 0; i3 < children.length; i3++) {
              this.removeChild(children[i3]);
            }
            return children[0];
          }
          const child = children[0];
          const index = this.children.indexOf(child);
          if (index > -1) {
            this._didViewChangeTick++;
            this.children.splice(index, 1);
            if (this.renderGroup) {
              this.renderGroup.removeChild(child);
            } else if (this.parentRenderGroup) {
              this.parentRenderGroup.removeChild(child);
            }
            if (child.parentRenderLayer) {
              child.parentRenderLayer.detach(child);
            }
            child.parent = null;
            this.emit("childRemoved", child, this, index);
            child.emit("removed", this);
          }
          return child;
        }
        /** @ignore */
        _onUpdate(point) {
          if (point) {
            if (point === this._skew) {
              this._updateSkew();
            }
          }
          this._didContainerChangeTick++;
          if (this.didChange)
            return;
          this.didChange = true;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.onChildUpdate(this);
          }
        }
        set isRenderGroup(value) {
          if (!!this.renderGroup === value)
            return;
          if (value) {
            this.enableRenderGroup();
          } else {
            this.disableRenderGroup();
          }
        }
        /**
         * Returns true if this container is a render group.
         * This means that it will be rendered as a separate pass, with its own set of instructions
         * @advanced
         */
        get isRenderGroup() {
          return !!this.renderGroup;
        }
        /**
         * Calling this enables a render group for this container.
         * This means it will be rendered as a separate set of instructions.
         * The transform of the container will also be handled on the GPU rather than the CPU.
         * @advanced
         */
        enableRenderGroup() {
          if (this.renderGroup)
            return;
          const parentRenderGroup = this.parentRenderGroup;
          parentRenderGroup == null ? void 0 : parentRenderGroup.removeChild(this);
          this.renderGroup = BigPool.get(RenderGroup, this);
          this.groupTransform = Matrix.IDENTITY;
          parentRenderGroup == null ? void 0 : parentRenderGroup.addChild(this);
          this._updateIsSimple();
        }
        /**
         * This will disable the render group for this container.
         * @advanced
         */
        disableRenderGroup() {
          if (!this.renderGroup)
            return;
          const parentRenderGroup = this.parentRenderGroup;
          parentRenderGroup == null ? void 0 : parentRenderGroup.removeChild(this);
          BigPool.return(this.renderGroup);
          this.renderGroup = null;
          this.groupTransform = this.relativeGroupTransform;
          parentRenderGroup == null ? void 0 : parentRenderGroup.addChild(this);
          this._updateIsSimple();
        }
        /** @ignore */
        _updateIsSimple() {
          this.isSimple = !this.renderGroup && this.effects.length === 0;
        }
        /**
         * Current transform of the object based on world (parent) factors.
         *
         * This matrix represents the absolute transformation in the scene graph.
         * @example
         * ```ts
         * // Get world position
         * const worldPos = container.worldTransform;
         * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);
         * ```
         * @readonly
         * @see {@link Container#localTransform} For local space transform
         */
        get worldTransform() {
          this._worldTransform || (this._worldTransform = new Matrix());
          if (this.renderGroup) {
            this._worldTransform.copyFrom(this.renderGroup.worldTransform);
          } else if (this.parentRenderGroup) {
            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
          }
          return this._worldTransform;
        }
        /**
         * The position of the container on the x axis relative to the local coordinates of the parent.
         *
         * An alias to position.x
         * @example
         * ```ts
         * // Basic position
         * container.x = 100;
         * ```
         */
        get x() {
          return this._position.x;
        }
        set x(value) {
          this._position.x = value;
        }
        /**
         * The position of the container on the y axis relative to the local coordinates of the parent.
         *
         * An alias to position.y
         * @example
         * ```ts
         * // Basic position
         * container.y = 200;
         * ```
         */
        get y() {
          return this._position.y;
        }
        set y(value) {
          this._position.y = value;
        }
        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         * @example
         * ```ts
         * // Basic position setting
         * container.position.set(100, 200);
         * container.position.set(100); // Sets both x and y to 100
         * // Using point data
         * container.position = { x: 50, y: 75 };
         * ```
         * @since 4.0.0
         */
        get position() {
          return this._position;
        }
        set position(value) {
          this._position.copyFrom(value);
        }
        /**
         * The rotation of the object in radians.
         *
         * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
         * > rotation is in radians, angle is in degrees.
         * @example
         * ```ts
         * // Basic rotation
         * container.rotation = Math.PI / 4; // 45 degrees
         *
         * // Convert from degrees
         * const degrees = 45;
         * container.rotation = degrees * Math.PI / 180;
         *
         * // Rotate around center
         * container.pivot.set(container.width / 2, container.height / 2);
         * container.rotation = Math.PI; // 180 degrees
         *
         * // Rotate around center with origin
         * container.origin.set(container.width / 2, container.height / 2);
         * container.rotation = Math.PI; // 180 degrees
         * ```
         */
        get rotation() {
          return this._rotation;
        }
        set rotation(value) {
          if (this._rotation !== value) {
            this._rotation = value;
            this._onUpdate(this._skew);
          }
        }
        /**
         * The angle of the object in degrees.
         *
         * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
         * > rotation is in radians, angle is in degrees.
         * @example
         * ```ts
         * // Basic angle rotation
         * sprite.angle = 45; // 45 degrees
         *
         * // Rotate around center
         * sprite.pivot.set(sprite.width / 2, sprite.height / 2);
         * sprite.angle = 180; // Half rotation
         *
         * // Rotate around center with origin
         * sprite.origin.set(sprite.width / 2, sprite.height / 2);
         * sprite.angle = 180; // Half rotation
         *
         * // Reset rotation
         * sprite.angle = 0;
         * ```
         */
        get angle() {
          return this.rotation * RAD_TO_DEG;
        }
        set angle(value) {
          this.rotation = value * DEG_TO_RAD;
        }
        /**
         * The center of rotation, scaling, and skewing for this display object in its local space.
         * The `position` is the projection of `pivot` in the parent's local space.
         *
         * By default, the pivot is the origin (0, 0).
         * @example
         * ```ts
         * // Rotate around center
         * container.pivot.set(container.width / 2, container.height / 2);
         * container.rotation = Math.PI; // Rotates around center
         * ```
         * @since 4.0.0
         */
        get pivot() {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint(this, 0, 0);
          }
          return this._pivot;
        }
        set pivot(value) {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint(this, 0, 0);
            if (this._origin !== defaultOrigin) {
              warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
            }
          }
          typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
        }
        /**
         * The skew factor for the object in radians. Skewing is a transformation that distorts
         * the object by rotating it differently at each point, creating a non-uniform shape.
         * @example
         * ```ts
         * // Basic skewing
         * container.skew.set(0.5, 0); // Skew horizontally
         * container.skew.set(0, 0.5); // Skew vertically
         *
         * // Skew with point data
         * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew
         *
         * // Reset skew
         * container.skew.set(0, 0);
         *
         * // Animate skew
         * app.ticker.add(() => {
         *     // Create wave effect
         *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;
         * });
         *
         * // Combine with rotation
         * container.rotation = Math.PI / 4; // 45 degrees
         * container.skew.set(0.2, 0.2); // Skew the rotated object
         * ```
         * @since 4.0.0
         * @type {ObservablePoint} Point-like object with x/y properties in radians
         * @default {x: 0, y: 0}
         */
        get skew() {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint(this, 0, 0);
          }
          return this._skew;
        }
        set skew(value) {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint(this, 0, 0);
          }
          this._skew.copyFrom(value);
        }
        /**
         * The scale factors of this object along the local coordinate axes.
         *
         * The default scale is (1, 1).
         * @example
         * ```ts
         * // Basic scaling
         * container.scale.set(2, 2); // Scales to double size
         * container.scale.set(2); // Scales uniformly to double size
         * container.scale = 2; // Scales uniformly to double size
         * // Scale to a specific width and height
         * container.setSize(200, 100); // Sets width to 200 and height to 100
         * ```
         * @since 4.0.0
         */
        get scale() {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint(this, 1, 1);
          }
          return this._scale;
        }
        set scale(value) {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint(this, 0, 0);
          }
          if (typeof value === "string") {
            value = parseFloat(value);
          }
          typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
        }
        /**
         * @experimental
         * The origin point around which the container rotates and scales without affecting its position.
         * Unlike pivot, changing the origin will not move the container's position.
         * @example
         * ```ts
         * // Rotate around center point
         * container.origin.set(container.width / 2, container.height / 2);
         * container.rotation = Math.PI; // Rotates around center
         *
         * // Reset origin
         * container.origin.set(0, 0);
         * ```
         */
        get origin() {
          if (this._origin === defaultOrigin) {
            this._origin = new ObservablePoint(this, 0, 0);
          }
          return this._origin;
        }
        set origin(value) {
          if (this._origin === defaultOrigin) {
            this._origin = new ObservablePoint(this, 0, 0);
            if (this._pivot !== defaultPivot) {
              warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
            }
          }
          typeof value === "number" ? this._origin.set(value) : this._origin.copyFrom(value);
        }
        /**
         * The width of the Container, setting this will actually modify the scale to achieve the value set.
         * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.
         * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
         * as it is more optimized by not recalculating the local bounds twice.
         * @example
         * ```ts
         * // Basic width setting
         * container.width = 100;
         * // Optimized width setting
         * container.setSize(100, 100);
         * ```
         */
        get width() {
          return Math.abs(this.scale.x * this.getLocalBounds().width);
        }
        set width(value) {
          const localWidth = this.getLocalBounds().width;
          this._setWidth(value, localWidth);
        }
        /**
         * The height of the Container,
         * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.
         * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
         * as it is more optimized by not recalculating the local bounds twice.
         * @example
         * ```ts
         * // Basic height setting
         * container.height = 200;
         * // Optimized height setting
         * container.setSize(100, 200);
         * ```
         */
        get height() {
          return Math.abs(this.scale.y * this.getLocalBounds().height);
        }
        set height(value) {
          const localHeight = this.getLocalBounds().height;
          this._setHeight(value, localHeight);
        }
        /**
         * Retrieves the size of the container as a [Size]{@link Size} object.
         *
         * This is faster than get the width and height separately.
         * @example
         * ```ts
         * // Basic size retrieval
         * const size = container.getSize();
         * console.log(`Size: ${size.width}x${size.height}`);
         *
         * // Reuse existing size object
         * const reuseSize = { width: 0, height: 0 };
         * container.getSize(reuseSize);
         * ```
         * @param out - Optional object to store the size in.
         * @returns The size of the container.
         */
        getSize(out2) {
          if (!out2) {
            out2 = {};
          }
          const bounds = this.getLocalBounds();
          out2.width = Math.abs(this.scale.x * bounds.width);
          out2.height = Math.abs(this.scale.y * bounds.height);
          return out2;
        }
        /**
         * Sets the size of the container to the specified width and height.
         * This is more efficient than setting width and height separately as it only recalculates bounds once.
         * @example
         * ```ts
         * // Basic size setting
         * container.setSize(100, 200);
         *
         * // Set uniform size
         * container.setSize(100); // Sets both width and height to 100
         * ```
         * @param value - This can be either a number or a [Size]{@link Size} object.
         * @param height - The height to set. Defaults to the value of `width` if not provided.
         */
        setSize(value, height) {
          var _a2;
          const size = this.getLocalBounds();
          if (typeof value === "object") {
            height = (_a2 = value.height) != null ? _a2 : value.width;
            value = value.width;
          } else {
            height != null ? height : height = value;
          }
          value !== void 0 && this._setWidth(value, size.width);
          height !== void 0 && this._setHeight(height, size.height);
        }
        /** Called when the skew or the rotation changes. */
        _updateSkew() {
          const rotation = this._rotation;
          const skew = this._skew;
          this._cx = Math.cos(rotation + skew._y);
          this._sx = Math.sin(rotation + skew._y);
          this._cy = -Math.sin(rotation - skew._x);
          this._sy = Math.cos(rotation - skew._x);
        }
        /**
         * Updates the transform properties of the container.
         * Allows partial updates of transform properties for optimized manipulation.
         * @example
         * ```ts
         * // Basic transform update
         * container.updateTransform({
         *     x: 100,
         *     y: 200,
         *     rotation: Math.PI / 4
         * });
         *
         * // Scale and rotate around center
         * sprite.updateTransform({
         *     pivotX: sprite.width / 2,
         *     pivotY: sprite.height / 2,
         *     scaleX: 2,
         *     scaleY: 2,
         *     rotation: Math.PI
         * });
         *
         * // Update position only
         * button.updateTransform({
         *     x: button.x + 10, // Move right
         *     y: button.y      // Keep same y
         * });
         * ```
         * @param opts - Transform options to update
         * @param opts.x - The x position
         * @param opts.y - The y position
         * @param opts.scaleX - The x-axis scale factor
         * @param opts.scaleY - The y-axis scale factor
         * @param opts.rotation - The rotation in radians
         * @param opts.skewX - The x-axis skew factor
         * @param opts.skewY - The y-axis skew factor
         * @param opts.pivotX - The x-axis pivot point
         * @param opts.pivotY - The y-axis pivot point
         * @returns This container, for chaining
         * @see {@link Container#setFromMatrix} For matrix-based transforms
         * @see {@link Container#position} For direct position access
         */
        updateTransform(opts) {
          this.position.set(
            typeof opts.x === "number" ? opts.x : this.position.x,
            typeof opts.y === "number" ? opts.y : this.position.y
          );
          this.scale.set(
            typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
            typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
          );
          this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
          this.skew.set(
            typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
            typeof opts.skewY === "number" ? opts.skewY : this.skew.y
          );
          this.pivot.set(
            typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
            typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
          );
          this.origin.set(
            typeof opts.originX === "number" ? opts.originX : this.origin.x,
            typeof opts.originY === "number" ? opts.originY : this.origin.y
          );
          return this;
        }
        /**
         * Updates the local transform properties by decomposing the given matrix.
         * Extracts position, scale, rotation, and skew from a transformation matrix.
         * @example
         * ```ts
         * // Basic matrix transform
         * const matrix = new Matrix()
         *     .translate(100, 100)
         *     .rotate(Math.PI / 4)
         *     .scale(2, 2);
         *
         * container.setFromMatrix(matrix);
         *
         * // Copy transform from another container
         * const source = new Container();
         * source.position.set(100, 100);
         * source.rotation = Math.PI / 2;
         *
         * target.setFromMatrix(source.localTransform);
         *
         * // Reset transform
         * container.setFromMatrix(Matrix.IDENTITY);
         * ```
         * @param matrix - The matrix to use for updating the transform
         * @see {@link Container#updateTransform} For property-based updates
         * @see {@link Matrix#decompose} For matrix decomposition details
         */
        setFromMatrix(matrix) {
          matrix.decompose(this);
        }
        /** Updates the local transform. */
        updateLocalTransform() {
          const localTransformChangeId = this._didContainerChangeTick;
          if (this._didLocalTransformChangeId === localTransformChangeId)
            return;
          this._didLocalTransformChangeId = localTransformChangeId;
          const lt = this.localTransform;
          const scale = this._scale;
          const pivot = this._pivot;
          const origin = this._origin;
          const position = this._position;
          const sx = scale._x;
          const sy = scale._y;
          const px = pivot._x;
          const py = pivot._y;
          const ox = -origin._x;
          const oy = -origin._y;
          lt.a = this._cx * sx;
          lt.b = this._sx * sx;
          lt.c = this._cy * sy;
          lt.d = this._sy * sy;
          lt.tx = position._x - (px * lt.a + py * lt.c) + (ox * lt.a + oy * lt.c) - ox;
          lt.ty = position._y - (px * lt.b + py * lt.d) + (ox * lt.b + oy * lt.d) - oy;
        }
        // / ///// color related stuff
        set alpha(value) {
          if (value === this.localAlpha)
            return;
          this.localAlpha = value;
          this._updateFlags |= UPDATE_COLOR;
          this._onUpdate();
        }
        /**
         * The opacity of the object relative to its parent's opacity.
         * Value ranges from 0 (fully transparent) to 1 (fully opaque).
         * @example
         * ```ts
         * // Basic transparency
         * sprite.alpha = 0.5; // 50% opacity
         *
         * // Inherited opacity
         * container.alpha = 0.5;
         * const child = new Sprite(texture);
         * child.alpha = 0.5;
         * container.addChild(child);
         * // child's effective opacity is 0.25 (0.5 * 0.5)
         * ```
         * @default 1
         * @see {@link Container#visible} For toggling visibility
         * @see {@link Container#renderable} For render control
         */
        get alpha() {
          return this.localAlpha;
        }
        set tint(value) {
          const tempColor = Color.shared.setValue(value != null ? value : 16777215);
          const bgr = tempColor.toBgrNumber();
          if (bgr === this.localColor)
            return;
          this.localColor = bgr;
          this._updateFlags |= UPDATE_COLOR;
          this._onUpdate();
        }
        /**
         * The tint applied to the sprite.
         *
         * This can be any valid {@link ColorSource}.
         * @example
         * ```ts
         * // Basic color tinting
         * container.tint = 0xff0000; // Red tint
         * container.tint = 'red';    // Same as above
         * container.tint = '#00ff00'; // Green
         * container.tint = 'rgb(0,0,255)'; // Blue
         *
         * // Remove tint
         * container.tint = 0xffffff; // White = no tint
         * container.tint = null;     // Also removes tint
         * ```
         * @default 0xFFFFFF
         * @see {@link Container#alpha} For transparency
         * @see {@link Container#visible} For visibility control
         */
        get tint() {
          return bgr2rgb(this.localColor);
        }
        // / //////////////// blend related stuff
        set blendMode(value) {
          if (this.localBlendMode === value)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_BLEND;
          this.localBlendMode = value;
          this._onUpdate();
        }
        /**
         * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.
         *
         * Setting to 'normal' will reset to default blending.
         * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.
         * @example
         * ```ts
         * // Basic blend modes
         * sprite.blendMode = 'add';        // Additive blending
         * sprite.blendMode = 'multiply';   // Multiply colors
         * sprite.blendMode = 'screen';     // Screen blend
         *
         * // Reset blend mode
         * sprite.blendMode = 'normal';     // Normal blending
         * ```
         * @default 'normal'
         * @see {@link Container#alpha} For transparency
         * @see {@link Container#tint} For color adjustments
         */
        get blendMode() {
          return this.localBlendMode;
        }
        // / ///////// VISIBILITY / RENDERABLE /////////////////
        /**
         * The visibility of the object. If false the object will not be drawn,
         * and the transform will not be updated.
         * @example
         * ```ts
         * // Basic visibility toggle
         * sprite.visible = false; // Hide sprite
         * sprite.visible = true;  // Show sprite
         * ```
         * @default true
         * @see {@link Container#renderable} For render-only control
         * @see {@link Container#alpha} For transparency
         */
        get visible() {
          return !!(this.localDisplayStatus & 2);
        }
        set visible(value) {
          const valueNumber = value ? 2 : 0;
          if ((this.localDisplayStatus & 2) === valueNumber)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 2;
          this._onUpdate();
        }
        /** @ignore */
        get culled() {
          return !(this.localDisplayStatus & 4);
        }
        /** @ignore */
        set culled(value) {
          const valueNumber = value ? 0 : 4;
          if ((this.localDisplayStatus & 4) === valueNumber)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 4;
          this._onUpdate();
        }
        /**
         * Controls whether this object can be rendered. If false the object will not be drawn,
         * but the transform will still be updated. This is different from visible, which skips
         * transform updates.
         * @example
         * ```ts
         * // Basic render control
         * sprite.renderable = false; // Skip rendering
         * sprite.renderable = true;  // Enable rendering
         * ```
         * @default true
         * @see {@link Container#visible} For skipping transform updates
         * @see {@link Container#alpha} For transparency
         */
        get renderable() {
          return !!(this.localDisplayStatus & 1);
        }
        set renderable(value) {
          const valueNumber = value ? 1 : 0;
          if ((this.localDisplayStatus & 1) === valueNumber)
            return;
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 1;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._onUpdate();
        }
        /**
         * Whether or not the object should be rendered.
         * @advanced
         */
        get isRenderable() {
          return this.localDisplayStatus === 7 && this.groupAlpha > 0;
        }
        /**
         * Removes all internal references and listeners as well as removes children from the display list.
         * Do not use a Container after calling `destroy`.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @example
         * ```ts
         * container.destroy();
         * container.destroy(true);
         * container.destroy({ children: true });
         * container.destroy({ children: true, texture: true, textureSource: true });
         * ```
         */
        destroy(options = false) {
          var _a2;
          if (this.destroyed)
            return;
          this.destroyed = true;
          let oldChildren;
          if (this.children.length) {
            oldChildren = this.removeChildren(0, this.children.length);
          }
          this.removeFromParent();
          this.parent = null;
          this._maskEffect = null;
          this._filterEffect = null;
          this.effects = null;
          this._position = null;
          this._scale = null;
          this._pivot = null;
          this._origin = null;
          this._skew = null;
          this.emit("destroyed", this);
          this.removeAllListeners();
          const destroyChildren = typeof options === "boolean" ? options : options == null ? void 0 : options.children;
          if (destroyChildren && oldChildren) {
            for (let i3 = 0; i3 < oldChildren.length; ++i3) {
              oldChildren[i3].destroy(options);
            }
          }
          (_a2 = this.renderGroup) == null ? void 0 : _a2.destroy();
          this.renderGroup = null;
        }
      };
      extensions.mixin(
        Container,
        childrenHelperMixin,
        getFastGlobalBoundsMixin,
        toLocalGlobalMixin,
        onRenderMixin,
        measureMixin,
        effectsMixin,
        findMixin,
        sortMixin,
        cullingMixin,
        cacheAsTextureMixin,
        getGlobalMixin,
        collectRenderablesMixin
      );
    }
  });

  // node_modules/pixi.js/lib/ticker/const.mjs
  var UPDATE_PRIORITY;
  var init_const2 = __esm({
    "node_modules/pixi.js/lib/ticker/const.mjs"() {
      "use strict";
      UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
        return UPDATE_PRIORITY2;
      })(UPDATE_PRIORITY || {});
    }
  });

  // node_modules/pixi.js/lib/ticker/TickerListener.mjs
  var TickerListener;
  var init_TickerListener = __esm({
    "node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
      "use strict";
      TickerListener = class {
        /**
         * Constructor
         * @private
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @param priority - The priority for emitting
         * @param once - If the handler should fire once
         */
        constructor(fn, context4 = null, priority = 0, once = false) {
          this.next = null;
          this.previous = null;
          this._destroyed = false;
          this._fn = fn;
          this._context = context4;
          this.priority = priority;
          this._once = once;
        }
        /**
         * Simple compare function to figure out if a function and context match.
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @returns `true` if the listener match the arguments
         */
        match(fn, context4 = null) {
          return this._fn === fn && this._context === context4;
        }
        /**
         * Emit by calling the current function.
         * @param ticker - The ticker emitting.
         * @returns Next ticker
         */
        emit(ticker) {
          if (this._fn) {
            if (this._context) {
              this._fn.call(this._context, ticker);
            } else {
              this._fn(ticker);
            }
          }
          const redirect = this.next;
          if (this._once) {
            this.destroy(true);
          }
          if (this._destroyed) {
            this.next = null;
          }
          return redirect;
        }
        /**
         * Connect to the list.
         * @param previous - Input node, previous listener
         */
        connect(previous) {
          this.previous = previous;
          if (previous.next) {
            previous.next.previous = this;
          }
          this.next = previous.next;
          previous.next = this;
        }
        /**
         * Destroy and don't use after this.
         * @param hard - `true` to remove the `next` reference, this
         *        is considered a hard destroy. Soft destroy maintains the next reference.
         * @returns The listener to redirect while emitting or removing.
         */
        destroy(hard = false) {
          this._destroyed = true;
          this._fn = null;
          this._context = null;
          if (this.previous) {
            this.previous.next = this.next;
          }
          if (this.next) {
            this.next.previous = this.previous;
          }
          const redirect = this.next;
          this.next = hard ? null : redirect;
          this.previous = null;
          return redirect;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/ticker/Ticker.mjs
  var _Ticker, Ticker;
  var init_Ticker = __esm({
    "node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
      init_const2();
      init_TickerListener();
      _Ticker = class _Ticker2 {
        constructor() {
          this.autoStart = false;
          this.deltaTime = 1;
          this.lastTime = -1;
          this.speed = 1;
          this.started = false;
          this._requestId = null;
          this._maxElapsedMS = 100;
          this._minElapsedMS = 0;
          this._protected = false;
          this._lastFrame = -1;
          this._head = new TickerListener(null, null, Infinity);
          this.deltaMS = 1 / _Ticker2.targetFPMS;
          this.elapsedMS = 1 / _Ticker2.targetFPMS;
          this._tick = (time) => {
            this._requestId = null;
            if (this.started) {
              this.update(time);
              if (this.started && this._requestId === null && this._head.next) {
                this._requestId = requestAnimationFrame(this._tick);
              }
            }
          };
        }
        /**
         * Conditionally requests a new animation frame.
         * If a frame has not already been requested, and if the internal
         * emitter has listeners, a new frame is requested.
         */
        _requestIfNeeded() {
          if (this._requestId === null && this._head.next) {
            this.lastTime = performance.now();
            this._lastFrame = this.lastTime;
            this._requestId = requestAnimationFrame(this._tick);
          }
        }
        /** Conditionally cancels a pending animation frame. */
        _cancelIfNeeded() {
          if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
          }
        }
        /**
         * Conditionally requests a new animation frame.
         * If the ticker has been started it checks if a frame has not already
         * been requested, and if the internal emitter has listeners. If these
         * conditions are met, a new frame is requested. If the ticker has not
         * been started, but autoStart is `true`, then the ticker starts now,
         * and continues with the previous conditions to request a new frame.
         */
        _startIfPossible() {
          if (this.started) {
            this._requestIfNeeded();
          } else if (this.autoStart) {
            this.start();
          }
        }
        /**
         * Register a handler for tick events.
         * @param fn - The listener function to add. Receives the Ticker instance as parameter
         * @param context - The context for the listener
         * @param priority - The priority of the listener
         * @example
         * ```ts
         * // Access time properties through the ticker parameter
         * ticker.add((ticker) => {
         *     // Use deltaTime (dimensionless scalar) for frame-independent animations
         *     sprite.rotation += 0.1 * ticker.deltaTime;
         *
         *     // Use deltaMS (milliseconds) for time-based calculations
         *     const progress = ticker.deltaMS / animationDuration;
         *
         *     // Use elapsedMS for raw timing measurements
         *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);
         * });
         * ```
         */
        add(fn, context4, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context4, priority));
        }
        /**
         * Add a handler for the tick event which is only executed once on the next frame.
         * @example
         * ```ts
         * // Basic one-time update
         * ticker.addOnce(() => {
         *     console.log('Runs next frame only');
         * });
         *
         * // With specific context
         * const game = {
         *     init(ticker) {
         *         this.loadResources();
         *         console.log('Game initialized');
         *     }
         * };
         * ticker.addOnce(game.init, game);
         *
         * // With priority
         * ticker.addOnce(
         *     () => {
         *         // High priority one-time setup
         *         physics.init();
         *     },
         *     undefined,
         *     UPDATE_PRIORITY.HIGH
         * );
         * ```
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)
         * @returns This instance of a ticker
         * @see {@link Ticker#add} For continuous updates
         * @see {@link Ticker#remove} For removing handlers
         */
        addOnce(fn, context4, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context4, priority, true));
        }
        /**
         * Internally adds the event handler so that it can be sorted by priority.
         * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
         * before the rendering.
         * @private
         * @param listener - Current listener being added.
         * @returns This instance of a ticker
         */
        _addListener(listener) {
          let current = this._head.next;
          let previous = this._head;
          if (!current) {
            listener.connect(previous);
          } else {
            while (current) {
              if (listener.priority > current.priority) {
                listener.connect(previous);
                break;
              }
              previous = current;
              current = current.next;
            }
            if (!listener.previous) {
              listener.connect(previous);
            }
          }
          this._startIfPossible();
          return this;
        }
        /**
         * Removes any handlers matching the function and context parameters.
         * If no handlers are left after removing, then it cancels the animation frame.
         * @example
         * ```ts
         * // Basic removal
         * const onTick = () => {
         *     sprite.rotation += 0.1;
         * };
         * ticker.add(onTick);
         * ticker.remove(onTick);
         *
         * // Remove with context
         * const game = {
         *     update(ticker) {
         *         this.physics.update(ticker.deltaTime);
         *     }
         * };
         * ticker.add(game.update, game);
         * ticker.remove(game.update, game);
         *
         * // Remove all matching handlers
         * // (if same function was added multiple times)
         * ticker.add(onTick);
         * ticker.add(onTick);
         * ticker.remove(onTick); // Removes all instances
         * ```
         * @param fn - The listener function to be removed
         * @param context - The listener context to be removed
         * @returns This instance of a ticker
         * @see {@link Ticker#add} For adding handlers
         * @see {@link Ticker#addOnce} For one-time handlers
         */
        remove(fn, context4) {
          let listener = this._head.next;
          while (listener) {
            if (listener.match(fn, context4)) {
              listener = listener.destroy();
            } else {
              listener = listener.next;
            }
          }
          if (!this._head.next) {
            this._cancelIfNeeded();
          }
          return this;
        }
        /**
         * The number of listeners on this ticker, calculated by walking through linked list.
         * @example
         * ```ts
         * // Check number of active listeners
         * const ticker = new Ticker();
         * console.log(ticker.count); // 0
         *
         * // Add some listeners
         * ticker.add(() => {});
         * ticker.add(() => {});
         * console.log(ticker.count); // 2
         *
         * // Check after cleanup
         * ticker.destroy();
         * console.log(ticker.count); // 0
         * ```
         * @readonly
         * @see {@link Ticker#add} For adding listeners
         * @see {@link Ticker#remove} For removing listeners
         */
        get count() {
          if (!this._head) {
            return 0;
          }
          let count2 = 0;
          let current = this._head;
          while (current = current.next) {
            count2++;
          }
          return count2;
        }
        /**
         * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.
         * @example
         * ```ts
         * // Basic manual start
         * const ticker = new Ticker();
         * ticker.add(() => {
         *     // Animation code here
         * });
         * ticker.start();
         * ```
         * @see {@link Ticker#stop} For stopping the ticker
         * @see {@link Ticker#autoStart} For automatic starting
         * @see {@link Ticker#started} For checking ticker state
         */
        start() {
          if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
          }
        }
        /**
         * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.
         * @example
         * ```ts
         * // Basic stop
         * const ticker = new Ticker();
         * ticker.stop();
         * ```
         * @see {@link Ticker#start} For starting the ticker
         * @see {@link Ticker#started} For checking ticker state
         * @see {@link Ticker#destroy} For cleaning up the ticker
         */
        stop() {
          if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
          }
        }
        /**
         * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.
         * @example
         * ```ts
         * // Clean up with active listeners
         * const ticker = new Ticker();
         * ticker.add(() => {});
         * ticker.destroy(); // Removes all listeners
         * ```
         * @see {@link Ticker#stop} For stopping without destroying
         * @see {@link Ticker#remove} For removing specific listeners
         */
        destroy() {
          if (!this._protected) {
            this.stop();
            let listener = this._head.next;
            while (listener) {
              listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
          }
        }
        /**
         * Triggers an update.
         *
         * An update entails setting the
         * current {@link Ticker#elapsedMS|elapsedMS},
         * the current {@link Ticker#deltaTime|deltaTime},
         * invoking all listeners with current deltaTime,
         * and then finally setting {@link Ticker#lastTime|lastTime}
         * with the value of currentTime that was provided.
         *
         * This method will be called automatically by animation
         * frame callbacks if the ticker instance has been started
         * and listeners are added.
         * @example
         * ```ts
         * // Basic manual update
         * const ticker = new Ticker();
         * ticker.update(performance.now());
         * ```
         * @param currentTime - The current time of execution (defaults to performance.now())
         * @see {@link Ticker#deltaTime} For frame delta value
         * @see {@link Ticker#elapsedMS} For raw elapsed time
         */
        update(currentTime = performance.now()) {
          let elapsedMS;
          if (currentTime > this.lastTime) {
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            if (elapsedMS > this._maxElapsedMS) {
              elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            if (this._minElapsedMS) {
              const delta = currentTime - this._lastFrame | 0;
              if (delta < this._minElapsedMS) {
                return;
              }
              this._lastFrame = currentTime - delta % this._minElapsedMS;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
            const head = this._head;
            let listener = head.next;
            while (listener) {
              listener = listener.emit(this);
            }
            if (!head.next) {
              this._cancelIfNeeded();
            }
          } else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
          }
          this.lastTime = currentTime;
        }
        /**
         * The frames per second at which this ticker is running.
         * The default is approximately 60 in most modern browsers.
         * > [!NOTE] This does not factor in the value of
         * > {@link Ticker#speed|speed}, which is specific
         * > to scaling {@link Ticker#deltaTime|deltaTime}.
         * @example
         * ```ts
         * // Basic FPS monitoring
         * ticker.add(() => {
         *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);
         * });
         * ```
         * @readonly
         */
        get FPS() {
          return 1e3 / this.elapsedMS;
        }
        /**
         * Manages the maximum amount of milliseconds allowed to
         * elapse between invoking {@link Ticker#update|update}.
         *
         * This value is used to cap {@link Ticker#deltaTime|deltaTime},
         * but does not effect the measured value of {@link Ticker#FPS|FPS}.
         *
         * When setting this property it is clamped to a value between
         * `0` and `Ticker.targetFPMS * 1000`.
         * @example
         * ```ts
         * // Set minimum acceptable frame rate
         * const ticker = new Ticker();
         * ticker.minFPS = 30; // Never go below 30 FPS
         *
         * // Use with maxFPS for frame rate clamping
         * ticker.minFPS = 30;
         * ticker.maxFPS = 60;
         *
         * // Monitor delta capping
         * ticker.add(() => {
         *     // Delta time will be capped based on minFPS
         *     console.log(`Delta time: ${ticker.deltaTime}`);
         * });
         * ```
         * @default 10
         */
        get minFPS() {
          return 1e3 / this._maxElapsedMS;
        }
        set minFPS(fps) {
          const minFPS = Math.min(this.maxFPS, fps);
          const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
          this._maxElapsedMS = 1 / minFPMS;
        }
        /**
         * Manages the minimum amount of milliseconds required to
         * elapse between invoking {@link Ticker#update|update}.
         *
         * This will effect the measured value of {@link Ticker#FPS|FPS}.
         *
         * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
         * Otherwise it will be at least `minFPS`
         * @example
         * ```ts
         * // Set minimum acceptable frame rate
         * const ticker = new Ticker();
         * ticker.maxFPS = 60; // Never go above 60 FPS
         *
         * // Use with maxFPS for frame rate clamping
         * ticker.minFPS = 30;
         * ticker.maxFPS = 60;
         *
         * // Monitor delta capping
         * ticker.add(() => {
         *     // Delta time will be capped based on maxFPS
         *     console.log(`Delta time: ${ticker.deltaTime}`);
         * });
         * ```
         * @default 0
         */
        get maxFPS() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        }
        set maxFPS(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            const maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        }
        /**
         * The shared ticker instance used by {@link AnimatedSprite} and by
         * {@link VideoSource} to update animation frames / video textures.
         *
         * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
         *
         * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
         * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
         * @example
         * import { Ticker } from 'pixi.js';
         *
         * const ticker = Ticker.shared;
         * // Set this to prevent starting this ticker when listeners are added.
         * // By default this is true only for the Ticker.shared instance.
         * ticker.autoStart = false;
         *
         * // FYI, call this to ensure the ticker is stopped. It should be stopped
         * // if you have not attempted to render anything yet.
         * ticker.stop();
         *
         * // Call this when you are ready for a running shared ticker.
         * ticker.start();
         * @example
         * import { autoDetectRenderer, Container } from 'pixi.js';
         *
         * // You may use the shared ticker to render...
         * const renderer = autoDetectRenderer();
         * const stage = new Container();
         * document.body.appendChild(renderer.view);
         * ticker.add((time) => renderer.render(stage));
         *
         * // Or you can just update it manually.
         * ticker.autoStart = false;
         * ticker.stop();
         * const animate = (time) => {
         *     ticker.update(time);
         *     renderer.render(stage);
         *     requestAnimationFrame(animate);
         * };
         * animate(performance.now());
         * @type {Ticker}
         * @readonly
         */
        static get shared() {
          if (!_Ticker2._shared) {
            const shared = _Ticker2._shared = new _Ticker2();
            shared.autoStart = true;
            shared._protected = true;
          }
          return _Ticker2._shared;
        }
        /**
         * The system ticker instance used by {@link PrepareBase} for core timing
         * functionality that shouldn't usually need to be paused, unlike the `shared`
         * ticker which drives visual animations and rendering which may want to be paused.
         *
         * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
         * @type {Ticker}
         * @readonly
         * @advanced
         */
        static get system() {
          if (!_Ticker2._system) {
            const system = _Ticker2._system = new _Ticker2();
            system.autoStart = true;
            system._protected = true;
          }
          return _Ticker2._system;
        }
      };
      _Ticker.targetFPMS = 0.06;
      Ticker = _Ticker;
    }
  });

  // node_modules/pixi.js/lib/dom/CanvasObserver.mjs
  var CanvasObserver;
  var init_CanvasObserver = __esm({
    "node_modules/pixi.js/lib/dom/CanvasObserver.mjs"() {
      init_const2();
      init_Ticker();
      CanvasObserver = class {
        constructor(options) {
          this._lastTransform = "";
          this._observer = null;
          this._tickerAttached = false;
          this.updateTranslation = () => {
            if (!this._canvas)
              return;
            const rect = this._canvas.getBoundingClientRect();
            const contentWidth = this._canvas.width;
            const contentHeight = this._canvas.height;
            const sx = rect.width / contentWidth * this._renderer.resolution;
            const sy = rect.height / contentHeight * this._renderer.resolution;
            const tx = rect.left;
            const ty = rect.top;
            const newTransform = `translate(${tx}px, ${ty}px) scale(${sx}, ${sy})`;
            if (newTransform !== this._lastTransform) {
              this._domElement.style.transform = newTransform;
              this._lastTransform = newTransform;
            }
          };
          this._domElement = options.domElement;
          this._renderer = options.renderer;
          if (globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas)
            return;
          this._canvas = this._renderer.canvas;
          this._attachObserver();
        }
        /** The canvas element that this CanvasObserver is associated with. */
        get canvas() {
          return this._canvas;
        }
        /** Attaches the DOM element to the canvas parent if it is not already attached. */
        ensureAttached() {
          if (!this._domElement.parentNode && this._canvas.parentNode) {
            this._canvas.parentNode.appendChild(this._domElement);
            this.updateTranslation();
          }
        }
        /** Sets up a ResizeObserver if available. This ensures that the DOM element is kept in sync with the canvas size . */
        _attachObserver() {
          if ("ResizeObserver" in globalThis) {
            if (this._observer) {
              this._observer.disconnect();
              this._observer = null;
            }
            this._observer = new ResizeObserver((entries) => {
              for (const entry of entries) {
                if (entry.target !== this._canvas) {
                  continue;
                }
                const contentWidth = this.canvas.width;
                const contentHeight = this.canvas.height;
                const sx = entry.contentRect.width / contentWidth * this._renderer.resolution;
                const sy = entry.contentRect.height / contentHeight * this._renderer.resolution;
                const needsUpdate = this._lastScaleX !== sx || this._lastScaleY !== sy;
                if (needsUpdate) {
                  this.updateTranslation();
                  this._lastScaleX = sx;
                  this._lastScaleY = sy;
                }
              }
            });
            this._observer.observe(this._canvas);
          } else if (!this._tickerAttached) {
            Ticker.shared.add(this.updateTranslation, this, UPDATE_PRIORITY.HIGH);
          }
        }
        /** Destroys the CanvasObserver instance, cleaning up observers and Ticker. */
        destroy() {
          if (this._observer) {
            this._observer.disconnect();
            this._observer = null;
          } else if (this._tickerAttached) {
            Ticker.shared.remove(this.updateTranslation);
          }
          this._domElement = null;
          this._renderer = null;
          this._canvas = null;
          this._tickerAttached = false;
          this._lastTransform = "";
          this._lastScaleX = null;
          this._lastScaleY = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/events/FederatedEvent.mjs
  var FederatedEvent;
  var init_FederatedEvent = __esm({
    "node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
      init_Point();
      FederatedEvent = class _FederatedEvent {
        /**
         * @param manager - The event boundary which manages this event. Propagation can only occur
         *  within the boundary's jurisdiction.
         */
        constructor(manager) {
          this.bubbles = true;
          this.cancelBubble = true;
          this.cancelable = false;
          this.composed = false;
          this.defaultPrevented = false;
          this.eventPhase = _FederatedEvent.prototype.NONE;
          this.propagationStopped = false;
          this.propagationImmediatelyStopped = false;
          this.layer = new Point();
          this.page = new Point();
          this.NONE = 0;
          this.CAPTURING_PHASE = 1;
          this.AT_TARGET = 2;
          this.BUBBLING_PHASE = 3;
          this.manager = manager;
        }
        /** @readonly */
        get layerX() {
          return this.layer.x;
        }
        /** @readonly */
        get layerY() {
          return this.layer.y;
        }
        /** @readonly */
        get pageX() {
          return this.page.x;
        }
        /** @readonly */
        get pageY() {
          return this.page.y;
        }
        /**
         * Fallback for the deprecated `InteractionEvent.data`.
         * @deprecated since 7.0.0
         */
        get data() {
          return this;
        }
        /**
         * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.
         * @advanced
         */
        composedPath() {
          if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
          }
          return this.path;
        }
        /**
         * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.
         * @deprecated
         * @ignore
         * @param _type
         * @param _bubbles
         * @param _cancelable
         */
        initEvent(_type, _bubbles, _cancelable) {
          throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        /**
         * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.
         * @ignore
         * @deprecated
         * @param _typeArg
         * @param _bubblesArg
         * @param _cancelableArg
         * @param _viewArg
         * @param _detailArg
         */
        initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
          throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        /**
         * Prevent default behavior of both PixiJS and the user agent.
         * @example
         * ```ts
         * sprite.on('click', (event) => {
         *     // Prevent both browser's default click behavior
         *     // and PixiJS's default handling
         *     event.preventDefault();
         *
         *     // Custom handling
         *     customClickHandler();
         * });
         * ```
         * @remarks
         * - Only works if the native event is cancelable
         * - Does not stop event propagation
         */
        preventDefault() {
          if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
            this.nativeEvent.preventDefault();
          }
          this.defaultPrevented = true;
        }
        /**
         * Stop this event from propagating to any additional listeners, including those
         * on the current target and any following targets in the propagation path.
         * @example
         * ```ts
         * container.on('pointerdown', (event) => {
         *     // Stop all further event handling
         *     event.stopImmediatePropagation();
         *
         *     // These handlers won't be called:
         *     // - Other pointerdown listeners on this container
         *     // - Any pointerdown listeners on parent containers
         * });
         * ```
         * @remarks
         * - Immediately stops all event propagation
         * - Prevents other listeners on same target from being called
         * - More aggressive than stopPropagation()
         */
        stopImmediatePropagation() {
          this.propagationImmediatelyStopped = true;
        }
        /**
         * Stop this event from propagating to the next target in the propagation path.
         * The rest of the listeners on the current target will still be notified.
         * @example
         * ```ts
         * child.on('pointermove', (event) => {
         *     // Handle event on child
         *     updateChild();
         *
         *     // Prevent parent handlers from being called
         *     event.stopPropagation();
         * });
         *
         * // This won't be called if child handles the event
         * parent.on('pointermove', (event) => {
         *     updateParent();
         * });
         * ```
         * @remarks
         * - Stops event bubbling to parent containers
         * - Does not prevent other listeners on same target
         * - Less aggressive than stopImmediatePropagation()
         */
        stopPropagation() {
          this.propagationStopped = true;
        }
      };
    }
  });

  // node_modules/ismobilejs/esm/isMobile.js
  function createMatch(userAgent) {
    return function(regex) {
      return regex.test(userAgent);
    };
  }
  function isMobile(param) {
    var nav = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav.userAgent = param;
    } else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    tmp = userAgent.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
      apple: {
        phone: match(appleIphone) && !match(windowsPhone),
        ipod: match(appleIpod),
        tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
        universal: match(appleUniversal),
        device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
      },
      amazon: {
        phone: match(amazonPhone),
        tablet: !match(amazonPhone) && match(amazonTablet),
        device: match(amazonPhone) || match(amazonTablet)
      },
      android: {
        phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
        tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
        device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone),
        tablet: match(windowsTablet),
        device: match(windowsPhone) || match(windowsTablet)
      },
      other: {
        blackberry: match(otherBlackBerry),
        blackberry10: match(otherBlackBerry10),
        opera: match(otherOpera),
        firefox: match(otherFirefox),
        chrome: match(otherChrome),
        device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
    result.phone = result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }
  var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
  var init_isMobile = __esm({
    "node_modules/ismobilejs/esm/isMobile.js"() {
      appleIphone = /iPhone/i;
      appleIpod = /iPod/i;
      appleTablet = /iPad/i;
      appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
      androidPhone = /\bAndroid(?:.+)Mobile\b/i;
      androidTablet = /Android/i;
      amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
      amazonTablet = /Silk/i;
      windowsPhone = /Windows Phone/i;
      windowsTablet = /\bWindows(?:.+)ARM\b/i;
      otherBlackBerry = /BlackBerry/i;
      otherBlackBerry10 = /BB10/i;
      otherOpera = /Opera Mini/i;
      otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
      otherFirefox = /Mobile(?:.+)Firefox\b/i;
      isAppleTabletOnIos13 = function(navigator2) {
        return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
      };
    }
  });

  // node_modules/ismobilejs/esm/index.js
  var init_esm = __esm({
    "node_modules/ismobilejs/esm/index.js"() {
      init_isMobile();
      init_isMobile();
    }
  });

  // node_modules/pixi.js/lib/utils/browser/isMobile.mjs
  var _a, isMobileCall, isMobile2;
  var init_isMobile2 = __esm({
    "node_modules/pixi.js/lib/utils/browser/isMobile.mjs"() {
      init_esm();
      isMobileCall = (_a = isMobile.default) != null ? _a : isMobile;
      isMobile2 = isMobileCall(globalThis.navigator);
    }
  });

  // node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
  var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, _AccessibilitySystem, AccessibilitySystem;
  var init_AccessibilitySystem = __esm({
    "node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs"() {
      init_CanvasObserver();
      init_FederatedEvent();
      init_Extensions();
      init_isMobile2();
      init_removeItems();
      KEY_CODE_TAB = 9;
      DIV_TOUCH_SIZE = 100;
      DIV_TOUCH_POS_X = 0;
      DIV_TOUCH_POS_Y = 0;
      DIV_TOUCH_ZINDEX = 2;
      DIV_HOOK_SIZE = 1;
      DIV_HOOK_POS_X = -1e3;
      DIV_HOOK_POS_Y = -1e3;
      DIV_HOOK_ZINDEX = 2;
      _AccessibilitySystem = class _AccessibilitySystem2 {
        // eslint-disable-next-line jsdoc/require-param
        /**
         * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
         */
        constructor(renderer, _mobileInfo = isMobile2) {
          this._mobileInfo = _mobileInfo;
          this.debug = false;
          this._activateOnTab = true;
          this._deactivateOnMouseMove = true;
          this._isActive = false;
          this._isMobileAccessibility = false;
          this._div = null;
          this._pools = {};
          this._renderId = 0;
          this._children = [];
          this._androidUpdateCount = 0;
          this._androidUpdateFrequency = 500;
          this._isRunningTests = false;
          this._boundOnKeyDown = this._onKeyDown.bind(this);
          this._boundOnMouseMove = this._onMouseMove.bind(this);
          this._hookDiv = null;
          if (_mobileInfo.tablet || _mobileInfo.phone) {
            this._createTouchHook();
          }
          this._renderer = renderer;
        }
        /**
         * Value of `true` if accessibility is currently active and accessibility layers are showing.
         * @type {boolean}
         * @readonly
         */
        get isActive() {
          return this._isActive;
        }
        /**
         * Value of `true` if accessibility is enabled for touch devices.
         * @type {boolean}
         * @readonly
         */
        get isMobileAccessibility() {
          return this._isMobileAccessibility;
        }
        /**
         * Button element for handling touch hooks.
         * @readonly
         */
        get hookDiv() {
          return this._hookDiv;
        }
        /**
         * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.
         * @readonly
         */
        get div() {
          return this._div;
        }
        /**
         * Creates the touch hooks.
         * @private
         */
        _createTouchHook() {
          const hookDiv = document.createElement("button");
          hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
          hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
          hookDiv.style.position = "absolute";
          hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
          hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
          hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
          hookDiv.style.backgroundColor = "#FF0000";
          hookDiv.title = "select to enable accessibility for this content";
          hookDiv.addEventListener("focus", () => {
            this._isMobileAccessibility = true;
            this._activate();
            this._destroyTouchHook();
          });
          document.body.appendChild(hookDiv);
          this._hookDiv = hookDiv;
        }
        /**
         * Destroys the touch hooks.
         * @private
         */
        _destroyTouchHook() {
          if (!this._hookDiv) {
            return;
          }
          document.body.removeChild(this._hookDiv);
          this._hookDiv = null;
        }
        /**
         * Activating will cause the Accessibility layer to be shown.
         * This is called when a user presses the tab key.
         * @private
         */
        _activate() {
          if (this._isActive) {
            return;
          }
          this._isActive = true;
          if (!this._div) {
            this._div = document.createElement("div");
            this._div.style.position = "absolute";
            this._div.style.top = `${DIV_TOUCH_POS_X}px`;
            this._div.style.left = `${DIV_TOUCH_POS_Y}px`;
            this._div.style.pointerEvents = "none";
            this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
            this._canvasObserver = new CanvasObserver({
              domElement: this._div,
              renderer: this._renderer
            });
          }
          if (this._activateOnTab) {
            globalThis.addEventListener("keydown", this._boundOnKeyDown, false);
          }
          if (this._deactivateOnMouseMove) {
            globalThis.document.addEventListener("mousemove", this._boundOnMouseMove, true);
          }
          const canvas = this._renderer.view.canvas;
          if (!canvas.parentNode) {
            const observer = new MutationObserver(() => {
              if (canvas.parentNode) {
                observer.disconnect();
                this._canvasObserver.ensureAttached();
                this._initAccessibilitySetup();
              }
            });
            observer.observe(document.body, { childList: true, subtree: true });
          } else {
            this._canvasObserver.ensureAttached();
            this._initAccessibilitySetup();
          }
        }
        // New method to handle initialization after div is ready
        _initAccessibilitySetup() {
          this._renderer.runners.postrender.add(this);
          if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
          }
        }
        /**
         * Deactivates the accessibility system. Removes listeners and accessibility elements.
         * @private
         */
        _deactivate() {
          var _a2, _b;
          if (!this._isActive || this._isMobileAccessibility) {
            return;
          }
          this._isActive = false;
          globalThis.document.removeEventListener("mousemove", this._boundOnMouseMove, true);
          if (this._activateOnTab) {
            globalThis.addEventListener("keydown", this._boundOnKeyDown, false);
          }
          this._renderer.runners.postrender.remove(this);
          for (const child of this._children) {
            if ((_a2 = child._accessibleDiv) == null ? void 0 : _a2.parentNode) {
              child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
              child._accessibleDiv = null;
            }
            child._accessibleActive = false;
          }
          for (const accessibleType in this._pools) {
            const pool = this._pools[accessibleType];
            pool.forEach((div) => {
              if (div.parentNode) {
                div.parentNode.removeChild(div);
              }
            });
            delete this._pools[accessibleType];
          }
          if ((_b = this._div) == null ? void 0 : _b.parentNode) {
            this._div.parentNode.removeChild(this._div);
          }
          this._pools = {};
          this._children = [];
        }
        /**
         * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
         * @private
         * @param {Container} container - The Container to check.
         */
        _updateAccessibleObjects(container) {
          if (!container.visible || !container.accessibleChildren) {
            return;
          }
          if (container.accessible) {
            if (!container._accessibleActive) {
              this._addChild(container);
            }
            container._renderId = this._renderId;
          }
          const children = container.children;
          if (children) {
            for (let i3 = 0; i3 < children.length; i3++) {
              this._updateAccessibleObjects(children[i3]);
            }
          }
        }
        /**
         * Runner init called, view is available at this point.
         * @ignore
         */
        init(options) {
          const defaultOpts = _AccessibilitySystem2.defaultOptions;
          const mergedOptions = {
            accessibilityOptions: __spreadValues(__spreadValues({}, defaultOpts), (options == null ? void 0 : options.accessibilityOptions) || {})
          };
          this.debug = mergedOptions.accessibilityOptions.debug;
          this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;
          this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;
          if (mergedOptions.accessibilityOptions.enabledByDefault) {
            this._activate();
          }
          this._renderer.runners.postrender.remove(this);
        }
        /**
         * Updates the accessibility layer during rendering.
         * - Removes divs for containers no longer in the scene
         * - Updates the position and dimensions of the root div
         * - Updates positions of active accessibility divs
         * Only fires while the accessibility system is active.
         * @ignore
         */
        postrender() {
          const now = performance.now();
          if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
            return;
          }
          this._androidUpdateCount = now + this._androidUpdateFrequency;
          if ((!this._renderer.renderingToScreen || !this._renderer.view.canvas) && !this._isRunningTests) {
            return;
          }
          const activeIds = /* @__PURE__ */ new Set();
          if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
            for (const child of this._children) {
              if (child._renderId === this._renderId) {
                activeIds.add(this._children.indexOf(child));
              }
            }
          }
          for (let i3 = this._children.length - 1; i3 >= 0; i3--) {
            const child = this._children[i3];
            if (!activeIds.has(i3)) {
              if (child._accessibleDiv && child._accessibleDiv.parentNode) {
                child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
                const pool = this._getPool(child.accessibleType);
                pool.push(child._accessibleDiv);
                child._accessibleDiv = null;
              }
              child._accessibleActive = false;
              removeItems(this._children, i3, 1);
            }
          }
          if (this._renderer.renderingToScreen) {
            this._canvasObserver.ensureAttached();
          }
          for (let i3 = 0; i3 < this._children.length; i3++) {
            const child = this._children[i3];
            if (!child._accessibleActive || !child._accessibleDiv) {
              continue;
            }
            const div = child._accessibleDiv;
            const hitArea = child.hitArea || child.getBounds().rectangle;
            if (child.hitArea) {
              const wt = child.worldTransform;
              div.style.left = `${wt.tx + hitArea.x * wt.a}px`;
              div.style.top = `${wt.ty + hitArea.y * wt.d}px`;
              div.style.width = `${hitArea.width * wt.a}px`;
              div.style.height = `${hitArea.height * wt.d}px`;
            } else {
              this._capHitArea(hitArea);
              div.style.left = `${hitArea.x}px`;
              div.style.top = `${hitArea.y}px`;
              div.style.width = `${hitArea.width}px`;
              div.style.height = `${hitArea.height}px`;
            }
          }
          this._renderId++;
        }
        /**
         * private function that will visually add the information to the
         * accessibility div
         * @param {HTMLElement} div -
         */
        _updateDebugHTML(div) {
          div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
        }
        /**
         * Adjust the hit area based on the bounds of a display object
         * @param {Rectangle} hitArea - Bounds of the child
         */
        _capHitArea(hitArea) {
          if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
          }
          if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
          }
          const { width: viewWidth, height: viewHeight } = this._renderer;
          if (hitArea.x + hitArea.width > viewWidth) {
            hitArea.width = viewWidth - hitArea.x;
          }
          if (hitArea.y + hitArea.height > viewHeight) {
            hitArea.height = viewHeight - hitArea.y;
          }
        }
        /**
         * Creates or reuses a div element for a Container and adds it to the accessibility layer.
         * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.
         * @private
         * @param {Container} container - The child to make accessible.
         */
        _addChild(container) {
          const pool = this._getPool(container.accessibleType);
          let div = pool.pop();
          if (div) {
            div.innerHTML = "";
            div.removeAttribute("title");
            div.removeAttribute("aria-label");
            div.tabIndex = 0;
          } else {
            if (container.accessibleType === "button") {
              div = document.createElement("button");
            } else {
              div = document.createElement(container.accessibleType);
              div.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `;
              if (container.accessibleText) {
                div.innerText = container.accessibleText;
              }
            }
            div.style.width = `${DIV_TOUCH_SIZE}px`;
            div.style.height = `${DIV_TOUCH_SIZE}px`;
            div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
            div.style.position = "absolute";
            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
            div.style.borderStyle = "none";
            if (navigator.userAgent.toLowerCase().includes("chrome")) {
              div.setAttribute("aria-live", "off");
            } else {
              div.setAttribute("aria-live", "polite");
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
              div.setAttribute("aria-relevant", "additions");
            } else {
              div.setAttribute("aria-relevant", "text");
            }
            div.addEventListener("click", this._onClick.bind(this));
            div.addEventListener("focus", this._onFocus.bind(this));
            div.addEventListener("focusout", this._onFocusOut.bind(this));
          }
          div.style.pointerEvents = container.accessiblePointerEvents;
          div.type = container.accessibleType;
          if (container.accessibleTitle && container.accessibleTitle !== null) {
            div.title = container.accessibleTitle;
          } else if (!container.accessibleHint || container.accessibleHint === null) {
            div.title = `container ${container.tabIndex}`;
          }
          if (container.accessibleHint && container.accessibleHint !== null) {
            div.setAttribute("aria-label", container.accessibleHint);
          }
          if (container.interactive) {
            div.tabIndex = container.tabIndex;
          } else {
            div.tabIndex = 0;
          }
          if (this.debug) {
            this._updateDebugHTML(div);
          }
          container._accessibleActive = true;
          container._accessibleDiv = div;
          div.container = container;
          this._children.push(container);
          this._div.appendChild(container._accessibleDiv);
        }
        /**
         * Dispatch events with the EventSystem.
         * @param e
         * @param type
         * @private
         */
        _dispatchEvent(e2, type) {
          const { container: target } = e2.target;
          const boundary = this._renderer.events.rootBoundary;
          const event = Object.assign(new FederatedEvent(boundary), { target });
          boundary.rootTarget = this._renderer.lastObjectRendered;
          type.forEach((type2) => boundary.dispatchEvent(event, type2));
        }
        /**
         * Maps the div button press to pixi's EventSystem (click)
         * @private
         * @param {MouseEvent} e - The click event.
         */
        _onClick(e2) {
          this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
        }
        /**
         * Maps the div focus events to pixi's EventSystem (mouseover)
         * @private
         * @param {FocusEvent} e - The focus event.
         */
        _onFocus(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "assertive");
          }
          this._dispatchEvent(e2, ["mouseover"]);
        }
        /**
         * Maps the div focus events to pixi's EventSystem (mouseout)
         * @private
         * @param {FocusEvent} e - The focusout event.
         */
        _onFocusOut(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "polite");
          }
          this._dispatchEvent(e2, ["mouseout"]);
        }
        /**
         * Is called when a key is pressed
         * @private
         * @param {KeyboardEvent} e - The keydown event.
         */
        _onKeyDown(e2) {
          if (e2.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {
            return;
          }
          this._activate();
        }
        /**
         * Is called when the mouse moves across the renderer element
         * @private
         * @param {MouseEvent} e - The mouse event.
         */
        _onMouseMove(e2) {
          if (e2.movementX === 0 && e2.movementY === 0) {
            return;
          }
          this._deactivate();
        }
        /**
         * Destroys the accessibility system. Removes all elements and listeners.
         * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.
         * > A typically user should not need to call this method directly.
         */
        destroy() {
          var _a2;
          this._deactivate();
          this._destroyTouchHook();
          (_a2 = this._canvasObserver) == null ? void 0 : _a2.destroy();
          this._canvasObserver = null;
          this._div = null;
          this._pools = null;
          this._children = null;
          this._renderer = null;
          this._hookDiv = null;
          globalThis.removeEventListener("keydown", this._boundOnKeyDown);
          this._boundOnKeyDown = null;
          globalThis.document.removeEventListener("mousemove", this._boundOnMouseMove, true);
          this._boundOnMouseMove = null;
        }
        /**
         * Enables or disables the accessibility system.
         * @param enabled - Whether to enable or disable accessibility.
         * @example
         * ```js
         * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility
         * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility
         * ```
         */
        setAccessibilityEnabled(enabled) {
          if (enabled) {
            this._activate();
          } else {
            this._deactivate();
          }
        }
        _getPool(accessibleType) {
          if (!this._pools[accessibleType]) {
            this._pools[accessibleType] = [];
          }
          return this._pools[accessibleType];
        }
      };
      _AccessibilitySystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "accessibility"
      };
      _AccessibilitySystem.defaultOptions = {
        /**
         * Whether to enable accessibility features on initialization
         * @default false
         */
        enabledByDefault: false,
        /**
         * Whether to visually show the accessibility divs for debugging
         * @default false
         */
        debug: false,
        /**
         * Whether to activate accessibility when tab key is pressed
         * @default true
         */
        activateOnTab: true,
        /**
         * Whether to deactivate accessibility when mouse moves
         * @default true
         */
        deactivateOnMouseMove: true
      };
      AccessibilitySystem = _AccessibilitySystem;
    }
  });

  // node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
  var accessibilityTarget;
  var init_accessibilityTarget = __esm({
    "node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs"() {
      "use strict";
      accessibilityTarget = {
        accessible: false,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        accessibleType: "button",
        accessibleText: null,
        accessiblePointerEvents: "auto",
        accessibleChildren: true,
        _accessibleActive: false,
        _accessibleDiv: null,
        _renderId: -1
      };
    }
  });

  // node_modules/pixi.js/lib/accessibility/init.mjs
  var init_init = __esm({
    "node_modules/pixi.js/lib/accessibility/init.mjs"() {
      init_Extensions();
      init_Container();
      init_AccessibilitySystem();
      init_accessibilityTarget();
      extensions.add(AccessibilitySystem);
      extensions.mixin(Container, accessibilityTarget);
    }
  });

  // node_modules/pixi.js/lib/app/ResizePlugin.mjs
  var ResizePlugin;
  var init_ResizePlugin = __esm({
    "node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
      init_Extensions();
      ResizePlugin = class {
        /**
         * Initialize the plugin with scope of application instance
         * @private
         * @param {object} [options] - See application options
         */
        static init(options) {
          Object.defineProperty(
            this,
            "resizeTo",
            {
              configurable: true,
              set(dom) {
                globalThis.removeEventListener("resize", this.queueResize);
                this._resizeTo = dom;
                if (dom) {
                  globalThis.addEventListener("resize", this.queueResize);
                  this.resize();
                }
              },
              get() {
                return this._resizeTo;
              }
            }
          );
          this.queueResize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            this._resizeId = requestAnimationFrame(() => this.resize());
          };
          this._cancelResize = () => {
            if (this._resizeId) {
              cancelAnimationFrame(this._resizeId);
              this._resizeId = null;
            }
          };
          this.resize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            let width;
            let height;
            if (this._resizeTo === globalThis.window) {
              width = globalThis.innerWidth;
              height = globalThis.innerHeight;
            } else {
              const { clientWidth, clientHeight } = this._resizeTo;
              width = clientWidth;
              height = clientHeight;
            }
            this.renderer.resize(width, height);
            this.render();
          };
          this._resizeId = null;
          this._resizeTo = null;
          this.resizeTo = options.resizeTo || null;
        }
        /**
         * Clean up the ticker, scoped to application
         * @private
         */
        static destroy() {
          globalThis.removeEventListener("resize", this.queueResize);
          this._cancelResize();
          this._cancelResize = null;
          this.queueResize = null;
          this.resizeTo = null;
          this.resize = null;
        }
      };
      ResizePlugin.extension = ExtensionType.Application;
    }
  });

  // node_modules/pixi.js/lib/app/TickerPlugin.mjs
  var TickerPlugin;
  var init_TickerPlugin = __esm({
    "node_modules/pixi.js/lib/app/TickerPlugin.mjs"() {
      init_Extensions();
      init_const2();
      init_Ticker();
      TickerPlugin = class {
        /**
         * Initialize the plugin with scope of application instance
         * @private
         * @param {object} [options] - See application options
         */
        static init(options) {
          options = Object.assign({
            autoStart: true,
            sharedTicker: false
          }, options);
          Object.defineProperty(
            this,
            "ticker",
            {
              configurable: true,
              set(ticker) {
                if (this._ticker) {
                  this._ticker.remove(this.render, this);
                }
                this._ticker = ticker;
                if (ticker) {
                  ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
                }
              },
              get() {
                return this._ticker;
              }
            }
          );
          this.stop = () => {
            this._ticker.stop();
          };
          this.start = () => {
            this._ticker.start();
          };
          this._ticker = null;
          this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
          if (options.autoStart) {
            this.start();
          }
        }
        /**
         * Clean up the ticker, scoped to application.
         * @private
         */
        static destroy() {
          if (this._ticker) {
            const oldTicker = this._ticker;
            this.ticker = null;
            oldTicker.destroy();
          }
        }
      };
      TickerPlugin.extension = ExtensionType.Application;
    }
  });

  // node_modules/pixi.js/lib/app/init.mjs
  var init_init2 = __esm({
    "node_modules/pixi.js/lib/app/init.mjs"() {
      init_Extensions();
      init_ResizePlugin();
      init_TickerPlugin();
      extensions.add(ResizePlugin);
      extensions.add(TickerPlugin);
    }
  });

  // node_modules/pixi.js/lib/events/EventTicker.mjs
  var EventsTickerClass, EventsTicker;
  var init_EventTicker = __esm({
    "node_modules/pixi.js/lib/events/EventTicker.mjs"() {
      init_const2();
      init_Ticker();
      EventsTickerClass = class {
        constructor() {
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        /**
         * Initializes the event ticker.
         * @param events - The event system.
         */
        init(events) {
          this.removeTickerListener();
          this.events = events;
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        /** Whether to pause the update checks or not. */
        get pauseUpdate() {
          return this._pauseUpdate;
        }
        set pauseUpdate(paused) {
          this._pauseUpdate = paused;
        }
        /** Adds the ticker listener. */
        addTickerListener() {
          if (this._tickerAdded || !this.domElement) {
            return;
          }
          Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
          this._tickerAdded = true;
        }
        /** Removes the ticker listener. */
        removeTickerListener() {
          if (!this._tickerAdded) {
            return;
          }
          Ticker.system.remove(this._tickerUpdate, this);
          this._tickerAdded = false;
        }
        /** Sets flag to not fire extra events when the user has already moved there mouse */
        pointerMoved() {
          this._didMove = true;
        }
        /** Updates the state of interactive objects. */
        _update() {
          if (!this.domElement || this._pauseUpdate) {
            return;
          }
          if (this._didMove) {
            this._didMove = false;
            return;
          }
          const rootPointerEvent = this.events["_rootPointerEvent"];
          if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
            return;
          }
          globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY,
            pointerType: rootPointerEvent.pointerType,
            pointerId: rootPointerEvent.pointerId
          }) : new MouseEvent("mousemove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY
          }));
        }
        /**
         * Updates the state of interactive objects if at least {@link interactionFrequency}
         * milliseconds have passed since the last invocation.
         *
         * Invoked by a throttled ticker update from {@link Ticker.system}.
         * @param ticker - The throttled ticker.
         */
        _tickerUpdate(ticker) {
          this._deltaTime += ticker.deltaTime;
          if (this._deltaTime < this.interactionFrequency) {
            return;
          }
          this._deltaTime = 0;
          this._update();
        }
        /** Destroys the event ticker. */
        destroy() {
          this.removeTickerListener();
          this.events = null;
          this.domElement = null;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
      };
      EventsTicker = new EventsTickerClass();
    }
  });

  // node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
  var FederatedMouseEvent;
  var init_FederatedMouseEvent = __esm({
    "node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
      init_Point();
      init_FederatedEvent();
      FederatedMouseEvent = class extends FederatedEvent {
        constructor() {
          super(...arguments);
          this.client = new Point();
          this.movement = new Point();
          this.offset = new Point();
          this.global = new Point();
          this.screen = new Point();
        }
        /** @readonly */
        get clientX() {
          return this.client.x;
        }
        /** @readonly */
        get clientY() {
          return this.client.y;
        }
        /**
         * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
         * @readonly
         */
        get x() {
          return this.clientX;
        }
        /**
         * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
         * @readonly
         */
        get y() {
          return this.clientY;
        }
        /** @readonly */
        get movementX() {
          return this.movement.x;
        }
        /** @readonly */
        get movementY() {
          return this.movement.y;
        }
        /** @readonly */
        get offsetX() {
          return this.offset.x;
        }
        /** @readonly */
        get offsetY() {
          return this.offset.y;
        }
        /** @readonly */
        get globalX() {
          return this.global.x;
        }
        /** @readonly */
        get globalY() {
          return this.global.y;
        }
        /**
         * The pointer coordinates in the renderer's screen. Alias for `screen.x`.
         * @readonly
         */
        get screenX() {
          return this.screen.x;
        }
        /**
         * The pointer coordinates in the renderer's screen. Alias for `screen.y`.
         * @readonly
         */
        get screenY() {
          return this.screen.y;
        }
        /**
         * Converts global coordinates into container-local coordinates.
         *
         * This method transforms coordinates from world space to a container's local space,
         * useful for precise positioning and hit testing.
         * @param container - The Container to get local coordinates for
         * @param point - Optional Point object to store the result. If not provided, a new Point will be created
         * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used
         * @returns The local coordinates as a Point object
         * @example
         * ```ts
         * // Basic usage - get local coordinates relative to a container
         * sprite.on('pointermove', (event: FederatedMouseEvent) => {
         *     // Get position relative to the sprite
         *     const localPos = event.getLocalPosition(sprite);
         *     console.log('Local position:', localPos.x, localPos.y);
         * });
         * // Using custom global coordinates
         * const customGlobal = new Point(100, 100);
         * sprite.on('pointermove', (event: FederatedMouseEvent) => {
         *     // Transform custom coordinates
         *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);
         *     console.log('Custom local position:', localPos.x, localPos.y);
         * });
         * ```
         * @see {@link Container.worldTransform} For the transformation matrix
         * @see {@link Point} For the point class used to store coordinates
         */
        getLocalPosition(container, point, globalPos) {
          return container.worldTransform.applyInverse(globalPos || this.global, point);
        }
        /**
         * Whether the modifier key was pressed when this event natively occurred.
         * @param key - The modifier key.
         */
        getModifierState(key) {
          return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
        }
        /**
         * Not supported.
         * @param _typeArg
         * @param _canBubbleArg
         * @param _cancelableArg
         * @param _viewArg
         * @param _detailArg
         * @param _screenXArg
         * @param _screenYArg
         * @param _clientXArg
         * @param _clientYArg
         * @param _ctrlKeyArg
         * @param _altKeyArg
         * @param _shiftKeyArg
         * @param _metaKeyArg
         * @param _buttonArg
         * @param _relatedTargetArg
         * @deprecated since 7.0.0
         * @ignore
         */
        // eslint-disable-next-line max-params
        initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
          throw new Error("Method not implemented.");
        }
      };
    }
  });

  // node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
  var FederatedPointerEvent;
  var init_FederatedPointerEvent = __esm({
    "node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedPointerEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments);
          this.width = 0;
          this.height = 0;
          this.isPrimary = false;
        }
        /**
         * Only included for completeness for now
         * @ignore
         */
        getCoalescedEvents() {
          if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
            return [this];
          }
          return [];
        }
        /**
         * Only included for completeness for now
         * @ignore
         */
        getPredictedEvents() {
          throw new Error("getPredictedEvents is not supported!");
        }
      };
    }
  });

  // node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
  var FederatedWheelEvent;
  var init_FederatedWheelEvent = __esm({
    "node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedWheelEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments);
          this.DOM_DELTA_PIXEL = 0;
          this.DOM_DELTA_LINE = 1;
          this.DOM_DELTA_PAGE = 2;
        }
      };
      FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
      FederatedWheelEvent.DOM_DELTA_LINE = 1;
      FederatedWheelEvent.DOM_DELTA_PAGE = 2;
    }
  });

  // node_modules/pixi.js/lib/events/EventBoundary.mjs
  var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
  var init_EventBoundary = __esm({
    "node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
      init_eventemitter3();
      init_Point();
      init_warn();
      init_EventTicker();
      init_FederatedMouseEvent();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      PROPAGATION_LIMIT = 2048;
      tempHitLocation = new Point();
      tempLocalMapping = new Point();
      EventBoundary = class {
        /**
         * @param rootTarget - The holder of the event boundary.
         */
        constructor(rootTarget) {
          this.dispatch = new eventemitter3_default();
          this.moveOnAll = false;
          this.enableGlobalMoveEvents = true;
          this.mappingState = {
            trackingData: {}
          };
          this.eventPool = /* @__PURE__ */ new Map();
          this._allInteractiveElements = [];
          this._hitElements = [];
          this._isPointerMoveEvent = false;
          this.rootTarget = rootTarget;
          this.hitPruneFn = this.hitPruneFn.bind(this);
          this.hitTestFn = this.hitTestFn.bind(this);
          this.mapPointerDown = this.mapPointerDown.bind(this);
          this.mapPointerMove = this.mapPointerMove.bind(this);
          this.mapPointerOut = this.mapPointerOut.bind(this);
          this.mapPointerOver = this.mapPointerOver.bind(this);
          this.mapPointerUp = this.mapPointerUp.bind(this);
          this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
          this.mapWheel = this.mapWheel.bind(this);
          this.mappingTable = {};
          this.addEventMapping("pointerdown", this.mapPointerDown);
          this.addEventMapping("pointermove", this.mapPointerMove);
          this.addEventMapping("pointerout", this.mapPointerOut);
          this.addEventMapping("pointerleave", this.mapPointerOut);
          this.addEventMapping("pointerover", this.mapPointerOver);
          this.addEventMapping("pointerup", this.mapPointerUp);
          this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
          this.addEventMapping("wheel", this.mapWheel);
        }
        /**
         * Adds an event mapping for the event `type` handled by `fn`.
         *
         * Event mappings can be used to implement additional or custom events. They take an event
         * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
         * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
         *
         * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
         * instead.
         * @param type - The type of upstream event to map.
         * @param fn - The mapping method. The context of this function must be bound manually, if desired.
         */
        addEventMapping(type, fn) {
          if (!this.mappingTable[type]) {
            this.mappingTable[type] = [];
          }
          this.mappingTable[type].push({
            fn,
            priority: 0
          });
          this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
        }
        /**
         * Dispatches the given event
         * @param e - The event to dispatch.
         * @param type - The type of event to dispatch. Defaults to `e.type`.
         */
        dispatchEvent(e2, type) {
          e2.propagationStopped = false;
          e2.propagationImmediatelyStopped = false;
          this.propagate(e2, type);
          this.dispatch.emit(type || e2.type, e2);
        }
        /**
         * Maps the given upstream event through the event boundary and propagates it downstream.
         * @param e - The event to map.
         */
        mapEvent(e2) {
          if (!this.rootTarget) {
            return;
          }
          const mappers = this.mappingTable[e2.type];
          if (mappers) {
            for (let i3 = 0, j2 = mappers.length; i3 < j2; i3++) {
              mappers[i3].fn(e2);
            }
          } else {
            warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
          }
        }
        /**
         * Finds the Container that is the target of a event at the given coordinates.
         *
         * The passed (x,y) coordinates are in the world space above this event boundary.
         * @param x - The x coordinate of the event.
         * @param y - The y coordinate of the event.
         */
        hitTest(x2, y2) {
          EventsTicker.pauseUpdate = true;
          const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
          const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
          const invertedPath = this[fn](
            this.rootTarget,
            this.rootTarget.eventMode,
            tempHitLocation.set(x2, y2),
            this.hitTestFn,
            this.hitPruneFn
          );
          return invertedPath && invertedPath[0];
        }
        /**
         * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
         * target `e.target`.
         * @param e - The event to propagate.
         * @param type - The type of event to propagate. Defaults to `e.type`.
         */
        propagate(e2, type) {
          if (!e2.target) {
            return;
          }
          const composedPath = e2.composedPath();
          e2.eventPhase = e2.CAPTURING_PHASE;
          for (let i3 = 0, j2 = composedPath.length - 1; i3 < j2; i3++) {
            e2.currentTarget = composedPath[i3];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
          e2.eventPhase = e2.AT_TARGET;
          e2.currentTarget = e2.target;
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          for (let i3 = composedPath.length - 2; i3 >= 0; i3--) {
            e2.currentTarget = composedPath[i3];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
        }
        /**
         * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.
         *
         * This is used in the `globalpointermove` event.
         * @param e - The emitted event.
         * @param type - The listeners to notify.
         * @param targets - The targets to notify.
         */
        all(e2, type, targets = this._allInteractiveElements) {
          if (targets.length === 0)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          const events = Array.isArray(type) ? type : [type];
          for (let i3 = targets.length - 1; i3 >= 0; i3--) {
            events.forEach((event) => {
              e2.currentTarget = targets[i3];
              this.notifyTarget(e2, event);
            });
          }
        }
        /**
         * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
         * `target`. The last element in the path is `target`.
         * @param target - The target to find the propagation path to.
         */
        propagationPath(target) {
          const propagationPath = [target];
          for (let i3 = 0; i3 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i3++) {
            if (!target.parent) {
              throw new Error("Cannot find propagation path to disconnected target");
            }
            propagationPath.push(target.parent);
            target = target.parent;
          }
          propagationPath.reverse();
          return propagationPath;
        }
        hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
          let shouldReturn = false;
          if (this._interactivePrune(currentTarget))
            return null;
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            for (let i3 = children.length - 1; i3 >= 0; i3--) {
              const child = children[i3];
              const nestedHit = this.hitTestMoveRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                location,
                testFn,
                pruneFn,
                ignore || pruneFn(currentTarget, location)
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive) {
                  if (isInteractive)
                    this._allInteractiveElements.push(currentTarget);
                  nestedHit.push(currentTarget);
                }
                if (this._hitElements.length === 0)
                  this._hitElements = nestedHit;
                shouldReturn = true;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveTarget && isInteractiveTarget)
            this._allInteractiveElements.push(currentTarget);
          if (ignore || this._hitElements.length > 0)
            return null;
          if (shouldReturn)
            return this._hitElements;
          if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        /**
         * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
         * @param currentTarget - The Container that is to be hit tested.
         * @param eventMode - The event mode for the `currentTarget` or one of its parents.
         * @param location - The location that is being tested for overlap.
         * @param testFn - Callback that determines whether the target passes hit testing. This callback
         *  can assume that `pruneFn` failed to prune the container.
         * @param pruneFn - Callback that determiness whether the target and all of its children
         *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
         *  of the scene graph.
         * @returns An array holding the hit testing target and all its ancestors in order. The first element
         *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
         *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
         */
        hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
          if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
            return null;
          }
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            const relativeLocation = location;
            for (let i3 = children.length - 1; i3 >= 0; i3--) {
              const child = children[i3];
              const nestedHit = this.hitTestRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                relativeLocation,
                testFn,
                pruneFn
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive)
                  nestedHit.push(currentTarget);
                return nestedHit;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveMode && testFn(currentTarget, location)) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        _isInteractive(int) {
          return int === "static" || int === "dynamic";
        }
        _interactivePrune(container) {
          if (!container || !container.visible || !container.renderable || !container.measurable) {
            return true;
          }
          if (container.eventMode === "none") {
            return true;
          }
          if (container.eventMode === "passive" && !container.interactiveChildren) {
            return true;
          }
          return false;
        }
        /**
         * Checks whether the container or any of its children cannot pass the hit test at all.
         *
         * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
         * and {@link Container._maskEffect} for pruning.
         * @param container - The container to prune.
         * @param location - The location to test for overlap.
         */
        hitPruneFn(container, location) {
          if (container.hitArea) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
              return true;
            }
          }
          if (container.effects && container.effects.length) {
            for (let i3 = 0; i3 < container.effects.length; i3++) {
              const effect = container.effects[i3];
              if (effect.containsPoint) {
                const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
                if (!effectContainsPoint) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        /**
         * Checks whether the container passes hit testing for the given location.
         * @param container - The container to test.
         * @param location - The location to test for overlap.
         * @returns - Whether `container` passes hit testing for `location`.
         */
        hitTestFn(container, location) {
          if (container.hitArea) {
            return true;
          }
          if (container == null ? void 0 : container.containsPoint) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            return container.containsPoint(tempLocalMapping);
          }
          return false;
        }
        /**
         * Notify all the listeners to the event's `currentTarget`.
         *
         * If the `currentTarget` contains the property `on<type>`, then it is called here,
         * simulating the behavior from version 6.x and prior.
         * @param e - The event passed to the target.
         * @param type - The type of event to notify. Defaults to `e.type`.
         */
        notifyTarget(e2, type) {
          var _a2, _b;
          if (!e2.currentTarget.isInteractive()) {
            return;
          }
          type != null ? type : type = e2.type;
          const handlerKey = `on${type}`;
          (_b = (_a2 = e2.currentTarget)[handlerKey]) == null ? void 0 : _b.call(_a2, e2);
          const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
          this._notifyListeners(e2, key);
          if (e2.eventPhase === e2.AT_TARGET) {
            this._notifyListeners(e2, type);
          }
        }
        /**
         * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
         *
         * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
         * @param from - The upstream `pointerdown` event.
         */
        mapPointerDown(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const e2 = this.createPointerEvent(from);
          this.dispatchEvent(e2, "pointerdown");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchstart");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
          }
          const trackingData = this.trackingData(from.pointerId);
          trackingData.pressTargetsByButton[from.button] = e2.composedPath();
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
         *
         * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
         * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
         * @param from - The upstream `pointermove` event.
         */
        mapPointerMove(from) {
          var _a2, _b, _c;
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          this._isPointerMoveEvent = true;
          const e2 = this.createPointerEvent(from);
          this._isPointerMoveEvent = false;
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          const trackingData = this.trackingData(from.pointerId);
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          if (((_a2 = trackingData.overTargets) == null ? void 0 : _a2.length) > 0 && outTarget !== e2.target) {
            const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
            const outEvent = this.createPointerEvent(from, outType, outTarget);
            this.dispatchEvent(outEvent, "pointerout");
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            if (!e2.composedPath().includes(outTarget)) {
              const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;
              while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
                leaveEvent.currentTarget = leaveEvent.target;
                this.notifyTarget(leaveEvent);
                if (isMouse)
                  this.notifyTarget(leaveEvent, "mouseleave");
                leaveEvent.target = leaveEvent.target.parent;
              }
              this.freeEvent(leaveEvent);
            }
            this.freeEvent(outEvent);
          }
          if (outTarget !== e2.target) {
            const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
            const overEvent = this.clonePointerEvent(e2, overType);
            this.dispatchEvent(overEvent, "pointerover");
            if (isMouse)
              this.dispatchEvent(overEvent, "mouseover");
            let overTargetAncestor = outTarget == null ? void 0 : outTarget.parent;
            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
              if (overTargetAncestor === e2.target)
                break;
              overTargetAncestor = overTargetAncestor.parent;
            }
            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
            if (didPointerEnter) {
              const enterEvent = this.clonePointerEvent(e2, "pointerenter");
              enterEvent.eventPhase = enterEvent.AT_TARGET;
              while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
                enterEvent.currentTarget = enterEvent.target;
                this.notifyTarget(enterEvent);
                if (isMouse)
                  this.notifyTarget(enterEvent, "mouseenter");
                enterEvent.target = enterEvent.target.parent;
              }
              this.freeEvent(enterEvent);
            }
            this.freeEvent(overEvent);
          }
          const allMethods = [];
          const allowGlobalPointerEvents = (_b = this.enableGlobalMoveEvents) != null ? _b : true;
          this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
          allowGlobalPointerEvents && allMethods.push("globalpointermove");
          if (e2.pointerType === "touch") {
            this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
            allowGlobalPointerEvents && allMethods.push("globaltouchmove");
          }
          if (isMouse) {
            this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
            allowGlobalPointerEvents && allMethods.push("globalmousemove");
            this.cursor = (_c = e2.target) == null ? void 0 : _c.cursor;
          }
          if (allMethods.length > 0) {
            this.all(e2, allMethods);
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
         *
         * The tracking data for the specific pointer gets a new `overTarget`.
         * @param from - The upstream `pointerover` event.
         */
        mapPointerOver(from) {
          var _a2;
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          const e2 = this.createPointerEvent(from);
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          this.dispatchEvent(e2, "pointerover");
          if (isMouse)
            this.dispatchEvent(e2, "mouseover");
          if (e2.pointerType === "mouse")
            this.cursor = (_a2 = e2.target) == null ? void 0 : _a2.cursor;
          const enterEvent = this.clonePointerEvent(e2, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
            enterEvent.currentTarget = enterEvent.target;
            this.notifyTarget(enterEvent);
            if (isMouse)
              this.notifyTarget(enterEvent, "mouseenter");
            enterEvent.target = enterEvent.target.parent;
          }
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
          this.freeEvent(enterEvent);
        }
        /**
         * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
         *
         * The tracking data for the specific pointer is cleared of a `overTarget`.
         * @param from - The upstream `pointerout` event.
         */
        mapPointerOut(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          if (trackingData.overTargets) {
            const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
            const outTarget = this.findMountedTarget(trackingData.overTargets);
            const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
            this.dispatchEvent(outEvent);
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            trackingData.overTargets = null;
            this.freeEvent(outEvent);
            this.freeEvent(leaveEvent);
          }
          this.cursor = null;
        }
        /**
         * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
         * and `click`/`rightclick`/`pointertap` events, in that order.
         *
         * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
         * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
         * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
         * specific pointer types.
         * @param from - The upstream `pointerup` event.
         */
        mapPointerUp(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const now = performance.now();
          const e2 = this.createPointerEvent(from);
          this.dispatchEvent(e2, "pointerup");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchend");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
          }
          const trackingData = this.trackingData(from.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          let clickTarget = pressTarget;
          if (pressTarget && !e2.composedPath().includes(pressTarget)) {
            let currentTarget = pressTarget;
            while (currentTarget && !e2.composedPath().includes(currentTarget)) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                const isRightButton = e2.button === 2;
                this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
            clickTarget = currentTarget;
          }
          if (clickTarget) {
            const clickEvent = this.clonePointerEvent(e2, "click");
            clickEvent.target = clickTarget;
            clickEvent.path = null;
            if (!trackingData.clicksByButton[from.button]) {
              trackingData.clicksByButton[from.button] = {
                clickCount: 0,
                target: clickEvent.target,
                timeStamp: now
              };
            }
            const clickHistory = trackingData.clicksByButton[from.button];
            if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
              ++clickHistory.clickCount;
            } else {
              clickHistory.clickCount = 1;
            }
            clickHistory.target = clickEvent.target;
            clickHistory.timeStamp = now;
            clickEvent.detail = clickHistory.clickCount;
            if (clickEvent.pointerType === "mouse") {
              const isRightButton = clickEvent.button === 2;
              this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
            } else if (clickEvent.pointerType === "touch") {
              this.dispatchEvent(clickEvent, "tap");
            }
            this.dispatchEvent(clickEvent, "pointertap");
            this.freeEvent(clickEvent);
          }
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
         * `pointerdown` target to `rootTarget`.
         *
         * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
         * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
         *
         * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
         * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
         * @param from - The upstream `pointerupoutside` event.
         */
        mapPointerUpOutside(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          const e2 = this.createPointerEvent(from);
          if (pressTarget) {
            let currentTarget = pressTarget;
            while (currentTarget) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
          }
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `wheel` event to a downstream `wheel` event.
         * @param from - The upstream `wheel` event.
         */
        mapWheel(from) {
          if (!(from instanceof FederatedWheelEvent)) {
            warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return;
          }
          const wheelEvent = this.createWheelEvent(from);
          this.dispatchEvent(wheelEvent);
          this.freeEvent(wheelEvent);
        }
        /**
         * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
         *
         * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
         * or `pointerover` target was unmounted from the scene graph.
         * @param propagationPath - The propagation path was valid in the past.
         * @returns - The most specific event-target still mounted at the same location in the scene graph.
         */
        findMountedTarget(propagationPath) {
          if (!propagationPath) {
            return null;
          }
          let currentTarget = propagationPath[0];
          for (let i3 = 1; i3 < propagationPath.length; i3++) {
            if (propagationPath[i3].parent === currentTarget) {
              currentTarget = propagationPath[i3];
            } else {
              break;
            }
          }
          return currentTarget;
        }
        /**
         * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The `originalEvent` for the returned event.
         * @param [type=from.type] - The type of the returned event.
         * @param target - The target of the returned event.
         */
        createPointerEvent(from, type, target) {
          var _a2;
          const event = this.allocateEvent(FederatedPointerEvent);
          this.copyPointerData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from;
          event.target = (_a2 = target != null ? target : this.hitTest(event.global.x, event.global.y)) != null ? _a2 : this._hitElements[0];
          if (typeof type === "string") {
            event.type = type;
          }
          return event;
        }
        /**
         * Creates a wheel event whose `originalEvent` is `from`.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The upstream wheel event.
         */
        createWheelEvent(from) {
          const event = this.allocateEvent(FederatedWheelEvent);
          this.copyWheelData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from;
          event.target = this.hitTest(event.global.x, event.global.y);
          return event;
        }
        /**
         * Clones the event `from`, with an optional `type` override.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The event to clone.
         * @param [type=from.type] - The type of the returned event.
         */
        clonePointerEvent(from, type) {
          const event = this.allocateEvent(FederatedPointerEvent);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from.originalEvent;
          this.copyPointerData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.target = from.target;
          event.path = from.composedPath().slice();
          event.type = type != null ? type : event.type;
          return event;
        }
        /**
         * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.
         *
         * The following properties are copied:
         * + deltaMode
         * + deltaX
         * + deltaY
         * + deltaZ
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyWheelData(from, to) {
          to.deltaMode = from.deltaMode;
          to.deltaX = from.deltaX;
          to.deltaY = from.deltaY;
          to.deltaZ = from.deltaZ;
        }
        /**
         * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.
         *
         * The following properties are copied:
         * + pointerId
         * + width
         * + height
         * + isPrimary
         * + pointerType
         * + pressure
         * + tangentialPressure
         * + tiltX
         * + tiltY
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyPointerData(from, to) {
          if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
            return;
          to.pointerId = from.pointerId;
          to.width = from.width;
          to.height = from.height;
          to.isPrimary = from.isPrimary;
          to.pointerType = from.pointerType;
          to.pressure = from.pressure;
          to.tangentialPressure = from.tangentialPressure;
          to.tiltX = from.tiltX;
          to.tiltY = from.tiltY;
          to.twist = from.twist;
        }
        /**
         * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.
         *
         * The following properties are copied:
         * + altKey
         * + button
         * + buttons
         * + clientX
         * + clientY
         * + metaKey
         * + movementX
         * + movementY
         * + pageX
         * + pageY
         * + x
         * + y
         * + screen
         * + shiftKey
         * + global
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyMouseData(from, to) {
          if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
            return;
          to.altKey = from.altKey;
          to.button = from.button;
          to.buttons = from.buttons;
          to.client.copyFrom(from.client);
          to.ctrlKey = from.ctrlKey;
          to.metaKey = from.metaKey;
          to.movement.copyFrom(from.movement);
          to.screen.copyFrom(from.screen);
          to.shiftKey = from.shiftKey;
          to.global.copyFrom(from.global);
        }
        /**
         * Copies base {@link FederatedEvent} data from `from` into `to`.
         *
         * The following properties are copied:
         * + isTrusted
         * + srcElement
         * + timeStamp
         * + type
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyData(from, to) {
          to.isTrusted = from.isTrusted;
          to.srcElement = from.srcElement;
          to.timeStamp = performance.now();
          to.type = from.type;
          to.detail = from.detail;
          to.view = from.view;
          to.which = from.which;
          to.layer.copyFrom(from.layer);
          to.page.copyFrom(from.page);
        }
        /**
         * @param id - The pointer ID.
         * @returns The tracking data stored for the given pointer. If no data exists, a blank
         *  state will be created.
         */
        trackingData(id) {
          if (!this.mappingState.trackingData[id]) {
            this.mappingState.trackingData[id] = {
              pressTargetsByButton: {},
              clicksByButton: {},
              overTarget: null
            };
          }
          return this.mappingState.trackingData[id];
        }
        /**
         * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
         *
         * This allocation is constructor-agnostic, as long as it only takes one argument - this event
         * boundary.
         * @param constructor - The event's constructor.
         * @returns An event of the given type.
         */
        allocateEvent(constructor) {
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          const event = this.eventPool.get(constructor).pop() || new constructor(this);
          event.eventPhase = event.NONE;
          event.currentTarget = null;
          event.defaultPrevented = false;
          event.path = null;
          event.target = null;
          return event;
        }
        /**
         * Frees the event and puts it back into the event pool.
         *
         * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
         *
         * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
         * not be freed. This is because of the possibility that the same event is freed twice, which can cause
         * it to be allocated twice & result in overwriting.
         * @param event - The event to be freed.
         * @throws Error if the event is managed by another event boundary.
         */
        freeEvent(event) {
          if (event.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
          const constructor = event.constructor;
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          this.eventPool.get(constructor).push(event);
        }
        /**
         * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
         * is set on the event.
         * @param e - The event to call each listener with.
         * @param type - The event key.
         */
        _notifyListeners(e2, type) {
          const listeners = e2.currentTarget._events[type];
          if (!listeners)
            return;
          if ("fn" in listeners) {
            if (listeners.once)
              e2.currentTarget.removeListener(type, listeners.fn, void 0, true);
            listeners.fn.call(listeners.context, e2);
          } else {
            for (let i3 = 0, j2 = listeners.length; i3 < j2 && !e2.propagationImmediatelyStopped; i3++) {
              if (listeners[i3].once)
                e2.currentTarget.removeListener(type, listeners[i3].fn, void 0, true);
              listeners[i3].fn.call(listeners[i3].context, e2);
            }
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/events/EventSystem.mjs
  var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
  var init_EventSystem = __esm({
    "node_modules/pixi.js/lib/events/EventSystem.mjs"() {
      init_Extensions();
      init_EventBoundary();
      init_EventTicker();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      MOUSE_POINTER_ID = 1;
      TOUCH_TO_POINTER = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
      };
      _EventSystem = class _EventSystem2 {
        /**
         * @param {Renderer} renderer
         */
        constructor(renderer) {
          this.supportsTouchEvents = "ontouchstart" in globalThis;
          this.supportsPointerEvents = !!globalThis.PointerEvent;
          this.domElement = null;
          this.resolution = 1;
          this.renderer = renderer;
          this.rootBoundary = new EventBoundary(null);
          EventsTicker.init(this);
          this.autoPreventDefault = true;
          this._eventsAdded = false;
          this._rootPointerEvent = new FederatedPointerEvent(null);
          this._rootWheelEvent = new FederatedWheelEvent(null);
          this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
          };
          this.features = new Proxy(__spreadValues({}, _EventSystem2.defaultEventFeatures), {
            set: (target, key, value) => {
              if (key === "globalMove") {
                this.rootBoundary.enableGlobalMoveEvents = value;
              }
              target[key] = value;
              return true;
            }
          });
          this._onPointerDown = this._onPointerDown.bind(this);
          this._onPointerMove = this._onPointerMove.bind(this);
          this._onPointerUp = this._onPointerUp.bind(this);
          this._onPointerOverOut = this._onPointerOverOut.bind(this);
          this.onWheel = this.onWheel.bind(this);
        }
        /**
         * The default interaction mode for all display objects.
         * @see Container.eventMode
         * @type {EventMode}
         * @readonly
         * @since 7.2.0
         */
        static get defaultEventMode() {
          return this._defaultEventMode;
        }
        /**
         * Runner init called, view is available at this point.
         * @ignore
         */
        init(options) {
          var _a2, _b;
          const { canvas, resolution } = this.renderer;
          this.setTargetElement(canvas);
          this.resolution = resolution;
          _EventSystem2._defaultEventMode = (_a2 = options.eventMode) != null ? _a2 : "passive";
          Object.assign(this.features, (_b = options.eventFeatures) != null ? _b : {});
          this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
        }
        /**
         * Handle changing resolution.
         * @ignore
         */
        resolutionChange(resolution) {
          this.resolution = resolution;
        }
        /** Destroys all event listeners and detaches the renderer. */
        destroy() {
          EventsTicker.destroy();
          this.setTargetElement(null);
          this.renderer = null;
          this._currentCursor = null;
        }
        /**
         * Sets the current cursor mode, handling any callbacks or CSS style changes.
         * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.
         * @param mode - Cursor mode to set. Can be:
         * - A CSS cursor string (e.g., 'pointer', 'grab')
         * - A key from the cursorStyles dictionary
         * - null/undefined to reset to default
         * @example
         * ```ts
         * // Using predefined cursor styles
         * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor
         * app.renderer.events.setCursor('grab');       // Set grab cursor
         * app.renderer.events.setCursor(null);         // Reset to default
         *
         * // Using custom cursor styles
         * app.renderer.events.cursorStyles.custom = 'url("cursor.png"), auto';
         * app.renderer.events.setCursor('custom');     // Apply custom cursor
         *
         * // Using callback-based cursor
         * app.renderer.events.cursorStyles.dynamic = (mode) => {
         *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';
         * };
         * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback
         * ```
         * @remarks
         * - Has no effect on OffscreenCanvas except for callback-based cursors
         * - Caches current cursor to avoid unnecessary DOM updates
         * - Supports CSS cursor values, style objects, and callback functions
         * @see {@link EventSystem.cursorStyles} For defining custom cursor styles
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference
         */
        setCursor(mode) {
          mode || (mode = "default");
          let applyStyles = true;
          if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
            applyStyles = false;
          }
          if (this._currentCursor === mode) {
            return;
          }
          this._currentCursor = mode;
          const style = this.cursorStyles[mode];
          if (style) {
            switch (typeof style) {
              case "string":
                if (applyStyles) {
                  this.domElement.style.cursor = style;
                }
                break;
              case "function":
                style(mode);
                break;
              case "object":
                if (applyStyles) {
                  Object.assign(this.domElement.style, style);
                }
                break;
            }
          } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.domElement.style.cursor = mode;
          }
        }
        /**
         * The global pointer event instance containing the most recent pointer state.
         * This is useful for accessing pointer information without listening to events.
         * @example
         * ```ts
         * // Access current pointer position at any time
         * const eventSystem = app.renderer.events;
         * const pointer = eventSystem.pointer;
         *
         * // Get global coordinates
         * console.log('Position:', pointer.global.x, pointer.global.y);
         *
         * // Check button state
         * console.log('Buttons pressed:', pointer.buttons);
         *
         * // Get pointer type and pressure
         * console.log('Type:', pointer.pointerType);
         * console.log('Pressure:', pointer.pressure);
         * ```
         * @readonly
         * @since 7.2.0
         * @see {@link FederatedPointerEvent} For all available pointer properties
         */
        get pointer() {
          return this._rootPointerEvent;
        }
        /**
         * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerDown(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const events = this._normalizeToPointerData(nativeEvent);
          if (this.autoPreventDefault && events[0].isNormalized) {
            const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
              nativeEvent.preventDefault();
            }
          }
          for (let i3 = 0, j2 = events.length; i3 < j2; i3++) {
            const nativeEvent2 = events[i3];
            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
            this.rootBoundary.mapEvent(federatedEvent);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch events.
         */
        _onPointerMove(nativeEvent) {
          if (!this.features.move)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          EventsTicker.pointerMoved();
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i3 = 0, j2 = normalizedEvents.length; i3 < j2; i3++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerUp(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          let target = nativeEvent.target;
          if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
            target = nativeEvent.composedPath()[0];
          }
          const outside = target !== this.domElement ? "outside" : "";
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i3 = 0, j2 = normalizedEvents.length; i3 < j2; i3++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
            event.type += outside;
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerOverOut(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i3 = 0, j2 = normalizedEvents.length; i3 < j2; i3++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
         * @param nativeEvent - The native wheel event.
         */
        onWheel(nativeEvent) {
          if (!this.features.wheel)
            return;
          const wheelEvent = this.normalizeWheelEvent(nativeEvent);
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          this.rootBoundary.mapEvent(wheelEvent);
        }
        /**
         * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
         * This method manages the DOM event bindings for the event system, allowing you to
         * change or remove the target element that receives input events.
         * > [!IMPORTANT] This will default to the canvas element of the renderer, so you
         * > should not need to call this unless you are using a custom element.
         * @param element - The new DOM element to bind events to, or null to remove all event bindings
         * @example
         * ```ts
         * // Set a new canvas element as the target
         * const canvas = document.createElement('canvas');
         * app.renderer.events.setTargetElement(canvas);
         *
         * // Remove all event bindings
         * app.renderer.events.setTargetElement(null);
         *
         * // Switch to a different canvas
         * const newCanvas = document.querySelector('#game-canvas');
         * app.renderer.events.setTargetElement(newCanvas);
         * ```
         * @remarks
         * - Automatically removes event listeners from previous element
         * - Required for the event system to function
         * - Safe to call multiple times
         * @see {@link EventSystem#domElement} The current DOM element
         * @see {@link EventsTicker} For the ticker system that tracks pointer movement
         */
        setTargetElement(element) {
          this._removeEvents();
          this.domElement = element;
          EventsTicker.domElement = element;
          this._addEvents();
        }
        /** Register event listeners on {@link Renderer#domElement this.domElement}. */
        _addEvents() {
          if (this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker.addTickerListener();
          const style = this.domElement.style;
          if (style) {
            if (globalThis.navigator.msPointerEnabled) {
              style.msContentZooming = "none";
              style.msTouchAction = "none";
            } else if (this.supportsPointerEvents) {
              style.touchAction = "none";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
            this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.addEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
            this.domElement.addEventListener("mousedown", this._onPointerDown, true);
            this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.addEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.addEventListener("touchstart", this._onPointerDown, true);
              this.domElement.addEventListener("touchend", this._onPointerUp, true);
              this.domElement.addEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.addEventListener("wheel", this.onWheel, {
            passive: true,
            capture: true
          });
          this._eventsAdded = true;
        }
        /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
        _removeEvents() {
          if (!this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker.removeTickerListener();
          const style = this.domElement.style;
          if (style) {
            if (globalThis.navigator.msPointerEnabled) {
              style.msContentZooming = "";
              style.msTouchAction = "";
            } else if (this.supportsPointerEvents) {
              style.touchAction = "";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
            this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.removeEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
            this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
            this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.removeEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
              this.domElement.removeEventListener("touchend", this._onPointerUp, true);
              this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.removeEventListener("wheel", this.onWheel, true);
          this.domElement = null;
          this._eventsAdded = false;
        }
        /**
         * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.
         * This takes into account the current scale, position, and resolution of the DOM element.
         * @param point - The point to store the mapped coordinates in
         * @param x - The x coordinate in DOM/client space
         * @param y - The y coordinate in DOM/client space
         * @example
         * ```ts
         * // Map mouse coordinates to PixiJS space
         * const point = new Point();
         * app.renderer.events.mapPositionToPoint(
         *     point,
         *     event.clientX,
         *     event.clientY
         * );
         * console.log('Mapped position:', point.x, point.y);
         *
         * // Using with pointer events
         * sprite.on('pointermove', (event) => {
         *     // event.global already contains mapped coordinates
         *     console.log('Global:', event.global.x, event.global.y);
         *
         *     // Map to local coordinates
         *     const local = event.getLocalPosition(sprite);
         *     console.log('Local:', local.x, local.y);
         * });
         * ```
         * @remarks
         * - Accounts for element scaling and positioning
         * - Adjusts for device pixel ratio/resolution
         */
        mapPositionToPoint(point, x2, y2) {
          const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
          };
          const resolutionMultiplier = 1 / this.resolution;
          point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
          point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
        }
        /**
         * Ensures that the original event object contains all data that a regular pointer event would have
         * @param event - The original event data from a touch or mouse event
         * @returns An array containing a single normalized pointer event, in the case of a pointer
         *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
         */
        _normalizeToPointerData(event) {
          const normalizedEvents = [];
          if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (let i3 = 0, li = event.changedTouches.length; i3 < li; i3++) {
              const touch = event.changedTouches[i3];
              if (typeof touch.button === "undefined")
                touch.button = 0;
              if (typeof touch.buttons === "undefined")
                touch.buttons = 1;
              if (typeof touch.isPrimary === "undefined") {
                touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
              }
              if (typeof touch.width === "undefined")
                touch.width = touch.radiusX || 1;
              if (typeof touch.height === "undefined")
                touch.height = touch.radiusY || 1;
              if (typeof touch.tiltX === "undefined")
                touch.tiltX = 0;
              if (typeof touch.tiltY === "undefined")
                touch.tiltY = 0;
              if (typeof touch.pointerType === "undefined")
                touch.pointerType = "touch";
              if (typeof touch.pointerId === "undefined")
                touch.pointerId = touch.identifier || 0;
              if (typeof touch.pressure === "undefined")
                touch.pressure = touch.force || 0.5;
              if (typeof touch.twist === "undefined")
                touch.twist = 0;
              if (typeof touch.tangentialPressure === "undefined")
                touch.tangentialPressure = 0;
              if (typeof touch.layerX === "undefined")
                touch.layerX = touch.offsetX = touch.clientX;
              if (typeof touch.layerY === "undefined")
                touch.layerY = touch.offsetY = touch.clientY;
              touch.isNormalized = true;
              touch.type = event.type;
              normalizedEvents.push(touch);
            }
          } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
            const tempEvent = event;
            if (typeof tempEvent.isPrimary === "undefined")
              tempEvent.isPrimary = true;
            if (typeof tempEvent.width === "undefined")
              tempEvent.width = 1;
            if (typeof tempEvent.height === "undefined")
              tempEvent.height = 1;
            if (typeof tempEvent.tiltX === "undefined")
              tempEvent.tiltX = 0;
            if (typeof tempEvent.tiltY === "undefined")
              tempEvent.tiltY = 0;
            if (typeof tempEvent.pointerType === "undefined")
              tempEvent.pointerType = "mouse";
            if (typeof tempEvent.pointerId === "undefined")
              tempEvent.pointerId = MOUSE_POINTER_ID;
            if (typeof tempEvent.pressure === "undefined")
              tempEvent.pressure = 0.5;
            if (typeof tempEvent.twist === "undefined")
              tempEvent.twist = 0;
            if (typeof tempEvent.tangentialPressure === "undefined")
              tempEvent.tangentialPressure = 0;
            tempEvent.isNormalized = true;
            normalizedEvents.push(tempEvent);
          } else {
            normalizedEvents.push(event);
          }
          return normalizedEvents;
        }
        /**
         * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
         *
         * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
         * multiple native wheel events.
         * @param nativeEvent - The native wheel event that occurred on the canvas.
         * @returns A federated wheel event.
         */
        normalizeWheelEvent(nativeEvent) {
          const event = this._rootWheelEvent;
          this._transferMouseData(event, nativeEvent);
          event.deltaX = nativeEvent.deltaX;
          event.deltaY = nativeEvent.deltaY;
          event.deltaZ = nativeEvent.deltaZ;
          event.deltaMode = nativeEvent.deltaMode;
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.nativeEvent = nativeEvent;
          event.type = nativeEvent.type;
          return event;
        }
        /**
         * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
         * @param event
         * @param nativeEvent
         */
        _bootstrapEvent(event, nativeEvent) {
          event.originalEvent = null;
          event.nativeEvent = nativeEvent;
          event.pointerId = nativeEvent.pointerId;
          event.width = nativeEvent.width;
          event.height = nativeEvent.height;
          event.isPrimary = nativeEvent.isPrimary;
          event.pointerType = nativeEvent.pointerType;
          event.pressure = nativeEvent.pressure;
          event.tangentialPressure = nativeEvent.tangentialPressure;
          event.tiltX = nativeEvent.tiltX;
          event.tiltY = nativeEvent.tiltY;
          event.twist = nativeEvent.twist;
          this._transferMouseData(event, nativeEvent);
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.isTrusted = nativeEvent.isTrusted;
          if (event.type === "pointerleave") {
            event.type = "pointerout";
          }
          if (event.type.startsWith("mouse")) {
            event.type = event.type.replace("mouse", "pointer");
          }
          if (event.type.startsWith("touch")) {
            event.type = TOUCH_TO_POINTER[event.type] || event.type;
          }
          return event;
        }
        /**
         * Transfers base & mouse event data from the `nativeEvent` to the federated event.
         * @param event
         * @param nativeEvent
         */
        _transferMouseData(event, nativeEvent) {
          event.isTrusted = nativeEvent.isTrusted;
          event.srcElement = nativeEvent.srcElement;
          event.timeStamp = performance.now();
          event.type = nativeEvent.type;
          event.altKey = nativeEvent.altKey;
          event.button = nativeEvent.button;
          event.buttons = nativeEvent.buttons;
          event.client.x = nativeEvent.clientX;
          event.client.y = nativeEvent.clientY;
          event.ctrlKey = nativeEvent.ctrlKey;
          event.metaKey = nativeEvent.metaKey;
          event.movement.x = nativeEvent.movementX;
          event.movement.y = nativeEvent.movementY;
          event.page.x = nativeEvent.pageX;
          event.page.y = nativeEvent.pageY;
          event.relatedTarget = null;
          event.shiftKey = nativeEvent.shiftKey;
        }
      };
      _EventSystem.extension = {
        name: "events",
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.CanvasSystem,
          ExtensionType.WebGPUSystem
        ],
        priority: -1
      };
      _EventSystem.defaultEventFeatures = {
        /** Enables pointer events associated with pointer movement. */
        move: true,
        /** Enables global pointer move events. */
        globalMove: true,
        /** Enables pointer events associated with clicking. */
        click: true,
        /** Enables wheel events. */
        wheel: true
      };
      EventSystem = _EventSystem;
    }
  });

  // node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
  var FederatedContainer;
  var init_FederatedEventTarget = __esm({
    "node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
      init_EventSystem();
      init_FederatedEvent();
      FederatedContainer = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        get interactive() {
          return this.eventMode === "dynamic" || this.eventMode === "static";
        },
        set interactive(value) {
          this.eventMode = value ? "static" : "passive";
        },
        _internalEventMode: void 0,
        get eventMode() {
          var _a2;
          return (_a2 = this._internalEventMode) != null ? _a2 : EventSystem.defaultEventMode;
        },
        set eventMode(value) {
          this._internalEventMode = value;
        },
        isInteractive() {
          return this.eventMode === "static" || this.eventMode === "dynamic";
        },
        interactiveChildren: true,
        hitArea: null,
        addEventListener(type, listener, options) {
          const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
          const signal = typeof options === "object" ? options.signal : void 0;
          const once = typeof options === "object" ? options.once === true : false;
          const context4 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
          const emitter = this;
          if (signal) {
            signal.addEventListener("abort", () => {
              emitter.off(type, listenerFn, context4);
            });
          }
          if (once) {
            emitter.once(type, listenerFn, context4);
          } else {
            emitter.on(type, listenerFn, context4);
          }
        },
        removeEventListener(type, listener, options) {
          const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
          const context4 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          listener = typeof listener === "function" ? listener : listener.handleEvent;
          this.off(type, listener, context4);
        },
        dispatchEvent(e2) {
          if (!(e2 instanceof FederatedEvent)) {
            throw new Error("Container cannot propagate events outside of the Federated Events API");
          }
          e2.defaultPrevented = false;
          e2.path = null;
          e2.target = this;
          e2.manager.dispatchEvent(e2);
          return !e2.defaultPrevented;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/events/init.mjs
  var init_init3 = __esm({
    "node_modules/pixi.js/lib/events/init.mjs"() {
      init_Extensions();
      init_Container();
      init_EventSystem();
      init_FederatedEventTarget();
      extensions.add(EventSystem);
      extensions.mixin(Container, FederatedContainer);
    }
  });

  // node_modules/pixi.js/lib/dom/DOMPipe.mjs
  var DOMPipe;
  var init_DOMPipe = __esm({
    "node_modules/pixi.js/lib/dom/DOMPipe.mjs"() {
      init_Extensions();
      init_CanvasObserver();
      DOMPipe = class {
        /**
         * Constructor for the DOMPipe class.
         * @param renderer - The renderer instance that this DOMPipe will be associated with.
         */
        constructor(renderer) {
          this._attachedDomElements = [];
          this._renderer = renderer;
          this._renderer.runners.postrender.add(this);
          this._renderer.runners.init.add(this);
          this._domElement = document.createElement("div");
          this._domElement.style.position = "absolute";
          this._domElement.style.top = "0";
          this._domElement.style.left = "0";
          this._domElement.style.pointerEvents = "none";
          this._domElement.style.zIndex = "1000";
        }
        /** Initializes the DOMPipe, setting up the main DOM element and adding it to the document body. */
        init() {
          this._canvasObserver = new CanvasObserver({
            domElement: this._domElement,
            renderer: this._renderer
          });
        }
        /**
         * Adds a renderable DOM container to the list of attached elements.
         * @param domContainer - The DOM container to be added.
         * @param _instructionSet - The instruction set (unused).
         */
        addRenderable(domContainer, _instructionSet) {
          if (!this._attachedDomElements.includes(domContainer)) {
            this._attachedDomElements.push(domContainer);
          }
        }
        /**
         * Updates a renderable DOM container.
         * @param _domContainer - The DOM container to be updated (unused).
         */
        updateRenderable(_domContainer) {
        }
        /**
         * Validates a renderable DOM container.
         * @param _domContainer - The DOM container to be validated (unused).
         * @returns Always returns true as validation is not required.
         */
        validateRenderable(_domContainer) {
          return true;
        }
        /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */
        postrender() {
          const attachedDomElements = this._attachedDomElements;
          if (attachedDomElements.length === 0) {
            this._domElement.remove();
            return;
          }
          this._canvasObserver.ensureAttached();
          for (let i3 = 0; i3 < attachedDomElements.length; i3++) {
            const domContainer = attachedDomElements[i3];
            const element = domContainer.element;
            if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {
              element == null ? void 0 : element.remove();
              attachedDomElements.splice(i3, 1);
              i3--;
            } else {
              if (!this._domElement.contains(element)) {
                element.style.position = "absolute";
                element.style.pointerEvents = "auto";
                this._domElement.appendChild(element);
              }
              const wt = domContainer.worldTransform;
              const anchor = domContainer._anchor;
              const ax = domContainer.width * anchor.x;
              const ay = domContainer.height * anchor.y;
              element.style.transformOrigin = `${ax}px ${ay}px`;
              element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;
              element.style.opacity = domContainer.groupAlpha.toString();
            }
          }
        }
        /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */
        destroy() {
          var _a2;
          this._renderer.runners.postrender.remove(this);
          for (let i3 = 0; i3 < this._attachedDomElements.length; i3++) {
            const domContainer = this._attachedDomElements[i3];
            (_a2 = domContainer.element) == null ? void 0 : _a2.remove();
          }
          this._attachedDomElements.length = 0;
          this._domElement.remove();
          this._canvasObserver.destroy();
          this._renderer = null;
        }
      };
      DOMPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "dom"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/view/ViewContainer.mjs
  var ViewContainer;
  var init_ViewContainer = __esm({
    "node_modules/pixi.js/lib/scene/view/ViewContainer.mjs"() {
      init_Bounds();
      init_Container();
      ViewContainer = class extends Container {
        constructor(options) {
          var _a2;
          super(options);
          this.canBundle = true;
          this.allowChildren = false;
          this._roundPixels = 0;
          this._lastUsed = -1;
          this._gpuData = /* @__PURE__ */ Object.create(null);
          this.autoGarbageCollect = true;
          this._gcLastUsed = -1;
          this._bounds = new Bounds(0, 1, 0, 0);
          this._boundsDirty = true;
          this.autoGarbageCollect = (_a2 = options.autoGarbageCollect) != null ? _a2 : true;
        }
        /**
         * The local bounds of the view in its own coordinate space.
         * Bounds are automatically updated when the view's content changes.
         * @example
         * ```ts
         * // Get bounds dimensions
         * const bounds = view.bounds;
         * console.log(`Width: ${bounds.maxX - bounds.minX}`);
         * console.log(`Height: ${bounds.maxY - bounds.minY}`);
         * ```
         * @returns The rectangular bounds of the view
         * @see {@link Bounds} For bounds operations
         */
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          this.updateBounds();
          this._boundsDirty = false;
          return this._bounds;
        }
        /**
         * Whether or not to round the x/y position of the sprite.
         * @example
         * ```ts
         * // Enable pixel rounding for crisp rendering
         * view.roundPixels = true;
         * ```
         * @default false
         */
        get roundPixels() {
          return !!this._roundPixels;
        }
        set roundPixels(value) {
          this._roundPixels = value ? 1 : 0;
        }
        /**
         * Checks if the object contains the given point in local coordinates.
         * Uses the view's bounds for hit testing.
         * @example
         * ```ts
         * // Basic point check
         * const localPoint = { x: 50, y: 25 };
         * const contains = view.containsPoint(localPoint);
         * console.log('Point is inside:', contains);
         * ```
         * @param point - The point to check in local coordinates
         * @returns True if the point is within the view's bounds
         * @see {@link ViewContainer#bounds} For the bounds used in hit testing
         * @see {@link Container#toLocal} For converting global coordinates to local
         */
        containsPoint(point) {
          const bounds = this.bounds;
          const { x: x2, y: y2 } = point;
          return x2 >= bounds.minX && x2 <= bounds.maxX && y2 >= bounds.minY && y2 <= bounds.maxY;
        }
        /** @private */
        onViewUpdate() {
          this._didViewChangeTick++;
          this._boundsDirty = true;
          if (this.didViewUpdate)
            return;
          this.didViewUpdate = true;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.onChildViewUpdate(this);
          }
        }
        /** Unloads the GPU data from the view. */
        unload() {
          var _a2;
          this.emit("unload", this);
          for (const key in this._gpuData) {
            (_a2 = this._gpuData[key]) == null ? void 0 : _a2.destroy();
          }
          this._gpuData = /* @__PURE__ */ Object.create(null);
          this.onViewUpdate();
        }
        destroy(options) {
          this.unload();
          super.destroy(options);
          this._bounds = null;
        }
        /**
         * Collects renderables for the view container.
         * @param instructionSet - The instruction set to collect renderables for.
         * @param renderer - The renderer to collect renderables for.
         * @param currentLayer - The current render layer.
         * @internal
         */
        collectRenderablesSimple(instructionSet, renderer, currentLayer) {
          const { renderPipes: renderPipes3 } = renderer;
          renderPipes3.blendMode.pushBlendMode(this, this.groupBlendMode, instructionSet);
          const rp = renderPipes3;
          rp[this.renderPipeId].addRenderable(this, instructionSet);
          this.didViewUpdate = false;
          const children = this.children;
          const length = children.length;
          for (let i3 = 0; i3 < length; i3++) {
            children[i3].collectRenderables(instructionSet, renderer, currentLayer);
          }
          renderPipes3.blendMode.popBlendMode(instructionSet);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/dom/DOMContainer.mjs
  var DOMContainer;
  var init_DOMContainer = __esm({
    "node_modules/pixi.js/lib/dom/DOMContainer.mjs"() {
      init_Point();
      init_ViewContainer();
      DOMContainer = class extends ViewContainer {
        /**
         * @param options - The options for creating the DOM container.
         */
        constructor(options = {}) {
          const _a2 = options, { element, anchor } = _a2, rest = __objRest(_a2, ["element", "anchor"]);
          super(__spreadValues({
            label: "DOMContainer"
          }, rest));
          this.renderPipeId = "dom";
          this.batched = false;
          this._anchor = new Point(0, 0);
          if (anchor) {
            this.anchor = anchor;
          }
          this.element = options.element || document.createElement("div");
        }
        /**
         * The anchor sets the origin point of the container.
         * Controls the relative positioning of the DOM element.
         *
         * The default is `(0,0)`, this means the container's origin is the top left.
         * Setting the anchor to `(0.5,0.5)` means the container's origin is centered.
         * Setting the anchor to `(1,1)` would mean the container's origin point will be the bottom right corner.
         * @example
         * ```ts
         * const container = new DOMContainer();
         *
         * // Set anchor to center (shorthand)
         * container.anchor = 0.5;
         *
         * // Set anchor to bottom-right
         * container.anchor = { x: 1, y: 1 };
         *
         * // Set anchor to custom position
         * container.anchor = new Point(0.3, 0.7);
         * ```
         */
        get anchor() {
          return this._anchor;
        }
        /**
         * Sets the anchor point of the container.
         * @param value - New anchor value:
         * - number: Sets both x and y to same value
         * - PointData: Sets x and y separately
         */
        set anchor(value) {
          typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
        }
        /**
         * Sets the DOM element for this container.
         * This will replace the current element and update the view.
         * @param value - The new DOM element to use
         * @example
         * ```ts
         * const domContainer = new DOMContainer();
         * domContainer.element = document.createElement('input');
         * ```
         */
        set element(value) {
          if (this._element === value)
            return;
          this._element = value;
          this.onViewUpdate();
        }
        /**
         * The DOM element associated with this container.
         * @example
         * ```ts
         * const domContainer = new DOMContainer();
         * domContainer.element.innerHTML = 'Hello World!';
         * document.body.appendChild(domContainer.element);
         * ```
         */
        get element() {
          return this._element;
        }
        /** @private */
        updateBounds() {
          const bounds = this._bounds;
          const element = this._element;
          if (!element) {
            bounds.minX = 0;
            bounds.minY = 0;
            bounds.maxX = 0;
            bounds.maxY = 0;
            return;
          }
          const { offsetWidth, offsetHeight } = element;
          bounds.minX = 0;
          bounds.maxX = offsetWidth;
          bounds.minY = 0;
          bounds.maxY = offsetHeight;
        }
        /**
         * Destroys this DOM container.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that
         * @example
         * domContainer.destroy();
         * domContainer.destroy(true);
         */
        destroy(options = false) {
          var _a2, _b;
          super.destroy(options);
          (_b = (_a2 = this._element) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.removeChild(this._element);
          this._element = null;
          this._anchor = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/dom/init.mjs
  var init_init4 = __esm({
    "node_modules/pixi.js/lib/dom/init.mjs"() {
      init_Extensions();
      init_DOMPipe();
      extensions.add(DOMPipe);
    }
  });

  // node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
  var LoaderParserPriority;
  var init_LoaderParser = __esm({
    "node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
      "use strict";
      LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
        LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
        LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
        LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
        return LoaderParserPriority2;
      })(LoaderParserPriority || {});
    }
  });

  // node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs
  var BrowserAdapter;
  var init_BrowserAdapter = __esm({
    "node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs"() {
      "use strict";
      BrowserAdapter = {
        createCanvas: (width, height) => {
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          return canvas;
        },
        createImage: () => new Image(),
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => {
          var _a2;
          return (_a2 = document.baseURI) != null ? _a2 : window.location.href;
        },
        getFontFaceSet: () => document.fonts,
        fetch: (url, options) => fetch(url, options),
        parseXML: (xml) => {
          const parser = new DOMParser();
          return parser.parseFromString(xml, "text/xml");
        }
      };
    }
  });

  // node_modules/pixi.js/lib/environment/adapter.mjs
  var currentAdapter, DOMAdapter;
  var init_adapter = __esm({
    "node_modules/pixi.js/lib/environment/adapter.mjs"() {
      init_BrowserAdapter();
      currentAdapter = BrowserAdapter;
      DOMAdapter = {
        /**
         * Returns the current adapter.
         * @returns {environment.Adapter} The current adapter.
         */
        get() {
          return currentAdapter;
        },
        /**
         * Sets the current adapter.
         * @param adapter - The new adapter.
         */
        set(adapter) {
          currentAdapter = adapter;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/utils/path.mjs
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
  }
  function removeUrlParams(url) {
    const re = url.split("?")[0];
    return re.split("#")[0];
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\/* inject:js */");
  }
  function replaceAll(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for (let i3 = 0; i3 <= path2.length; ++i3) {
      if (i3 < path2.length) {
        code = path2.charCodeAt(i3);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i3 - 1 || dots === 1) {
        } else if (lastSlash !== i3 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i3;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i3;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `/${path2.slice(lastSlash + 1, i3)}`;
          } else {
            res = path2.slice(lastSlash + 1, i3);
          }
          lastSegmentLength = i3 - lastSlash - 1;
        }
        lastSlash = i3;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  var path;
  var init_path = __esm({
    "node_modules/pixi.js/lib/utils/path.mjs"() {
      init_adapter();
      path = {
        /**
         * Converts a path to posix format.
         * @param path - The path to convert to posix
         * @example
         * ```ts
         * // Convert a Windows path to POSIX format
         * path.toPosix('C:\\Users\\User\\Documents\\file.txt');
         * // -> 'C:/Users/User/Documents/file.txt'
         * ```
         */
        toPosix(path2) {
          return replaceAll(path2, "\\", "/");
        },
        /**
         * Checks if the path is a URL e.g. http://, https://
         * @param path - The path to check
         * @example
         * ```ts
         * // Check if a path is a URL
         * path.isUrl('http://www.example.com');
         * // -> true
         * path.isUrl('C:/Users/User/Documents/file.txt');
         * // -> false
         * ```
         */
        isUrl(path2) {
          return /^https?:/.test(this.toPosix(path2));
        },
        /**
         * Checks if the path is a data URL
         * @param path - The path to check
         * @example
         * ```ts
         * // Check if a path is a data URL
         * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');
         * // -> true
         * ```
         */
        isDataUrl(path2) {
          return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!/* inject:js */',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
        },
        /**
         * Checks if the path is a blob URL
         * @param path - The path to check
         * @example
         * ```ts
         * // Check if a path is a blob URL
         * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');
         * // -> true
         * ```
         */
        isBlobUrl(path2) {
          return path2.startsWith("blob:");
        },
        /**
         * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
         * This will return true for windows file paths
         * @param path - The path to check
         * @example
         * ```ts
         * // Check if a path has a protocol
         * path.hasProtocol('http://www.example.com');
         * // -> true
         * path.hasProtocol('C:/Users/User/Documents/file.txt');
         * // -> true
         * ```
         */
        hasProtocol(path2) {
          return /^[^/:]+:/.test(this.toPosix(path2));
        },
        /**
         * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
         * @param path - The path to get the protocol from
         * @example
         * ```ts
         * // Get the protocol from a URL
         * path.getProtocol('http://www.example.com/path/to/resource');
         * // -> 'http://'
         * // Get the protocol from a file path
         * path.getProtocol('C:/Users/User/Documents/file.txt');
         * // -> 'C:/'
         * ```
         */
        getProtocol(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          const matchFile = /^file:\/\/\//.exec(path2);
          if (matchFile) {
            return matchFile[0];
          }
          const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
          if (matchProtocol) {
            return matchProtocol[0];
          }
          return "";
        },
        /**
         * Converts URL to an absolute path.
         * When loading from a Web Worker, we must use absolute paths.
         * If the URL is already absolute we return it as is
         * If it's not, we convert it
         * @param url - The URL to test
         * @param customBaseUrl - The base URL to use
         * @param customRootUrl - The root URL to use
         * @example
         * ```ts
         * // Convert a relative URL to an absolute path
         * path.toAbsolute('images/texture.png', 'http://example.com/assets/');
         * // -> 'http://example.com/assets/images/texture.png'
         * ```
         */
        toAbsolute(url, customBaseUrl, customRootUrl) {
          assertPath(url);
          if (this.isDataUrl(url) || this.isBlobUrl(url))
            return url;
          const baseUrl = removeUrlParams(this.toPosix(customBaseUrl != null ? customBaseUrl : DOMAdapter.get().getBaseUrl()));
          const rootUrl = removeUrlParams(this.toPosix(customRootUrl != null ? customRootUrl : this.rootname(baseUrl)));
          url = this.toPosix(url);
          if (url.startsWith("/")) {
            return path.join(rootUrl, url.slice(1));
          }
          const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
          return absolutePath;
        },
        /**
         * Normalizes the given path, resolving '..' and '.' segments
         * @param path - The path to normalize
         * @example
         * ```ts
         * // Normalize a path with relative segments
         * path.normalize('http://www.example.com/foo/bar/../baz');
         * // -> 'http://www.example.com/foo/baz'
         * // Normalize a file path with relative segments
         * path.normalize('C:\\Users\\User\\Documents\\..\\file.txt');
         * // -> 'C:/Users/User/file.txt'
         * ```
         */
        normalize(path2) {
          assertPath(path2);
          if (path2.length === 0)
            return ".";
          if (this.isDataUrl(path2) || this.isBlobUrl(path2))
            return path2;
          path2 = this.toPosix(path2);
          let protocol = "";
          const isAbsolute = path2.startsWith("/");
          if (this.hasProtocol(path2)) {
            protocol = this.rootname(path2);
            path2 = path2.slice(protocol.length);
          }
          const trailingSeparator = path2.endsWith("/");
          path2 = normalizeStringPosix(path2, false);
          if (path2.length > 0 && trailingSeparator)
            path2 += "/";
          if (isAbsolute)
            return `/${path2}`;
          return protocol + path2;
        },
        /**
         * Determines if path is an absolute path.
         * Absolute paths can be urls, data urls, or paths on disk
         * @param path - The path to test
         * @example
         * ```ts
         * // Check if a path is absolute
         * path.isAbsolute('http://www.example.com/foo/bar');
         * // -> true
         * path.isAbsolute('C:/Users/User/Documents/file.txt');
         * // -> true
         * ```
         */
        isAbsolute(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          if (this.hasProtocol(path2))
            return true;
          return path2.startsWith("/");
        },
        /**
         * Joins all given path segments together using the platform-specific separator as a delimiter,
         * then normalizes the resulting path
         * @param segments - The segments of the path to join
         * @example
         * ```ts
         * // Join multiple path segments
         * path.join('assets', 'images', 'sprite.png');
         * // -> 'assets/images/sprite.png'
         * // Join with relative segments
         * path.join('assets', 'images', '../textures', 'sprite.png');
         * // -> 'assets/textures/sprite.png'
         * ```
         */
        join(...segments) {
          var _a2;
          if (segments.length === 0) {
            return ".";
          }
          let joined;
          for (let i3 = 0; i3 < segments.length; ++i3) {
            const arg = segments[i3];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else {
                const prevArg = (_a2 = segments[i3 - 1]) != null ? _a2 : "";
                if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
                  joined += `/../${arg}`;
                } else {
                  joined += `/${arg}`;
                }
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          return this.normalize(joined);
        },
        /**
         * Returns the directory name of a path
         * @param path - The path to parse
         * @example
         * ```ts
         * // Get the directory name of a path
         * path.dirname('http://www.example.com/foo/bar/baz.png');
         * // -> 'http://www.example.com/foo/bar'
         * // Get the directory name of a file path
         * path.dirname('C:/Users/User/Documents/file.txt');
         * // -> 'C:/Users/User/Documents'
         * ```
         */
        dirname(path2) {
          assertPath(path2);
          if (path2.length === 0)
            return ".";
          path2 = this.toPosix(path2);
          let code = path2.charCodeAt(0);
          const hasRoot = code === 47;
          let end = -1;
          let matchedSlash = true;
          const proto = this.getProtocol(path2);
          const origpath = path2;
          path2 = path2.slice(proto.length);
          for (let i3 = path2.length - 1; i3 >= 1; --i3) {
            code = path2.charCodeAt(i3);
            if (code === 47) {
              if (!matchedSlash) {
                end = i3;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
          if (hasRoot && end === 1)
            return "//";
          return proto + path2.slice(0, end);
        },
        /**
         * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
         * @param path - The path to parse
         * @example
         * ```ts
         * // Get the root of a URL
         * path.rootname('http://www.example.com/foo/bar/baz.png');
         * // -> 'http://www.example.com/'
         * // Get the root of a file path
         * path.rootname('C:/Users/User/Documents/file.txt');
         * // -> 'C:/'
         * ```
         */
        rootname(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          let root = "";
          if (path2.startsWith("/"))
            root = "/";
          else {
            root = this.getProtocol(path2);
          }
          if (this.isUrl(path2)) {
            const index = path2.indexOf("/", root.length);
            if (index !== -1) {
              root = path2.slice(0, index);
            } else
              root = path2;
            if (!root.endsWith("/"))
              root += "/";
          }
          return root;
        },
        /**
         * Returns the last portion of a path
         * @param path - The path to test
         * @param ext - Optional extension to remove
         * @example
         * ```ts
         * // Get the basename of a URL
         * path.basename('http://www.example.com/foo/bar/baz.png');
         * // -> 'baz.png'
         * // Get the basename of a file path
         * path.basename('C:/Users/User/Documents/file.txt');
         * // -> 'file.txt'
         * ```
         */
        basename(path2, ext) {
          assertPath(path2);
          if (ext)
            assertPath(ext);
          path2 = removeUrlParams(this.toPosix(path2));
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i3;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
            if (ext.length === path2.length && ext === path2)
              return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i3 = path2.length - 1; i3 >= 0; --i3) {
              const code = path2.charCodeAt(i3);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i3 + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i3 + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i3;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path2.length;
            return path2.slice(start, end);
          }
          for (i3 = path2.length - 1; i3 >= 0; --i3) {
            if (path2.charCodeAt(i3) === 47) {
              if (!matchedSlash) {
                start = i3 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i3 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        },
        /**
         * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
         * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
         * the first character of the basename of path, an empty string is returned.
         * @param path - The path to parse
         * @example
         * ```ts
         * // Get the extension of a URL
         * path.extname('http://www.example.com/foo/bar/baz.png');
         * // -> '.png'
         * // Get the extension of a file path
         * path.extname('C:/Users/User/Documents/file.txt');
         * // -> '.txt'
         * ```
         */
        extname(path2) {
          assertPath(path2);
          path2 = removeUrlParams(this.toPosix(path2));
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          for (let i3 = path2.length - 1; i3 >= 0; --i3) {
            const code = path2.charCodeAt(i3);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i3 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i3 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i3;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path2.slice(startDot, end);
        },
        /**
         * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
         * @param path - The path to parse
         * @example
         * ```ts
         * // Parse a URL
         * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');
         * // -> {
         * //   root: 'http://www.example.com/',
         * //   dir: 'http://www.example.com/foo/bar',
         * //   base: 'baz.png',
         * //   ext: '.png',
         * //   name: 'baz'
         * // }
         * // Parse a file path
         * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');
         * // -> {
         * //   root: 'C:/',
         * //   dir: 'C:/Users/User/Documents',
         * //   base: 'file.txt',
         * //   ext: '.txt',
         * //   name: 'file'
         * // }
         * ```
         */
        parse(path2) {
          assertPath(path2);
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path2.length === 0)
            return ret;
          path2 = removeUrlParams(this.toPosix(path2));
          let code = path2.charCodeAt(0);
          const isAbsolute = this.isAbsolute(path2);
          let start;
          const protocol = "";
          ret.root = this.rootname(path2);
          if (isAbsolute || this.hasProtocol(path2)) {
            start = 1;
          } else {
            start = 0;
          }
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let i3 = path2.length - 1;
          let preDotState = 0;
          for (; i3 >= start; --i3) {
            code = path2.charCodeAt(i3);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i3 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i3 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i3;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path2.slice(1, end);
              else
                ret.base = ret.name = path2.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path2.slice(1, startDot);
              ret.base = path2.slice(1, end);
            } else {
              ret.name = path2.slice(startPart, startDot);
              ret.base = path2.slice(startPart, end);
            }
            ret.ext = path2.slice(startDot, end);
          }
          ret.dir = this.dirname(path2);
          if (protocol)
            ret.dir = protocol + ret.dir;
          return ret;
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [".html"]
      };
    }
  });

  // node_modules/pixi.js/lib/assets/utils/convertToList.mjs
  var convertToList;
  var init_convertToList = __esm({
    "node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
      "use strict";
      convertToList = (input, transform2, forceTransform = false) => {
        if (!Array.isArray(input)) {
          input = [input];
        }
        if (!transform2) {
          return input;
        }
        return input.map((item) => {
          if (typeof item === "string" || forceTransform) {
            return transform2(item);
          }
          return item;
        });
      };
    }
  });

  // node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
  function processX(base, ids, depth, result, tags) {
    const id = ids[depth];
    for (let i3 = 0; i3 < id.length; i3++) {
      const value = id[i3];
      if (depth < ids.length - 1) {
        processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
      } else {
        tags.push(base.replace(result[depth], value));
      }
    }
  }
  function createStringVariations(string) {
    const regex = /\{(.*?)\}/g;
    const result = string.match(regex);
    const tags = [];
    if (result) {
      const ids = [];
      result.forEach((vars) => {
        const split = vars.substring(1, vars.length - 1).split(",");
        ids.push(split);
      });
      processX(string, ids, 0, result, tags);
    } else {
      tags.push(string);
    }
    return tags;
  }
  var init_createStringVariations = __esm({
    "node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
  var isSingleItem;
  var init_isSingleItem = __esm({
    "node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs"() {
      "use strict";
      isSingleItem = (item) => !Array.isArray(item);
    }
  });

  // node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
  function getUrlExtension(url) {
    return url.split(".").pop().split("?").shift().split("#").shift();
  }
  var Resolver;
  var init_Resolver = __esm({
    "node_modules/pixi.js/lib/assets/resolver/Resolver.mjs"() {
      init_warn();
      init_path();
      init_convertToList();
      init_createStringVariations();
      init_isSingleItem();
      Resolver = class {
        constructor() {
          this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
            extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
          };
          this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
          this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
          this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
          this._assetMap = {};
          this._preferredOrder = [];
          this._parsers = [];
          this._resolverHash = {};
          this._bundles = {};
        }
        /**
         * Override how the resolver deals with generating bundle ids.
         * must be called before any bundles are added
         * @param bundleIdentifier - the bundle identifier options
         */
        setBundleIdentifier(bundleIdentifier) {
          var _a2, _b, _c;
          this._bundleIdConnector = (_a2 = bundleIdentifier.connector) != null ? _a2 : this._bundleIdConnector;
          this._createBundleAssetId = (_b = bundleIdentifier.createBundleAssetId) != null ? _b : this._createBundleAssetId;
          this._extractAssetIdFromBundle = (_c = bundleIdentifier.extractAssetIdFromBundle) != null ? _c : this._extractAssetIdFromBundle;
          if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
          }
        }
        /**
         * Let the resolver know which assets you prefer to use when resolving assets.
         * Multiple prefer user defined rules can be added.
         * @example
         * resolver.prefer({
         *     // first look for something with the correct format, and then then correct resolution
         *     priority: ['format', 'resolution'],
         *     params:{
         *         format:'webp', // prefer webp images
         *         resolution: 2, // prefer a resolution of 2
         *     }
         * })
         * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
         * resolver.resolveUrl('foo') // => 'bar@2x.webp'
         * @param preferOrders - the prefer options
         */
        prefer(...preferOrders) {
          preferOrders.forEach((prefer) => {
            this._preferredOrder.push(prefer);
            if (!prefer.priority) {
              prefer.priority = Object.keys(prefer.params);
            }
          });
          this._resolverHash = {};
        }
        /**
         * Set the base path to prepend to all urls when resolving
         * @example
         * resolver.basePath = 'https://home.com/';
         * resolver.add('foo', 'bar.ong');
         * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
         * @param basePath - the base path to use
         */
        set basePath(basePath) {
          this._basePath = basePath;
        }
        get basePath() {
          return this._basePath;
        }
        /**
         * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
         * default value for browsers is `window.location.origin`
         * @example
         * // Application hosted on https://home.com/some-path/index.html
         * resolver.basePath = 'https://home.com/some-path/';
         * resolver.rootPath = 'https://home.com/';
         * resolver.add('foo', '/bar.png');
         * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
         * @param rootPath - the root path to use
         */
        set rootPath(rootPath) {
          this._rootPath = rootPath;
        }
        get rootPath() {
          return this._rootPath;
        }
        /**
         * All the active URL parsers that help the parser to extract information and create
         * an asset object-based on parsing the URL itself.
         *
         * Can be added using the extensions API
         * @example
         * resolver.add('foo', [
         *     {
         *         resolution: 2,
         *         format: 'png',
         *         src: 'image@2x.png',
         *     },
         *     {
         *         resolution:1,
         *         format:'png',
         *         src: 'image.png',
         *     },
         * ]);
         *
         * // With a url parser the information such as resolution and file format could extracted from the url itself:
         * extensions.add({
         *     extension: ExtensionType.ResolveParser,
         *     test: loadTextures.test, // test if url ends in an image
         *     parse: (value: string) =>
         *     ({
         *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
         *         format: value.split('.').pop(),
         *         src: value,
         *     }),
         * });
         *
         * // Now resolution and format can be extracted from the url
         * resolver.add('foo', [
         *     'image@2x.png',
         *     'image.png',
         * ]);
         */
        get parsers() {
          return this._parsers;
        }
        /** Used for testing, this resets the resolver to its initial state */
        reset() {
          this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
          this._assetMap = {};
          this._preferredOrder = [];
          this._resolverHash = {};
          this._rootPath = null;
          this._basePath = null;
          this._manifest = null;
          this._bundles = {};
          this._defaultSearchParams = null;
        }
        /**
         * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
         * @param searchParams - the default url parameters to append when resolving urls
         */
        setDefaultSearchParams(searchParams) {
          if (typeof searchParams === "string") {
            this._defaultSearchParams = searchParams;
          } else {
            const queryValues = searchParams;
            this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
          }
        }
        /**
         * Returns the aliases for a given asset
         * @param asset - the asset to get the aliases for
         */
        getAlias(asset) {
          const { alias, src } = asset;
          const aliasesToUse = convertToList(
            alias || src,
            (value) => {
              if (typeof value === "string")
                return value;
              if (Array.isArray(value))
                return value.map((v2) => {
                  var _a2;
                  return (_a2 = v2 == null ? void 0 : v2.src) != null ? _a2 : v2;
                });
              if (value == null ? void 0 : value.src)
                return value.src;
              return value;
            },
            true
          );
          return aliasesToUse;
        }
        /**
         * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
         * generally a manifest would be built using a tool.
         * @param manifest - the manifest to add to the resolver
         */
        addManifest(manifest) {
          if (this._manifest) {
            warn("[Resolver] Manifest already exists, this will be overwritten");
          }
          this._manifest = manifest;
          manifest.bundles.forEach((bundle) => {
            this.addBundle(bundle.name, bundle.assets);
          });
        }
        /**
         * This adds a bundle of assets in one go so that you can resolve them as a group.
         * For example you could add a bundle for each screen in you pixi app
         * @example
         * resolver.addBundle('animals', [
         *  { alias: 'bunny', src: 'bunny.png' },
         *  { alias: 'chicken', src: 'chicken.png' },
         *  { alias: 'thumper', src: 'thumper.png' },
         * ]);
         * // or
         * resolver.addBundle('animals', {
         *     bunny: 'bunny.png',
         *     chicken: 'chicken.png',
         *     thumper: 'thumper.png',
         * });
         *
         * const resolvedAssets = await resolver.resolveBundle('animals');
         * @param bundleId - The id of the bundle to add
         * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
         */
        addBundle(bundleId, assets) {
          const assetNames = [];
          let convertedAssets = assets;
          if (!Array.isArray(assets)) {
            convertedAssets = Object.entries(assets).map(([alias, src]) => {
              if (typeof src === "string" || Array.isArray(src)) {
                return { alias, src };
              }
              return __spreadValues({ alias }, src);
            });
          }
          convertedAssets.forEach((asset) => {
            const srcs = asset.src;
            const aliases = asset.alias;
            let ids;
            if (typeof aliases === "string") {
              const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
              assetNames.push(bundleAssetId);
              ids = [aliases, bundleAssetId];
            } else {
              const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
              assetNames.push(...bundleIds);
              ids = [...aliases, ...bundleIds];
            }
            this.add(__spreadValues(__spreadValues({}, asset), {
              alias: ids,
              src: srcs
            }));
          });
          this._bundles[bundleId] = assetNames;
        }
        /**
         * Tells the resolver what keys are associated with witch asset.
         * The most important thing the resolver does
         * @example
         * // Single key, single asset:
         * resolver.add({alias: 'foo', src: 'bar.png');
         * resolver.resolveUrl('foo') // => 'bar.png'
         *
         * // Multiple keys, single asset:
         * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
         * resolver.resolveUrl('foo') // => 'bar.png'
         * resolver.resolveUrl('boo') // => 'bar.png'
         *
         * // Multiple keys, multiple assets:
         * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
         * resolver.resolveUrl('foo') // => 'bar.png'
         *
         * // Add custom data attached to the resolver
         * Resolver.add({
         *     alias: 'bunnyBooBooSmooth',
         *     src: 'bunny{png,webp}',
         *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
         * });
         *
         * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
         * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
         */
        add(aliases) {
          const assets = [];
          if (Array.isArray(aliases)) {
            assets.push(...aliases);
          } else {
            assets.push(aliases);
          }
          let keyCheck;
          keyCheck = (key) => {
            if (this.hasKey(key)) {
              warn(`[Resolver] already has key: ${key} overwriting`);
            }
          };
          const assetArray = convertToList(assets);
          assetArray.forEach((asset) => {
            const { src } = asset;
            let {
              data,
              format,
              loadParser: userDefinedLoadParser,
              parser: userDefinedParser
            } = asset;
            const srcsToUse = convertToList(src).map((src2) => {
              if (typeof src2 === "string") {
                return createStringVariations(src2);
              }
              return Array.isArray(src2) ? src2 : [src2];
            });
            const aliasesToUse = this.getAlias(asset);
            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
            const resolvedAssets = [];
            const parseUrl = (url) => {
              const parser = this._parsers.find((p3) => p3.test(url));
              return __spreadProps(__spreadValues({}, parser == null ? void 0 : parser.parse(url)), {
                src: url
              });
            };
            srcsToUse.forEach((srcs) => {
              srcs.forEach((src2) => {
                var _a2, _b, _c, _d;
                let formattedAsset = {};
                if (typeof src2 !== "object") {
                  formattedAsset = parseUrl(src2);
                } else {
                  data = (_a2 = src2.data) != null ? _a2 : data;
                  format = (_b = src2.format) != null ? _b : format;
                  if (src2.loadParser || src2.parser) {
                    userDefinedLoadParser = (_c = src2.loadParser) != null ? _c : userDefinedLoadParser;
                    userDefinedParser = (_d = src2.parser) != null ? _d : userDefinedParser;
                  }
                  formattedAsset = __spreadValues(__spreadValues({}, parseUrl(src2.src)), src2);
                }
                if (!aliasesToUse) {
                  throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
                }
                formattedAsset = this._buildResolvedAsset(formattedAsset, {
                  aliases: aliasesToUse,
                  data,
                  format,
                  loadParser: userDefinedLoadParser,
                  parser: userDefinedParser,
                  progressSize: asset.progressSize
                });
                resolvedAssets.push(formattedAsset);
              });
            });
            aliasesToUse.forEach((alias) => {
              this._assetMap[alias] = resolvedAssets;
            });
          });
        }
        // TODO: this needs an overload like load did in Assets
        /**
         * If the resolver has had a manifest set via setManifest, this will return the assets urls for
         * a given bundleId or bundleIds.
         * @example
         * // Manifest Example
         * const manifest = {
         *     bundles: [
         *         {
         *             name: 'load-screen',
         *             assets: [
         *                 {
         *                     alias: 'background',
         *                     src: 'sunset.png',
         *                 },
         *                 {
         *                     alias: 'bar',
         *                     src: 'load-bar.{png,webp}',
         *                 },
         *             ],
         *         },
         *         {
         *             name: 'game-screen',
         *             assets: [
         *                 {
         *                     alias: 'character',
         *                     src: 'robot.png',
         *                 },
         *                 {
         *                     alias: 'enemy',
         *                     src: 'bad-guy.png',
         *                 },
         *             ],
         *         },
         *     ]
         * };
         *
         * resolver.setManifest(manifest);
         * const resolved = resolver.resolveBundle('load-screen');
         * @param bundleIds - The bundle ids to resolve
         * @returns All the bundles assets or a hash of assets for each bundle specified
         */
        resolveBundle(bundleIds) {
          const singleAsset = isSingleItem(bundleIds);
          bundleIds = convertToList(bundleIds);
          const out2 = {};
          bundleIds.forEach((bundleId) => {
            const assetNames = this._bundles[bundleId];
            if (assetNames) {
              const results = this.resolve(assetNames);
              const assets = {};
              for (const key in results) {
                const asset = results[key];
                assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
              }
              out2[bundleId] = assets;
            }
          });
          return singleAsset ? out2[bundleIds[0]] : out2;
        }
        /**
         * Does exactly what resolve does, but returns just the URL rather than the whole asset object
         * @param key - The key or keys to resolve
         * @returns - The URLs associated with the key(s)
         */
        resolveUrl(key) {
          const result = this.resolve(key);
          if (typeof key !== "string") {
            const out2 = {};
            for (const i3 in result) {
              out2[i3] = result[i3].src;
            }
            return out2;
          }
          return result.src;
        }
        resolve(keys) {
          const singleAsset = isSingleItem(keys);
          keys = convertToList(keys);
          const result = {};
          keys.forEach((key) => {
            if (!this._resolverHash[key]) {
              if (this._assetMap[key]) {
                let assets = this._assetMap[key];
                const preferredOrder = this._getPreferredOrder(assets);
                preferredOrder == null ? void 0 : preferredOrder.priority.forEach((priorityKey) => {
                  preferredOrder.params[priorityKey].forEach((value) => {
                    const filteredAssets = assets.filter((asset) => {
                      if (asset[priorityKey]) {
                        return asset[priorityKey] === value;
                      }
                      return false;
                    });
                    if (filteredAssets.length) {
                      assets = filteredAssets;
                    }
                  });
                });
                this._resolverHash[key] = assets[0];
              } else {
                this._resolverHash[key] = this._buildResolvedAsset({
                  alias: [key],
                  src: key
                }, {});
              }
            }
            result[key] = this._resolverHash[key];
          });
          return singleAsset ? result[keys[0]] : result;
        }
        /**
         * Checks if an asset with a given key exists in the resolver
         * @param key - The key of the asset
         */
        hasKey(key) {
          return !!this._assetMap[key];
        }
        /**
         * Checks if a bundle with the given key exists in the resolver
         * @param key - The key of the bundle
         */
        hasBundle(key) {
          return !!this._bundles[key];
        }
        /**
         * Internal function for figuring out what prefer criteria an asset should use.
         * @param assets
         */
        _getPreferredOrder(assets) {
          for (let i3 = 0; i3 < assets.length; i3++) {
            const asset = assets[i3];
            const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
            if (preferred) {
              return preferred;
            }
          }
          return this._preferredOrder[0];
        }
        /**
         * Appends the default url parameters to the url
         * @param url - The url to append the default parameters to
         * @returns - The url with the default parameters appended
         */
        _appendDefaultSearchParams(url) {
          if (!this._defaultSearchParams)
            return url;
          const paramConnector = /\?/.test(url) ? "&" : "?";
          return `${url}${paramConnector}${this._defaultSearchParams}`;
        }
        _buildResolvedAsset(formattedAsset, data) {
          var _a2, _b;
          const { aliases, data: assetData, loadParser, parser, format, progressSize } = data;
          if (this._basePath || this._rootPath) {
            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
          }
          formattedAsset.alias = (_a2 = aliases != null ? aliases : formattedAsset.alias) != null ? _a2 : [formattedAsset.src];
          formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
          formattedAsset.data = __spreadValues(__spreadValues({}, assetData || {}), formattedAsset.data);
          formattedAsset.loadParser = loadParser != null ? loadParser : formattedAsset.loadParser;
          formattedAsset.parser = parser != null ? parser : formattedAsset.parser;
          formattedAsset.format = (_b = format != null ? format : formattedAsset.format) != null ? _b : getUrlExtension(formattedAsset.src);
          if (progressSize !== void 0) {
            formattedAsset.progressSize = progressSize;
          }
          return formattedAsset;
        }
      };
      Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
    }
  });

  // node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
  var copySearchParams;
  var init_copySearchParams = __esm({
    "node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
      "use strict";
      copySearchParams = (targetUrl, sourceUrl) => {
        const searchParams = sourceUrl.split("?")[1];
        if (searchParams) {
          targetUrl += `?${searchParams}`;
        }
        return targetUrl;
      };
    }
  });

  // node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
  var _Spritesheet, Spritesheet;
  var init_Spritesheet = __esm({
    "node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
      init_Rectangle();
      init_TextureSource();
      init_Texture();
      _Spritesheet = class _Spritesheet2 {
        constructor(optionsOrTexture, arg1) {
          this.linkedSheets = [];
          let options = optionsOrTexture;
          if ((optionsOrTexture == null ? void 0 : optionsOrTexture.source) instanceof TextureSource) {
            options = {
              texture: optionsOrTexture,
              data: arg1
            };
          }
          const { texture, data, cachePrefix = "" } = options;
          this.cachePrefix = cachePrefix;
          this._texture = texture instanceof Texture ? texture : null;
          this.textureSource = texture.source;
          this.textures = {};
          this.animations = {};
          this.data = data;
          const metaResolution = parseFloat(data.meta.scale);
          if (metaResolution) {
            this.resolution = metaResolution;
            texture.source.resolution = this.resolution;
          } else {
            this.resolution = texture.source._resolution;
          }
          this._frames = this.data.frames;
          this._frameKeys = Object.keys(this._frames);
          this._batchIndex = 0;
          this._callback = null;
        }
        /**
         * Parser spritesheet from loaded data. This is done asynchronously
         * to prevent creating too many Texture within a single process.
         */
        parse() {
          return new Promise((resolve) => {
            this._callback = resolve;
            this._batchIndex = 0;
            if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
              this._processFrames(0);
              this._processAnimations();
              this._parseComplete();
            } else {
              this._nextBatch();
            }
          });
        }
        /**
         * Process a batch of frames
         * @param initialFrameIndex - The index of frame to start.
         */
        _processFrames(initialFrameIndex) {
          let frameIndex = initialFrameIndex;
          const maxFrames = _Spritesheet2.BATCH_SIZE;
          while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            const i3 = this._frameKeys[frameIndex];
            const data = this._frames[i3];
            const rect = data.frame;
            if (rect) {
              let frame = null;
              let trim = null;
              const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
              const orig = new Rectangle(
                0,
                0,
                Math.floor(sourceSize.w) / this.resolution,
                Math.floor(sourceSize.h) / this.resolution
              );
              if (data.rotated) {
                frame = new Rectangle(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.h) / this.resolution,
                  Math.floor(rect.w) / this.resolution
                );
              } else {
                frame = new Rectangle(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              if (data.trimmed !== false && data.spriteSourceSize) {
                trim = new Rectangle(
                  Math.floor(data.spriteSourceSize.x) / this.resolution,
                  Math.floor(data.spriteSourceSize.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              this.textures[i3] = new Texture({
                source: this.textureSource,
                frame,
                orig,
                trim,
                rotate: data.rotated ? 2 : 0,
                defaultAnchor: data.anchor,
                defaultBorders: data.borders,
                label: i3.toString()
              });
            }
            frameIndex++;
          }
        }
        /** Parse animations config. */
        _processAnimations() {
          const animations = this.data.animations || {};
          for (const animName in animations) {
            this.animations[animName] = [];
            for (let i3 = 0; i3 < animations[animName].length; i3++) {
              const frameName = animations[animName][i3];
              this.animations[animName].push(this.textures[frameName]);
            }
          }
        }
        /** The parse has completed. */
        _parseComplete() {
          const callback = this._callback;
          this._callback = null;
          this._batchIndex = 0;
          callback.call(this, this.textures);
        }
        /** Begin the next batch of textures. */
        _nextBatch() {
          this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
          this._batchIndex++;
          setTimeout(() => {
            if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
              this._nextBatch();
            } else {
              this._processAnimations();
              this._parseComplete();
            }
          }, 0);
        }
        /**
         * Destroy Spritesheet and don't use after this.
         * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
         */
        destroy(destroyBase = false) {
          var _a2;
          for (const i3 in this.textures) {
            this.textures[i3].destroy();
          }
          this._frames = null;
          this._frameKeys = null;
          this.data = null;
          this.textures = null;
          if (destroyBase) {
            (_a2 = this._texture) == null ? void 0 : _a2.destroy();
            this.textureSource.destroy();
          }
          this._texture = null;
          this.textureSource = null;
          this.linkedSheets = [];
        }
      };
      _Spritesheet.BATCH_SIZE = 1e3;
      Spritesheet = _Spritesheet;
    }
  });

  // node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
  function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out2 = {};
    keys.forEach((key) => {
      out2[key] = asset;
    });
    Object.keys(asset.textures).forEach((key) => {
      out2[`${asset.cachePrefix}${key}`] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
      const basePath = path.dirname(keys[0]);
      asset.linkedSheets.forEach((item, i3) => {
        const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i3]}`], item, true);
        Object.assign(out2, out22);
      });
    }
    return out2;
  }
  var validImages, spritesheetAsset;
  var init_spritesheetAsset = __esm({
    "node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
      init_LoaderParser();
      init_Resolver();
      init_copySearchParams();
      init_Extensions();
      init_Texture();
      init_path();
      init_Spritesheet();
      validImages = [
        "jpg",
        "png",
        "jpeg",
        "avif",
        "webp",
        "basis",
        "etc2",
        "bc7",
        "bc6h",
        "bc5",
        "bc4",
        "bc3",
        "bc2",
        "bc1",
        "eac",
        "astc"
      ];
      spritesheetAsset = {
        extension: ExtensionType.Asset,
        /** Handle the caching of the related Spritesheet Textures */
        cache: {
          test: (asset) => asset instanceof Spritesheet,
          getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
        },
        /** Resolve the resolution of the asset. */
        resolver: {
          extension: {
            type: ExtensionType.ResolveParser,
            name: "resolveSpritesheet"
          },
          test: (value) => {
            const tempURL = value.split("?")[0];
            const split = tempURL.split(".");
            const extension = split.pop();
            const format = split.pop();
            return extension === "json" && validImages.includes(format);
          },
          parse: (value) => {
            var _a2, _b;
            const split = value.split(".");
            return {
              resolution: parseFloat((_b = (_a2 = Resolver.RETINA_PREFIX.exec(value)) == null ? void 0 : _a2[1]) != null ? _b : "1"),
              format: split[split.length - 2],
              src: value
            };
          }
        },
        /**
         * Loader plugin that parses sprite sheets!
         * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
         * If it is, we load the spritesheets image and parse the data into Spritesheet
         * All textures in the sprite sheet are then added to the cache
         */
        loader: {
          /** used for deprecation purposes */
          name: "spritesheetLoader",
          id: "spritesheet",
          extension: {
            type: ExtensionType.LoadParser,
            priority: LoaderParserPriority.Normal,
            name: "spritesheetLoader"
          },
          testParse(asset, options) {
            return __async(this, null, function* () {
              return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
            });
          },
          parse(asset, options, loader) {
            return __async(this, null, function* () {
              var _a2, _b, _c;
              const {
                texture: imageTexture,
                // if user need to use preloaded texture
                imageFilename,
                // if user need to use custom filename (not from jsonFile.meta.image)
                textureOptions,
                // if user need to set texture options on texture
                cachePrefix
                // if user need to use custom cache prefix
              } = (_a2 = options == null ? void 0 : options.data) != null ? _a2 : {};
              let basePath = path.dirname(options.src);
              if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
                basePath += "/";
              }
              let texture;
              if (imageTexture instanceof Texture) {
                texture = imageTexture;
              } else {
                const imagePath = copySearchParams(basePath + (imageFilename != null ? imageFilename : asset.meta.image), options.src);
                const assets = yield loader.load([{ src: imagePath, data: textureOptions }]);
                texture = assets[imagePath];
              }
              const spritesheet = new Spritesheet({
                texture: texture.source,
                data: asset,
                cachePrefix
              });
              yield spritesheet.parse();
              const multiPacks = (_b = asset == null ? void 0 : asset.meta) == null ? void 0 : _b.related_multi_packs;
              if (Array.isArray(multiPacks)) {
                const promises = [];
                for (const item of multiPacks) {
                  if (typeof item !== "string") {
                    continue;
                  }
                  let itemUrl = basePath + item;
                  if ((_c = options.data) == null ? void 0 : _c.ignoreMultiPack) {
                    continue;
                  }
                  itemUrl = copySearchParams(itemUrl, options.src);
                  promises.push(loader.load({
                    src: itemUrl,
                    data: {
                      textureOptions,
                      ignoreMultiPack: true
                    }
                  }));
                }
                const res = yield Promise.all(promises);
                spritesheet.linkedSheets = res;
                res.forEach((item) => {
                  item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
                });
              }
              return spritesheet;
            });
          },
          unload(spritesheet, _resolvedAsset, loader) {
            return __async(this, null, function* () {
              yield loader.unload(spritesheet.textureSource._sourceOrigin);
              spritesheet.destroy(false);
            });
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/spritesheet/init.mjs
  var init_init5 = __esm({
    "node_modules/pixi.js/lib/spritesheet/init.mjs"() {
      init_Extensions();
      init_spritesheetAsset();
      extensions.add(spritesheetAsset);
    }
  });

  // node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs
  function updateQuadBounds(bounds, anchor, texture) {
    const { width, height } = texture.orig;
    const trim = texture.trim;
    if (trim) {
      const sourceWidth = trim.width;
      const sourceHeight = trim.height;
      bounds.minX = trim.x - anchor._x * width;
      bounds.maxX = bounds.minX + sourceWidth;
      bounds.minY = trim.y - anchor._y * height;
      bounds.maxY = bounds.minY + sourceHeight;
    } else {
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
  }
  var init_updateQuadBounds = __esm({
    "node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
  var Sprite;
  var init_Sprite = __esm({
    "node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"() {
      init_ObservablePoint();
      init_Texture();
      init_updateQuadBounds();
      init_deprecation();
      init_ViewContainer();
      Sprite = class _Sprite extends ViewContainer {
        /**
         * @param options - The options for creating the sprite.
         */
        constructor(options = Texture.EMPTY) {
          if (options instanceof Texture) {
            options = { texture: options };
          }
          const _a2 = options, { texture = Texture.EMPTY, anchor, roundPixels, width, height } = _a2, rest = __objRest(_a2, ["texture", "anchor", "roundPixels", "width", "height"]);
          super(__spreadValues({
            label: "Sprite"
          }, rest));
          this.renderPipeId = "sprite";
          this.batched = true;
          this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          this._anchor = new ObservablePoint(
            {
              _onUpdate: () => {
                this.onViewUpdate();
              }
            }
          );
          if (anchor) {
            this.anchor = anchor;
          } else if (texture.defaultAnchor) {
            this.anchor = texture.defaultAnchor;
          }
          this.texture = texture;
          this.allowChildren = false;
          this.roundPixels = roundPixels != null ? roundPixels : false;
          if (width !== void 0)
            this.width = width;
          if (height !== void 0)
            this.height = height;
        }
        /**
         * Creates a new sprite based on a source texture, image, video, or canvas element.
         * This is a convenience method that automatically creates and manages textures.
         * @example
         * ```ts
         * // Create from path or URL
         * const sprite = Sprite.from('assets/image.png');
         *
         * // Create from existing texture
         * const sprite = Sprite.from(texture);
         *
         * // Create from canvas
         * const canvas = document.createElement('canvas');
         * const sprite = Sprite.from(canvas, true); // Skip caching new texture
         * ```
         * @param source - The source to create the sprite from. Can be a path to an image, a texture,
         * or any valid texture source (canvas, video, etc.)
         * @param skipCache - Whether to skip adding to the texture cache when creating a new texture
         * @returns A new sprite based on the source
         * @see {@link Texture.from} For texture creation details
         * @see {@link Assets} For asset loading and management
         */
        static from(source11, skipCache = false) {
          if (source11 instanceof Texture) {
            return new _Sprite(source11);
          }
          return new _Sprite(Texture.from(source11, skipCache));
        }
        set texture(value) {
          value || (value = Texture.EMPTY);
          const currentTexture = this._texture;
          if (currentTexture === value)
            return;
          if (currentTexture && currentTexture.dynamic)
            currentTexture.off("update", this.onViewUpdate, this);
          if (value.dynamic)
            value.on("update", this.onViewUpdate, this);
          this._texture = value;
          if (this._width) {
            this._setWidth(this._width, this._texture.orig.width);
          }
          if (this._height) {
            this._setHeight(this._height, this._texture.orig.height);
          }
          this.onViewUpdate();
        }
        /**
         * The texture that is displayed by the sprite. When changed, automatically updates
         * the sprite dimensions and manages texture event listeners.
         * @example
         * ```ts
         * // Create sprite with texture
         * const sprite = new Sprite({
         *     texture: Texture.from('sprite.png')
         * });
         *
         * // Update texture
         * sprite.texture = Texture.from('newSprite.png');
         *
         * // Use texture from spritesheet
         * const sheet = await Assets.load('spritesheet.json');
         * sprite.texture = sheet.textures['frame1.png'];
         *
         * // Reset to empty texture
         * sprite.texture = Texture.EMPTY;
         * ```
         * @see {@link Texture} For texture creation and management
         * @see {@link Assets} For asset loading
         */
        get texture() {
          return this._texture;
        }
        /**
         * The bounds of the sprite, taking into account the texture's trim area.
         * @example
         * ```ts
         * const texture = new Texture({
         *     source: new TextureSource({ width: 300, height: 300 }),
         *     frame: new Rectangle(196, 66, 58, 56),
         *     trim: new Rectangle(4, 4, 58, 56),
         *     orig: new Rectangle(0, 0, 64, 64),
         *     rotate: 2,
         * });
         * const sprite = new Sprite(texture);
         * const visualBounds = sprite.visualBounds;
         * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }
         */
        get visualBounds() {
          updateQuadBounds(this._visualBounds, this._anchor, this._texture);
          return this._visualBounds;
        }
        /**
         * @deprecated
         * @ignore
         */
        get sourceBounds() {
          deprecation("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead.");
          return this.visualBounds;
        }
        /** @private */
        updateBounds() {
          const anchor = this._anchor;
          const texture = this._texture;
          const bounds = this._bounds;
          const { width, height } = texture.orig;
          bounds.minX = -anchor._x * width;
          bounds.maxX = bounds.minX + width;
          bounds.minY = -anchor._y * height;
          bounds.maxY = bounds.minY + height;
        }
        /**
         * Destroys this sprite renderable and optionally its texture.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @example
         * sprite.destroy();
         * sprite.destroy(true);
         * sprite.destroy({ texture: true, textureSource: true });
         */
        destroy(options = false) {
          super.destroy(options);
          const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
            this._texture.destroy(destroyTextureSource);
          }
          this._texture = null;
          this._visualBounds = null;
          this._bounds = null;
          this._anchor = null;
        }
        /**
         * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
         * and passed to the constructor.
         *
         * - The default is `(0,0)`, this means the sprite's origin is the top left.
         * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
         * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
         *
         * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
         * @example
         * ```ts
         * // Center the anchor point
         * sprite.anchor = 0.5; // Sets both x and y to 0.5
         * sprite.position.set(400, 300); // Sprite will be centered at this position
         *
         * // Set specific x/y anchor points
         * sprite.anchor = {
         *     x: 1, // Right edge
         *     y: 0  // Top edge
         * };
         *
         * // Using individual coordinates
         * sprite.anchor.set(0.5, 1); // Center-bottom
         *
         * // For rotation around center
         * sprite.anchor.set(0.5);
         * sprite.rotation = Math.PI / 4; // 45 degrees around center
         *
         * // For scaling from center
         * sprite.anchor.set(0.5);
         * sprite.scale.set(2); // Scales from center point
         * ```
         */
        get anchor() {
          return this._anchor;
        }
        set anchor(value) {
          typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
        }
        /**
         * The width of the sprite, setting this will actually modify the scale to achieve the value set.
         * @example
         * ```ts
         * // Set width directly
         * sprite.width = 200;
         * console.log(sprite.scale.x); // Scale adjusted to match width
         *
         * // Set width while preserving aspect ratio
         * const ratio = sprite.height / sprite.width;
         * sprite.width = 300;
         * sprite.height = 300 * ratio;
         *
         * // For better performance when setting both width and height
         * sprite.setSize(300, 400); // Avoids recalculating bounds twice
         *
         * // Reset to original texture size
         * sprite.width = sprite.texture.orig.width;
         * ```
         */
        get width() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        }
        set width(value) {
          this._setWidth(value, this._texture.orig.width);
          this._width = value;
        }
        /**
         * The height of the sprite, setting this will actually modify the scale to achieve the value set.
         * @example
         * ```ts
         * // Set height directly
         * sprite.height = 150;
         * console.log(sprite.scale.y); // Scale adjusted to match height
         *
         * // Set height while preserving aspect ratio
         * const ratio = sprite.width / sprite.height;
         * sprite.height = 200;
         * sprite.width = 200 * ratio;
         *
         * // For better performance when setting both width and height
         * sprite.setSize(300, 400); // Avoids recalculating bounds twice
         *
         * // Reset to original texture size
         * sprite.height = sprite.texture.orig.height;
         * ```
         */
        get height() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        }
        set height(value) {
          this._setHeight(value, this._texture.orig.height);
          this._height = value;
        }
        /**
         * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.
         * This is faster than getting width and height separately as it only calculates the bounds once.
         * @example
         * ```ts
         * // Basic size retrieval
         * const sprite = new Sprite(Texture.from('sprite.png'));
         * const size = sprite.getSize();
         * console.log(`Size: ${size.width}x${size.height}`);
         *
         * // Reuse existing size object
         * const reuseSize = { width: 0, height: 0 };
         * sprite.getSize(reuseSize);
         * ```
         * @param out - Optional object to store the size in, to avoid allocating a new object
         * @returns The size of the Sprite
         * @see {@link Sprite#width} For getting just the width
         * @see {@link Sprite#height} For getting just the height
         * @see {@link Sprite#setSize} For setting both width and height
         */
        getSize(out2) {
          out2 || (out2 = {});
          out2.width = Math.abs(this.scale.x) * this._texture.orig.width;
          out2.height = Math.abs(this.scale.y) * this._texture.orig.height;
          return out2;
        }
        /**
         * Sets the size of the Sprite to the specified width and height.
         * This is faster than setting width and height separately as it only recalculates bounds once.
         * @example
         * ```ts
         * // Basic size setting
         * const sprite = new Sprite(Texture.from('sprite.png'));
         * sprite.setSize(100, 200); // Width: 100, Height: 200
         *
         * // Set uniform size
         * sprite.setSize(100); // Sets both width and height to 100
         *
         * // Set size with object
         * sprite.setSize({
         *     width: 200,
         *     height: 300
         * });
         *
         * // Reset to texture size
         * sprite.setSize(
         *     sprite.texture.orig.width,
         *     sprite.texture.orig.height
         * );
         * ```
         * @param value - This can be either a number or a {@link Size} object
         * @param height - The height to set. Defaults to the value of `width` if not provided
         * @see {@link Sprite#width} For setting width only
         * @see {@link Sprite#height} For setting height only
         * @see {@link Sprite#texture} For the source dimensions
         */
        setSize(value, height) {
          var _a2;
          if (typeof value === "object") {
            height = (_a2 = value.height) != null ? _a2 : value.width;
            value = value.width;
          } else {
            height != null ? height : height = value;
          }
          value !== void 0 && this._setWidth(value, this._texture.orig.width);
          height !== void 0 && this._setHeight(height, this._texture.orig.height);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
  function addMaskBounds(mask, bounds, skipUpdateTransform) {
    const boundsToMask = tempBounds;
    mask.measurable = true;
    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
    bounds.addBoundsMask(boundsToMask);
    mask.measurable = false;
  }
  var tempBounds;
  var init_addMaskBounds = __esm({
    "node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs"() {
      init_Bounds();
      init_getGlobalBounds();
      tempBounds = new Bounds();
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
  function addMaskLocalBounds(mask, bounds, localRoot) {
    const boundsToMask = boundsPool.get();
    mask.measurable = true;
    const tempMatrix8 = matrixPool.get().identity();
    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix8);
    getLocalBounds(mask, boundsToMask, relativeMask);
    mask.measurable = false;
    bounds.addBoundsMask(boundsToMask);
    matrixPool.return(tempMatrix8);
    boundsPool.return(boundsToMask);
  }
  function getMatrixRelativeToParent(target, root, matrix) {
    if (!target) {
      warn("Mask bounds, renderable is not inside the root container");
      return matrix;
    }
    if (target !== root) {
      getMatrixRelativeToParent(target.parent, root, matrix);
      target.updateLocalTransform();
      matrix.append(target.localTransform);
    }
    return matrix;
  }
  var init_addMaskLocalBounds = __esm({
    "node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
      init_getLocalBounds();
      init_matrixAndBoundsPool();
      init_warn();
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
  var AlphaMask;
  var init_AlphaMask = __esm({
    "node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs"() {
      init_Extensions();
      init_Sprite();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      AlphaMask = class {
        constructor(options) {
          this.priority = 0;
          this.inverse = false;
          this.pipe = "alphaMask";
          if (options == null ? void 0 : options.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.renderMaskToTexture = !(mask instanceof Sprite);
          this.mask.renderable = this.renderMaskToTexture;
          this.mask.includeInBuild = !this.renderMaskToTexture;
          this.mask.measurable = false;
        }
        reset() {
          if (this.mask === null)
            return;
          this.mask.measurable = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          if (!this.inverse) {
            addMaskBounds(this.mask, bounds, skipUpdateTransform);
          }
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Sprite;
        }
      };
      AlphaMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
  var ColorMask;
  var init_ColorMask = __esm({
    "node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs"() {
      init_Extensions();
      ColorMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "colorMask";
          if (options == null ? void 0 : options.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
        }
        destroy() {
        }
        static test(mask) {
          return typeof mask === "number";
        }
      };
      ColorMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
  var StencilMask;
  var init_StencilMask = __esm({
    "node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs"() {
      init_Extensions();
      init_Container();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      StencilMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "stencilMask";
          if (options == null ? void 0 : options.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.mask.includeInBuild = false;
          this.mask.measurable = false;
        }
        reset() {
          if (this.mask === null)
            return;
          this.mask.measurable = true;
          this.mask.includeInBuild = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Container;
        }
      };
      StencilMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
  var CanvasSource;
  var init_CanvasSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
      init_adapter();
      init_Extensions();
      init_TextureSource();
      CanvasSource = class extends TextureSource {
        constructor(options) {
          if (!options.resource) {
            options.resource = DOMAdapter.get().createCanvas();
          }
          if (!options.width) {
            options.width = options.resource.width;
            if (!options.autoDensity) {
              options.width /= options.resolution;
            }
          }
          if (!options.height) {
            options.height = options.resource.height;
            if (!options.autoDensity) {
              options.height /= options.resolution;
            }
          }
          super(options);
          this.uploadMethodId = "image";
          this.autoDensity = options.autoDensity;
          this.resizeCanvas();
          this.transparent = !!options.transparent;
        }
        resizeCanvas() {
          if (this.autoDensity && "style" in this.resource) {
            this.resource.style.width = `${this.width}px`;
            this.resource.style.height = `${this.height}px`;
          }
          if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
            this.resource.width = this.pixelWidth;
            this.resource.height = this.pixelHeight;
          }
        }
        resize(width = this.width, height = this.height, resolution = this._resolution) {
          const didResize = super.resize(width, height, resolution);
          if (didResize) {
            this.resizeCanvas();
          }
          return didResize;
        }
        static test(resource) {
          return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
        }
        /**
         * Returns the 2D rendering context for the canvas.
         * Caches the context after creating it.
         * @returns The 2D rendering context of the canvas.
         */
        get context2D() {
          return this._context2D || (this._context2D = this.resource.getContext("2d"));
        }
      };
      CanvasSource.extension = ExtensionType.TextureSource;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
  var ImageSource;
  var init_ImageSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
      init_Extensions();
      init_TextureSource();
      ImageSource = class extends TextureSource {
        constructor(options) {
          super(options);
          this.uploadMethodId = "image";
          this.autoGarbageCollect = true;
        }
        static test(resource) {
          return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
        }
      };
      ImageSource.extension = ExtensionType.TextureSource;
    }
  });

  // node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
  function detectVideoAlphaMode() {
    return __async(this, null, function* () {
      promise != null ? promise : promise = (() => __async(null, null, function* () {
        var _a2;
        const canvas = DOMAdapter.get().createCanvas(1, 1);
        const gl = canvas.getContext("webgl");
        if (!gl) {
          return "premultiply-alpha-on-upload";
        }
        const video = yield new Promise((resolve) => {
          const video2 = document.createElement("video");
          video2.onloadeddata = () => resolve(video2);
          video2.onerror = () => resolve(null);
          video2.autoplay = false;
          video2.crossOrigin = "anonymous";
          video2.preload = "auto";
          video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
          video2.load();
        });
        if (!video) {
          return "premultiply-alpha-on-upload";
        }
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          texture,
          0
        );
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
        const pixel = new Uint8Array(4);
        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(texture);
        (_a2 = gl.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext();
        return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
      }))();
      return promise;
    });
  }
  var promise;
  var init_detectVideoAlphaMode = __esm({
    "node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
  var _VideoSource, VideoSource;
  var init_VideoSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
      init_Extensions();
      init_Ticker();
      init_detectVideoAlphaMode();
      init_TextureSource();
      _VideoSource = class _VideoSource2 extends TextureSource {
        constructor(options) {
          var _a2;
          super(options);
          this.isReady = false;
          this.uploadMethodId = "video";
          options = __spreadValues(__spreadValues({}, _VideoSource2.defaultOptions), options);
          this._autoUpdate = true;
          this._isConnectedToTicker = false;
          this._updateFPS = options.updateFPS || 0;
          this._msToNextUpdate = 0;
          this.autoPlay = options.autoPlay !== false;
          this.alphaMode = (_a2 = options.alphaMode) != null ? _a2 : "premultiply-alpha-on-upload";
          this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
          this._videoFrameRequestCallbackHandle = null;
          this._load = null;
          this._resolve = null;
          this._reject = null;
          this._onCanPlay = this._onCanPlay.bind(this);
          this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
          this._onError = this._onError.bind(this);
          this._onPlayStart = this._onPlayStart.bind(this);
          this._onPlayStop = this._onPlayStop.bind(this);
          this._onSeeked = this._onSeeked.bind(this);
          if (options.autoLoad !== false) {
            void this.load();
          }
        }
        /** Update the video frame if the source is not destroyed and meets certain conditions. */
        updateFrame() {
          if (this.destroyed) {
            return;
          }
          if (this._updateFPS) {
            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          }
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
          if (this.isValid) {
            this.update();
          }
        }
        /** Callback to update the video frame and potentially request the next frame update. */
        _videoFrameRequestCallback() {
          this.updateFrame();
          if (this.destroyed) {
            this._videoFrameRequestCallbackHandle = null;
          } else {
            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
              this._videoFrameRequestCallback
            );
          }
        }
        /**
         * Checks if the resource has valid dimensions.
         * @returns {boolean} True if width and height are set, otherwise false.
         */
        get isValid() {
          return !!this.resource.videoWidth && !!this.resource.videoHeight;
        }
        /**
         * Start preloading the video resource.
         * @returns {Promise<this>} Handle the validate event
         */
        load() {
          return __async(this, null, function* () {
            if (this._load) {
              return this._load;
            }
            const source11 = this.resource;
            const options = this.options;
            if ((source11.readyState === source11.HAVE_ENOUGH_DATA || source11.readyState === source11.HAVE_FUTURE_DATA) && source11.width && source11.height) {
              source11.complete = true;
            }
            source11.addEventListener("play", this._onPlayStart);
            source11.addEventListener("pause", this._onPlayStop);
            source11.addEventListener("seeked", this._onSeeked);
            if (!this._isSourceReady()) {
              if (!options.preload) {
                source11.addEventListener("canplay", this._onCanPlay);
              }
              source11.addEventListener("canplaythrough", this._onCanPlayThrough);
              source11.addEventListener("error", this._onError, true);
            } else {
              this._mediaReady();
            }
            this.alphaMode = yield detectVideoAlphaMode();
            this._load = new Promise((resolve, reject) => {
              if (this.isValid) {
                resolve(this);
              } else {
                this._resolve = resolve;
                this._reject = reject;
                if (options.preloadTimeoutMs !== void 0) {
                  this._preloadTimeout = setTimeout(() => {
                    this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
                  });
                }
                source11.load();
              }
            });
            return this._load;
          });
        }
        /**
         * Handle video error events.
         * @param event - The error event
         */
        _onError(event) {
          this.resource.removeEventListener("error", this._onError, true);
          this.emit("error", event);
          if (this._reject) {
            this._reject(event);
            this._reject = null;
            this._resolve = null;
          }
        }
        /**
         * Checks if the underlying source is playing.
         * @returns True if playing.
         */
        _isSourcePlaying() {
          const source11 = this.resource;
          return !source11.paused && !source11.ended;
        }
        /**
         * Checks if the underlying source is ready for playing.
         * @returns True if ready.
         */
        _isSourceReady() {
          const source11 = this.resource;
          return source11.readyState > 2;
        }
        /** Runs the update loop when the video is ready to play. */
        _onPlayStart() {
          if (!this.isValid) {
            this._mediaReady();
          }
          this._configureAutoUpdate();
        }
        /** Stops the update loop when a pause event is triggered. */
        _onPlayStop() {
          this._configureAutoUpdate();
        }
        /** Handles behavior when the video completes seeking to the current playback position. */
        _onSeeked() {
          if (this._autoUpdate && !this._isSourcePlaying()) {
            this._msToNextUpdate = 0;
            this.updateFrame();
            this._msToNextUpdate = 0;
          }
        }
        _onCanPlay() {
          const source11 = this.resource;
          source11.removeEventListener("canplay", this._onCanPlay);
          this._mediaReady();
        }
        _onCanPlayThrough() {
          const source11 = this.resource;
          source11.removeEventListener("canplaythrough", this._onCanPlay);
          if (this._preloadTimeout) {
            clearTimeout(this._preloadTimeout);
            this._preloadTimeout = void 0;
          }
          this._mediaReady();
        }
        /** Fired when the video is loaded and ready to play. */
        _mediaReady() {
          const source11 = this.resource;
          if (this.isValid) {
            this.isReady = true;
            this.resize(source11.videoWidth, source11.videoHeight);
          }
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
          if (this._resolve) {
            this._resolve(this);
            this._resolve = null;
            this._reject = null;
          }
          if (this._isSourcePlaying()) {
            this._onPlayStart();
          } else if (this.autoPlay) {
            void this.resource.play();
          }
        }
        /** Cleans up resources and event listeners associated with this texture. */
        destroy() {
          this._configureAutoUpdate();
          const source11 = this.resource;
          if (source11) {
            source11.removeEventListener("play", this._onPlayStart);
            source11.removeEventListener("pause", this._onPlayStop);
            source11.removeEventListener("seeked", this._onSeeked);
            source11.removeEventListener("canplay", this._onCanPlay);
            source11.removeEventListener("canplaythrough", this._onCanPlayThrough);
            source11.removeEventListener("error", this._onError, true);
            source11.pause();
            source11.src = "";
            source11.load();
          }
          super.destroy();
        }
        /** Should the base texture automatically update itself, set to true by default. */
        get autoUpdate() {
          return this._autoUpdate;
        }
        set autoUpdate(value) {
          if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            this._configureAutoUpdate();
          }
        }
        /**
         * How many times a second to update the texture from the video.
         * Leave at 0 to update at every render.
         * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
         */
        get updateFPS() {
          return this._updateFPS;
        }
        set updateFPS(value) {
          if (value !== this._updateFPS) {
            this._updateFPS = value;
            this._configureAutoUpdate();
          }
        }
        /**
         * Configures the updating mechanism based on the current state and settings.
         *
         * This method decides between using the browser's native video frame callback or a custom ticker
         * for updating the video frame. It ensures optimal performance and responsiveness
         * based on the video's state, playback status, and the desired frames-per-second setting.
         *
         * - If `_autoUpdate` is enabled and the video source is playing:
         *   - It will prefer the native video frame callback if available and no specific FPS is set.
         *   - Otherwise, it will use a custom ticker for manual updates.
         * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
         */
        _configureAutoUpdate() {
          if (this._autoUpdate && this._isSourcePlaying()) {
            if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
              if (this._isConnectedToTicker) {
                Ticker.shared.remove(this.updateFrame, this);
                this._isConnectedToTicker = false;
                this._msToNextUpdate = 0;
              }
              if (this._videoFrameRequestCallbackHandle === null) {
                this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                  this._videoFrameRequestCallback
                );
              }
            } else {
              if (this._videoFrameRequestCallbackHandle !== null) {
                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
                this._videoFrameRequestCallbackHandle = null;
              }
              if (!this._isConnectedToTicker) {
                Ticker.shared.add(this.updateFrame, this);
                this._isConnectedToTicker = true;
                this._msToNextUpdate = 0;
              }
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (this._isConnectedToTicker) {
              Ticker.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
          }
        }
        static test(resource) {
          return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
        }
      };
      _VideoSource.extension = ExtensionType.TextureSource;
      _VideoSource.defaultOptions = __spreadProps(__spreadValues({}, TextureSource.defaultOptions), {
        /** If true, the video will start loading immediately. */
        autoLoad: true,
        /** If true, the video will start playing as soon as it is loaded. */
        autoPlay: true,
        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
        updateFPS: 0,
        /** If true, the video will be loaded with the `crossorigin` attribute. */
        crossorigin: true,
        /** If true, the video will loop when it ends. */
        loop: false,
        /** If true, the video will be muted. */
        muted: true,
        /** If true, the video will play inline. */
        playsinline: true,
        /** If true, the video will be preloaded. */
        preload: false
      });
      _VideoSource.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      VideoSource = _VideoSource;
    }
  });

  // node_modules/pixi.js/lib/assets/cache/Cache.mjs
  var CacheClass, Cache;
  var init_Cache = __esm({
    "node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
      init_warn();
      init_convertToList();
      CacheClass = class {
        constructor() {
          this._parsers = [];
          this._cache = /* @__PURE__ */ new Map();
          this._cacheMap = /* @__PURE__ */ new Map();
        }
        /** Clear all entries. */
        reset() {
          this._cacheMap.clear();
          this._cache.clear();
        }
        /**
         * Check if the key exists
         * @param key - The key to check
         */
        has(key) {
          return this._cache.has(key);
        }
        /**
         * Fetch entry by key
         * @param key - The key of the entry to get
         */
        get(key) {
          const result = this._cache.get(key);
          if (!result) {
            warn(`[Assets] Asset id ${key} was not found in the Cache`);
          }
          return result;
        }
        /**
         * Set a value by key or keys name
         * @param key - The key or keys to set
         * @param value - The value to store in the cache or from which cacheable assets will be derived.
         */
        set(key, value) {
          const keys = convertToList(key);
          let cacheableAssets;
          for (let i3 = 0; i3 < this.parsers.length; i3++) {
            const parser = this.parsers[i3];
            if (parser.test(value)) {
              cacheableAssets = parser.getCacheableAssets(keys, value);
              break;
            }
          }
          const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
          if (!cacheableAssets) {
            keys.forEach((key2) => {
              cacheableMap.set(key2, value);
            });
          }
          const cacheKeys = [...cacheableMap.keys()];
          const cachedAssets = {
            cacheKeys,
            keys
          };
          keys.forEach((key2) => {
            this._cacheMap.set(key2, cachedAssets);
          });
          cacheKeys.forEach((key2) => {
            const val = cacheableAssets ? cacheableAssets[key2] : value;
            if (this._cache.has(key2) && this._cache.get(key2) !== val) {
              warn("[Cache] already has key:", key2);
            }
            this._cache.set(key2, cacheableMap.get(key2));
          });
        }
        /**
         * Remove entry by key
         *
         * This function will also remove any associated alias from the cache also.
         * @param key - The key of the entry to remove
         */
        remove(key) {
          if (!this._cacheMap.has(key)) {
            warn(`[Assets] Asset id ${key} was not found in the Cache`);
            return;
          }
          const cacheMap2 = this._cacheMap.get(key);
          const cacheKeys = cacheMap2.cacheKeys;
          cacheKeys.forEach((key2) => {
            this._cache.delete(key2);
          });
          cacheMap2.keys.forEach((key2) => {
            this._cacheMap.delete(key2);
          });
        }
        /**
         * All loader parsers registered
         * @advanced
         */
        get parsers() {
          return this._parsers;
        }
      };
      Cache = new CacheClass();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs
  function autoDetectSource(options = {}) {
    return textureSourceFrom(options);
  }
  function textureSourceFrom(options = {}) {
    const hasResource = options && options.resource;
    const res = hasResource ? options.resource : options;
    const opts = hasResource ? options : { resource: options };
    for (let i3 = 0; i3 < sources.length; i3++) {
      const Source = sources[i3];
      if (Source.test(res)) {
        return new Source(opts);
      }
    }
    throw new Error(`Could not find a source type for resource: ${opts.resource}`);
  }
  function resourceToTexture(options = {}, skipCache = false) {
    const hasResource = options && options.resource;
    const resource = hasResource ? options.resource : options;
    const opts = hasResource ? options : { resource: options };
    if (!skipCache && Cache.has(resource)) {
      return Cache.get(resource);
    }
    const texture = new Texture({ source: textureSourceFrom(opts) });
    texture.on("destroy", () => {
      if (Cache.has(resource)) {
        Cache.remove(resource);
      }
    });
    if (!skipCache) {
      Cache.set(resource, texture);
    }
    return texture;
  }
  function textureFrom(id, skipCache = false) {
    if (typeof id === "string") {
      return Cache.get(id);
    } else if (id instanceof TextureSource) {
      return new Texture({ source: id });
    }
    return resourceToTexture(id, skipCache);
  }
  var sources;
  var init_textureFrom = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs"() {
      init_Cache();
      init_Extensions();
      init_TextureSource();
      init_Texture();
      sources = [];
      extensions.handleByList(ExtensionType.TextureSource, sources);
      Texture.from = textureFrom;
      TextureSource.from = textureSourceFrom;
    }
  });

  // node_modules/pixi.js/lib/rendering/init.mjs
  var init_init6 = __esm({
    "node_modules/pixi.js/lib/rendering/init.mjs"() {
      init_Extensions();
      init_AlphaMask();
      init_ColorMask();
      init_StencilMask();
      init_BufferImageSource();
      init_CanvasSource();
      init_ImageSource();
      init_VideoSource();
      init_textureFrom();
      extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
  var BindGroup;
  var init_BindGroup = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
      "use strict";
      BindGroup = class {
        /**
         * Create a new instance eof the Bind Group.
         * @param resources - The resources that are bound together for use by a shader.
         */
        constructor(resources) {
          this.resources = /* @__PURE__ */ Object.create(null);
          this._dirty = true;
          let index = 0;
          for (const i3 in resources) {
            const resource = resources[i3];
            this.setResource(resource, index++);
          }
          this._updateKey();
        }
        /**
         * Updates the key if its flagged as dirty. This is used internally to
         * match this bind group to a WebGPU BindGroup.
         * @internal
         */
        _updateKey() {
          if (!this._dirty)
            return;
          this._dirty = false;
          const keyParts = [];
          let index = 0;
          for (const i3 in this.resources) {
            keyParts[index++] = this.resources[i3]._resourceId;
          }
          this._key = keyParts.join("|");
        }
        /**
         * Set a resource at a given index. this function will
         * ensure that listeners will be removed from the current resource
         * and added to the new resource.
         * @param resource - The resource to set.
         * @param index - The index to set the resource at.
         */
        setResource(resource, index) {
          var _a2, _b;
          const currentResource = this.resources[index];
          if (resource === currentResource)
            return;
          if (currentResource) {
            (_a2 = resource.off) == null ? void 0 : _a2.call(resource, "change", this.onResourceChange, this);
          }
          (_b = resource.on) == null ? void 0 : _b.call(resource, "change", this.onResourceChange, this);
          this.resources[index] = resource;
          this._dirty = true;
        }
        /**
         * Returns the resource at the current specified index.
         * @param index - The index of the resource to get.
         * @returns - The resource at the specified index.
         */
        getResource(index) {
          return this.resources[index];
        }
        /**
         * Used internally to 'touch' each resource, to ensure that the GC
         * knows that all resources in this bind group are still being used.
         * @param now - The current time in milliseconds.
         * @param tick - The current tick.
         * @internal
         */
        _touch(now, tick) {
          const resources = this.resources;
          for (const i3 in resources) {
            resources[i3]._gcLastUsed = now;
            resources[i3]._touched = tick;
          }
        }
        /** Destroys this bind group and removes all listeners. */
        destroy() {
          var _a2;
          const resources = this.resources;
          for (const i3 in resources) {
            const resource = resources[i3];
            (_a2 = resource == null ? void 0 : resource.off) == null ? void 0 : _a2.call(resource, "change", this.onResourceChange, this);
          }
          this.resources = null;
        }
        onResourceChange(resource) {
          this._dirty = true;
          if (resource.destroyed) {
            const resources = this.resources;
            for (const i3 in resources) {
              if (resources[i3] === resource) {
                resources[i3] = null;
              }
            }
          } else {
            this._updateKey();
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
  function getTextureBatchBindGroup(textures, size, maxTextures) {
    let uid4 = 2166136261;
    for (let i3 = 0; i3 < size; i3++) {
      uid4 ^= textures[i3].uid;
      uid4 = Math.imul(uid4, 16777619);
      uid4 >>>= 0;
    }
    return cachedGroups[uid4] || generateTextureBatchBindGroup(textures, size, uid4, maxTextures);
  }
  function generateTextureBatchBindGroup(textures, size, key, maxTextures) {
    const bindGroupResources = {};
    let bindIndex = 0;
    for (let i3 = 0; i3 < maxTextures; i3++) {
      const texture = i3 < size ? textures[i3] : Texture.EMPTY.source;
      bindGroupResources[bindIndex++] = texture.source;
      bindGroupResources[bindIndex++] = texture.style;
    }
    const bindGroup = new BindGroup(bindGroupResources);
    cachedGroups[key] = bindGroup;
    return bindGroup;
  }
  var cachedGroups;
  var init_getTextureBatchBindGroup = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
      init_BindGroup();
      init_Texture();
      cachedGroups = {};
    }
  });

  // node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs
  var ViewableBuffer;
  var init_ViewableBuffer = __esm({
    "node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs"() {
      "use strict";
      ViewableBuffer = class {
        constructor(sizeOrBuffer) {
          if (typeof sizeOrBuffer === "number") {
            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
          } else if (sizeOrBuffer instanceof Uint8Array) {
            this.rawBinaryData = sizeOrBuffer.buffer;
          } else {
            this.rawBinaryData = sizeOrBuffer;
          }
          this.uint32View = new Uint32Array(this.rawBinaryData);
          this.float32View = new Float32Array(this.rawBinaryData);
          this.size = this.rawBinaryData.byteLength;
        }
        /** View on the raw binary data as a `Int8Array`. */
        get int8View() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        }
        /** View on the raw binary data as a `Uint8Array`. */
        get uint8View() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        }
        /**  View on the raw binary data as a `Int16Array`. */
        get int16View() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        }
        /** View on the raw binary data as a `Int32Array`. */
        get int32View() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        }
        /** View on the raw binary data as a `Float64Array`. */
        get float64View() {
          if (!this._float64Array) {
            this._float64Array = new Float64Array(this.rawBinaryData);
          }
          return this._float64Array;
        }
        /** View on the raw binary data as a `BigUint64Array`. */
        get bigUint64View() {
          if (!this._bigUint64Array) {
            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
          }
          return this._bigUint64Array;
        }
        /**
         * Returns the view of the given type.
         * @param type - One of `int8`, `uint8`, `int16`,
         *    `uint16`, `int32`, `uint32`, and `float32`.
         * @returns - typed array of given type
         */
        view(type) {
          return this[`${type}View`];
        }
        /** Destroys all buffer references. Do not use after calling this. */
        destroy() {
          this.rawBinaryData = null;
          this.uint32View = null;
          this.float32View = null;
          this.uint16View = null;
          this._int8View = null;
          this._uint8View = null;
          this._int16View = null;
          this._int32View = null;
          this._float64Array = null;
          this._bigUint64Array = null;
        }
        /**
         * Returns the size of the given type in bytes.
         * @param type - One of `int8`, `uint8`, `int16`,
         *   `uint16`, `int32`, `uint32`, and `float32`.
         * @returns - size of the type in bytes
         */
        static sizeOf(type) {
          switch (type) {
            case "int8":
            case "uint8":
              return 1;
            case "int16":
            case "uint16":
              return 2;
            case "int32":
            case "uint32":
            case "float32":
              return 4;
            default:
              throw new Error(`${type} isn't a valid view type`);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
  function fastCopy(sourceBuffer, destinationBuffer) {
    const lengthDouble = sourceBuffer.byteLength / 8 | 0;
    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
    destinationFloat64View.set(sourceFloat64View);
    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
    if (remainingBytes > 0) {
      const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
      const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
      destinationUint8View.set(sourceUint8View);
    }
  }
  var init_fastCopy = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
  var BLEND_TO_NPM, STENCIL_MODES;
  var init_const3 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs"() {
      "use strict";
      BLEND_TO_NPM = {
        normal: "normal-npm",
        add: "add-npm",
        screen: "screen-npm"
      };
      STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
        STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
        STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
        STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
        STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
        return STENCIL_MODES2;
      })(STENCIL_MODES || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs
  function getAdjustedBlendModeBlend(blendMode, textureSource) {
    if (textureSource.alphaMode === "no-premultiply-alpha") {
      return BLEND_TO_NPM[blendMode] || blendMode;
    }
    return blendMode;
  }
  var init_getAdjustedBlendModeBlend = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"() {
      init_const3();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
  function getTestContext() {
    if (!context3 || (context3 == null ? void 0 : context3.isContextLost())) {
      const canvas = DOMAdapter.get().createCanvas();
      context3 = canvas.getContext("webgl", {});
    }
    return context3;
  }
  var context3;
  var init_getTestContext = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs
  function generateIfTestSrc(maxIfs) {
    let src = "";
    for (let i3 = 0; i3 < maxIfs; ++i3) {
      if (i3 > 0) {
        src += "\nelse ";
      }
      if (i3 < maxIfs - 1) {
        src += `if(test == ${i3}.0){}`;
      }
    }
    return src;
  }
  function checkMaxIfStatementsInShader(maxIfs, gl) {
    if (maxIfs === 0) {
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    }
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    try {
      while (true) {
        const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          maxIfs = maxIfs / 2 | 0;
        } else {
          break;
        }
      }
    } finally {
      gl.deleteShader(shader);
    }
    return maxIfs;
  }
  var fragTemplate;
  var init_checkMaxIfStatementsInShader = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs"() {
      "use strict";
      fragTemplate = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}"
      ].join("\n");
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs
  function getMaxTexturesPerBatch() {
    var _a2;
    if (maxTexturesPerBatchCache)
      return maxTexturesPerBatchCache;
    const gl = getTestContext();
    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(
      maxTexturesPerBatchCache,
      gl
    );
    (_a2 = gl.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext();
    return maxTexturesPerBatchCache;
  }
  var maxTexturesPerBatchCache;
  var init_maxRecommendedTextures = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs"() {
      init_getTestContext();
      init_checkMaxIfStatementsInShader();
      maxTexturesPerBatchCache = null;
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
  var BatchTextureArray;
  var init_BatchTextureArray = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
      "use strict";
      BatchTextureArray = class {
        constructor() {
          this.ids = /* @__PURE__ */ Object.create(null);
          this.textures = [];
          this.count = 0;
        }
        /** Clear the textures and their locations. */
        clear() {
          for (let i3 = 0; i3 < this.count; i3++) {
            const t2 = this.textures[i3];
            this.textures[i3] = null;
            this.ids[t2.uid] = null;
          }
          this.count = 0;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
  function getBatchFromPool() {
    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
  }
  function returnBatchToPool(batch) {
    batchPool[batchPoolIndex++] = batch;
  }
  var Batch, batchPool, batchPoolIndex, BATCH_TICK, _Batcher, Batcher;
  var init_Batcher = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"() {
      init_uid();
      init_ViewableBuffer();
      init_deprecation();
      init_GlobalResourceRegistry();
      init_fastCopy();
      init_getAdjustedBlendModeBlend();
      init_maxRecommendedTextures();
      init_BatchTextureArray();
      Batch = class {
        constructor() {
          this.renderPipeId = "batch";
          this.action = "startBatch";
          this.start = 0;
          this.size = 0;
          this.textures = new BatchTextureArray();
          this.blendMode = "normal";
          this.topology = "triangle-strip";
          this.canBundle = true;
        }
        destroy() {
          this.textures = null;
          this.gpuBindGroup = null;
          this.bindGroup = null;
          this.batcher = null;
        }
      };
      batchPool = [];
      batchPoolIndex = 0;
      GlobalResourceRegistry.register({
        clear: () => {
          if (batchPool.length > 0) {
            for (const item of batchPool) {
              if (item)
                item.destroy();
            }
          }
          batchPool.length = 0;
          batchPoolIndex = 0;
        }
      });
      BATCH_TICK = 0;
      _Batcher = class _Batcher2 {
        constructor(options) {
          this.uid = uid2("batcher");
          this.dirty = true;
          this.batchIndex = 0;
          this.batches = [];
          this._elements = [];
          options = __spreadValues(__spreadValues({}, _Batcher2.defaultOptions), options);
          if (!options.maxTextures) {
            deprecation("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options");
            options.maxTextures = getMaxTexturesPerBatch();
          }
          const { maxTextures, attributesInitialSize, indicesInitialSize } = options;
          this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);
          this.indexBuffer = new Uint16Array(indicesInitialSize);
          this.maxTextures = maxTextures;
        }
        begin() {
          this.elementSize = 0;
          this.elementStart = 0;
          this.indexSize = 0;
          this.attributeSize = 0;
          for (let i3 = 0; i3 < this.batchIndex; i3++) {
            returnBatchToPool(this.batches[i3]);
          }
          this.batchIndex = 0;
          this._batchIndexStart = 0;
          this._batchIndexSize = 0;
          this.dirty = true;
        }
        add(batchableObject) {
          this._elements[this.elementSize++] = batchableObject;
          batchableObject._indexStart = this.indexSize;
          batchableObject._attributeStart = this.attributeSize;
          batchableObject._batcher = this;
          this.indexSize += batchableObject.indexSize;
          this.attributeSize += batchableObject.attributeSize * this.vertexSize;
        }
        checkAndUpdateTexture(batchableObject, texture) {
          const textureId = batchableObject._batch.textures.ids[texture._source.uid];
          if (!textureId && textureId !== 0)
            return false;
          batchableObject._textureId = textureId;
          batchableObject.texture = texture;
          return true;
        }
        updateElement(batchableObject) {
          this.dirty = true;
          const attributeBuffer = this.attributeBuffer;
          if (batchableObject.packAsQuad) {
            this.packQuadAttributes(
              batchableObject,
              attributeBuffer.float32View,
              attributeBuffer.uint32View,
              batchableObject._attributeStart,
              batchableObject._textureId
            );
          } else {
            this.packAttributes(
              batchableObject,
              attributeBuffer.float32View,
              attributeBuffer.uint32View,
              batchableObject._attributeStart,
              batchableObject._textureId
            );
          }
        }
        /**
         * breaks the batcher. This happens when a batch gets too big,
         * or we need to switch to a different type of rendering (a filter for example)
         * @param instructionSet
         */
        break(instructionSet) {
          const elements = this._elements;
          if (!elements[this.elementStart])
            return;
          let batch = getBatchFromPool();
          let textureBatch = batch.textures;
          textureBatch.clear();
          const firstElement = elements[this.elementStart];
          let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
          let topology = firstElement.topology;
          if (this.attributeSize * 4 > this.attributeBuffer.size) {
            this._resizeAttributeBuffer(this.attributeSize * 4);
          }
          if (this.indexSize > this.indexBuffer.length) {
            this._resizeIndexBuffer(this.indexSize);
          }
          const f32 = this.attributeBuffer.float32View;
          const u32 = this.attributeBuffer.uint32View;
          const indexBuffer = this.indexBuffer;
          let size = this._batchIndexSize;
          let start = this._batchIndexStart;
          let action = "startBatch";
          const maxTextures = this.maxTextures;
          for (let i3 = this.elementStart; i3 < this.elementSize; ++i3) {
            const element = elements[i3];
            elements[i3] = null;
            const texture = element.texture;
            const source11 = texture._source;
            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source11);
            const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;
            if (source11._batchTick === BATCH_TICK && !breakRequired) {
              element._textureId = source11._textureBindLocation;
              size += element.indexSize;
              if (element.packAsQuad) {
                this.packQuadAttributes(
                  element,
                  f32,
                  u32,
                  element._attributeStart,
                  element._textureId
                );
                this.packQuadIndex(
                  indexBuffer,
                  element._indexStart,
                  element._attributeStart / this.vertexSize
                );
              } else {
                this.packAttributes(
                  element,
                  f32,
                  u32,
                  element._attributeStart,
                  element._textureId
                );
                this.packIndex(
                  element,
                  indexBuffer,
                  element._indexStart,
                  element._attributeStart / this.vertexSize
                );
              }
              element._batch = batch;
              continue;
            }
            source11._batchTick = BATCH_TICK;
            if (textureBatch.count >= maxTextures || breakRequired) {
              this._finishBatch(
                batch,
                start,
                size - start,
                textureBatch,
                blendMode,
                topology,
                instructionSet,
                action
              );
              action = "renderBatch";
              start = size;
              blendMode = adjustedBlendMode;
              topology = element.topology;
              batch = getBatchFromPool();
              textureBatch = batch.textures;
              textureBatch.clear();
              ++BATCH_TICK;
            }
            element._textureId = source11._textureBindLocation = textureBatch.count;
            textureBatch.ids[source11.uid] = textureBatch.count;
            textureBatch.textures[textureBatch.count++] = source11;
            element._batch = batch;
            size += element.indexSize;
            if (element.packAsQuad) {
              this.packQuadAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packQuadIndex(
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            } else {
              this.packAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packIndex(
                element,
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            }
          }
          if (textureBatch.count > 0) {
            this._finishBatch(
              batch,
              start,
              size - start,
              textureBatch,
              blendMode,
              topology,
              instructionSet,
              action
            );
            start = size;
            ++BATCH_TICK;
          }
          this.elementStart = this.elementSize;
          this._batchIndexStart = start;
          this._batchIndexSize = size;
        }
        _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {
          batch.gpuBindGroup = null;
          batch.bindGroup = null;
          batch.action = action;
          batch.batcher = this;
          batch.textures = textureBatch;
          batch.blendMode = blendMode;
          batch.topology = topology;
          batch.start = indexStart;
          batch.size = indexSize;
          ++BATCH_TICK;
          this.batches[this.batchIndex++] = batch;
          instructionSet.add(batch);
        }
        finish(instructionSet) {
          this.break(instructionSet);
        }
        /**
         * Resizes the attribute buffer to the given size (1 = 1 float32)
         * @param size - the size in vertices to ensure (not bytes!)
         */
        ensureAttributeBuffer(size) {
          if (size * 4 <= this.attributeBuffer.size)
            return;
          this._resizeAttributeBuffer(size * 4);
        }
        /**
         * Resizes the index buffer to the given size (1 = 1 float32)
         * @param size - the size in vertices to ensure (not bytes!)
         */
        ensureIndexBuffer(size) {
          if (size <= this.indexBuffer.length)
            return;
          this._resizeIndexBuffer(size);
        }
        _resizeAttributeBuffer(size) {
          const newSize = Math.max(size, this.attributeBuffer.size * 2);
          const newArrayBuffer = new ViewableBuffer(newSize);
          fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
          this.attributeBuffer = newArrayBuffer;
        }
        _resizeIndexBuffer(size) {
          const indexBuffer = this.indexBuffer;
          let newSize = Math.max(size, indexBuffer.length * 1.5);
          newSize += newSize % 2;
          const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
          if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
            for (let i3 = 0; i3 < indexBuffer.length; i3++) {
              newIndexBuffer[i3] = indexBuffer[i3];
            }
          } else {
            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
          }
          this.indexBuffer = newIndexBuffer;
        }
        packQuadIndex(indexBuffer, index, indicesOffset) {
          indexBuffer[index] = indicesOffset + 0;
          indexBuffer[index + 1] = indicesOffset + 1;
          indexBuffer[index + 2] = indicesOffset + 2;
          indexBuffer[index + 3] = indicesOffset + 0;
          indexBuffer[index + 4] = indicesOffset + 2;
          indexBuffer[index + 5] = indicesOffset + 3;
        }
        packIndex(element, indexBuffer, index, indicesOffset) {
          const indices = element.indices;
          const size = element.indexSize;
          const indexOffset = element.indexOffset;
          const attributeOffset = element.attributeOffset;
          for (let i3 = 0; i3 < size; i3++) {
            indexBuffer[index++] = indicesOffset + indices[i3 + indexOffset] - attributeOffset;
          }
        }
        /**
         * Destroys the batch and its resources.
         * @param options - destruction options
         * @param options.shader - whether to destroy the associated shader
         */
        destroy(options = {}) {
          var _a2;
          if (this.batches === null)
            return;
          for (let i3 = 0; i3 < this.batchIndex; i3++) {
            returnBatchToPool(this.batches[i3]);
          }
          this.batches = null;
          this.geometry.destroy(true);
          this.geometry = null;
          if (options.shader) {
            (_a2 = this.shader) == null ? void 0 : _a2.destroy();
            this.shader = null;
          }
          for (let i3 = 0; i3 < this._elements.length; i3++) {
            if (this._elements[i3])
              this._elements[i3]._batch = null;
          }
          this._elements = null;
          this.indexBuffer = null;
          this.attributeBuffer.destroy();
          this.attributeBuffer = null;
        }
      };
      _Batcher.defaultOptions = {
        maxTextures: null,
        attributesInitialSize: 4,
        indicesInitialSize: 6
      };
      Batcher = _Batcher;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
  var BufferUsage;
  var init_const4 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"() {
      "use strict";
      BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
        BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
        BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
        BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
        BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
        BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
        BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
        BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
        BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
        BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
        BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
        BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
        return BufferUsage2;
      })(BufferUsage || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
  var Buffer2;
  var init_Buffer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
      init_eventemitter3();
      init_uid();
      init_const4();
      Buffer2 = class extends eventemitter3_default {
        /**
         * Creates a new Buffer with the given options
         * @param options - the options for the buffer
         */
        constructor(options) {
          let { data, size } = options;
          const { usage, label, shrinkToFit } = options;
          super();
          this._gpuData = /* @__PURE__ */ Object.create(null);
          this._gcLastUsed = -1;
          this.autoGarbageCollect = true;
          this.uid = uid2("buffer");
          this._resourceType = "buffer";
          this._resourceId = uid2("resource");
          this._touched = 0;
          this._updateID = 1;
          this._dataInt32 = null;
          this.shrinkToFit = true;
          this.destroyed = false;
          if (data instanceof Array) {
            data = new Float32Array(data);
          }
          this._data = data;
          size != null ? size : size = data == null ? void 0 : data.byteLength;
          const mappedAtCreation = !!data;
          this.descriptor = {
            size,
            usage,
            mappedAtCreation,
            label
          };
          this.shrinkToFit = shrinkToFit != null ? shrinkToFit : true;
        }
        /** the data in the buffer */
        get data() {
          return this._data;
        }
        set data(value) {
          this.setDataWithSize(value, value.length, true);
        }
        get dataInt32() {
          if (!this._dataInt32) {
            this._dataInt32 = new Int32Array(this.data.buffer);
          }
          return this._dataInt32;
        }
        /** whether the buffer is static or not */
        get static() {
          return !!(this.descriptor.usage & BufferUsage.STATIC);
        }
        set static(value) {
          if (value) {
            this.descriptor.usage |= BufferUsage.STATIC;
          } else {
            this.descriptor.usage &= ~BufferUsage.STATIC;
          }
        }
        /**
         * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
         * If you only want to update a subset of the buffer, you can pass in the size of the data.
         * @param value - the data to set
         * @param size - the size of the data in bytes
         * @param syncGPU - should the buffer be updated on the GPU immediately?
         */
        setDataWithSize(value, size, syncGPU) {
          this._updateID++;
          this._updateSize = size * value.BYTES_PER_ELEMENT;
          if (this._data === value) {
            if (syncGPU)
              this.emit("update", this);
            return;
          }
          const oldData = this._data;
          this._data = value;
          this._dataInt32 = null;
          if (!oldData || oldData.length !== value.length) {
            if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {
              if (syncGPU)
                this.emit("update", this);
            } else {
              this.descriptor.size = value.byteLength;
              this._resourceId = uid2("resource");
              this.emit("change", this);
            }
            return;
          }
          if (syncGPU)
            this.emit("update", this);
        }
        /**
         * updates the buffer on the GPU to reflect the data in the buffer.
         * By default it will update the entire buffer. If you only want to update a subset of the buffer,
         * you can pass in the size of the buffer to update.
         * @param sizeInBytes - the new size of the buffer in bytes
         */
        update(sizeInBytes) {
          this._updateSize = sizeInBytes != null ? sizeInBytes : this._updateSize;
          this._updateID++;
          this.emit("update", this);
        }
        /** Unloads the buffer from the GPU */
        unload() {
          var _a2;
          this.emit("unload", this);
          for (const key in this._gpuData) {
            (_a2 = this._gpuData[key]) == null ? void 0 : _a2.destroy();
          }
          this._gpuData = /* @__PURE__ */ Object.create(null);
        }
        /** Destroys the buffer */
        destroy() {
          this.destroyed = true;
          this.unload();
          this.emit("destroy", this);
          this.emit("change", this);
          this._data = null;
          this.descriptor = null;
          this.removeAllListeners();
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
  function ensureIsBuffer(buffer, index) {
    if (!(buffer instanceof Buffer2)) {
      let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
      if (buffer instanceof Array) {
        if (index) {
          buffer = new Uint32Array(buffer);
          usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
        } else {
          buffer = new Float32Array(buffer);
          usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
        }
      }
      buffer = new Buffer2({
        data: buffer,
        label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage
      });
    }
    return buffer;
  }
  var init_ensureIsBuffer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
      init_Buffer();
      init_const4();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs
  function getGeometryBounds(geometry, attributeId, bounds) {
    const attribute = geometry.getAttribute(attributeId);
    if (!attribute) {
      bounds.minX = 0;
      bounds.minY = 0;
      bounds.maxX = 0;
      bounds.maxY = 0;
      return bounds;
    }
    const data = attribute.buffer.data;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    const byteSize = data.BYTES_PER_ELEMENT;
    const offset = (attribute.offset || 0) / byteSize;
    const stride = (attribute.stride || 2 * 4) / byteSize;
    for (let i3 = offset; i3 < data.length; i3 += stride) {
      const x2 = data[i3];
      const y2 = data[i3 + 1];
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
    }
    bounds.minX = minX;
    bounds.minY = minY;
    bounds.maxX = maxX;
    bounds.maxY = maxY;
    return bounds;
  }
  var init_getGeometryBounds = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
  function ensureIsAttribute(attribute) {
    if (attribute instanceof Buffer2 || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
      attribute = {
        buffer: attribute
      };
    }
    attribute.buffer = ensureIsBuffer(attribute.buffer, false);
    return attribute;
  }
  var Geometry;
  var init_Geometry = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
      init_eventemitter3();
      init_Bounds();
      init_uid();
      init_Buffer();
      init_ensureIsBuffer();
      init_getGeometryBounds();
      Geometry = class extends eventemitter3_default {
        /**
         * Create a new instance of a geometry
         * @param options - The options for the geometry.
         */
        constructor(options = {}) {
          var _a2;
          super();
          this._gpuData = /* @__PURE__ */ Object.create(null);
          this.autoGarbageCollect = true;
          this._gcLastUsed = -1;
          this.uid = uid2("geometry");
          this._layoutKey = 0;
          this.instanceCount = 1;
          this._bounds = new Bounds();
          this._boundsDirty = true;
          const { attributes, indexBuffer, topology } = options;
          this.buffers = [];
          this.attributes = {};
          if (attributes) {
            for (const i3 in attributes) {
              this.addAttribute(i3, attributes[i3]);
            }
          }
          this.instanceCount = (_a2 = options.instanceCount) != null ? _a2 : 1;
          if (indexBuffer) {
            this.addIndex(indexBuffer);
          }
          this.topology = topology || "triangle-list";
        }
        onBufferUpdate() {
          this._boundsDirty = true;
          this.emit("update", this);
        }
        /**
         * Returns the requested attribute.
         * @param id - The name of the attribute required
         * @returns - The attribute requested.
         */
        getAttribute(id) {
          return this.attributes[id];
        }
        /**
         * Returns the index buffer
         * @returns - The index buffer.
         */
        getIndex() {
          return this.indexBuffer;
        }
        /**
         * Returns the requested buffer.
         * @param id - The name of the buffer required.
         * @returns - The buffer requested.
         */
        getBuffer(id) {
          return this.getAttribute(id).buffer;
        }
        /**
         * Used to figure out how many vertices there are in this geometry
         * @returns the number of vertices in the geometry
         */
        getSize() {
          for (const i3 in this.attributes) {
            const attribute = this.attributes[i3];
            const buffer = attribute.buffer;
            return buffer.data.length / (attribute.stride / 4 || attribute.size);
          }
          return 0;
        }
        /**
         * Adds an attribute to the geometry.
         * @param name - The name of the attribute to add.
         * @param attributeOption - The attribute option to add.
         */
        addAttribute(name, attributeOption) {
          const attribute = ensureIsAttribute(attributeOption);
          const bufferIndex = this.buffers.indexOf(attribute.buffer);
          if (bufferIndex === -1) {
            this.buffers.push(attribute.buffer);
            attribute.buffer.on("update", this.onBufferUpdate, this);
            attribute.buffer.on("change", this.onBufferUpdate, this);
          }
          this.attributes[name] = attribute;
        }
        /**
         * Adds an index buffer to the geometry.
         * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
         */
        addIndex(indexBuffer) {
          this.indexBuffer = ensureIsBuffer(indexBuffer, true);
          this.buffers.push(this.indexBuffer);
        }
        /** Returns the bounds of the geometry. */
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          this._boundsDirty = false;
          return getGeometryBounds(this, "aPosition", this._bounds);
        }
        /** Unloads the geometry from the GPU. */
        unload() {
          var _a2;
          this.emit("unload", this);
          for (const key in this._gpuData) {
            (_a2 = this._gpuData[key]) == null ? void 0 : _a2.destroy();
          }
          this._gpuData = /* @__PURE__ */ Object.create(null);
        }
        /**
         * destroys the geometry.
         * @param destroyBuffers - destroy the buffers associated with this geometry
         */
        destroy(destroyBuffers = false) {
          var _a2;
          this.emit("destroy", this);
          this.removeAllListeners();
          if (destroyBuffers) {
            this.buffers.forEach((buffer) => buffer.destroy());
          }
          this.unload();
          (_a2 = this.indexBuffer) == null ? void 0 : _a2.destroy();
          this.attributes = null;
          this.buffers = null;
          this.indexBuffer = null;
          this._bounds = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs
  var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
  var init_BatchGeometry = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs"() {
      init_Buffer();
      init_const4();
      init_Geometry();
      placeHolderBufferData = new Float32Array(1);
      placeHolderIndexData = new Uint32Array(1);
      BatchGeometry = class extends Geometry {
        constructor() {
          const vertexSize = 6;
          const attributeBuffer = new Buffer2({
            data: placeHolderBufferData,
            label: "attribute-batch-buffer",
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
            shrinkToFit: false
          });
          const indexBuffer = new Buffer2({
            data: placeHolderIndexData,
            label: "index-batch-buffer",
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
            // | BufferUsage.STATIC,
            shrinkToFit: false
          });
          const stride = vertexSize * 4;
          super({
            attributes: {
              aPosition: {
                buffer: attributeBuffer,
                format: "float32x2",
                stride,
                offset: 0
              },
              aUV: {
                buffer: attributeBuffer,
                format: "float32x2",
                stride,
                offset: 2 * 4
              },
              aColor: {
                buffer: attributeBuffer,
                format: "unorm8x4",
                stride,
                offset: 4 * 4
              },
              aTextureIdAndRound: {
                buffer: attributeBuffer,
                format: "uint16x2",
                stride,
                offset: 5 * 4
              }
            },
            indexBuffer
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
  function createIdFromString(value, groupId) {
    let id = idHash2[value];
    if (id === void 0) {
      if (idCounts[groupId] === void 0) {
        idCounts[groupId] = 1;
      }
      idHash2[value] = id = idCounts[groupId]++;
    }
    return id;
  }
  var idCounts, idHash2;
  var init_createIdFromString = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
      "use strict";
      idCounts = /* @__PURE__ */ Object.create(null);
      idHash2 = /* @__PURE__ */ Object.create(null);
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = "mediump";
      const gl = getTestContext();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
        }
      }
    }
    return maxFragmentPrecision;
  }
  var maxFragmentPrecision;
  var init_getMaxFragmentPrecision = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
      init_getTestContext();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs
  function addProgramDefines(src, isES300, isFragment) {
    if (isES300)
      return src;
    if (isFragment) {
      src = src.replace("out vec4 finalColor;", "");
      return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
    }
    return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
  }
  var init_addProgramDefines = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs
  function ensurePrecision(src, options, isFragment) {
    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
    if (src.substring(0, 9) !== "precision") {
      let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
      if (precision === "highp" && maxSupportedPrecision !== "highp") {
        precision = "mediump";
      }
      return `precision ${precision} float;
${src}`;
    } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }
  var init_ensurePrecision = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs
  function insertVersion(src, isES300) {
    if (!isES300)
      return src;
    return `#version 300 es
${src}`;
  }
  var init_insertVersion = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs
  function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
    name = name.replace(/\s+/g, "-");
    name += isFragment ? "-fragment" : "-vertex";
    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
    if (nameCache[name]) {
      nameCache[name]++;
      name += `-${nameCache[name]}`;
    } else {
      nameCache[name] = 1;
    }
    if (src.indexOf("#define SHADER_NAME") !== -1)
      return src;
    const shaderName = `#define SHADER_NAME ${name}`;
    return `${shaderName}
${src}`;
  }
  var fragmentNameCache, VertexNameCache;
  var init_setProgramName = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs"() {
      "use strict";
      fragmentNameCache = {};
      VertexNameCache = {};
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs
  function stripVersion(src, isES300) {
    if (!isES300)
      return src;
    return src.replace("#version 300 es", "");
  }
  var init_stripVersion = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
  var processes, programCache, _GlProgram, GlProgram;
  var init_GlProgram = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
      init_createIdFromString();
      init_getMaxFragmentPrecision();
      init_addProgramDefines();
      init_ensurePrecision();
      init_insertVersion();
      init_setProgramName();
      init_stripVersion();
      processes = {
        // strips any version headers..
        stripVersion,
        // adds precision string if not already present
        ensurePrecision,
        // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
        addProgramDefines,
        // add the program name to the shader
        setProgramName,
        // add the version string to the shader header
        insertVersion
      };
      programCache = /* @__PURE__ */ Object.create(null);
      _GlProgram = class _GlProgram2 {
        /**
         * Creates a shiny new GlProgram. Used by WebGL renderer.
         * @param options - The options for the program.
         */
        constructor(options) {
          options = __spreadValues(__spreadValues({}, _GlProgram2.defaultOptions), options);
          const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
          const preprocessorOptions = {
            stripVersion: isES300,
            ensurePrecision: {
              requestedFragmentPrecision: options.preferredFragmentPrecision,
              requestedVertexPrecision: options.preferredVertexPrecision,
              maxSupportedVertexPrecision: "highp",
              maxSupportedFragmentPrecision: getMaxFragmentPrecision()
            },
            setProgramName: {
              name: options.name
            },
            addProgramDefines: isES300,
            insertVersion: isES300
          };
          let fragment11 = options.fragment;
          let vertex6 = options.vertex;
          Object.keys(processes).forEach((processKey) => {
            const processOptions = preprocessorOptions[processKey];
            fragment11 = processes[processKey](fragment11, processOptions, true);
            vertex6 = processes[processKey](vertex6, processOptions, false);
          });
          this.fragment = fragment11;
          this.vertex = vertex6;
          this.transformFeedbackVaryings = options.transformFeedbackVaryings;
          this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
        }
        /** destroys the program */
        destroy() {
          this.fragment = null;
          this.vertex = null;
          this._attributeData = null;
          this._uniformData = null;
          this._uniformBlockData = null;
          this.transformFeedbackVaryings = null;
          programCache[this._cacheKey] = null;
        }
        /**
         * Helper function that creates a program for a given source.
         * It will check the program cache if the program has already been created.
         * If it has that one will be returned, if not a new one will be created and cached.
         * @param options - The options for the program.
         * @returns A program using the same source
         */
        static from(options) {
          const key = `${options.vertex}:${options.fragment}`;
          if (!programCache[key]) {
            programCache[key] = new _GlProgram2(options);
            programCache[key]._cacheKey = key;
          }
          return programCache[key];
        }
      };
      _GlProgram.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
      };
      GlProgram = _GlProgram;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs
  function getAttributeInfoFromFormat(format) {
    var _a2;
    return (_a2 = attributeFormatData[format]) != null ? _a2 : attributeFormatData.float32;
  }
  var attributeFormatData;
  var init_getAttributeInfoFromFormat = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs"() {
      "use strict";
      attributeFormatData = {
        uint8x2: { size: 2, stride: 2, normalised: false },
        uint8x4: { size: 4, stride: 4, normalised: false },
        sint8x2: { size: 2, stride: 2, normalised: false },
        sint8x4: { size: 4, stride: 4, normalised: false },
        unorm8x2: { size: 2, stride: 2, normalised: true },
        unorm8x4: { size: 4, stride: 4, normalised: true },
        snorm8x2: { size: 2, stride: 2, normalised: true },
        snorm8x4: { size: 4, stride: 4, normalised: true },
        uint16x2: { size: 2, stride: 4, normalised: false },
        uint16x4: { size: 4, stride: 8, normalised: false },
        sint16x2: { size: 2, stride: 4, normalised: false },
        sint16x4: { size: 4, stride: 8, normalised: false },
        unorm16x2: { size: 2, stride: 4, normalised: true },
        unorm16x4: { size: 4, stride: 8, normalised: true },
        snorm16x2: { size: 2, stride: 4, normalised: true },
        snorm16x4: { size: 4, stride: 8, normalised: true },
        float16x2: { size: 2, stride: 4, normalised: false },
        float16x4: { size: 4, stride: 8, normalised: false },
        float32: { size: 1, stride: 4, normalised: false },
        float32x2: { size: 2, stride: 8, normalised: false },
        float32x3: { size: 3, stride: 12, normalised: false },
        float32x4: { size: 4, stride: 16, normalised: false },
        uint32: { size: 1, stride: 4, normalised: false },
        uint32x2: { size: 2, stride: 8, normalised: false },
        uint32x3: { size: 3, stride: 12, normalised: false },
        uint32x4: { size: 4, stride: 16, normalised: false },
        sint32: { size: 1, stride: 4, normalised: false },
        sint32x2: { size: 2, stride: 8, normalised: false },
        sint32x3: { size: 3, stride: 12, normalised: false },
        sint32x4: { size: 4, stride: 16, normalised: false }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs
  function extractAttributesFromGpuProgram({ source: source11, entryPoint }) {
    var _a2;
    const results = {};
    const mainVertStart = source11.indexOf(`fn ${entryPoint}`);
    if (mainVertStart !== -1) {
      const arrowFunctionStart = source11.indexOf("->", mainVertStart);
      if (arrowFunctionStart !== -1) {
        const functionArgsSubstring = source11.substring(mainVertStart, arrowFunctionStart);
        const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let match;
        while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
          const format = (_a2 = WGSL_TO_VERTEX_TYPES[match[3]]) != null ? _a2 : "float32";
          results[match[2]] = {
            location: parseInt(match[1], 10),
            format,
            stride: getAttributeInfoFromFormat(format).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return results;
  }
  var WGSL_TO_VERTEX_TYPES;
  var init_extractAttributesFromGpuProgram = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs"() {
      init_getAttributeInfoFromFormat();
      WGSL_TO_VERTEX_TYPES = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs
  function extractStructAndGroups(wgsl2) {
    var _a2, _b, _c;
    const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
    const groupPattern = /@group\((\d+)\)/;
    const bindingPattern = /@binding\((\d+)\)/;
    const namePattern = /var(<[^>]+>)? (\w+)/;
    const typePattern = /:\s*(\w+)/;
    const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
    const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
    const structName = /struct\s+(\w+)/;
    const groups = (_a2 = wgsl2.match(linePattern)) == null ? void 0 : _a2.map((item) => ({
      group: parseInt(item.match(groupPattern)[1], 10),
      binding: parseInt(item.match(bindingPattern)[1], 10),
      name: item.match(namePattern)[2],
      isUniform: item.match(namePattern)[1] === "<uniform>",
      type: item.match(typePattern)[1]
    }));
    if (!groups) {
      return {
        groups: [],
        structs: []
      };
    }
    const structs = (_c = (_b = wgsl2.match(structPattern)) == null ? void 0 : _b.map((struct) => {
      const name = struct.match(structName)[1];
      const members = struct.match(structMemberPattern).reduce((acc, member) => {
        const [name2, type] = member.split(":");
        acc[name2.trim()] = type.trim();
        return acc;
      }, {});
      if (!members) {
        return null;
      }
      return { name, members };
    }).filter(({ name }) => groups.some((group) => group.type === name))) != null ? _c : [];
    return {
      groups,
      structs
    };
  }
  var init_extractStructAndGroups = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
  var ShaderStage;
  var init_const5 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
      "use strict";
      ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
        ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
        ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
        ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
        return ShaderStage2;
      })(ShaderStage || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs
  function generateGpuLayoutGroups({ groups }) {
    const layout = [];
    for (let i3 = 0; i3 < groups.length; i3++) {
      const group = groups[i3];
      if (!layout[group.group]) {
        layout[group.group] = [];
      }
      if (group.isUniform) {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
          buffer: {
            type: "uniform"
          }
        });
      } else if (group.type === "sampler") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        });
      } else if (group.type === "texture_2d") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          texture: {
            sampleType: "float",
            viewDimension: "2d",
            multisampled: false
          }
        });
      }
    }
    return layout;
  }
  var init_generateGpuLayoutGroups = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs"() {
      init_const5();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs
  function generateLayoutHash({ groups }) {
    const layout = [];
    for (let i3 = 0; i3 < groups.length; i3++) {
      const group = groups[i3];
      if (!layout[group.group]) {
        layout[group.group] = {};
      }
      layout[group.group][group.name] = group.binding;
    }
    return layout;
  }
  var init_generateLayoutHash = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs
  function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
    const structNameSet = /* @__PURE__ */ new Set();
    const dupeGroupKeySet = /* @__PURE__ */ new Set();
    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
      if (structNameSet.has(struct.name)) {
        return false;
      }
      structNameSet.add(struct.name);
      return true;
    });
    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
      const key = `${group.name}-${group.binding}`;
      if (dupeGroupKeySet.has(key)) {
        return false;
      }
      dupeGroupKeySet.add(key);
      return true;
    });
    return { structs, groups };
  }
  var init_removeStructAndGroupDuplicates = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
  var programCache2, GpuProgram;
  var init_GpuProgram = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
      init_createIdFromString();
      init_extractAttributesFromGpuProgram();
      init_extractStructAndGroups();
      init_generateGpuLayoutGroups();
      init_generateLayoutHash();
      init_removeStructAndGroupDuplicates();
      programCache2 = /* @__PURE__ */ Object.create(null);
      GpuProgram = class _GpuProgram {
        /**
         * Create a new GpuProgram
         * @param options - The options for the gpu program
         */
        constructor(options) {
          var _a2, _b;
          this._layoutKey = 0;
          this._attributeLocationsKey = 0;
          const { fragment: fragment11, vertex: vertex6, layout, gpuLayout, name } = options;
          this.name = name;
          this.fragment = fragment11;
          this.vertex = vertex6;
          if (fragment11.source === vertex6.source) {
            const structsAndGroups = extractStructAndGroups(fragment11.source);
            this.structsAndGroups = structsAndGroups;
          } else {
            const vertexStructsAndGroups = extractStructAndGroups(vertex6.source);
            const fragmentStructsAndGroups = extractStructAndGroups(fragment11.source);
            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
          }
          this.layout = layout != null ? layout : generateLayoutHash(this.structsAndGroups);
          this.gpuLayout = gpuLayout != null ? gpuLayout : generateGpuLayoutGroups(this.structsAndGroups);
          this.autoAssignGlobalUniforms = !!(((_a2 = this.layout[0]) == null ? void 0 : _a2.globalUniforms) !== void 0);
          this.autoAssignLocalUniforms = !!(((_b = this.layout[1]) == null ? void 0 : _b.localUniforms) !== void 0);
          this._generateProgramKey();
        }
        // TODO maker this pure
        _generateProgramKey() {
          const { vertex: vertex6, fragment: fragment11 } = this;
          const bigKey = vertex6.source + fragment11.source + vertex6.entryPoint + fragment11.entryPoint;
          this._layoutKey = createIdFromString(bigKey, "program");
        }
        get attributeData() {
          var _a2;
          (_a2 = this._attributeData) != null ? _a2 : this._attributeData = extractAttributesFromGpuProgram(this.vertex);
          return this._attributeData;
        }
        /** destroys the program */
        destroy() {
          this.gpuLayout = null;
          this.layout = null;
          this.structsAndGroups = null;
          this.fragment = null;
          this.vertex = null;
          programCache2[this._cacheKey] = null;
        }
        /**
         * Helper function that creates a program for a given source.
         * It will check the program cache if the program has already been created.
         * If it has that one will be returned, if not a new one will be created and cached.
         * @param options - The options for the program.
         * @returns A program using the same source
         */
        static from(options) {
          const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
          if (!programCache2[key]) {
            programCache2[key] = new _GpuProgram(options);
            programCache2[key]._cacheKey = key;
          }
          return programCache2[key];
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
  function addBits(srcParts, parts, name) {
    if (srcParts) {
      for (const i3 in srcParts) {
        const id = i3.toLocaleLowerCase();
        const part = parts[id];
        if (part) {
          let sanitisedPart = srcParts[i3];
          if (i3 === "header") {
            sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
          }
          if (name) {
            part.push(`//----${name}----//`);
          }
          part.push(sanitisedPart);
        } else {
          warn(`${i3} placement hook does not exist in shader`);
        }
      }
    }
  }
  var init_addBits = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
      init_warn();
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
  function compileHooks(programSrc) {
    var _a2, _b;
    const parts = {};
    const partMatches = (_b = (_a2 = programSrc.match(findHooksRx)) == null ? void 0 : _a2.map((hook) => hook.replace(/[{()}]/g, ""))) != null ? _b : [];
    partMatches.forEach((hook) => {
      parts[hook] = [];
    });
    return parts;
  }
  var findHooksRx;
  var init_compileHooks = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
      "use strict";
      findHooksRx = /\{\{(.*?)\}\}/g;
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
  function extractInputs(fragmentSource, out2) {
    let match;
    const regex = /@in\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function compileInputs(fragments, template, sort = false) {
    const results = [];
    extractInputs(template, results);
    fragments.forEach((fragment11) => {
      if (fragment11.header) {
        extractInputs(fragment11.header, results);
      }
    });
    const mainInput = results;
    if (sort) {
      mainInput.sort();
    }
    const finalString = mainInput.map((inValue, i3) => `       @location(${i3}) ${inValue},`).join("\n");
    let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
    cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
    return cleanedString;
  }
  var init_compileInputs = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
  function extractOutputs(fragmentSource, out2) {
    let match;
    const regex = /@out\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function extractVariableName(value) {
    const regex = /\b(\w+)\s*:/g;
    const match = regex.exec(value);
    return match ? match[1] : "";
  }
  function stripVariable(value) {
    const regex = /@.*?\s+/g;
    return value.replace(regex, "");
  }
  function compileOutputs(fragments, template) {
    const results = [];
    extractOutputs(template, results);
    fragments.forEach((fragment11) => {
      if (fragment11.header) {
        extractOutputs(fragment11.header, results);
      }
    });
    let index = 0;
    const mainStruct = results.sort().map((inValue) => {
      if (inValue.indexOf("builtin") > -1) {
        return inValue;
      }
      return `@location(${index++}) ${inValue}`;
    }).join(",\n");
    const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
    const mainEnd = `return VSOutput(
            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
    let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
    compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
    compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
    compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
    return compiledCode;
  }
  var init_compileOutputs = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
  function injectBits(templateSrc, fragmentParts) {
    let out2 = templateSrc;
    for (const i3 in fragmentParts) {
      const parts = fragmentParts[i3];
      const toInject = parts.join("\n");
      if (toInject.length) {
        out2 = out2.replace(`{{${i3}}}`, `//-----${i3} START-----//
${parts.join("\n")}
//----${i3} FINISH----//`);
      } else {
        out2 = out2.replace(`{{${i3}}}`, "");
      }
    }
    return out2;
  }
  var init_injectBits = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
  function compileHighShader({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    const { vertex: vertex6, fragment: fragment11 } = compileInputsAndOutputs(template, bits);
    cacheMap[cacheId] = compileBits(vertex6, fragment11, bits);
    return cacheMap[cacheId];
  }
  function compileHighShaderGl({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
    return cacheMap[cacheId];
  }
  function compileInputsAndOutputs(template, bits) {
    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
    compiledVertex = compileOutputs(vertexFragments, compiledVertex);
    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
    return {
      vertex: compiledVertex,
      fragment: compiledFragment
    };
  }
  function generateCacheId(template, bits) {
    return bits.map((highFragment) => {
      if (!bitCacheMap.has(highFragment)) {
        bitCacheMap.set(highFragment, CACHE_UID++);
      }
      return bitCacheMap.get(highFragment);
    }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
  }
  function compileBits(vertex6, fragment11, bits) {
    const vertexParts = compileHooks(vertex6);
    const fragmentParts = compileHooks(fragment11);
    bits.forEach((shaderBit) => {
      addBits(shaderBit.vertex, vertexParts, shaderBit.name);
      addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
    });
    return {
      vertex: injectBits(vertex6, vertexParts),
      fragment: injectBits(fragment11, fragmentParts)
    };
  }
  var cacheMap, bitCacheMap, CACHE_UID;
  var init_compileHighShader = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
      init_addBits();
      init_compileHooks();
      init_compileInputs();
      init_compileOutputs();
      init_injectBits();
      cacheMap = /* @__PURE__ */ Object.create(null);
      bitCacheMap = /* @__PURE__ */ new Map();
      CACHE_UID = 0;
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
  var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
  var init_defaultProgramTemplate = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
      "use strict";
      vertexGPUTemplate = /* wgsl */
      `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`;
      fragmentGPUTemplate = /* wgsl */
      `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`;
      vertexGlTemplate = /* glsl */
      `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`;
      fragmentGlTemplate = /* glsl */
      `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`;
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
  var globalUniformsBit, globalUniformsUBOBitGl, globalUniformsBitGl;
  var init_globalUniformsBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
      "use strict";
      globalUniformsBit = {
        name: "global-uniforms-bit",
        vertex: {
          header: (
            /* wgsl */
            `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
          )
        }
      };
      globalUniformsUBOBitGl = {
        name: "global-uniforms-ubo-bit",
        vertex: {
          header: (
            /* glsl */
            `
          uniform globalUniforms {
            mat3 uProjectionMatrix;
            mat3 uWorldTransformMatrix;
            vec4 uWorldColorAlpha;
            vec2 uResolution;
          };
        `
          )
        }
      };
      globalUniformsBitGl = {
        name: "global-uniforms-bit",
        vertex: {
          header: (
            /* glsl */
            `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
  function compileHighShaderGpuProgram({ bits, name }) {
    const source11 = compileHighShader({
      template: {
        fragment: fragmentGPUTemplate,
        vertex: vertexGPUTemplate
      },
      bits: [
        globalUniformsBit,
        ...bits
      ]
    });
    return GpuProgram.from({
      name,
      vertex: {
        source: source11.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: source11.fragment,
        entryPoint: "main"
      }
    });
  }
  function compileHighShaderGlProgram({ bits, name }) {
    return new GlProgram(__spreadValues({
      name
    }, compileHighShaderGl({
      template: {
        vertex: vertexGlTemplate,
        fragment: fragmentGlTemplate
      },
      bits: [
        globalUniformsBitGl,
        ...bits
      ]
    })));
  }
  var init_compileHighShaderToProgram = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_compileHighShader();
      init_defaultProgramTemplate();
      init_globalUniformsBit();
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
  var colorBit, colorBitGl;
  var init_colorBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
      "use strict";
      colorBit = {
        name: "color-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            @in aColor: vec4<f32>;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
          )
        }
      };
      colorBitGl = {
        name: "color-bit",
        vertex: {
          header: (
            /* glsl */
            `
            in vec4 aColor;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
  function generateBindingSrc(maxTextures) {
    const src = [];
    if (maxTextures === 1) {
      src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
      src.push("@group(1) @binding(1) var textureSampler1: sampler;");
    } else {
      let bindingIndex = 0;
      for (let i3 = 0; i3 < maxTextures; i3++) {
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i3 + 1}: texture_2d<f32>;`);
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i3 + 1}: sampler;`);
      }
    }
    return src.join("\n");
  }
  function generateSampleSrc(maxTextures) {
    const src = [];
    if (maxTextures === 1) {
      src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    } else {
      src.push("switch vTextureId {");
      for (let i3 = 0; i3 < maxTextures; i3++) {
        if (i3 === maxTextures - 1) {
          src.push(`  default:{`);
        } else {
          src.push(`  case ${i3}:{`);
        }
        src.push(`      outColor = textureSampleGrad(textureSource${i3 + 1}, textureSampler${i3 + 1}, vUV, uvDx, uvDy);`);
        src.push(`      break;}`);
      }
      src.push(`}`);
    }
    return src.join("\n");
  }
  function generateTextureBatchBit(maxTextures) {
    if (!textureBatchBitGpuCache[maxTextures]) {
      textureBatchBitGpuCache[maxTextures] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
        },
        fragment: {
          header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures)}
            `,
          main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures)}
            `
        }
      };
    }
    return textureBatchBitGpuCache[maxTextures];
  }
  function generateSampleGlSrc(maxTextures) {
    const src = [];
    for (let i3 = 0; i3 < maxTextures; i3++) {
      if (i3 > 0) {
        src.push("else");
      }
      if (i3 < maxTextures - 1) {
        src.push(`if(vTextureId < ${i3}.5)`);
      }
      src.push("{");
      src.push(`	outColor = texture(uTextures[${i3}], vUV);`);
      src.push("}");
    }
    return src.join("\n");
  }
  function generateTextureBatchBitGl(maxTextures) {
    if (!textureBatchBitGlCache[maxTextures]) {
      textureBatchBitGlCache[maxTextures] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
        },
        fragment: {
          header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures}];

            `,
          main: `

                ${generateSampleGlSrc(maxTextures)}
            `
        }
      };
    }
    return textureBatchBitGlCache[maxTextures];
  }
  var textureBatchBitGpuCache, textureBatchBitGlCache;
  var init_generateTextureBatchBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
      "use strict";
      textureBatchBitGpuCache = {};
      textureBatchBitGlCache = {};
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
  var roundPixelsBit, roundPixelsBitGl;
  var init_roundPixelsBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
      "use strict";
      roundPixelsBit = {
        name: "round-pixels-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
          )
        }
      };
      roundPixelsBitGl = {
        name: "round-pixels-bit",
        vertex: {
          header: (
            /* glsl */
            `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs
  var UNIFORM_TYPES_VALUES, UNIFORM_TYPES_MAP;
  var init_types = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs"() {
      "use strict";
      UNIFORM_TYPES_VALUES = [
        "f32",
        "i32",
        "vec2<f32>",
        "vec3<f32>",
        "vec4<f32>",
        "mat2x2<f32>",
        "mat3x3<f32>",
        "mat4x4<f32>",
        "mat3x2<f32>",
        "mat4x2<f32>",
        "mat2x3<f32>",
        "mat4x3<f32>",
        "mat2x4<f32>",
        "mat3x4<f32>",
        "vec2<i32>",
        "vec3<i32>",
        "vec4<i32>"
      ];
      UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
        acc[type] = true;
        return acc;
      }, {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs
  function getDefaultUniformValue(type, size) {
    switch (type) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * size);
      case "vec3<f32>":
        return new Float32Array(3 * size);
      case "vec4<f32>":
        return new Float32Array(4 * size);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_getDefaultUniformValue = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
  var _UniformGroup, UniformGroup;
  var init_UniformGroup = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
      init_uid();
      init_createIdFromString();
      init_types();
      init_getDefaultUniformValue();
      _UniformGroup = class _UniformGroup2 {
        /**
         * Create a new Uniform group
         * @param uniformStructures - The structures of the uniform group
         * @param options - The optional parameters of this uniform group
         */
        constructor(uniformStructures, options) {
          var _a2, _b;
          this._touched = 0;
          this.uid = uid2("uniform");
          this._resourceType = "uniformGroup";
          this._resourceId = uid2("resource");
          this.isUniformGroup = true;
          this._dirtyId = 0;
          this.destroyed = false;
          options = __spreadValues(__spreadValues({}, _UniformGroup2.defaultOptions), options);
          this.uniformStructures = uniformStructures;
          const uniforms = {};
          for (const i3 in uniformStructures) {
            const uniformData = uniformStructures[i3];
            uniformData.name = i3;
            uniformData.size = (_a2 = uniformData.size) != null ? _a2 : 1;
            if (!UNIFORM_TYPES_MAP[uniformData.type]) {
              const arrayMatch = uniformData.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
              if (arrayMatch) {
                const [, innerType, size] = arrayMatch;
                throw new Error(
                  `Uniform type ${uniformData.type} is not supported. Use type: '${innerType}', size: ${size} instead.`
                );
              }
              throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
            }
            (_b = uniformData.value) != null ? _b : uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size);
            uniforms[i3] = uniformData.value;
          }
          this.uniforms = uniforms;
          this._dirtyId = 1;
          this.ubo = options.ubo;
          this.isStatic = options.isStatic;
          this._signature = createIdFromString(Object.keys(uniforms).map(
            (i3) => `${i3}-${uniformStructures[i3].type}`
          ).join("-"), "uniform-group");
        }
        /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
        update() {
          this._dirtyId++;
        }
      };
      _UniformGroup.defaultOptions = {
        /** if true the UniformGroup is handled as an Uniform buffer object. */
        ubo: false,
        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
        isStatic: false
      };
      UniformGroup = _UniformGroup;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs
  function getBatchSamplersUniformGroup(maxTextures) {
    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];
    if (batchSamplersUniformGroup)
      return batchSamplersUniformGroup;
    const sampleValues = new Int32Array(maxTextures);
    for (let i3 = 0; i3 < maxTextures; i3++) {
      sampleValues[i3] = i3;
    }
    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({
      uTextures: { value: sampleValues, type: `i32`, size: maxTextures }
    }, { isStatic: true });
    return batchSamplersUniformGroup;
  }
  var batchSamplersUniformGroupHash;
  var init_getBatchSamplersUniformGroup = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs"() {
      init_UniformGroup();
      batchSamplersUniformGroupHash = {};
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/types.mjs
  var RendererType;
  var init_types2 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/types.mjs"() {
      "use strict";
      RendererType = /* @__PURE__ */ ((RendererType2) => {
        RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
        RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
        RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
        return RendererType2;
      })(RendererType || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
  var Shader;
  var init_Shader = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
      init_eventemitter3();
      init_uid();
      init_GlProgram();
      init_BindGroup();
      init_GpuProgram();
      init_types2();
      init_UniformGroup();
      Shader = class _Shader extends eventemitter3_default {
        constructor(options) {
          super();
          this.uid = uid2("shader");
          this._uniformBindMap = /* @__PURE__ */ Object.create(null);
          this._ownedBindGroups = [];
          this._destroyed = false;
          let {
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            groups,
            resources,
            compatibleRenderers,
            groupMap
          } = options;
          this.gpuProgram = gpuProgram3;
          this.glProgram = glProgram3;
          if (compatibleRenderers === void 0) {
            compatibleRenderers = 0;
            if (gpuProgram3)
              compatibleRenderers |= RendererType.WEBGPU;
            if (glProgram3)
              compatibleRenderers |= RendererType.WEBGL;
          }
          this.compatibleRenderers = compatibleRenderers;
          const nameHash = {};
          if (!resources && !groups) {
            resources = {};
          }
          if (resources && groups) {
            throw new Error("[Shader] Cannot have both resources and groups");
          } else if (!gpuProgram3 && groups && !groupMap) {
            throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
          } else if (!gpuProgram3 && groups && groupMap) {
            for (const i3 in groupMap) {
              for (const j2 in groupMap[i3]) {
                const uniformName = groupMap[i3][j2];
                nameHash[uniformName] = {
                  group: i3,
                  binding: j2,
                  name: uniformName
                };
              }
            }
          } else if (gpuProgram3 && groups && !groupMap) {
            const groupData = gpuProgram3.structsAndGroups.groups;
            groupMap = {};
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          } else if (resources) {
            groups = {};
            groupMap = {};
            if (gpuProgram3) {
              const groupData = gpuProgram3.structsAndGroups.groups;
              groupData.forEach((data) => {
                groupMap[data.group] = groupMap[data.group] || {};
                groupMap[data.group][data.binding] = data.name;
                nameHash[data.name] = data;
              });
            }
            let bindTick = 0;
            for (const i3 in resources) {
              if (nameHash[i3])
                continue;
              if (!groups[99]) {
                groups[99] = new BindGroup();
                this._ownedBindGroups.push(groups[99]);
              }
              nameHash[i3] = { group: 99, binding: bindTick, name: i3 };
              groupMap[99] = groupMap[99] || {};
              groupMap[99][bindTick] = i3;
              bindTick++;
            }
            for (const i3 in resources) {
              const name = i3;
              let value = resources[i3];
              if (!value.source && !value._resourceType) {
                value = new UniformGroup(value);
              }
              const data = nameHash[name];
              if (data) {
                if (!groups[data.group]) {
                  groups[data.group] = new BindGroup();
                  this._ownedBindGroups.push(groups[data.group]);
                }
                groups[data.group].setResource(value, data.binding);
              }
            }
          }
          this.groups = groups;
          this._uniformBindMap = groupMap;
          this.resources = this._buildResourceAccessor(groups, nameHash);
        }
        /**
         * Sometimes a resource group will be provided later (for example global uniforms)
         * In such cases, this method can be used to let the shader know about the group.
         * @param name - the name of the resource group
         * @param groupIndex - the index of the group (should match the webGPU shader group location)
         * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
         */
        addResource(name, groupIndex, bindIndex) {
          var _a2, _b;
          (_a2 = this._uniformBindMap)[groupIndex] || (_a2[groupIndex] = {});
          (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
          if (!this.groups[groupIndex]) {
            this.groups[groupIndex] = new BindGroup();
            this._ownedBindGroups.push(this.groups[groupIndex]);
          }
        }
        _buildResourceAccessor(groups, nameHash) {
          const uniformsOut = {};
          for (const i3 in nameHash) {
            const data = nameHash[i3];
            Object.defineProperty(uniformsOut, data.name, {
              get() {
                return groups[data.group].getResource(data.binding);
              },
              set(value) {
                groups[data.group].setResource(value, data.binding);
              }
            });
          }
          return uniformsOut;
        }
        /**
         * Use to destroy the shader when its not longer needed.
         * It will destroy the resources and remove listeners.
         * @param destroyPrograms - if the programs should be destroyed as well.
         * Make sure its not being used by other shaders!
         */
        destroy(destroyPrograms = false) {
          var _a2, _b;
          if (this._destroyed)
            return;
          this._destroyed = true;
          this.emit("destroy", this);
          if (destroyPrograms) {
            (_a2 = this.gpuProgram) == null ? void 0 : _a2.destroy();
            (_b = this.glProgram) == null ? void 0 : _b.destroy();
          }
          this.gpuProgram = null;
          this.glProgram = null;
          this.removeAllListeners();
          this._uniformBindMap = null;
          this._ownedBindGroups.forEach((bindGroup) => {
            bindGroup.destroy();
          });
          this._ownedBindGroups = null;
          this.resources = null;
          this.groups = null;
        }
        static from(options) {
          const _a2 = options, { gpu, gl } = _a2, rest = __objRest(_a2, ["gpu", "gl"]);
          let gpuProgram3;
          let glProgram3;
          if (gpu) {
            gpuProgram3 = GpuProgram.from(gpu);
          }
          if (gl) {
            glProgram3 = GlProgram.from(gl);
          }
          return new _Shader(__spreadValues({
            gpuProgram: gpuProgram3,
            glProgram: glProgram3
          }, rest));
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs
  var DefaultShader;
  var init_DefaultShader = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs"() {
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader();
      DefaultShader = class extends Shader {
        constructor(maxTextures) {
          const glProgram3 = compileHighShaderGlProgram({
            name: "batch",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures),
              roundPixelsBitGl
            ]
          });
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "batch",
            bits: [
              colorBit,
              generateTextureBatchBit(maxTextures),
              roundPixelsBit
            ]
          });
          super({
            glProgram: glProgram3,
            gpuProgram: gpuProgram3,
            resources: {
              batchSamplers: getBatchSamplersUniformGroup(maxTextures)
            }
          });
          this.maxTextures = maxTextures;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs
  var defaultShader, _DefaultBatcher, DefaultBatcher;
  var init_DefaultBatcher = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs"() {
      init_Extensions();
      init_Batcher();
      init_BatchGeometry();
      init_DefaultShader();
      defaultShader = null;
      _DefaultBatcher = class _DefaultBatcher2 extends Batcher {
        constructor(options) {
          super(options);
          this.geometry = new BatchGeometry();
          this.name = _DefaultBatcher2.extension.name;
          this.vertexSize = 6;
          defaultShader != null ? defaultShader : defaultShader = new DefaultShader(options.maxTextures);
          this.shader = defaultShader;
        }
        /**
         * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
         * @param element - The DefaultBatchableMeshElement to pack.
         * @param float32View - The Float32Array view to pack into.
         * @param uint32View - The Uint32Array view to pack into.
         * @param index - The starting index in the views.
         * @param textureId - The texture ID to use.
         */
        packAttributes(element, float32View, uint32View, index, textureId) {
          const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
          const wt = element.transform;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const { positions, uvs } = element;
          const argb = element.color;
          const offset = element.attributeOffset;
          const end = offset + element.attributeSize;
          for (let i3 = offset; i3 < end; i3++) {
            const i22 = i3 * 2;
            const x2 = positions[i22];
            const y2 = positions[i22 + 1];
            float32View[index++] = a2 * x2 + c2 * y2 + tx;
            float32View[index++] = d2 * y2 + b2 * x2 + ty;
            float32View[index++] = uvs[i22];
            float32View[index++] = uvs[i22 + 1];
            uint32View[index++] = argb;
            uint32View[index++] = textureIdAndRound;
          }
        }
        /**
         * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
         * @param element - The DefaultBatchableQuadElement to pack.
         * @param float32View - The Float32Array view to pack into.
         * @param uint32View - The Uint32Array view to pack into.
         * @param index - The starting index in the views.
         * @param textureId - The texture ID to use.
         */
        packQuadAttributes(element, float32View, uint32View, index, textureId) {
          const texture = element.texture;
          const wt = element.transform;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const bounds = element.bounds;
          const w0 = bounds.maxX;
          const w1 = bounds.minX;
          const h0 = bounds.maxY;
          const h1 = bounds.minY;
          const uvs = texture.uvs;
          const argb = element.color;
          const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
          float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
          float32View[index + 1] = d2 * h1 + b2 * w1 + ty;
          float32View[index + 2] = uvs.x0;
          float32View[index + 3] = uvs.y0;
          uint32View[index + 4] = argb;
          uint32View[index + 5] = textureIdAndRound;
          float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
          float32View[index + 7] = d2 * h1 + b2 * w0 + ty;
          float32View[index + 8] = uvs.x1;
          float32View[index + 9] = uvs.y1;
          uint32View[index + 10] = argb;
          uint32View[index + 11] = textureIdAndRound;
          float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
          float32View[index + 13] = d2 * h0 + b2 * w0 + ty;
          float32View[index + 14] = uvs.x2;
          float32View[index + 15] = uvs.y2;
          uint32View[index + 16] = argb;
          uint32View[index + 17] = textureIdAndRound;
          float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
          float32View[index + 19] = d2 * h0 + b2 * w1 + ty;
          float32View[index + 20] = uvs.x3;
          float32View[index + 21] = uvs.y3;
          uint32View[index + 22] = argb;
          uint32View[index + 23] = textureIdAndRound;
        }
        /**
         * Updates the maximum number of textures that can be used in the shader.
         * @param maxTextures - The maximum number of textures that can be used in the shader.
         * @internal
         */
        _updateMaxTextures(maxTextures) {
          if (this.shader.maxTextures === maxTextures)
            return;
          defaultShader = new DefaultShader(maxTextures);
          this.shader = defaultShader;
        }
        destroy() {
          this.shader = null;
          super.destroy();
        }
      };
      _DefaultBatcher.extension = {
        type: [
          ExtensionType.Batcher
        ],
        name: "default"
      };
      DefaultBatcher = _DefaultBatcher;
    }
  });

  // node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs
  var GCManagedHash;
  var init_GCManagedHash = __esm({
    "node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs"() {
      "use strict";
      GCManagedHash = class {
        constructor(options) {
          this.items = /* @__PURE__ */ Object.create(null);
          const { renderer, type, onUnload, priority, name } = options;
          this._renderer = renderer;
          renderer.gc.addResourceHash(this, "items", type, priority != null ? priority : 0);
          this._onUnload = onUnload;
          this.name = name;
        }
        /**
         * Add an item to the hash. No-op if already added.
         * @param item
         * @returns true if the item was added, false if it was already in the hash
         */
        add(item) {
          if (this.items[item.uid])
            return false;
          this.items[item.uid] = item;
          item.once("unload", this.remove, this);
          item._gcLastUsed = this._renderer.gc.now;
          return true;
        }
        remove(item, ...args) {
          var _a2;
          if (!this.items[item.uid])
            return;
          const gpuData = item._gpuData[this._renderer.uid];
          if (!gpuData)
            return;
          (_a2 = this._onUnload) == null ? void 0 : _a2.call(this, item, ...args);
          gpuData.destroy();
          item._gpuData[this._renderer.uid] = null;
          this.items[item.uid] = null;
        }
        removeAll(...args) {
          Object.values(this.items).forEach((item) => item && this.remove(item, ...args));
        }
        destroy(...args) {
          this.removeAll(...args);
          this.items = /* @__PURE__ */ Object.create(null);
          this._renderer = null;
          this._onUnload = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
  function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
    let index = 0;
    verticesOffset *= verticesStride;
    uvsOffset *= uvsStride;
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    while (index < size) {
      const x2 = vertices[verticesOffset];
      const y2 = vertices[verticesOffset + 1];
      uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
      uvs[uvsOffset + 1] = b2 * x2 + d2 * y2 + ty;
      uvsOffset += uvsStride;
      verticesOffset += verticesStride;
      index++;
    }
  }
  function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
    let index = 0;
    uvsOffset *= uvsStride;
    while (index < size) {
      uvs[uvsOffset] = 0;
      uvs[uvsOffset + 1] = 0;
      uvsOffset += uvsStride;
      index++;
    }
  }
  var init_buildUvs = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
  function transformVertices(vertices, m2, offset, stride, size) {
    const a2 = m2.a;
    const b2 = m2.b;
    const c2 = m2.c;
    const d2 = m2.d;
    const tx = m2.tx;
    const ty = m2.ty;
    offset || (offset = 0);
    stride || (stride = 2);
    size || (size = vertices.length / stride - offset);
    let index = offset * stride;
    for (let i3 = 0; i3 < size; i3++) {
      const x2 = vertices[index];
      const y2 = vertices[index + 1];
      vertices[index] = a2 * x2 + c2 * y2 + tx;
      vertices[index + 1] = b2 * x2 + d2 * y2 + ty;
      index += stride;
    }
  }
  var init_transformVertices = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
  var identityMatrix2, BatchableGraphics;
  var init_BatchableGraphics = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
      init_Matrix();
      init_multiplyHexColors();
      identityMatrix2 = new Matrix();
      BatchableGraphics = class {
        constructor() {
          this.packAsQuad = false;
          this.batcherName = "default";
          this.topology = "triangle-list";
          this.applyTransform = true;
          this.roundPixels = 0;
          this._batcher = null;
          this._batch = null;
        }
        get uvs() {
          return this.geometryData.uvs;
        }
        get positions() {
          return this.geometryData.vertices;
        }
        get indices() {
          return this.geometryData.indices;
        }
        get blendMode() {
          if (this.renderable && this.applyTransform) {
            return this.renderable.groupBlendMode;
          }
          return "normal";
        }
        get color() {
          const rgb = this.baseColor;
          const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
          const renderable = this.renderable;
          if (renderable) {
            return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
          }
          return bgr + (this.alpha * 255 << 24);
        }
        get transform() {
          var _a2;
          return ((_a2 = this.renderable) == null ? void 0 : _a2.groupTransform) || identityMatrix2;
        }
        copyTo(gpuBuffer) {
          gpuBuffer.indexOffset = this.indexOffset;
          gpuBuffer.indexSize = this.indexSize;
          gpuBuffer.attributeOffset = this.attributeOffset;
          gpuBuffer.attributeSize = this.attributeSize;
          gpuBuffer.baseColor = this.baseColor;
          gpuBuffer.alpha = this.alpha;
          gpuBuffer.texture = this.texture;
          gpuBuffer.geometryData = this.geometryData;
          gpuBuffer.topology = this.topology;
        }
        reset() {
          this.applyTransform = true;
          this.renderable = null;
          this.topology = "triangle-list";
        }
        destroy() {
          this.renderable = null;
          this.texture = null;
          this.geometryData = null;
          this._batcher = null;
          this._batch = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
  var buildCircle, buildEllipse, buildRoundedRectangle;
  var init_buildCircle = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
      init_Extensions();
      buildCircle = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "circle"
        },
        build(shape, points) {
          let x2;
          let y2;
          let dx;
          let dy;
          let rx;
          let ry;
          if (shape.type === "circle") {
            const circle = shape;
            rx = ry = circle.radius;
            if (rx <= 0) {
              return false;
            }
            x2 = circle.x;
            y2 = circle.y;
            dx = dy = 0;
          } else if (shape.type === "ellipse") {
            const ellipse = shape;
            rx = ellipse.halfWidth;
            ry = ellipse.halfHeight;
            if (rx <= 0 || ry <= 0) {
              return false;
            }
            x2 = ellipse.x;
            y2 = ellipse.y;
            dx = dy = 0;
          } else {
            const roundedRect = shape;
            const halfWidth = roundedRect.width / 2;
            const halfHeight = roundedRect.height / 2;
            x2 = roundedRect.x + halfWidth;
            y2 = roundedRect.y + halfHeight;
            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
            dx = halfWidth - rx;
            dy = halfHeight - ry;
          }
          if (dx < 0 || dy < 0) {
            return false;
          }
          const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
          const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
          if (m2 === 0) {
            return false;
          }
          if (n2 === 0) {
            points[0] = points[6] = x2 + dx;
            points[1] = points[3] = y2 + dy;
            points[2] = points[4] = x2 - dx;
            points[5] = points[7] = y2 - dy;
            return true;
          }
          let j1 = 0;
          let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
          let j3 = j2;
          let j4 = m2;
          let x0 = dx + rx;
          let y0 = dy;
          let x1 = x2 + x0;
          let x22 = x2 - x0;
          let y1 = y2 + y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j2] = y1;
          points[--j2] = x22;
          if (dy) {
            const y222 = y2 - y0;
            points[j3++] = x22;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x1;
          }
          for (let i3 = 1; i3 < n2; i3++) {
            const a2 = Math.PI / 2 * (i3 / n2);
            const x02 = dx + Math.cos(a2) * rx;
            const y02 = dy + Math.sin(a2) * ry;
            const x12 = x2 + x02;
            const x222 = x2 - x02;
            const y12 = y2 + y02;
            const y222 = y2 - y02;
            points[j1++] = x12;
            points[j1++] = y12;
            points[--j2] = y12;
            points[--j2] = x222;
            points[j3++] = x222;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x12;
          }
          x0 = dx;
          y0 = dy + ry;
          x1 = x2 + x0;
          x22 = x2 - x0;
          y1 = y2 + y0;
          const y22 = y2 - y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x1;
          if (dx) {
            points[j1++] = x22;
            points[j1++] = y1;
            points[--j4] = y22;
            points[--j4] = x22;
          }
          return true;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          if (points.length === 0) {
            return;
          }
          let centerX = 0;
          let centerY = 0;
          for (let i3 = 0; i3 < points.length; i3 += 2) {
            centerX += points[i3];
            centerY += points[i3 + 1];
          }
          centerX /= points.length / 2;
          centerY /= points.length / 2;
          let count2 = verticesOffset;
          vertices[count2 * verticesStride] = centerX;
          vertices[count2 * verticesStride + 1] = centerY;
          const centerIndex = count2++;
          for (let i3 = 0; i3 < points.length; i3 += 2) {
            vertices[count2 * verticesStride] = points[i3];
            vertices[count2 * verticesStride + 1] = points[i3 + 1];
            if (i3 > 0) {
              indices[indicesOffset++] = count2;
              indices[indicesOffset++] = centerIndex;
              indices[indicesOffset++] = count2 - 1;
            }
            count2++;
          }
          indices[indicesOffset++] = centerIndex + 1;
          indices[indicesOffset++] = centerIndex;
          indices[indicesOffset++] = count2 - 1;
        }
      };
      buildEllipse = __spreadProps(__spreadValues({}, buildCircle), { extension: __spreadProps(__spreadValues({}, buildCircle.extension), { name: "ellipse" }) });
      buildRoundedRectangle = __spreadProps(__spreadValues({}, buildCircle), { extension: __spreadProps(__spreadValues({}, buildCircle.extension), { name: "roundedRectangle" }) });
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
  var closePointEps, curveEps;
  var init_const6 = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/const.mjs"() {
      "use strict";
      closePointEps = 1e-4;
      curveEps = 1e-4;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
  function getOrientationOfPoints(points) {
    const m2 = points.length;
    if (m2 < 6) {
      return 1;
    }
    let area2 = 0;
    for (let i3 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i3 < m2; i3 += 2) {
      const x2 = points[i3];
      const y2 = points[i3 + 1];
      area2 += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    if (area2 < 0) {
      return -1;
    }
    return 1;
  }
  var init_getOrientationOfPoints = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
  function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x2 - nx * innerWeight;
    const iy = y2 - ny * innerWeight;
    const ox = x2 + nx * outerWeight;
    const oy = y2 + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    const eix = ix + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i3 = 1, angle = startAngle; i3 < segCount; i3++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i3 = 1, angle = startAngle; i3 < segCount; i3++, angle += angleInc) {
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }
  function buildLine(points, lineStyle, flipAlignment, closed2, vertices, indices) {
    const eps = closePointEps;
    if (points.length === 0) {
      return;
    }
    const style = lineStyle;
    let alignment = style.alignment;
    if (lineStyle.alignment !== 0.5) {
      let orientation = getOrientationOfPoints(points);
      if (flipAlignment)
        orientation *= -1;
      alignment = (alignment - 0.5) * orientation + 0.5;
    }
    const firstPoint = new Point(points[0], points[1]);
    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    const closedShape = closed2;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    const verts = vertices;
    const length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width = style.width / 2;
    const widthSquared = width * width;
    const miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x2 = 0;
    let y2 = 0;
    let perpX = -(y0 - y1);
    let perpY = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    const ratio = alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(
          x0 - perpX * (innerWeight - outerWeight) * 0.5,
          y0 - perpY * (innerWeight - outerWeight) * 0.5,
          x0 - perpX * innerWeight,
          y0 - perpY * innerWeight,
          x0 + perpX * outerWeight,
          y0 + perpY * outerWeight,
          verts,
          true
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(
      x0 - perpX * innerWeight,
      y0 - perpY * innerWeight
    );
    verts.push(
      x0 + perpX * outerWeight,
      y0 + perpY * outerWeight
    );
    for (let i3 = 1; i3 < length - 1; ++i3) {
      x0 = points[(i3 - 1) * 2];
      y0 = points[(i3 - 1) * 2 + 1];
      x1 = points[i3 * 2];
      y1 = points[i3 * 2 + 1];
      x2 = points[(i3 + 1) * 2];
      y2 = points[(i3 + 1) * 2 + 1];
      perpX = -(y0 - y1);
      perpY = x0 - x1;
      dist = Math.sqrt(perpX * perpX + perpY * perpY);
      perpX /= dist;
      perpY /= dist;
      perpX *= width;
      perpY *= width;
      perp1x = -(y1 - y2);
      perp1y = x1 - x2;
      dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist;
      perp1y /= dist;
      perp1x *= width;
      perp1y *= width;
      const dx0 = x1 - x0;
      const dy0 = y0 - y1;
      const dx1 = x1 - x2;
      const dy1 = y2 - y1;
      const dot = dx0 * dx1 + dy0 * dy1;
      const cross = dy0 * dx1 - dy1 * dx0;
      const clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
        verts.push(
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight
        );
        verts.push(
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight
        );
        if (dot >= 0) {
          if (style.join === "round") {
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
          } else {
            indexCount += 2;
          }
          verts.push(
            x1 - perp1x * outerWeight,
            y1 - perp1y * outerWeight
          );
          verts.push(
            x1 + perp1x * innerWeight,
            y1 + perp1y * innerWeight
          );
        }
        continue;
      }
      const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
      const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
      const px = (dx0 * c2 - dx1 * c1) / cross;
      const py = (dy1 * c1 - dy0 * c2) / cross;
      const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      const imx = x1 + (px - x1) * innerWeight;
      const imy = y1 + (py - y1) * innerWeight;
      const omx = x1 - (px - x1) * outerWeight;
      const omy = y1 - (py - y1) * outerWeight;
      const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      const insideWeight = clockwise ? innerWeight : outerWeight;
      const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      const insideMiterOk = pDist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === "round") {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            indexCount += round(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
        verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
        if (style.join === "round") {
          if (clockwise) {
            indexCount += round(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 2;
          } else {
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 2;
          }
        } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(
          x1 - perpX * (innerWeight - outerWeight) * 0.5,
          y1 - perpY * (innerWeight - outerWeight) * 0.5,
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight,
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight,
          verts,
          false
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
      }
    }
    const eps2 = curveEps * curveEps;
    for (let i3 = indexStart; i3 < indexCount + indexStart - 2; ++i3) {
      x0 = verts[i3 * 2];
      y0 = verts[i3 * 2 + 1];
      x1 = verts[(i3 + 1) * 2];
      y1 = verts[(i3 + 1) * 2 + 1];
      x2 = verts[(i3 + 2) * 2];
      y2 = verts[(i3 + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
        continue;
      }
      indices.push(i3, i3 + 1, i3 + 2);
    }
  }
  var init_buildLine = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
      init_Point();
      init_const6();
      init_getOrientationOfPoints();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs
  function buildPixelLine(points, closed2, vertices, indices) {
    const eps = closePointEps;
    if (points.length === 0) {
      return;
    }
    const fx = points[0];
    const fy = points[1];
    const lx = points[points.length - 2];
    const ly = points[points.length - 1];
    const closePath = closed2 || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;
    const verts = vertices;
    const length = points.length / 2;
    const indexStart = verts.length / 2;
    for (let i3 = 0; i3 < length; i3++) {
      verts.push(points[i3 * 2]);
      verts.push(points[i3 * 2 + 1]);
    }
    for (let i3 = 0; i3 < length - 1; i3++) {
      indices.push(indexStart + i3, indexStart + i3 + 1);
    }
    if (closePath) {
      indices.push(indexStart + length - 1, indexStart);
    }
  }
  var init_buildPixelLine = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs"() {
      init_const6();
    }
  });

  // node_modules/earcut/src/earcut.js
  function earcut(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = data[0];
      minY = data[1];
      let maxX = minX;
      let maxY = minY;
      for (let i3 = dim; i3 < outerLen; i3 += dim) {
        const x2 = data[i3];
        const y2 = data[i3 + 1];
        if (x2 < minX) minX = x2;
        if (y2 < minY) minY = y2;
        if (x2 > maxX) maxX = x2;
        if (y2 > maxY) maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise) {
    let last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (let i3 = start; i3 < end; i3 += dim) last = insertNode(i3 / dim | 0, data[i3], data[i3 + 1], last);
    } else {
      for (let i3 = end - dim; i3 >= start; i3 -= dim) last = insertNode(i3 / dim | 0, data[i3], data[i3 + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p3 = start, again;
    do {
      again = false;
      if (!p3.steiner && (equals(p3, p3.next) || area(p3.prev, p3, p3.next) === 0)) {
        removeNode(p3);
        p3 = end = p3.prev;
        if (p3 === p3.next) break;
        again = true;
      } else {
        p3 = p3.next;
      }
    } while (again || p3 !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    while (ear.prev !== ear.next) {
      const prev = ear.prev;
      const next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i, ear.i, next.i);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0) return false;
    const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
    const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
    let p3 = c2.next;
    while (p3 !== a2) {
      if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
      p3 = p3.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0) return false;
    const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
    const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
    const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    let p3 = ear.prevZ, n2 = ear.nextZ;
    while (p3 && p3.z >= minZ && n2 && n2.z <= maxZ) {
      if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a2 && p3 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
      p3 = p3.prevZ;
      if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
      n2 = n2.nextZ;
    }
    while (p3 && p3.z >= minZ) {
      if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a2 && p3 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0) return false;
      p3 = p3.prevZ;
    }
    while (n2 && n2.z <= maxZ) {
      if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
      n2 = n2.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles) {
    let p3 = start;
    do {
      const a2 = p3.prev, b2 = p3.next.next;
      if (!equals(a2, b2) && intersects(a2, p3, p3.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
        triangles.push(a2.i, p3.i, b2.i);
        removeNode(p3);
        removeNode(p3.next);
        p3 = start = b2;
      }
      p3 = p3.next;
    } while (p3 !== start);
    return filterPoints(p3);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a2 = start;
    do {
      let b2 = a2.next.next;
      while (b2 !== a2.prev) {
        if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
          let c2 = splitPolygon(a2, b2);
          a2 = filterPoints(a2, a2.next);
          c2 = filterPoints(c2, c2.next);
          earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b2 = b2.next;
      }
      a2 = a2.next;
    } while (a2 !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    for (let i3 = 0, len = holeIndices.length; i3 < len; i3++) {
      const start = holeIndices[i3] * dim;
      const end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
      const list = linkedList(data, start, end, dim, false);
      if (list === list.next) list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareXYSlope);
    for (let i3 = 0; i3 < queue.length; i3++) {
      outerNode = eliminateHole(queue[i3], outerNode);
    }
    return outerNode;
  }
  function compareXYSlope(a2, b2) {
    let result = a2.x - b2.x;
    if (result === 0) {
      result = a2.y - b2.y;
      if (result === 0) {
        const aSlope = (a2.next.y - a2.y) / (a2.next.x - a2.x);
        const bSlope = (b2.next.y - b2.y) / (b2.next.x - b2.x);
        result = aSlope - bSlope;
      }
    }
    return result;
  }
  function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    const bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }
  function findHoleBridge(hole, outerNode) {
    let p3 = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m2;
    if (equals(hole, p3)) return p3;
    do {
      if (equals(hole, p3.next)) return p3.next;
      else if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
        const x2 = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
        if (x2 <= hx && x2 > qx) {
          qx = x2;
          m2 = p3.x < p3.next.x ? p3 : p3.next;
          if (x2 === hx) return m2;
        }
      }
      p3 = p3.next;
    } while (p3 !== outerNode);
    if (!m2) return null;
    const stop = m2;
    const mx = m2.x;
    const my = m2.y;
    let tanMin = Infinity;
    p3 = m2;
    do {
      if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
        const tan = Math.abs(hy - p3.y) / (hx - p3.x);
        if (locallyInside(p3, hole) && (tan < tanMin || tan === tanMin && (p3.x > m2.x || p3.x === m2.x && sectorContainsSector(m2, p3)))) {
          m2 = p3;
          tanMin = tan;
        }
      }
      p3 = p3.next;
    } while (p3 !== stop);
    return m2;
  }
  function sectorContainsSector(m2, p3) {
    return area(m2.prev, m2, p3.prev) < 0 && area(p3.next, m2, m2.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p3 = start;
    do {
      if (p3.z === 0) p3.z = zOrder(p3.x, p3.y, minX, minY, invSize);
      p3.prevZ = p3.prev;
      p3.nextZ = p3.next;
      p3 = p3.next;
    } while (p3 !== start);
    p3.prevZ.nextZ = null;
    p3.prevZ = null;
    sortLinked(p3);
  }
  function sortLinked(list) {
    let numMerges;
    let inSize = 1;
    do {
      let p3 = list;
      let e2;
      list = null;
      let tail = null;
      numMerges = 0;
      while (p3) {
        numMerges++;
        let q = p3;
        let pSize = 0;
        for (let i3 = 0; i3 < inSize; i3++) {
          pSize++;
          q = q.nextZ;
          if (!q) break;
        }
        let qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p3.z <= q.z)) {
            e2 = p3;
            p3 = p3.nextZ;
            pSize--;
          } else {
            e2 = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail) tail.nextZ = e2;
          else list = e2;
          e2.prevZ = tail;
          tail = e2;
        }
        p3 = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x2, y2, minX, minY, invSize) {
    x2 = (x2 - minX) * invSize | 0;
    y2 = (y2 - minY) * invSize | 0;
    x2 = (x2 | x2 << 8) & 16711935;
    x2 = (x2 | x2 << 4) & 252645135;
    x2 = (x2 | x2 << 2) & 858993459;
    x2 = (x2 | x2 << 1) & 1431655765;
    y2 = (y2 | y2 << 8) & 16711935;
    y2 = (y2 | y2 << 4) & 252645135;
    y2 = (y2 | y2 << 2) & 858993459;
    y2 = (y2 | y2 << 1) & 1431655765;
    return x2 | y2 << 1;
  }
  function getLeftmost(start) {
    let p3 = start, leftmost = start;
    do {
      if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y) leftmost = p3;
      p3 = p3.next;
    } while (p3 !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }
  function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);
  }
  function isValidDiagonal(a2, b2) {
    return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // doesn't intersect other edges
    (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
    (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
    equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
  }
  function area(p3, q, r2) {
    return (q.y - p3.y) * (r2.x - q.x) - (q.x - p3.x) * (r2.y - q.y);
  }
  function equals(p1, p22) {
    return p1.x === p22.x && p1.y === p22.y;
  }
  function intersects(p1, q1, p22, q2) {
    const o1 = sign(area(p1, q1, p22));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p22, q2, p1));
    const o4 = sign(area(p22, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true;
    if (o1 === 0 && onSegment(p1, p22, q1)) return true;
    if (o2 === 0 && onSegment(p1, q2, q1)) return true;
    if (o3 === 0 && onSegment(p22, p1, q2)) return true;
    if (o4 === 0 && onSegment(p22, q1, q2)) return true;
    return false;
  }
  function onSegment(p3, q, r2) {
    return q.x <= Math.max(p3.x, r2.x) && q.x >= Math.min(p3.x, r2.x) && q.y <= Math.max(p3.y, r2.y) && q.y >= Math.min(p3.y, r2.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a2, b2) {
    let p3 = a2;
    do {
      if (p3.i !== a2.i && p3.next.i !== a2.i && p3.i !== b2.i && p3.next.i !== b2.i && intersects(p3, p3.next, a2, b2)) return true;
      p3 = p3.next;
    } while (p3 !== a2);
    return false;
  }
  function locallyInside(a2, b2) {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
  }
  function middleInside(a2, b2) {
    let p3 = a2;
    let inside = false;
    const px = (a2.x + b2.x) / 2;
    const py = (a2.y + b2.y) / 2;
    do {
      if (p3.y > py !== p3.next.y > py && p3.next.y !== p3.y && px < (p3.next.x - p3.x) * (py - p3.y) / (p3.next.y - p3.y) + p3.x)
        inside = !inside;
      p3 = p3.next;
    } while (p3 !== a2);
    return inside;
  }
  function splitPolygon(a2, b2) {
    const a22 = createNode(a2.i, a2.x, a2.y), b22 = createNode(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
    a2.next = b2;
    b2.prev = a2;
    a22.next = an;
    an.prev = a22;
    b22.next = a22;
    a22.prev = b22;
    bp.next = b22;
    b22.prev = bp;
    return b22;
  }
  function insertNode(i3, x2, y2, last) {
    const p3 = createNode(i3, x2, y2);
    if (!last) {
      p3.prev = p3;
      p3.next = p3;
    } else {
      p3.next = last.next;
      p3.prev = last;
      last.next.prev = p3;
      last.next = p3;
    }
    return p3;
  }
  function removeNode(p3) {
    p3.next.prev = p3.prev;
    p3.prev.next = p3.next;
    if (p3.prevZ) p3.prevZ.nextZ = p3.nextZ;
    if (p3.nextZ) p3.nextZ.prevZ = p3.prevZ;
  }
  function createNode(i3, x2, y2) {
    return {
      i: i3,
      // vertex index in coordinates array
      x: x2,
      y: y2,
      // vertex coordinates
      prev: null,
      // previous and next vertex nodes in a polygon ring
      next: null,
      z: 0,
      // z-order curve value
      prevZ: null,
      // previous and next nodes in z-order
      nextZ: null,
      steiner: false
      // indicates whether this is a steiner point
    };
  }
  function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i3 = start, j2 = end - dim; i3 < end; i3 += dim) {
      sum += (data[j2] - data[i3]) * (data[i3 + 1] + data[j2 + 1]);
      j2 = i3;
    }
    return sum;
  }
  var init_earcut = __esm({
    "node_modules/earcut/src/earcut.js"() {
    }
  });

  // node_modules/pixi.js/lib/utils/utils.mjs
  var earcut2;
  var init_utils = __esm({
    "node_modules/pixi.js/lib/utils/utils.mjs"() {
      init_earcut();
      init_eventemitter3();
      earcut2 = earcut.default || earcut;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
  function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    const triangles = earcut2(points, holes, 2);
    if (!triangles) {
      return;
    }
    for (let i3 = 0; i3 < triangles.length; i3 += 3) {
      indices[indicesOffset++] = triangles[i3] + verticesOffset;
      indices[indicesOffset++] = triangles[i3 + 1] + verticesOffset;
      indices[indicesOffset++] = triangles[i3 + 2] + verticesOffset;
    }
    let index = verticesOffset * verticesStride;
    for (let i3 = 0; i3 < points.length; i3 += 2) {
      vertices[index] = points[i3];
      vertices[index + 1] = points[i3 + 1];
      index += verticesStride;
    }
  }
  var init_triangulateWithHoles = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
      init_utils();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
  var emptyArray, buildPolygon;
  var init_buildPolygon = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
      init_Extensions();
      init_triangulateWithHoles();
      emptyArray = [];
      buildPolygon = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "polygon"
        },
        build(shape, points) {
          for (let i3 = 0; i3 < shape.points.length; i3++) {
            points[i3] = shape.points[i3];
          }
          return true;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
  var buildRectangle;
  var init_buildRectangle = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
      init_Extensions();
      buildRectangle = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "rectangle"
        },
        build(shape, points) {
          const rectData = shape;
          const x2 = rectData.x;
          const y2 = rectData.y;
          const width = rectData.width;
          const height = rectData.height;
          if (!(width > 0 && height > 0)) {
            return false;
          }
          points[0] = x2;
          points[1] = y2;
          points[2] = x2 + width;
          points[3] = y2;
          points[4] = x2 + width;
          points[5] = y2 + height;
          points[6] = x2;
          points[7] = y2 + height;
          return true;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[6];
          vertices[verticesOffset + count2 + 1] = points[7];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          count2 += verticesStride;
          const verticesIndex = verticesOffset / verticesStride;
          indices[indicesOffset++] = verticesIndex;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 2;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 3;
          indices[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
  var buildTriangle;
  var init_buildTriangle = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
      init_Extensions();
      buildTriangle = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "triangle"
        },
        build(shape, points) {
          points[0] = shape.x;
          points[1] = shape.y;
          points[2] = shape.x2;
          points[3] = shape.y2;
          points[4] = shape.x3;
          points[5] = shape.y3;
          return true;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          const verticesIndex = verticesOffset / verticesStride;
          indices[indicesOffset++] = verticesIndex;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
  function addColorStops(gradient, colorStops) {
    for (let i3 = 0; i3 < colorStops.length; i3++) {
      const stop = colorStops[i3];
      gradient.addColorStop(stop.offset, stop.color);
    }
  }
  function getCanvas(width, height) {
    const canvas = DOMAdapter.get().createCanvas(width, height);
    const context4 = canvas.getContext("2d");
    return { canvas, context: context4 };
  }
  function ensureGradientOptions(args) {
    var _a2, _b;
    let options = (_a2 = args[0]) != null ? _a2 : {};
    if (typeof options === "number" || args[1]) {
      deprecation("8.5.2", `use options object instead`);
      options = {
        type: "linear",
        start: { x: args[0], y: args[1] },
        end: { x: args[2], y: args[3] },
        textureSpace: args[4],
        textureSize: (_b = args[5]) != null ? _b : FillGradient.defaultLinearOptions.textureSize
      };
    }
    return options;
  }
  var emptyColorStops, _FillGradient, FillGradient;
  var init_FillGradient = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
      init_Color();
      init_adapter();
      init_Matrix();
      init_ImageSource();
      init_Texture();
      init_uid();
      init_deprecation();
      init_definedProps();
      emptyColorStops = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }];
      _FillGradient = class _FillGradient2 {
        constructor(...args) {
          var _a2;
          this.uid = uid2("fillGradient");
          this._tick = 0;
          this.type = "linear";
          this.colorStops = [];
          let options = ensureGradientOptions(args);
          const defaults2 = options.type === "radial" ? _FillGradient2.defaultRadialOptions : _FillGradient2.defaultLinearOptions;
          options = __spreadValues(__spreadValues({}, defaults2), definedProps(options));
          this._textureSize = options.textureSize;
          this._wrapMode = options.wrapMode;
          if (options.type === "radial") {
            this.center = options.center;
            this.outerCenter = (_a2 = options.outerCenter) != null ? _a2 : this.center;
            this.innerRadius = options.innerRadius;
            this.outerRadius = options.outerRadius;
            this.scale = options.scale;
            this.rotation = options.rotation;
          } else {
            this.start = options.start;
            this.end = options.end;
          }
          this.textureSpace = options.textureSpace;
          this.type = options.type;
          options.colorStops.forEach((stop) => {
            this.addColorStop(stop.offset, stop.color);
          });
        }
        /**
         * Adds a color stop to the gradient
         * @param offset - Position of the stop (0-1)
         * @param color - Color of the stop
         * @returns This gradient instance for chaining
         */
        addColorStop(offset, color) {
          this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });
          return this;
        }
        /**
         * Builds the internal texture and transform for the gradient.
         * Called automatically when the gradient is first used.
         * @internal
         */
        buildLinearGradient() {
          if (this.texture)
            return;
          let { x: x0, y: y0 } = this.start;
          let { x: x1, y: y1 } = this.end;
          let dx = x1 - x0;
          let dy = y1 - y0;
          const flip = dx < 0 || dy < 0;
          if (this._wrapMode === "clamp-to-edge") {
            if (dx < 0) {
              const temp = x0;
              x0 = x1;
              x1 = temp;
              dx *= -1;
            }
            if (dy < 0) {
              const temp = y0;
              y0 = y1;
              y1 = temp;
              dy *= -1;
            }
          }
          const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
          const defaultSize = this._textureSize;
          const { canvas, context: context4 } = getCanvas(defaultSize, 1);
          const gradient = !flip ? context4.createLinearGradient(0, 0, this._textureSize, 0) : context4.createLinearGradient(this._textureSize, 0, 0, 0);
          addColorStops(gradient, colorStops);
          context4.fillStyle = gradient;
          context4.fillRect(0, 0, defaultSize, 1);
          this.texture = new Texture({
            source: new ImageSource({
              resource: canvas,
              addressMode: this._wrapMode
            })
          });
          const dist = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          const m2 = new Matrix();
          m2.scale(dist / defaultSize, 1);
          m2.rotate(angle);
          m2.translate(x0, y0);
          if (this.textureSpace === "local") {
            m2.scale(defaultSize, defaultSize);
          }
          this.transform = m2;
        }
        /**
         * Builds the internal texture and transform for the gradient.
         * Called automatically when the gradient is first used.
         * @internal
         */
        buildGradient() {
          if (!this.texture)
            this._tick++;
          if (this.type === "linear") {
            this.buildLinearGradient();
          } else {
            this.buildRadialGradient();
          }
        }
        /**
         * Builds the internal texture and transform for the radial gradient.
         * Called automatically when the gradient is first used.
         * @internal
         */
        buildRadialGradient() {
          if (this.texture)
            return;
          const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
          const defaultSize = this._textureSize;
          const { canvas, context: context4 } = getCanvas(defaultSize, defaultSize);
          const { x: x0, y: y0 } = this.center;
          const { x: x1, y: y1 } = this.outerCenter;
          const r0 = this.innerRadius;
          const r1 = this.outerRadius;
          const ox = x1 - r1;
          const oy = y1 - r1;
          const scale = defaultSize / (r1 * 2);
          const cx = (x0 - ox) * scale;
          const cy = (y0 - oy) * scale;
          const gradient = context4.createRadialGradient(
            cx,
            cy,
            r0 * scale,
            (x1 - ox) * scale,
            (y1 - oy) * scale,
            r1 * scale
          );
          addColorStops(gradient, colorStops);
          context4.fillStyle = colorStops[colorStops.length - 1].color;
          context4.fillRect(0, 0, defaultSize, defaultSize);
          context4.fillStyle = gradient;
          context4.translate(cx, cy);
          context4.rotate(this.rotation);
          context4.scale(1, this.scale);
          context4.translate(-cx, -cy);
          context4.fillRect(0, 0, defaultSize, defaultSize);
          this.texture = new Texture({
            source: new ImageSource({
              resource: canvas,
              addressMode: this._wrapMode
            })
          });
          const m2 = new Matrix();
          m2.scale(1 / scale, 1 / scale);
          m2.translate(ox, oy);
          if (this.textureSpace === "local") {
            m2.scale(defaultSize, defaultSize);
          }
          this.transform = m2;
        }
        /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */
        destroy() {
          var _a2;
          (_a2 = this.texture) == null ? void 0 : _a2.destroy(true);
          this.texture = null;
          this.transform = null;
          this.colorStops = [];
          this.start = null;
          this.end = null;
          this.center = null;
          this.outerCenter = null;
        }
        /**
         * Returns a unique key for this gradient instance.
         * This key is used for caching and texture management.
         * @returns {string} Unique key for the gradient
         */
        get styleKey() {
          return `fill-gradient-${this.uid}-${this._tick}`;
        }
      };
      _FillGradient.defaultLinearOptions = {
        start: { x: 0, y: 0 },
        end: { x: 0, y: 1 },
        colorStops: [],
        textureSpace: "local",
        type: "linear",
        textureSize: 256,
        wrapMode: "clamp-to-edge"
      };
      _FillGradient.defaultRadialOptions = {
        center: { x: 0.5, y: 0.5 },
        innerRadius: 0,
        outerRadius: 0.5,
        colorStops: [],
        scale: 1,
        textureSpace: "local",
        type: "radial",
        textureSize: 256,
        wrapMode: "clamp-to-edge"
      };
      FillGradient = _FillGradient;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs
  function generateTextureMatrix(out2, style, shape, matrix) {
    const textureMatrix = style.matrix ? out2.copyFrom(style.matrix).invert() : out2.identity();
    if (style.textureSpace === "local") {
      const bounds = shape.getBounds(tempRect);
      if (style.width) {
        bounds.pad(style.width);
      }
      const { x: tx, y: ty } = bounds;
      const sx = 1 / bounds.width;
      const sy = 1 / bounds.height;
      const mTx = -tx * sx;
      const mTy = -ty * sy;
      const a1 = textureMatrix.a;
      const b1 = textureMatrix.b;
      const c1 = textureMatrix.c;
      const d1 = textureMatrix.d;
      textureMatrix.a *= sx;
      textureMatrix.b *= sx;
      textureMatrix.c *= sy;
      textureMatrix.d *= sy;
      textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;
      textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;
    } else {
      textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);
      textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
    }
    const sourceStyle = style.texture.source.style;
    if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === "clamp-to-edge") {
      sourceStyle.addressMode = "repeat";
      sourceStyle.update();
    }
    if (matrix) {
      textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());
    }
    return textureMatrix;
  }
  var tempTextureMatrix, tempRect;
  var init_generateTextureFillMatrix = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs"() {
      init_Matrix();
      init_Rectangle();
      init_FillGradient();
      tempTextureMatrix = new Matrix();
      tempRect = new Rectangle();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
  function buildContextBatches(context4, gpuContext) {
    const { geometryData, batches } = gpuContext;
    batches.length = 0;
    geometryData.indices.length = 0;
    geometryData.vertices.length = 0;
    geometryData.uvs.length = 0;
    for (let i3 = 0; i3 < context4.instructions.length; i3++) {
      const instruction = context4.instructions[i3];
      if (instruction.action === "texture") {
        addTextureToGeometryData(instruction.data, batches, geometryData);
      } else if (instruction.action === "fill" || instruction.action === "stroke") {
        const isStroke = instruction.action === "stroke";
        const shapePath = instruction.data.path.shapePath;
        const style = instruction.data.style;
        const hole = instruction.data.hole;
        if (isStroke && hole) {
          addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);
        }
        if (hole) {
          shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;
        }
        addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);
      }
    }
  }
  function addTextureToGeometryData(data, batches, geometryData) {
    const points = [];
    const build = shapeBuilders.rectangle;
    const rect = tempRect2;
    rect.x = data.dx;
    rect.y = data.dy;
    rect.width = data.dw;
    rect.height = data.dh;
    const matrix = data.transform;
    if (!build.build(rect, points)) {
      return;
    }
    const { vertices, uvs, indices } = geometryData;
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    if (matrix) {
      transformVertices(points, matrix);
    }
    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
    const texture = data.image;
    const textureUvs = texture.uvs;
    uvs.push(
      textureUvs.x0,
      textureUvs.y0,
      textureUvs.x1,
      textureUvs.y1,
      textureUvs.x3,
      textureUvs.y3,
      textureUvs.x2,
      textureUvs.y2
    );
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = data.style;
    graphicsBatch.alpha = data.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  }
  function addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) => {
      var _a2;
      const points = [];
      const build = shapeBuilders[shape.type];
      if (!build.build(shape, points)) {
        return;
      }
      const indexOffset = indices.length;
      const vertOffset = vertices.length / 2;
      let topology = "triangle-list";
      if (matrix) {
        transformVertices(points, matrix);
      }
      if (!isStroke) {
        if (holes) {
          const holeIndices = [];
          const otherPoints = points.slice();
          const holeArrays = getHoleArrays(holes);
          holeArrays.forEach((holePoints) => {
            holeIndices.push(otherPoints.length / 2);
            otherPoints.push(...holePoints);
          });
          triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
        } else {
          build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
        }
      } else {
        const close = (_a2 = shape.closePath) != null ? _a2 : true;
        const lineStyle = style;
        if (!lineStyle.pixelLine) {
          buildLine(points, lineStyle, false, close, vertices, indices);
        } else {
          buildPixelLine(points, close, vertices, indices);
          topology = "line-list";
        }
      }
      const uvsOffset = uvs.length / 2;
      const texture = style.texture;
      if (texture !== Texture.WHITE) {
        const textureMatrix = generateTextureMatrix(tempTextureMatrix2, style, shape, matrix);
        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
      const graphicsBatch = BigPool.get(BatchableGraphics);
      graphicsBatch.indexOffset = indexOffset;
      graphicsBatch.indexSize = indices.length - indexOffset;
      graphicsBatch.attributeOffset = vertOffset;
      graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
      graphicsBatch.baseColor = style.color;
      graphicsBatch.alpha = style.alpha;
      graphicsBatch.texture = texture;
      graphicsBatch.geometryData = geometryData;
      graphicsBatch.topology = topology;
      batches.push(graphicsBatch);
    });
  }
  function getHoleArrays(holePrimitives) {
    const holeArrays = [];
    for (let k2 = 0; k2 < holePrimitives.length; k2++) {
      const holePrimitive = holePrimitives[k2].shape;
      const holePoints = [];
      const holeBuilder = shapeBuilders[holePrimitive.type];
      if (holeBuilder.build(holePrimitive, holePoints)) {
        holeArrays.push(holePoints);
      }
    }
    return holeArrays;
  }
  var shapeBuilders, tempRect2, tempTextureMatrix2;
  var init_buildContextBatches = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
      init_Extensions();
      init_Matrix();
      init_Rectangle();
      init_buildUvs();
      init_transformVertices();
      init_Texture();
      init_PoolGroup();
      init_BatchableGraphics();
      init_buildCircle();
      init_buildLine();
      init_buildPixelLine();
      init_buildPolygon();
      init_buildRectangle();
      init_buildTriangle();
      init_generateTextureFillMatrix();
      init_triangulateWithHoles();
      shapeBuilders = {};
      extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
      extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);
      tempRect2 = new Rectangle();
      tempTextureMatrix2 = new Matrix();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
  var GpuGraphicsContext, GraphicsContextRenderData, _GraphicsContextSystem, GraphicsContextSystem;
  var init_GraphicsContextSystem = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
      init_Extensions();
      init_getTextureBatchBindGroup();
      init_DefaultBatcher();
      init_InstructionSet();
      init_GCManagedHash();
      init_deprecation();
      init_PoolGroup();
      init_buildContextBatches();
      GpuGraphicsContext = class {
        constructor() {
          this.batches = [];
          this.geometryData = {
            vertices: [],
            uvs: [],
            indices: []
          };
        }
        reset() {
          if (this.batches) {
            this.batches.forEach((batch) => {
              BigPool.return(batch);
            });
          }
          if (this.graphicsData) {
            BigPool.return(this.graphicsData);
          }
          this.isBatchable = false;
          this.context = null;
          this.batches.length = 0;
          this.geometryData.indices.length = 0;
          this.geometryData.vertices.length = 0;
          this.geometryData.uvs.length = 0;
          this.graphicsData = null;
        }
        destroy() {
          this.reset();
          this.batches = null;
          this.geometryData = null;
        }
      };
      GraphicsContextRenderData = class {
        constructor() {
          this.instructions = new InstructionSet();
        }
        init(options) {
          const maxTextures = options.maxTextures;
          this.batcher ? this.batcher._updateMaxTextures(maxTextures) : this.batcher = new DefaultBatcher({ maxTextures });
          this.instructions.reset();
        }
        /**
         * @deprecated since version 8.0.0
         * Use `batcher.geometry` instead.
         * @see {Batcher#geometry}
         */
        get geometry() {
          deprecation(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
          return this.batcher.geometry;
        }
        destroy() {
          this.batcher.destroy();
          this.instructions.destroy();
          this.batcher = null;
          this.instructions = null;
        }
      };
      _GraphicsContextSystem = class _GraphicsContextSystem2 {
        constructor(renderer) {
          this._renderer = renderer;
          this._managedContexts = new GCManagedHash({ renderer, type: "resource", name: "graphicsContext" });
        }
        /**
         * Runner init called, update the default options
         * @ignore
         */
        init(options) {
          var _a2;
          _GraphicsContextSystem2.defaultOptions.bezierSmoothness = (_a2 = options == null ? void 0 : options.bezierSmoothness) != null ? _a2 : _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
        }
        /**
         * Returns the render data for a given GraphicsContext.
         * @param context - The GraphicsContext to get the render data for.
         * @internal
         */
        getContextRenderData(context4) {
          return context4._gpuData[this._renderer.uid].graphicsData || this._initContextRenderData(context4);
        }
        /**
         * Updates the GPU context for a given GraphicsContext.
         * If the context is dirty, it will rebuild the batches and geometry data.
         * @param context - The GraphicsContext to update.
         * @returns The updated GpuGraphicsContext.
         * @internal
         */
        updateGpuContext(context4) {
          const hasContext = !!context4._gpuData[this._renderer.uid];
          const gpuContext = context4._gpuData[this._renderer.uid] || this._initContext(context4);
          if (context4.dirty || !hasContext) {
            if (hasContext) {
              gpuContext.reset();
            }
            buildContextBatches(context4, gpuContext);
            const batchMode = context4.batchMode;
            if (context4.customShader || batchMode === "no-batch") {
              gpuContext.isBatchable = false;
            } else if (batchMode === "auto") {
              gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
            } else {
              gpuContext.isBatchable = true;
            }
            context4.dirty = false;
          }
          return gpuContext;
        }
        /**
         * Returns the GpuGraphicsContext for a given GraphicsContext.
         * If it does not exist, it will initialize a new one.
         * @param context - The GraphicsContext to get the GpuGraphicsContext for.
         * @returns The GpuGraphicsContext for the given GraphicsContext.
         * @internal
         */
        getGpuContext(context4) {
          return context4._gpuData[this._renderer.uid] || this._initContext(context4);
        }
        _initContextRenderData(context4) {
          const graphicsData = BigPool.get(GraphicsContextRenderData, {
            maxTextures: this._renderer.limits.maxBatchableTextures
          });
          const gpuContext = context4._gpuData[this._renderer.uid];
          const { batches, geometryData } = gpuContext;
          gpuContext.graphicsData = graphicsData;
          const vertexSize = geometryData.vertices.length;
          const indexSize = geometryData.indices.length;
          for (let i3 = 0; i3 < batches.length; i3++) {
            batches[i3].applyTransform = false;
          }
          const batcher = graphicsData.batcher;
          batcher.ensureAttributeBuffer(vertexSize);
          batcher.ensureIndexBuffer(indexSize);
          batcher.begin();
          for (let i3 = 0; i3 < batches.length; i3++) {
            const batch = batches[i3];
            batcher.add(batch);
          }
          batcher.finish(graphicsData.instructions);
          const geometry = batcher.geometry;
          geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
          geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
          const drawBatches = batcher.batches;
          for (let i3 = 0; i3 < drawBatches.length; i3++) {
            const batch = drawBatches[i3];
            batch.bindGroup = getTextureBatchBindGroup(
              batch.textures.textures,
              batch.textures.count,
              this._renderer.limits.maxBatchableTextures
            );
          }
          return graphicsData;
        }
        _initContext(context4) {
          const gpuContext = new GpuGraphicsContext();
          gpuContext.context = context4;
          context4._gpuData[this._renderer.uid] = gpuContext;
          this._managedContexts.add(context4);
          return gpuContext;
        }
        destroy() {
          this._managedContexts.destroy();
          this._renderer = null;
        }
      };
      _GraphicsContextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "graphicsContext"
      };
      _GraphicsContextSystem.defaultOptions = {
        /**
         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
         * @default 0.5
         */
        bezierSmoothness: 0.5
      };
      GraphicsContextSystem = _GraphicsContextSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
  var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, _State, State;
  var init_State = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
      "use strict";
      blendModeIds = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
      };
      BLEND = 0;
      OFFSET = 1;
      CULLING = 2;
      DEPTH_TEST = 3;
      WINDING = 4;
      DEPTH_MASK = 5;
      _State = class _State2 {
        constructor() {
          this.data = 0;
          this.blendMode = "normal";
          this.polygonOffset = 0;
          this.blend = true;
          this.depthMask = true;
        }
        /**
         * Activates blending of the computed fragment color values.
         * @default true
         */
        get blend() {
          return !!(this.data & 1 << BLEND);
        }
        set blend(value) {
          if (!!(this.data & 1 << BLEND) !== value) {
            this.data ^= 1 << BLEND;
          }
        }
        /**
         * Activates adding an offset to depth values of polygon's fragments
         * @default false
         */
        get offsets() {
          return !!(this.data & 1 << OFFSET);
        }
        set offsets(value) {
          if (!!(this.data & 1 << OFFSET) !== value) {
            this.data ^= 1 << OFFSET;
          }
        }
        /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
        set cullMode(value) {
          if (value === "none") {
            this.culling = false;
            return;
          }
          this.culling = true;
          this.clockwiseFrontFace = value === "front";
        }
        get cullMode() {
          if (!this.culling) {
            return "none";
          }
          return this.clockwiseFrontFace ? "front" : "back";
        }
        /**
         * Activates culling of polygons.
         * @default false
         */
        get culling() {
          return !!(this.data & 1 << CULLING);
        }
        set culling(value) {
          if (!!(this.data & 1 << CULLING) !== value) {
            this.data ^= 1 << CULLING;
          }
        }
        /**
         * Activates depth comparisons and updates to the depth buffer.
         * @default false
         */
        get depthTest() {
          return !!(this.data & 1 << DEPTH_TEST);
        }
        set depthTest(value) {
          if (!!(this.data & 1 << DEPTH_TEST) !== value) {
            this.data ^= 1 << DEPTH_TEST;
          }
        }
        /**
         * Enables or disables writing to the depth buffer.
         * @default true
         */
        get depthMask() {
          return !!(this.data & 1 << DEPTH_MASK);
        }
        set depthMask(value) {
          if (!!(this.data & 1 << DEPTH_MASK) !== value) {
            this.data ^= 1 << DEPTH_MASK;
          }
        }
        /**
         * Specifies whether or not front or back-facing polygons can be culled.
         * @default false
         */
        get clockwiseFrontFace() {
          return !!(this.data & 1 << WINDING);
        }
        set clockwiseFrontFace(value) {
          if (!!(this.data & 1 << WINDING) !== value) {
            this.data ^= 1 << WINDING;
          }
        }
        /**
         * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
         * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
         * @default 'normal'
         */
        get blendMode() {
          return this._blendMode;
        }
        set blendMode(value) {
          this.blend = value !== "none";
          this._blendMode = value;
          this._blendModeId = blendModeIds[value] || 0;
        }
        /**
         * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
         * @default 0
         */
        get polygonOffset() {
          return this._polygonOffset;
        }
        set polygonOffset(value) {
          this.offsets = !!value;
          this._polygonOffset = value;
        }
        toString() {
          return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        /**
         * A quickly getting an instance of a State that is configured for 2d rendering.
         * @returns a new State with values set for 2d rendering
         */
        static for2d() {
          const state = new _State2();
          state.depthTest = false;
          state.blend = true;
          return state;
        }
      };
      _State.default2d = _State.for2d();
      State = _State;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
  function colorToUniform(rgb, alpha, out2, offset) {
    out2[offset++] = (rgb >> 16 & 255) / 255;
    out2[offset++] = (rgb >> 8 & 255) / 255;
    out2[offset++] = (rgb & 255) / 255;
    out2[offset++] = alpha;
  }
  function color32BitToUniform(abgr, out2, offset) {
    const alpha = (abgr >> 24 & 255) / 255;
    out2[offset++] = (abgr & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 8 & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 16 & 255) / 255 * alpha;
    out2[offset++] = alpha;
  }
  var init_colorToUniform = __esm({
    "node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
  var GraphicsGpuData, GraphicsPipe;
  var init_GraphicsPipe = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
      init_Extensions();
      init_State();
      init_GCManagedHash();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableGraphics();
      GraphicsGpuData = class {
        constructor() {
          this.batches = [];
          this.batched = false;
        }
        destroy() {
          this.batches.forEach((batch) => {
            BigPool.return(batch);
          });
          this.batches.length = 0;
        }
      };
      GraphicsPipe = class {
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this.renderer = renderer;
          this._adaptor = adaptor;
          this.renderer.runners.contextChange.add(this);
          this._managedGraphics = new GCManagedHash({ renderer, type: "renderable", priority: -1, name: "graphics" });
        }
        contextChange() {
          this._adaptor.contextChange(this.renderer);
        }
        validateRenderable(graphics) {
          const context4 = graphics.context;
          const wasBatched = !!graphics._gpuData;
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(context4);
          if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
            return true;
          }
          return false;
        }
        addRenderable(graphics, instructionSet) {
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
          if (graphics.didViewUpdate) {
            this._rebuild(graphics);
          }
          if (gpuContext.isBatchable) {
            this._addToBatcher(graphics, instructionSet);
          } else {
            this.renderer.renderPipes.batch.break(instructionSet);
            instructionSet.add(graphics);
          }
        }
        updateRenderable(graphics) {
          const gpuData = this._getGpuDataForRenderable(graphics);
          const batches = gpuData.batches;
          for (let i3 = 0; i3 < batches.length; i3++) {
            const batch = batches[i3];
            batch._batcher.updateElement(batch);
          }
        }
        execute(graphics) {
          if (!graphics.isRenderable)
            return;
          const renderer = this.renderer;
          const context4 = graphics.context;
          const contextSystem = renderer.graphicsContext;
          if (!contextSystem.getGpuContext(context4).batches.length) {
            return;
          }
          const shader = context4.customShader || this._adaptor.shader;
          this.state.blendMode = graphics.groupBlendMode;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = graphics.groupTransform;
          localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
          color32BitToUniform(
            graphics.groupColorAlpha,
            localUniforms.uColor,
            0
          );
          this._adaptor.execute(this, graphics);
        }
        _rebuild(graphics) {
          const gpuData = this._getGpuDataForRenderable(graphics);
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
          gpuData.destroy();
          if (gpuContext.isBatchable) {
            this._updateBatchesForRenderable(graphics, gpuData);
          }
        }
        _addToBatcher(graphics, instructionSet) {
          const batchPipe = this.renderer.renderPipes.batch;
          const batches = this._getGpuDataForRenderable(graphics).batches;
          for (let i3 = 0; i3 < batches.length; i3++) {
            const batch = batches[i3];
            batchPipe.addToBatch(batch, instructionSet);
          }
        }
        _getGpuDataForRenderable(graphics) {
          return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);
        }
        _initGpuDataForRenderable(graphics) {
          const gpuData = new GraphicsGpuData();
          graphics._gpuData[this.renderer.uid] = gpuData;
          this._managedGraphics.add(graphics);
          return gpuData;
        }
        _updateBatchesForRenderable(graphics, gpuData) {
          const context4 = graphics.context;
          const gpuContext = this.renderer.graphicsContext.getGpuContext(context4);
          const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
          gpuData.batches = gpuContext.batches.map((batch) => {
            const batchClone = BigPool.get(BatchableGraphics);
            batch.copyTo(batchClone);
            batchClone.renderable = graphics;
            batchClone.roundPixels = roundPixels;
            return batchClone;
          });
        }
        destroy() {
          this._managedGraphics.destroy();
          this.renderer = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.state = null;
        }
      };
      GraphicsPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/init.mjs
  var init_init7 = __esm({
    "node_modules/pixi.js/lib/scene/graphics/init.mjs"() {
      init_Extensions();
      init_GraphicsContextSystem();
      init_GraphicsPipe();
      extensions.add(GraphicsPipe);
      extensions.add(GraphicsContextSystem);
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
  var BatchableMesh;
  var init_BatchableMesh = __esm({
    "node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"() {
      "use strict";
      BatchableMesh = class {
        constructor() {
          this.batcherName = "default";
          this.packAsQuad = false;
          this.indexOffset = 0;
          this.attributeOffset = 0;
          this.roundPixels = 0;
          this._batcher = null;
          this._batch = null;
          this._textureMatrixUpdateId = -1;
          this._uvUpdateId = -1;
        }
        get blendMode() {
          return this.renderable.groupBlendMode;
        }
        get topology() {
          return this._topology || this.geometry.topology;
        }
        set topology(value) {
          this._topology = value;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this._batcher = null;
          this._batch = null;
          this.geometry = null;
          this._uvUpdateId = -1;
          this._textureMatrixUpdateId = -1;
        }
        /**
         * Sets the texture for the batchable mesh.
         * As it does so, it resets the texture matrix update ID.
         * this is to ensure that the texture matrix is recalculated when the uvs are referenced
         * @param value - The texture to set.
         */
        setTexture(value) {
          if (this.texture === value)
            return;
          this.texture = value;
          this._textureMatrixUpdateId = -1;
        }
        get uvs() {
          const geometry = this.geometry;
          const uvBuffer = geometry.getBuffer("aUV");
          const uvs = uvBuffer.data;
          let transformedUvs = uvs;
          const textureMatrix = this.texture.textureMatrix;
          if (!textureMatrix.isSimple) {
            transformedUvs = this._transformedUvs;
            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
              if (!transformedUvs || transformedUvs.length < uvs.length) {
                transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
              }
              this._textureMatrixUpdateId = textureMatrix._updateID;
              this._uvUpdateId = uvBuffer._updateID;
              textureMatrix.multiplyUvs(uvs, transformedUvs);
            }
          }
          return transformedUvs;
        }
        get positions() {
          return this.geometry.positions;
        }
        get indices() {
          return this.geometry.indices;
        }
        get color() {
          return this.renderable.groupColorAlpha;
        }
        get groupTransform() {
          return this.renderable.groupTransform;
        }
        get attributeSize() {
          return this.geometry.positions.length / 2;
        }
        get indexSize() {
          return this.geometry.indices.length;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
  var MeshGpuData, MeshPipe;
  var init_MeshPipe = __esm({
    "node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs"() {
      init_Extensions();
      init_Matrix();
      init_BindGroup();
      init_UniformGroup();
      init_getAdjustedBlendModeBlend();
      init_colorToUniform();
      init_BatchableMesh();
      MeshGpuData = class {
        destroy() {
        }
      };
      MeshPipe = class {
        constructor(renderer, adaptor) {
          this.localUniforms = new UniformGroup({
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          this.localUniformsBindGroup = new BindGroup({
            0: this.localUniforms
          });
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
        }
        validateRenderable(mesh) {
          const meshData = this._getMeshData(mesh);
          const wasBatched = meshData.batched;
          const isBatched = mesh.batched;
          meshData.batched = isBatched;
          if (wasBatched !== isBatched) {
            return true;
          } else if (isBatched) {
            const geometry = mesh._geometry;
            if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
              meshData.indexSize = geometry.indices.length;
              meshData.vertexSize = geometry.positions.length;
              return true;
            }
            const batchableMesh = this._getBatchableMesh(mesh);
            if (batchableMesh.texture.uid !== mesh._texture.uid) {
              batchableMesh._textureMatrixUpdateId = -1;
            }
            return !batchableMesh._batcher.checkAndUpdateTexture(
              batchableMesh,
              mesh._texture
            );
          }
          return false;
        }
        addRenderable(mesh, instructionSet) {
          var _a2, _b;
          const batcher = this.renderer.renderPipes.batch;
          const meshData = this._getMeshData(mesh);
          if (mesh.didViewUpdate) {
            meshData.indexSize = (_a2 = mesh._geometry.indices) == null ? void 0 : _a2.length;
            meshData.vertexSize = (_b = mesh._geometry.positions) == null ? void 0 : _b.length;
          }
          if (meshData.batched) {
            const gpuBatchableMesh = this._getBatchableMesh(mesh);
            gpuBatchableMesh.setTexture(mesh._texture);
            gpuBatchableMesh.geometry = mesh._geometry;
            batcher.addToBatch(gpuBatchableMesh, instructionSet);
          } else {
            batcher.break(instructionSet);
            instructionSet.add(mesh);
          }
        }
        updateRenderable(mesh) {
          if (mesh.batched) {
            const gpuBatchableMesh = this._getBatchableMesh(mesh);
            gpuBatchableMesh.setTexture(mesh._texture);
            gpuBatchableMesh.geometry = mesh._geometry;
            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
          }
        }
        execute(mesh) {
          if (!mesh.isRenderable)
            return;
          mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
          const localUniforms = this.localUniforms;
          localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
          localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
          localUniforms.update();
          color32BitToUniform(
            mesh.groupColorAlpha,
            localUniforms.uniforms.uColor,
            0
          );
          this._adaptor.execute(this, mesh);
        }
        _getMeshData(mesh) {
          var _a2, _b;
          (_a2 = mesh._gpuData)[_b = this.renderer.uid] || (_a2[_b] = new MeshGpuData());
          return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);
        }
        _initMeshData(mesh) {
          mesh._gpuData[this.renderer.uid].meshData = {
            batched: mesh.batched,
            indexSize: 0,
            vertexSize: 0
          };
          return mesh._gpuData[this.renderer.uid].meshData;
        }
        _getBatchableMesh(mesh) {
          var _a2, _b;
          (_a2 = mesh._gpuData)[_b = this.renderer.uid] || (_a2[_b] = new MeshGpuData());
          return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);
        }
        _initBatchableMesh(mesh) {
          const gpuMesh = new BatchableMesh();
          gpuMesh.renderable = mesh;
          gpuMesh.setTexture(mesh._texture);
          gpuMesh.transform = mesh.groupTransform;
          gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
          mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;
          return gpuMesh;
        }
        destroy() {
          this.localUniforms = null;
          this.localUniformsBindGroup = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.renderer = null;
        }
      };
      MeshPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/init.mjs
  var init_init8 = __esm({
    "node_modules/pixi.js/lib/scene/mesh/init.mjs"() {
      init_Extensions();
      init_MeshPipe();
      extensions.add(MeshPipe);
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs
  var GlParticleContainerAdaptor;
  var init_GlParticleContainerAdaptor = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs"() {
      "use strict";
      GlParticleContainerAdaptor = class {
        execute(particleContainerPipe, container) {
          const state = particleContainerPipe.state;
          const renderer = particleContainerPipe.renderer;
          const shader = container.shader || particleContainerPipe.defaultShader;
          shader.resources.uTexture = container.texture._source;
          shader.resources.uniforms = particleContainerPipe.localUniforms;
          const gl = renderer.gl;
          const buffer = particleContainerPipe.getBuffers(container);
          renderer.shader.bind(shader);
          renderer.state.set(state);
          renderer.geometry.bind(buffer.geometry, shader.glProgram);
          const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs
  function createIndicesForQuads(size, outBuffer = null) {
    const totalIndices = size * 6;
    if (totalIndices > 65535) {
      outBuffer || (outBuffer = new Uint32Array(totalIndices));
    } else {
      outBuffer || (outBuffer = new Uint16Array(totalIndices));
    }
    if (outBuffer.length !== totalIndices) {
      throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
    }
    for (let i3 = 0, j2 = 0; i3 < totalIndices; i3 += 6, j2 += 4) {
      outBuffer[i3 + 0] = j2 + 0;
      outBuffer[i3 + 1] = j2 + 1;
      outBuffer[i3 + 2] = j2 + 2;
      outBuffer[i3 + 3] = j2 + 0;
      outBuffer[i3 + 4] = j2 + 2;
      outBuffer[i3 + 5] = j2 + 3;
    }
    return outBuffer;
  }
  var init_createIndicesForQuads = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs
  function generateParticleUpdateFunction(properties) {
    return {
      dynamicUpdate: generateUpdateFunction(properties, true),
      staticUpdate: generateUpdateFunction(properties, false)
    };
  }
  function generateUpdateFunction(properties, dynamic) {
    const funcFragments = [];
    funcFragments.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
    let offset = 0;
    for (const i3 in properties) {
      const property = properties[i3];
      if (dynamic !== property.dynamic)
        continue;
      funcFragments.push(`offset = index + ${offset}`);
      funcFragments.push(property.code);
      const attributeInfo = getAttributeInfoFromFormat(property.format);
      offset += attributeInfo.stride / 4;
    }
    funcFragments.push(`
            index += stride * 4;
        }
    `);
    funcFragments.unshift(`
        var stride = ${offset};
    `);
    const functionSource = funcFragments.join("\n");
    return new Function("ps", "f32v", "u32v", functionSource);
  }
  var init_generateParticleUpdateFunction = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs"() {
      init_getAttributeInfoFromFormat();
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs
  function getParticleSyncKey(properties) {
    const keyGen = [];
    for (const key in properties) {
      const property = properties[key];
      keyGen.push(key, property.code, property.dynamic ? "d" : "s");
    }
    return keyGen.join("_");
  }
  var ParticleBuffer;
  var init_ParticleBuffer = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs"() {
      init_Buffer();
      init_const4();
      init_Geometry();
      init_getAttributeInfoFromFormat();
      init_ViewableBuffer();
      init_createIndicesForQuads();
      init_generateParticleUpdateFunction();
      ParticleBuffer = class {
        constructor(options) {
          var _a2;
          this._size = 0;
          this._generateParticleUpdateCache = {};
          const size = this._size = (_a2 = options.size) != null ? _a2 : 1e3;
          const properties = options.properties;
          let staticVertexSize = 0;
          let dynamicVertexSize = 0;
          for (const i3 in properties) {
            const property = properties[i3];
            const attributeInfo = getAttributeInfoFromFormat(property.format);
            if (property.dynamic) {
              dynamicVertexSize += attributeInfo.stride;
            } else {
              staticVertexSize += attributeInfo.stride;
            }
          }
          this._dynamicStride = dynamicVertexSize / 4;
          this._staticStride = staticVertexSize / 4;
          this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);
          this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);
          this.indexBuffer = createIndicesForQuads(size);
          const geometry = new Geometry();
          let dynamicOffset = 0;
          let staticOffset = 0;
          this._staticBuffer = new Buffer2({
            data: new Float32Array(1),
            label: "static-particle-buffer",
            shrinkToFit: false,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          this._dynamicBuffer = new Buffer2({
            data: new Float32Array(1),
            label: "dynamic-particle-buffer",
            shrinkToFit: false,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          for (const i3 in properties) {
            const property = properties[i3];
            const attributeInfo = getAttributeInfoFromFormat(property.format);
            if (property.dynamic) {
              geometry.addAttribute(property.attributeName, {
                buffer: this._dynamicBuffer,
                stride: this._dynamicStride * 4,
                offset: dynamicOffset * 4,
                format: property.format
              });
              dynamicOffset += attributeInfo.size;
            } else {
              geometry.addAttribute(property.attributeName, {
                buffer: this._staticBuffer,
                stride: this._staticStride * 4,
                offset: staticOffset * 4,
                format: property.format
              });
              staticOffset += attributeInfo.size;
            }
          }
          geometry.addIndex(this.indexBuffer);
          const uploadFunction = this.getParticleUpdate(properties);
          this._dynamicUpload = uploadFunction.dynamicUpdate;
          this._staticUpload = uploadFunction.staticUpdate;
          this.geometry = geometry;
        }
        getParticleUpdate(properties) {
          const key = getParticleSyncKey(properties);
          if (this._generateParticleUpdateCache[key]) {
            return this._generateParticleUpdateCache[key];
          }
          this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);
          return this._generateParticleUpdateCache[key];
        }
        generateParticleUpdate(properties) {
          return generateParticleUpdateFunction(properties);
        }
        update(particles, uploadStatic) {
          if (particles.length > this._size) {
            uploadStatic = true;
            this._size = Math.max(particles.length, this._size * 1.5 | 0);
            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);
            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);
            this.indexBuffer = createIndicesForQuads(this._size);
            this.geometry.indexBuffer.setDataWithSize(
              this.indexBuffer,
              this.indexBuffer.byteLength,
              true
            );
          }
          const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
          this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
          this._dynamicBuffer.setDataWithSize(
            this.dynamicAttributeBuffer.float32View,
            particles.length * this._dynamicStride * 4,
            true
          );
          if (uploadStatic) {
            const staticAttributeBuffer = this.staticAttributeBuffer;
            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);
            this._staticBuffer.setDataWithSize(
              staticAttributeBuffer.float32View,
              particles.length * this._staticStride * 4,
              true
            );
          }
        }
        destroy() {
          this._staticBuffer.destroy();
          this._dynamicBuffer.destroy();
          this.geometry.destroy();
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs
  var fragment;
  var init_particles_frag = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs"() {
      fragment = "varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}";
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs
  var vertex;
  var init_particles_vert = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs"() {
      vertex = "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n";
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs
  var wgsl;
  var init_particles_wgsl = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs"() {
      wgsl = "\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs
  var ParticleShader;
  var init_ParticleShader = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs"() {
      init_Color();
      init_Matrix();
      init_GlProgram();
      init_GpuProgram();
      init_Shader();
      init_Texture();
      init_TextureStyle();
      init_particles_frag();
      init_particles_vert();
      init_particles_wgsl();
      ParticleShader = class extends Shader {
        constructor() {
          const glProgram3 = GlProgram.from({
            vertex,
            fragment
          });
          const gpuProgram3 = GpuProgram.from({
            fragment: {
              source: wgsl,
              entryPoint: "mainFragment"
            },
            vertex: {
              source: wgsl,
              entryPoint: "mainVertex"
            }
          });
          super({
            glProgram: glProgram3,
            gpuProgram: gpuProgram3,
            resources: {
              // this will be replaced with the texture from the particle container
              uTexture: Texture.WHITE.source,
              // this will be replaced with the texture style from the particle container
              uSampler: new TextureStyle({}),
              // this will be replaced with the local uniforms from the particle container
              uniforms: {
                uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
                uColor: { value: new Color(16777215), type: "vec4<f32>" },
                uRound: { value: 1, type: "f32" },
                uResolution: { value: [0, 0], type: "vec2<f32>" }
              }
            }
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs
  var ParticleContainerPipe;
  var init_ParticleContainerPipe = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs"() {
      init_Matrix();
      init_UniformGroup();
      init_getAdjustedBlendModeBlend();
      init_State();
      init_GCManagedHash();
      init_colorToUniform();
      init_ParticleBuffer();
      init_ParticleShader();
      ParticleContainerPipe = class {
        /**
         * @param renderer - The renderer this sprite batch works for.
         * @param adaptor
         */
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this.localUniforms = new UniformGroup({
            uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array(4), type: "vec4<f32>" },
            uRound: { value: 1, type: "f32" },
            uResolution: { value: [0, 0], type: "vec2<f32>" }
          });
          this.renderer = renderer;
          this.adaptor = adaptor;
          this.defaultShader = new ParticleShader();
          this.state = State.for2d();
          this._managedContainers = new GCManagedHash({ renderer, type: "renderable", name: "particleContainer" });
        }
        validateRenderable(_renderable) {
          return false;
        }
        addRenderable(renderable, instructionSet) {
          this.renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(renderable);
        }
        getBuffers(renderable) {
          return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);
        }
        _initBuffer(renderable) {
          renderable._gpuData[this.renderer.uid] = new ParticleBuffer({
            size: renderable.particleChildren.length,
            properties: renderable._properties
          });
          this._managedContainers.add(renderable);
          return renderable._gpuData[this.renderer.uid];
        }
        updateRenderable(_renderable) {
        }
        execute(container) {
          const children = container.particleChildren;
          if (children.length === 0) {
            return;
          }
          const renderer = this.renderer;
          const buffer = this.getBuffers(container);
          container.texture || (container.texture = children[0].texture);
          const state = this.state;
          buffer.update(children, container._childrenDirty);
          container._childrenDirty = false;
          state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);
          const uniforms = this.localUniforms.uniforms;
          const transformationMatrix = uniforms.uTranslationMatrix;
          container.worldTransform.copyTo(transformationMatrix);
          transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);
          uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;
          uniforms.uRound = renderer._roundPixels | container._roundPixels;
          color32BitToUniform(
            container.groupColorAlpha,
            uniforms.uColor,
            0
          );
          this.adaptor.execute(this, container);
        }
        /** Destroys the ParticleRenderer. */
        destroy() {
          this._managedContainers.destroy();
          this.renderer = null;
          if (this.defaultShader) {
            this.defaultShader.destroy();
            this.defaultShader = null;
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs
  var GlParticleContainerPipe;
  var init_GlParticleContainerPipe = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs"() {
      init_Extensions();
      init_GlParticleContainerAdaptor();
      init_ParticleContainerPipe();
      GlParticleContainerPipe = class extends ParticleContainerPipe {
        constructor(renderer) {
          super(renderer, new GlParticleContainerAdaptor());
        }
      };
      GlParticleContainerPipe.extension = {
        type: [
          ExtensionType.WebGLPipes
        ],
        name: "particle"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs
  var GpuParticleContainerAdaptor;
  var init_GpuParticleContainerAdaptor = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs"() {
      "use strict";
      GpuParticleContainerAdaptor = class {
        execute(particleContainerPipe, container) {
          const renderer = particleContainerPipe.renderer;
          const shader = container.shader || particleContainerPipe.defaultShader;
          shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);
          shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);
          const state = particleContainerPipe.state;
          const buffer = particleContainerPipe.getBuffers(container);
          renderer.encoder.draw({
            geometry: buffer.geometry,
            shader: container.shader || particleContainerPipe.defaultShader,
            state,
            size: container.particleChildren.length * 6
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs
  var GpuParticleContainerPipe;
  var init_GpuParticleContainerPipe = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs"() {
      init_Extensions();
      init_GpuParticleContainerAdaptor();
      init_ParticleContainerPipe();
      GpuParticleContainerPipe = class extends ParticleContainerPipe {
        constructor(renderer) {
          super(renderer, new GpuParticleContainerAdaptor());
        }
      };
      GpuParticleContainerPipe.extension = {
        type: [
          ExtensionType.WebGPUPipes
        ],
        name: "particle"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/init.mjs
  var init_init9 = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/init.mjs"() {
      init_Extensions();
      init_GlParticleContainerPipe();
      init_GpuParticleContainerPipe();
      extensions.add(GlParticleContainerPipe);
      extensions.add(GpuParticleContainerPipe);
    }
  });

  // node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs
  function updateTextBounds(batchableSprite, text) {
    const { texture, bounds } = batchableSprite;
    const padding = text._style._getFinalPadding();
    updateQuadBounds(bounds, text._anchor, texture);
    const paddingOffset = text._anchor._x * padding * 2;
    const paddingOffsetY = text._anchor._y * padding * 2;
    bounds.minX -= padding - paddingOffset;
    bounds.minY -= padding - paddingOffsetY;
    bounds.maxX -= padding - paddingOffset;
    bounds.maxY -= padding - paddingOffsetY;
  }
  var init_updateTextBounds = __esm({
    "node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs"() {
      init_updateQuadBounds();
    }
  });

  // node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
  var BatchableSprite;
  var init_BatchableSprite = __esm({
    "node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"() {
      "use strict";
      BatchableSprite = class {
        constructor() {
          this.batcherName = "default";
          this.topology = "triangle-list";
          this.attributeSize = 4;
          this.indexSize = 6;
          this.packAsQuad = true;
          this.roundPixels = 0;
          this._attributeStart = 0;
          this._batcher = null;
          this._batch = null;
        }
        get blendMode() {
          return this.renderable.groupBlendMode;
        }
        get color() {
          return this.renderable.groupColorAlpha;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this._batcher = null;
          this._batch = null;
          this.bounds = null;
        }
        destroy() {
          this.reset();
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs
  var BatchableText;
  var init_BatchableText = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs"() {
      init_BatchableSprite();
      BatchableText = class extends BatchableSprite {
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
  var CanvasTextPipe;
  var init_CanvasTextPipe = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
      init_Extensions();
      init_GCManagedHash();
      init_updateTextBounds();
      init_BatchableText();
      CanvasTextPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
          renderer.runners.resolutionChange.add(this);
          this._managedTexts = new GCManagedHash({
            renderer,
            type: "renderable",
            onUnload: this.onTextUnload.bind(this),
            name: "canvasText"
          });
        }
        resolutionChange() {
          for (const key in this._managedTexts.items) {
            const text = this._managedTexts.items[key];
            if (text == null ? void 0 : text._autoResolution)
              text.onViewUpdate();
          }
        }
        validateRenderable(text) {
          const gpuText = this._getGpuText(text);
          const newKey = text.styleKey;
          if (gpuText.currentKey !== newKey)
            return true;
          return text._didTextUpdate;
        }
        addRenderable(text, instructionSet) {
          const batchableText = this._getGpuText(text);
          if (text._didTextUpdate) {
            const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
            if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution) {
              this._updateGpuText(text);
            }
            text._didTextUpdate = false;
            updateTextBounds(batchableText, text);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);
        }
        updateRenderable(text) {
          const batchableText = this._getGpuText(text);
          batchableText._batcher.updateElement(batchableText);
        }
        _updateGpuText(text) {
          const batchableText = this._getGpuText(text);
          if (batchableText.texture) {
            this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);
          }
          text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
          batchableText.texture = this._renderer.canvasText.getManagedTexture(text);
          batchableText.currentKey = text.styleKey;
        }
        _getGpuText(text) {
          return text._gpuData[this._renderer.uid] || this.initGpuText(text);
        }
        initGpuText(text) {
          const batchableText = new BatchableText();
          batchableText.currentKey = "--";
          batchableText.renderable = text;
          batchableText.transform = text.groupTransform;
          batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;
          text._gpuData[this._renderer.uid] = batchableText;
          this._managedTexts.add(text);
          return batchableText;
        }
        onTextUnload(text) {
          const gpuData = text._gpuData[this._renderer.uid];
          if (!gpuData)
            return;
          const { canvasText } = this._renderer;
          const refCount = canvasText.getReferenceCount(gpuData.currentKey);
          if (refCount > 0) {
            canvasText.decreaseReferenceCount(gpuData.currentKey);
          } else if (gpuData.texture) {
            canvasText.returnTexture(gpuData.texture);
          }
        }
        destroy() {
          this._managedTexts.destroy();
          this._renderer = null;
        }
      };
      CanvasTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "text"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
  var repetitionMap, FillPattern;
  var init_FillPattern = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
      init_Matrix();
      init_uid();
      repetitionMap = {
        repeat: {
          addressModeU: "repeat",
          addressModeV: "repeat"
        },
        "repeat-x": {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
          addressModeU: "clamp-to-edge",
          addressModeV: "repeat"
        },
        "no-repeat": {
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      };
      FillPattern = class {
        constructor(texture, repetition) {
          this.uid = uid2("fillPattern");
          this._tick = 0;
          this.transform = new Matrix();
          this.texture = texture;
          this.transform.scale(
            1 / texture.frame.width,
            1 / texture.frame.height
          );
          if (repetition) {
            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
          }
        }
        /**
         * Sets the transform for the pattern
         * @param transform - The transform matrix to apply to the pattern.
         * If not provided, the pattern will use the default transform.
         */
        setTransform(transform2) {
          const texture = this.texture;
          this.transform.copyFrom(transform2);
          this.transform.invert();
          this.transform.scale(
            1 / texture.frame.width,
            1 / texture.frame.height
          );
          this._tick++;
        }
        /** Internal texture used to render the gradient */
        get texture() {
          return this._texture;
        }
        set texture(value) {
          if (this._texture === value)
            return;
          this._texture = value;
          this._tick++;
        }
        /**
         * Returns a unique key for this instance.
         * This key is used for caching.
         * @returns {string} Unique key for the instance
         */
        get styleKey() {
          return `fill-pattern-${this.uid}-${this._tick}`;
        }
        /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */
        destroy() {
          this.texture.destroy(true);
          this.texture = null;
        }
      };
    }
  });

  // node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS({
    "node_modules/parse-svg-path/index.js"(exports, module) {
      module.exports = parse2;
      var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function parse2(path2) {
        var data = [];
        path2.replace(segment, function(_, command, args) {
          var type = command.toLowerCase();
          args = parseValues(args);
          if (type == "m" && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = "l";
            command = command == "m" ? "l" : "L";
          }
          while (true) {
            if (args.length == length[type]) {
              args.unshift(command);
              return data.push(args);
            }
            if (args.length < length[type]) throw new Error("malformed path data");
            data.push([command].concat(args.splice(0, length[type])));
          }
        });
        return data;
      }
      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function parseValues(args) {
        var numbers = args.match(number);
        return numbers ? numbers.map(Number) : [];
      }
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs
  function parseSVGPath(svgPath, path2) {
    const commands = (0, import_parse_svg_path.default)(svgPath);
    const subpaths = [];
    let currentSubPath = null;
    let lastX = 0;
    let lastY = 0;
    for (let i3 = 0; i3 < commands.length; i3++) {
      const command = commands[i3];
      const type = command[0];
      const data = command;
      switch (type) {
        case "M":
          lastX = data[1];
          lastY = data[2];
          path2.moveTo(lastX, lastY);
          break;
        case "m":
          lastX += data[1];
          lastY += data[2];
          path2.moveTo(lastX, lastY);
          break;
        case "H":
          lastX = data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "h":
          lastX += data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "V":
          lastY = data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "v":
          lastY += data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "L":
          lastX = data[1];
          lastY = data[2];
          path2.lineTo(lastX, lastY);
          break;
        case "l":
          lastX += data[1];
          lastY += data[2];
          path2.lineTo(lastX, lastY);
          break;
        case "C":
          lastX = data[5];
          lastY = data[6];
          path2.bezierCurveTo(
            data[1],
            data[2],
            // First control point
            data[3],
            data[4],
            // Second control point
            lastX,
            lastY
            // End point
          );
          break;
        case "c":
          path2.bezierCurveTo(
            lastX + data[1],
            lastY + data[2],
            // First control point
            lastX + data[3],
            lastY + data[4],
            // Second control point
            lastX + data[5],
            lastY + data[6]
            // End point
          );
          lastX += data[5];
          lastY += data[6];
          break;
        case "S":
          lastX = data[3];
          lastY = data[4];
          path2.bezierCurveToShort(
            data[1],
            data[2],
            // Control point
            lastX,
            lastY
            // End point
          );
          break;
        case "s":
          path2.bezierCurveToShort(
            lastX + data[1],
            lastY + data[2],
            // Control point
            lastX + data[3],
            lastY + data[4]
            // End point
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "Q":
          lastX = data[3];
          lastY = data[4];
          path2.quadraticCurveTo(
            data[1],
            data[2],
            // Control point
            lastX,
            lastY
            // End point
          );
          break;
        case "q":
          path2.quadraticCurveTo(
            lastX + data[1],
            lastY + data[2],
            // Control point
            lastX + data[3],
            lastY + data[4]
            // End point
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "T":
          lastX = data[1];
          lastY = data[2];
          path2.quadraticCurveToShort(
            lastX,
            lastY
            // End point
          );
          break;
        case "t":
          lastX += data[1];
          lastY += data[2];
          path2.quadraticCurveToShort(
            lastX,
            lastY
            // End point
          );
          break;
        case "A":
          lastX = data[6];
          lastY = data[7];
          path2.arcToSvg(
            data[1],
            // rx
            data[2],
            // ry
            data[3],
            // x-axis-rotation
            data[4],
            // large-arc-flag
            data[5],
            // sweep-flag
            lastX,
            lastY
            // End point
          );
          break;
        case "a":
          lastX += data[6];
          lastY += data[7];
          path2.arcToSvg(
            data[1],
            // rx
            data[2],
            // ry
            data[3],
            // x-axis-rotation
            data[4],
            // large-arc-flag
            data[5],
            // sweep-flag
            lastX,
            lastY
            // End point
          );
          break;
        case "Z":
        case "z":
          path2.closePath();
          if (subpaths.length > 0) {
            currentSubPath = subpaths.pop();
            if (currentSubPath) {
              lastX = currentSubPath.startX;
              lastY = currentSubPath.startY;
            } else {
              lastX = 0;
              lastY = 0;
            }
          }
          currentSubPath = null;
          break;
        default:
          warn(`Unknown SVG path command: ${type}`);
      }
      if (type !== "Z" && type !== "z") {
        if (currentSubPath === null) {
          currentSubPath = { startX: lastX, startY: lastY };
          subpaths.push(currentSubPath);
        }
      }
    }
    return path2;
  }
  var import_parse_svg_path;
  var init_parseSVGPath = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs"() {
      import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
      init_warn();
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/Circle.mjs
  var Circle;
  var init_Circle = __esm({
    "node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
      init_Rectangle();
      Circle = class _Circle {
        /**
         * @param x - The X coordinate of the center of this circle
         * @param y - The Y coordinate of the center of this circle
         * @param radius - The radius of the circle
         */
        constructor(x2 = 0, y2 = 0, radius = 0) {
          this.type = "circle";
          this.x = x2;
          this.y = y2;
          this.radius = radius;
        }
        /**
         * Creates a clone of this Circle instance.
         * @example
         * ```ts
         * // Basic circle cloning
         * const original = new Circle(100, 100, 50);
         * const copy = original.clone();
         *
         * // Clone and modify
         * const modified = original.clone();
         * modified.radius = 75;
         *
         * // Verify independence
         * console.log(original.radius); // 50
         * console.log(modified.radius); // 75
         * ```
         * @returns A copy of the Circle
         * @see {@link Circle.copyFrom} For copying into existing circle
         * @see {@link Circle.copyTo} For copying to another circle
         */
        clone() {
          return new _Circle(this.x, this.y, this.radius);
        }
        /**
         * Checks whether the x and y coordinates given are contained within this circle.
         *
         * Uses the distance formula to determine if a point is inside the circle's radius.
         *
         * Commonly used for hit testing in PixiJS events and graphics.
         * @example
         * ```ts
         * // Basic containment check
         * const circle = new Circle(100, 100, 50);
         * const isInside = circle.contains(120, 120);
         *
         * // Check mouse position
         * const circle = new Circle(0, 0, 100);
         * container.hitArea = circle;
         * container.on('pointermove', (e) => {
         *     // only called if pointer is within circle
         * });
         * ```
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Circle
         * @see {@link Circle.strokeContains} For checking stroke intersection
         * @see {@link Circle.getBounds} For getting bounding box
         */
        contains(x2, y2) {
          if (this.radius <= 0)
            return false;
          const r2 = this.radius * this.radius;
          let dx = this.x - x2;
          let dy = this.y - y2;
          dx *= dx;
          dy *= dy;
          return dx + dy <= r2;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this circle including the stroke.
         * @example
         * ```ts
         * // Basic stroke check
         * const circle = new Circle(100, 100, 50);
         * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width
         *
         * // Check with different alignments
         * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside
         * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered
         * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside
         * ```
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param width - The width of the line to check
         * @param alignment - The alignment of the stroke, 0.5 by default
         * @returns Whether the x/y coordinates are within this Circle's stroke
         * @see {@link Circle.contains} For checking fill containment
         * @see {@link Circle.getBounds} For getting stroke bounds
         */
        strokeContains(x2, y2, width, alignment = 0.5) {
          if (this.radius === 0)
            return false;
          const dx = this.x - x2;
          const dy = this.y - y2;
          const radius = this.radius;
          const outerWidth = (1 - alignment) * width;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance <= radius + outerWidth && distance > radius - (width - outerWidth);
        }
        /**
         * Returns the framing rectangle of the circle as a Rectangle object.
         * @example
         * ```ts
         * // Basic bounds calculation
         * const circle = new Circle(100, 100, 50);
         * const bounds = circle.getBounds();
         * // bounds: x=50, y=50, width=100, height=100
         *
         * // Reuse existing rectangle
         * const rect = new Rectangle();
         * circle.getBounds(rect);
         * ```
         * @param out - Optional Rectangle object to store the result
         * @returns The framing rectangle
         * @see {@link Rectangle} For rectangle properties
         * @see {@link Circle.contains} For point containment
         */
        getBounds(out2) {
          out2 || (out2 = new Rectangle());
          out2.x = this.x - this.radius;
          out2.y = this.y - this.radius;
          out2.width = this.radius * 2;
          out2.height = this.radius * 2;
          return out2;
        }
        /**
         * Copies another circle to this one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Circle(100, 100, 50);
         * const target = new Circle();
         * target.copyFrom(source);
         * ```
         * @param circle - The circle to copy from
         * @returns Returns itself
         * @see {@link Circle.copyTo} For copying to another circle
         * @see {@link Circle.clone} For creating new circle copy
         */
        copyFrom(circle) {
          this.x = circle.x;
          this.y = circle.y;
          this.radius = circle.radius;
          return this;
        }
        /**
         * Copies this circle to another one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Circle(100, 100, 50);
         * const target = new Circle();
         * source.copyTo(target);
         * ```
         * @param circle - The circle to copy to
         * @returns Returns given parameter
         * @see {@link Circle.copyFrom} For copying from another circle
         * @see {@link Circle.clone} For creating new circle copy
         */
        copyTo(circle) {
          circle.copyFrom(this);
          return circle;
        }
        toString() {
          return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
  var Ellipse;
  var init_Ellipse = __esm({
    "node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
      init_Rectangle();
      Ellipse = class _Ellipse {
        /**
         * @param x - The X coordinate of the center of this ellipse
         * @param y - The Y coordinate of the center of this ellipse
         * @param halfWidth - The half width of this ellipse
         * @param halfHeight - The half height of this ellipse
         */
        constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
          this.type = "ellipse";
          this.x = x2;
          this.y = y2;
          this.halfWidth = halfWidth;
          this.halfHeight = halfHeight;
        }
        /**
         * Creates a clone of this Ellipse instance.
         * @example
         * ```ts
         * // Basic cloning
         * const original = new Ellipse(100, 100, 50, 25);
         * const copy = original.clone();
         *
         * // Clone and modify
         * const modified = original.clone();
         * modified.halfWidth *= 2;
         * modified.halfHeight *= 2;
         *
         * // Verify independence
         * console.log(original.halfWidth);  // 50
         * console.log(modified.halfWidth);  // 100
         * ```
         * @returns A copy of the ellipse
         * @see {@link Ellipse.copyFrom} For copying into existing ellipse
         * @see {@link Ellipse.copyTo} For copying to another ellipse
         */
        clone() {
          return new _Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
        }
        /**
         * Checks whether the x and y coordinates given are contained within this ellipse.
         * Uses normalized coordinates and the ellipse equation to determine containment.
         * @example
         * ```ts
         * // Basic containment check
         * const ellipse = new Ellipse(100, 100, 50, 25);
         * const isInside = ellipse.contains(120, 110);
         * ```
         * @remarks
         * - Uses ellipse equation (x/a + y/b  1)
         * - Returns false if dimensions are 0 or negative
         * - Normalized to center (0,0) for calculation
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coords are within this ellipse
         * @see {@link Ellipse.strokeContains} For checking stroke intersection
         * @see {@link Ellipse.getBounds} For getting containing rectangle
         */
        contains(x2, y2) {
          if (this.halfWidth <= 0 || this.halfHeight <= 0) {
            return false;
          }
          let normx = (x2 - this.x) / this.halfWidth;
          let normy = (y2 - this.y) / this.halfHeight;
          normx *= normx;
          normy *= normy;
          return normx + normy <= 1;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this ellipse including stroke.
         * @example
         * ```ts
         * // Basic stroke check
         * const ellipse = new Ellipse(100, 100, 50, 25);
         * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width
         *
         * // Check with different alignments
         * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside
         * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered
         * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside
         * ```
         * @remarks
         * - Uses normalized ellipse equations
         * - Considers stroke alignment
         * - Returns false if dimensions are 0
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
         * @returns Whether the x/y coords are within this ellipse's stroke
         * @see {@link Ellipse.contains} For checking fill containment
         * @see {@link Ellipse.getBounds} For getting stroke bounds
         */
        strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
          const { halfWidth, halfHeight } = this;
          if (halfWidth <= 0 || halfHeight <= 0) {
            return false;
          }
          const strokeOuterWidth = strokeWidth * (1 - alignment);
          const strokeInnerWidth = strokeWidth - strokeOuterWidth;
          const innerHorizontal = halfWidth - strokeInnerWidth;
          const innerVertical = halfHeight - strokeInnerWidth;
          const outerHorizontal = halfWidth + strokeOuterWidth;
          const outerVertical = halfHeight + strokeOuterWidth;
          const normalizedX = x2 - this.x;
          const normalizedY = y2 - this.y;
          const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);
          const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);
          return innerEllipse > 1 && outerEllipse <= 1;
        }
        /**
         * Returns the framing rectangle of the ellipse as a Rectangle object.
         * @example
         * ```ts
         * // Basic bounds calculation
         * const ellipse = new Ellipse(100, 100, 50, 25);
         * const bounds = ellipse.getBounds();
         * // bounds: x=50, y=75, width=100, height=50
         *
         * // Reuse existing rectangle
         * const rect = new Rectangle();
         * ellipse.getBounds(rect);
         * ```
         * @remarks
         * - Creates Rectangle if none provided
         * - Top-left is (x-halfWidth, y-halfHeight)
         * - Width is halfWidth * 2
         * - Height is halfHeight * 2
         * @param out - Optional Rectangle object to store the result
         * @returns The framing rectangle
         * @see {@link Rectangle} For rectangle properties
         * @see {@link Ellipse.contains} For checking if a point is inside
         */
        getBounds(out2) {
          out2 || (out2 = new Rectangle());
          out2.x = this.x - this.halfWidth;
          out2.y = this.y - this.halfHeight;
          out2.width = this.halfWidth * 2;
          out2.height = this.halfHeight * 2;
          return out2;
        }
        /**
         * Copies another ellipse to this one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Ellipse(100, 100, 50, 25);
         * const target = new Ellipse();
         * target.copyFrom(source);
         * ```
         * @param ellipse - The ellipse to copy from
         * @returns Returns itself
         * @see {@link Ellipse.copyTo} For copying to another ellipse
         * @see {@link Ellipse.clone} For creating new ellipse copy
         */
        copyFrom(ellipse) {
          this.x = ellipse.x;
          this.y = ellipse.y;
          this.halfWidth = ellipse.halfWidth;
          this.halfHeight = ellipse.halfHeight;
          return this;
        }
        /**
         * Copies this ellipse to another one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Ellipse(100, 100, 50, 25);
         * const target = new Ellipse();
         * source.copyTo(target);
         * ```
         * @param ellipse - The ellipse to copy to
         * @returns Returns given parameter
         * @see {@link Ellipse.copyFrom} For copying from another ellipse
         * @see {@link Ellipse.clone} For creating new ellipse copy
         */
        copyTo(ellipse) {
          ellipse.copyFrom(this);
          return ellipse;
        }
        toString() {
          return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs
  function squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22) {
    const a2 = x2 - x1;
    const b2 = y2 - y1;
    const c2 = x22 - x1;
    const d2 = y22 - y1;
    const dot = a2 * c2 + b2 * d2;
    const lenSq = c2 * c2 + d2 * d2;
    let param = -1;
    if (lenSq !== 0) {
      param = dot / lenSq;
    }
    let xx;
    let yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x22;
      yy = y22;
    } else {
      xx = x1 + param * c2;
      yy = y1 + param * d2;
    }
    const dx = x2 - xx;
    const dy = y2 - yy;
    return dx * dx + dy * dy;
  }
  var init_squaredDistanceToLineSegment = __esm({
    "node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
  var tempRect3, tempRect22, Polygon;
  var init_Polygon = __esm({
    "node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
      init_deprecation();
      init_squaredDistanceToLineSegment();
      init_Rectangle();
      Polygon = class _Polygon {
        /**
         * @param points - This can be an array of Points
         *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
         *  the arguments passed can be all the points of the polygon e.g.
         *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
         *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
         */
        constructor(...points) {
          this.type = "polygon";
          let flat = Array.isArray(points[0]) ? points[0] : points;
          if (typeof flat[0] !== "number") {
            const p3 = [];
            for (let i3 = 0, il = flat.length; i3 < il; i3++) {
              p3.push(flat[i3].x, flat[i3].y);
            }
            flat = p3;
          }
          this.points = flat;
          this.closePath = true;
        }
        /**
         * Determines whether the polygon's points are arranged in a clockwise direction.
         * Uses the shoelace formula (surveyor's formula) to calculate the signed area.
         *
         * A positive area indicates clockwise winding, while negative indicates counter-clockwise.
         *
         * The formula sums up the cross products of adjacent vertices:
         * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)
         * The final sum divided by 2 gives the signed area - positive for clockwise.
         * @example
         * ```ts
         * // Check polygon winding
         * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
         * console.log(polygon.isClockwise()); // Check direction
         *
         * // Use in path construction
         * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);
         * if (hole.isClockwise() === shape.isClockwise()) {
         *     hole.points.reverse(); // Reverse for proper hole winding
         * }
         * ```
         * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise
         */
        isClockwise() {
          let area2 = 0;
          const points = this.points;
          const length = points.length;
          for (let i3 = 0; i3 < length; i3 += 2) {
            const x1 = points[i3];
            const y1 = points[i3 + 1];
            const x2 = points[(i3 + 2) % length];
            const y2 = points[(i3 + 3) % length];
            area2 += (x2 - x1) * (y2 + y1);
          }
          return area2 < 0;
        }
        /**
         * Checks if this polygon completely contains another polygon.
         * Used for detecting holes in shapes, like when parsing SVG paths.
         * @example
         * ```ts
         * // Basic containment check
         * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square
         * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside
         *
         * outerSquare.containsPolygon(innerSquare); // Returns true
         * innerSquare.containsPolygon(outerSquare); // Returns false
         * ```
         * @remarks
         * - Uses bounds check for quick rejection
         * - Tests all points for containment
         * @param polygon - The polygon to test for containment
         * @returns True if this polygon completely contains the other polygon
         * @see {@link Polygon.contains} For single point testing
         * @see {@link Polygon.getBounds} For bounds calculation
         */
        containsPolygon(polygon) {
          const thisBounds = this.getBounds(tempRect3);
          const otherBounds = polygon.getBounds(tempRect22);
          if (!thisBounds.containsRect(otherBounds)) {
            return false;
          }
          const points = polygon.points;
          for (let i3 = 0; i3 < points.length; i3 += 2) {
            const x2 = points[i3];
            const y2 = points[i3 + 1];
            if (!this.contains(x2, y2)) {
              return false;
            }
          }
          return true;
        }
        /**
         * Creates a clone of this polygon.
         * @example
         * ```ts
         * // Basic cloning
         * const original = new Polygon([0, 0, 100, 0, 50, 100]);
         * const copy = original.clone();
         *
         * // Clone and modify
         * const modified = original.clone();
         * modified.points[0] = 10; // Modify first x coordinate
         * ```
         * @returns A copy of the polygon
         * @see {@link Polygon.copyFrom} For copying into existing polygon
         * @see {@link Polygon.copyTo} For copying to another polygon
         */
        clone() {
          const points = this.points.slice();
          const polygon = new _Polygon(points);
          polygon.closePath = this.closePath;
          return polygon;
        }
        /**
         * Checks whether the x and y coordinates passed to this function are contained within this polygon.
         * Uses raycasting algorithm for point-in-polygon testing.
         * @example
         * ```ts
         * // Basic containment check
         * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
         * const isInside = polygon.contains(25, 25); // true
         * ```
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this polygon
         * @see {@link Polygon.strokeContains} For checking stroke intersection
         * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing
         */
        contains(x2, y2) {
          let inside = false;
          const length = this.points.length / 2;
          for (let i3 = 0, j2 = length - 1; i3 < length; j2 = i3++) {
            const xi = this.points[i3 * 2];
            const yi = this.points[i3 * 2 + 1];
            const xj = this.points[j2 * 2];
            const yj = this.points[j2 * 2 + 1];
            const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
            if (intersect) {
              inside = !inside;
            }
          }
          return inside;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
         * @example
         * ```ts
         * // Basic stroke check
         * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
         * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width
         *
         * // Check with different alignments
         * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside
         * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered
         * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside
         * ```
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
         * @returns Whether the x/y coordinates are within this polygon's stroke
         * @see {@link Polygon.contains} For checking fill containment
         * @see {@link Polygon.getBounds} For getting stroke bounds
         */
        strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
          const strokeWidthSquared = strokeWidth * strokeWidth;
          const rightWidthSquared = strokeWidthSquared * (1 - alignment);
          const leftWidthSquared = strokeWidthSquared - rightWidthSquared;
          const { points } = this;
          const iterationLength = points.length - (this.closePath ? 0 : 2);
          for (let i3 = 0; i3 < iterationLength; i3 += 2) {
            const x1 = points[i3];
            const y1 = points[i3 + 1];
            const x22 = points[(i3 + 2) % points.length];
            const y22 = points[(i3 + 3) % points.length];
            const distanceSquared = squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22);
            const sign2 = Math.sign((x22 - x1) * (y2 - y1) - (y22 - y1) * (x2 - x1));
            if (distanceSquared <= (sign2 < 0 ? leftWidthSquared : rightWidthSquared)) {
              return true;
            }
          }
          return false;
        }
        /**
         * Returns the framing rectangle of the polygon as a Rectangle object.
         * @example
         * ```ts
         * // Basic bounds calculation
         * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
         * const bounds = polygon.getBounds();
         * // bounds: x=0, y=0, width=100, height=100
         *
         * // Reuse existing rectangle
         * const rect = new Rectangle();
         * polygon.getBounds(rect);
         * ```
         * @param out - Optional rectangle to store the result
         * @returns The framing rectangle
         * @see {@link Rectangle} For rectangle properties
         * @see {@link Polygon.contains} For checking if a point is inside
         */
        getBounds(out2) {
          out2 || (out2 = new Rectangle());
          const points = this.points;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (let i3 = 0, n2 = points.length; i3 < n2; i3 += 2) {
            const x2 = points[i3];
            const y2 = points[i3 + 1];
            minX = x2 < minX ? x2 : minX;
            maxX = x2 > maxX ? x2 : maxX;
            minY = y2 < minY ? y2 : minY;
            maxY = y2 > maxY ? y2 : maxY;
          }
          out2.x = minX;
          out2.width = maxX - minX;
          out2.y = minY;
          out2.height = maxY - minY;
          return out2;
        }
        /**
         * Copies another polygon to this one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Polygon([0, 0, 100, 0, 50, 100]);
         * const target = new Polygon();
         * target.copyFrom(source);
         * ```
         * @param polygon - The polygon to copy from
         * @returns Returns itself
         * @see {@link Polygon.copyTo} For copying to another polygon
         * @see {@link Polygon.clone} For creating new polygon copy
         */
        copyFrom(polygon) {
          this.points = polygon.points.slice();
          this.closePath = polygon.closePath;
          return this;
        }
        /**
         * Copies this polygon to another one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Polygon([0, 0, 100, 0, 50, 100]);
         * const target = new Polygon();
         * source.copyTo(target);
         * ```
         * @param polygon - The polygon to copy to
         * @returns Returns given parameter
         * @see {@link Polygon.copyFrom} For copying from another polygon
         * @see {@link Polygon.clone} For creating new polygon copy
         */
        copyTo(polygon) {
          polygon.copyFrom(this);
          return polygon;
        }
        toString() {
          return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
        }
        /**
         * Get the last X coordinate of the polygon.
         * @example
         * ```ts
         * // Basic coordinate access
         * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
         * console.log(polygon.lastX); // 300
         * ```
         * @readonly
         * @returns The x-coordinate of the last vertex
         * @see {@link Polygon.lastY} For last Y coordinate
         * @see {@link Polygon.points} For raw points array
         */
        get lastX() {
          return this.points[this.points.length - 2];
        }
        /**
         * Get the last Y coordinate of the polygon.
         * @example
         * ```ts
         * // Basic coordinate access
         * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
         * console.log(polygon.lastY); // 400
         * ```
         * @readonly
         * @returns The y-coordinate of the last vertex
         * @see {@link Polygon.lastX} For last X coordinate
         * @see {@link Polygon.points} For raw points array
         */
        get lastY() {
          return this.points[this.points.length - 1];
        }
        /**
         * Get the last X coordinate of the polygon.
         * @readonly
         * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.
         */
        get x() {
          deprecation("8.11.0", "Polygon.lastX is deprecated, please use Polygon.lastX instead.");
          return this.points[this.points.length - 2];
        }
        /**
         * Get the last Y coordinate of the polygon.
         * @readonly
         * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.
         */
        get y() {
          deprecation("8.11.0", "Polygon.y is deprecated, please use Polygon.lastY instead.");
          return this.points[this.points.length - 1];
        }
        /**
         * Get the first X coordinate of the polygon.
         * @example
         * ```ts
         * // Basic coordinate access
         * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
         * console.log(polygon.x); // 0
         * ```
         * @readonly
         * @returns The x-coordinate of the first vertex
         * @see {@link Polygon.startY} For first Y coordinate
         * @see {@link Polygon.points} For raw points array
         */
        get startX() {
          return this.points[0];
        }
        /**
         * Get the first Y coordinate of the polygon.
         * @example
         * ```ts
         * // Basic coordinate access
         * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
         * console.log(polygon.y); // 0
         * ```
         * @readonly
         * @returns The y-coordinate of the first vertex
         * @see {@link Polygon.startX} For first X coordinate
         * @see {@link Polygon.points} For raw points array
         */
        get startY() {
          return this.points[1];
        }
      };
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
  var isCornerWithinStroke, RoundedRectangle;
  var init_RoundedRectangle = __esm({
    "node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
      init_Rectangle();
      isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter) => {
        const dx = pX - cornerX;
        const dy = pY - cornerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;
      };
      RoundedRectangle = class _RoundedRectangle {
        /**
         * @param x - The X coordinate of the upper-left corner of the rounded rectangle
         * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
         * @param width - The overall width of this rounded rectangle
         * @param height - The overall height of this rounded rectangle
         * @param radius - Controls the radius of the rounded corners
         */
        constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
          this.type = "roundedRectangle";
          this.x = x2;
          this.y = y2;
          this.width = width;
          this.height = height;
          this.radius = radius;
        }
        /**
         * Returns the framing rectangle of the rounded rectangle as a Rectangle object
         * @example
         * ```ts
         * // Basic bounds calculation
         * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
         * const bounds = rect.getBounds();
         * // bounds: x=100, y=100, width=200, height=150
         *
         * // Reuse existing rectangle
         * const out = new Rectangle();
         * rect.getBounds(out);
         * ```
         * @remarks
         * - Rectangle matches outer dimensions
         * - Ignores corner radius
         * @param out - Optional rectangle to store the result
         * @returns The framing rectangle
         * @see {@link Rectangle} For rectangle properties
         * @see {@link RoundedRectangle.contains} For checking if a point is inside
         */
        getBounds(out2) {
          out2 || (out2 = new Rectangle());
          out2.x = this.x;
          out2.y = this.y;
          out2.width = this.width;
          out2.height = this.height;
          return out2;
        }
        /**
         * Creates a clone of this Rounded Rectangle.
         * @example
         * ```ts
         * // Basic cloning
         * const original = new RoundedRectangle(100, 100, 200, 150, 20);
         * const copy = original.clone();
         *
         * // Clone and modify
         * const modified = original.clone();
         * modified.radius = 30;
         * modified.width *= 2;
         *
         * // Verify independence
         * console.log(original.radius);  // 20
         * console.log(modified.radius);  // 30
         * ```
         * @returns A copy of the rounded rectangle
         * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle
         * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
         */
        clone() {
          return new _RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        }
        /**
         * Copies another rectangle to this one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new RoundedRectangle(100, 100, 200, 150, 20);
         * const target = new RoundedRectangle();
         * target.copyFrom(source);
         *
         * // Chain with other operations
         * const rect = new RoundedRectangle()
         *     .copyFrom(source)
         *     .getBounds(rect);
         * ```
         * @param rectangle - The rectangle to copy from
         * @returns Returns itself
         * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
         * @see {@link RoundedRectangle.clone} For creating new rectangle copy
         */
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        /**
         * Copies this rectangle to another one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new RoundedRectangle(100, 100, 200, 150, 20);
         * const target = new RoundedRectangle();
         * source.copyTo(target);
         *
         * // Chain with other operations
         * const result = source
         *     .copyTo(new RoundedRectangle())
         *     .getBounds();
         * ```
         * @param rectangle - The rectangle to copy to
         * @returns Returns given parameter
         * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle
         * @see {@link RoundedRectangle.clone} For creating new rectangle copy
         */
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
         * @example
         * ```ts
         * // Basic containment check
         * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
         * const isInside = rect.contains(150, 125); // true
         * // Check corner radius
         * const corner = rect.contains(100, 100); // false if within corner curve
         * ```
         * @remarks
         * - Returns false if width/height is 0 or negative
         * - Handles rounded corners with radius check
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Rounded Rectangle
         * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection
         * @see {@link RoundedRectangle.getBounds} For getting containing rectangle
         */
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 <= this.x + this.width) {
            if (y2 >= this.y && y2 <= this.y + this.height) {
              const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
              if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
                return true;
              }
              let dx = x2 - (this.x + radius);
              let dy = y2 - (this.y + radius);
              const radius2 = radius * radius;
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + this.width - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dy = y2 - (this.y + this.height - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
            }
          }
          return false;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
         * @example
         * ```ts
         * // Basic stroke check
         * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
         * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
         *
         * // Check with different alignments
         * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
         * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
         * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
         * ```
         * @param pX - The X coordinate of the point to test
         * @param pY - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
         * @returns Whether the x/y coordinates are within this rectangle's stroke
         * @see {@link RoundedRectangle.contains} For checking fill containment
         * @see {@link RoundedRectangle.getBounds} For getting stroke bounds
         */
        strokeContains(pX, pY, strokeWidth, alignment = 0.5) {
          const { x: x2, y: y2, width, height, radius } = this;
          const strokeWidthOuter = strokeWidth * (1 - alignment);
          const strokeWidthInner = strokeWidth - strokeWidthOuter;
          const innerX = x2 + radius;
          const innerY = y2 + radius;
          const innerWidth = width - radius * 2;
          const innerHeight = height - radius * 2;
          const rightBound = x2 + width;
          const bottomBound = y2 + height;
          if ((pX >= x2 - strokeWidthOuter && pX <= x2 + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) {
            return true;
          }
          if ((pY >= y2 - strokeWidthOuter && pY <= y2 + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) {
            return true;
          }
          return (
            // Top-left
            pX < innerX && pY < innerY && isCornerWithinStroke(
              pX,
              pY,
              innerX,
              innerY,
              radius,
              strokeWidthInner,
              strokeWidthOuter
            ) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(
              pX,
              pY,
              rightBound - radius,
              innerY,
              radius,
              strokeWidthInner,
              strokeWidthOuter
            ) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(
              pX,
              pY,
              rightBound - radius,
              bottomBound - radius,
              radius,
              strokeWidthInner,
              strokeWidthOuter
            ) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(
              pX,
              pY,
              innerX,
              bottomBound - radius,
              radius,
              strokeWidthInner,
              strokeWidthOuter
            )
          );
        }
        toString() {
          return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
  function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
      Math.max(0, smoothness != null ? smoothness : GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
    if (level > RECURSION_LIMIT) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x34 = (x3 + x4) / 2;
    const y34 = (y3 + y4) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    const x234 = (x23 + x34) / 2;
    const y234 = (y23 + y34) / 2;
    const x1234 = (x123 + x234) / 2;
    const y1234 = (y123 + y234) / 2;
    if (level > 0) {
      let dx = x4 - x1;
      let dy = y4 - y1;
      const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
      const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
      let da1;
      let da2;
      if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
        if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          const a23 = Math.atan2(y3 - y2, x3 - x2);
          da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
          da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da2 >= pi)
            da2 = 2 * pi - da2;
          if (da1 + da2 < mAngleTolerance) {
            points.push(x1234, y1234);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
            if (da2 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else if (d2 > FLT_EPSILON) {
        if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
          }
        }
      } else if (d3 > FLT_EPSILON) {
        if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else {
        dx = x1234 - (x1 + x4) / 2;
        dy = y1234 - (y1 + y4) / 2;
        if (dx * dx + dy * dy <= distanceTolerance) {
          points.push(x1234, y1234);
          return;
        }
      }
    }
    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
  var init_buildAdaptiveBezier = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
      init_GraphicsContextSystem();
      RECURSION_LIMIT = 8;
      FLT_EPSILON = 11920929e-14;
      PATH_DISTANCE_EPSILON = 1;
      curveAngleToleranceEpsilon = 0.01;
      mAngleTolerance = 0;
      mCuspLimit = 0;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
  function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
      Math.max(0, smoothness != null ? smoothness : GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON2 - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
    recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
    if (level > RECURSION_LIMIT2) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    let dx = x3 - x1;
    let dy = y3 - y1;
    const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
    if (d2 > FLT_EPSILON2) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
          points.push(x123, y123);
          return;
        }
        let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da >= pi)
          da = 2 * pi - da;
        if (da < mAngleTolerance2) {
          points.push(x123, y123);
          return;
        }
      }
    } else {
      dx = x123 - (x1 + x3) / 2;
      dy = y123 - (y1 + y3) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x123, y123);
        return;
      }
    }
    recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
    recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
  var init_buildAdaptiveQuadratic = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
      init_GraphicsContextSystem();
      RECURSION_LIMIT2 = 8;
      FLT_EPSILON2 = 11920929e-14;
      PATH_DISTANCE_EPSILON2 = 1;
      curveAngleToleranceEpsilon2 = 0.01;
      mAngleTolerance2 = 0;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
  function buildArc(points, x2, y2, radius, start, end, clockwise, steps) {
    let dist = Math.abs(start - end);
    if (!clockwise && start > end) {
      dist = 2 * Math.PI - dist;
    } else if (clockwise && end > start) {
      dist = 2 * Math.PI - dist;
    }
    steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));
    steps = Math.max(steps, 3);
    let f2 = dist / steps;
    let t2 = start;
    f2 *= clockwise ? -1 : 1;
    for (let i3 = 0; i3 < steps + 1; i3++) {
      const cs = Math.cos(t2);
      const sn = Math.sin(t2);
      const nx = x2 + cs * radius;
      const ny = y2 + sn * radius;
      points.push(nx, ny);
      t2 += f2;
    }
  }
  var init_buildArc = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
  function buildArcTo(points, x1, y1, x2, y2, radius) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    buildArc(
      points,
      cx + x1,
      cy + y1,
      radius,
      startAngle,
      endAngle,
      b1 * a2 > b2 * a1
    );
  }
  var init_buildArcTo = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
      init_buildArc();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
  function approxUnitArc(ang1, ang2) {
    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
    const x1 = Math.cos(ang1);
    const y1 = Math.sin(ang1);
    const x2 = Math.cos(ang1 + ang2);
    const y2 = Math.sin(ang1 + ang2);
    return [
      {
        x: x1 - y1 * a2,
        y: y1 + x1 * a2
      },
      {
        x: x2 + y2 * a2,
        y: y2 - x2 * a2
      },
      {
        x: x2,
        y: y2
      }
    ];
  }
  function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
    if (rx === 0 || ry === 0) {
      return;
    }
    const sinPhi = Math.sin(xAxisRotation * TAU / 360);
    const cosPhi = Math.cos(xAxisRotation * TAU / 360);
    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return;
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    getArcCenter(
      px,
      py,
      cx,
      cy,
      rx,
      ry,
      largeArcFlag,
      sweepFlag,
      sinPhi,
      cosPhi,
      pxp,
      pyp,
      out
    );
    let { ang1, ang2 } = out;
    const { centerX, centerY } = out;
    let ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    const segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    let lastX = points[points.length - 2];
    let lastY = points[points.length - 1];
    const outCurvePoint = { x: 0, y: 0 };
    for (let i3 = 0; i3 < segments; i3++) {
      const curve = approxUnitArc(ang1, ang2);
      const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      buildAdaptiveBezier(
        points,
        lastX,
        lastY,
        x1,
        y1,
        x2,
        y2,
        x3,
        y3
      );
      lastX = x3;
      lastY = y3;
      ang1 += ang2;
    }
  }
  var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
  var init_buildArcToSvg = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
      init_buildAdaptiveBezier();
      TAU = Math.PI * 2;
      out = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
      };
      mapToEllipse = ({ x: x2, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
        x2 *= rx;
        y2 *= ry;
        const xp = cosPhi * x2 - sinPhi * y2;
        const yp = sinPhi * x2 + cosPhi * y2;
        out2.x = xp + centerX;
        out2.y = yp + centerY;
        return out2;
      };
      vectorAngle = (ux2, uy2, vx2, vy2) => {
        const sign2 = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
        let dot = ux2 * vx2 + uy2 * vy2;
        if (dot > 1) {
          dot = 1;
        }
        if (dot < -1) {
          dot = -1;
        }
        return sign2 * Math.acos(dot);
      };
      getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
        const rxSq = Math.pow(rx, 2);
        const rySq = Math.pow(ry, 2);
        const pxpSq = Math.pow(pxp, 2);
        const pypSq = Math.pow(pyp, 2);
        let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
        if (radicant < 0) {
          radicant = 0;
        }
        radicant /= rxSq * pypSq + rySq * pxpSq;
        radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
        const centerXp = radicant * rx / ry * pyp;
        const centerYp = radicant * -ry / rx * pxp;
        const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
        const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
        const vx1 = (pxp - centerXp) / rx;
        const vy1 = (pyp - centerYp) / ry;
        const vx2 = (-pxp - centerXp) / rx;
        const vy2 = (-pyp - centerYp) / ry;
        const ang1 = vectorAngle(1, 0, vx1, vy1);
        let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
        if (sweepFlag === 0 && ang2 > 0) {
          ang2 -= TAU;
        }
        if (sweepFlag === 1 && ang2 < 0) {
          ang2 += TAU;
        }
        out2.centerX = centerX;
        out2.centerY = centerY;
        out2.ang1 = ang1;
        out2.ang2 = ang2;
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs
  function roundedShapeArc(g2, points, radius) {
    var _a2;
    const vecFrom = (p3, pp) => {
      const x2 = pp.x - p3.x;
      const y2 = pp.y - p3.y;
      const len = Math.sqrt(x2 * x2 + y2 * y2);
      const nx = x2 / len;
      const ny = y2 / len;
      return { len, nx, ny };
    };
    const sharpCorner = (i3, p3) => {
      if (i3 === 0) {
        g2.moveTo(p3.x, p3.y);
      } else {
        g2.lineTo(p3.x, p3.y);
      }
    };
    let p1 = points[points.length - 1];
    for (let i3 = 0; i3 < points.length; i3++) {
      const p22 = points[i3 % points.length];
      const pRadius = (_a2 = p22.radius) != null ? _a2 : radius;
      if (pRadius <= 0) {
        sharpCorner(i3, p22);
        p1 = p22;
        continue;
      }
      const p3 = points[(i3 + 1) % points.length];
      const v1 = vecFrom(p22, p1);
      const v2 = vecFrom(p22, p3);
      if (v1.len < 1e-4 || v2.len < 1e-4) {
        sharpCorner(i3, p22);
        p1 = p22;
        continue;
      }
      let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
      let radDirection = 1;
      let drawDirection = false;
      if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
        if (angle < 0) {
          angle = Math.PI + angle;
        } else {
          angle = Math.PI - angle;
          radDirection = -1;
          drawDirection = true;
        }
      } else if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
      const halfAngle = angle / 2;
      let cRadius;
      let lenOut = Math.abs(
        Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
      );
      if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
        lenOut = Math.min(v1.len / 2, v2.len / 2);
        cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
      } else {
        cRadius = pRadius;
      }
      const cX = p22.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
      const cY = p22.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
      const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
      const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
      if (i3 === 0) {
        g2.moveTo(
          cX + Math.cos(startAngle) * cRadius,
          cY + Math.sin(startAngle) * cRadius
        );
      }
      g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
      p1 = p22;
    }
  }
  function roundedShapeQuadraticCurve(g2, points, radius, smoothness) {
    var _a2;
    const distance = (p1, p22) => Math.sqrt(__pow(p1.x - p22.x, 2) + __pow(p1.y - p22.y, 2));
    const pointLerp = (p1, p22, t2) => ({
      x: p1.x + (p22.x - p1.x) * t2,
      y: p1.y + (p22.y - p1.y) * t2
    });
    const numPoints = points.length;
    for (let i3 = 0; i3 < numPoints; i3++) {
      const thisPoint = points[(i3 + 1) % numPoints];
      const pRadius = (_a2 = thisPoint.radius) != null ? _a2 : radius;
      if (pRadius <= 0) {
        if (i3 === 0) {
          g2.moveTo(thisPoint.x, thisPoint.y);
        } else {
          g2.lineTo(thisPoint.x, thisPoint.y);
        }
        continue;
      }
      const lastPoint = points[i3];
      const nextPoint = points[(i3 + 2) % numPoints];
      const lastEdgeLength = distance(lastPoint, thisPoint);
      let start;
      if (lastEdgeLength < 1e-4) {
        start = thisPoint;
      } else {
        const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
        start = pointLerp(
          thisPoint,
          lastPoint,
          lastOffsetDistance / lastEdgeLength
        );
      }
      const nextEdgeLength = distance(nextPoint, thisPoint);
      let end;
      if (nextEdgeLength < 1e-4) {
        end = thisPoint;
      } else {
        const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
        end = pointLerp(
          thisPoint,
          nextPoint,
          nextOffsetDistance / nextEdgeLength
        );
      }
      if (i3 === 0) {
        g2.moveTo(start.x, start.y);
      } else {
        g2.lineTo(start.x, start.y);
      }
      g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
    }
  }
  var init_roundShape = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
  var tempRectangle, ShapePath;
  var init_ShapePath = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"() {
      init_Circle();
      init_Ellipse();
      init_Polygon();
      init_Rectangle();
      init_RoundedRectangle();
      init_Bounds();
      init_buildAdaptiveBezier();
      init_buildAdaptiveQuadratic();
      init_buildArc();
      init_buildArcTo();
      init_buildArcToSvg();
      init_roundShape();
      tempRectangle = new Rectangle();
      ShapePath = class {
        constructor(graphicsPath2D) {
          this.shapePrimitives = [];
          this._currentPoly = null;
          this._bounds = new Bounds();
          this._graphicsPath2D = graphicsPath2D;
          this.signed = graphicsPath2D.checkForHoles;
        }
        /**
         * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
         * @param x - The x-coordinate for the starting point.
         * @param y - The y-coordinate for the starting point.
         * @returns The instance of the current object for chaining.
         */
        moveTo(x2, y2) {
          this.startPoly(x2, y2);
          return this;
        }
        /**
         * Connects the current point to a new point with a straight line. This method updates the current path.
         * @param x - The x-coordinate of the new point to connect to.
         * @param y - The y-coordinate of the new point to connect to.
         * @returns The instance of the current object for chaining.
         */
        lineTo(x2, y2) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          const fromX = points[points.length - 2];
          const fromY = points[points.length - 1];
          if (fromX !== x2 || fromY !== y2) {
            points.push(x2, y2);
          }
          return this;
        }
        /**
         * Adds an arc to the path. The arc is centered at (x, y)
         *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
         * @param x - The x-coordinate of the arc's center.
         * @param y - The y-coordinate of the arc's center.
         * @param radius - The radius of the arc.
         * @param startAngle - The starting angle of the arc, in radians.
         * @param endAngle - The ending angle of the arc, in radians.
         * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
         * @returns The instance of the current object for chaining.
         */
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._ensurePoly(false);
          const points = this._currentPoly.points;
          buildArc(points, x2, y2, radius, startAngle, endAngle, counterclockwise);
          return this;
        }
        /**
         * Adds an arc to the path with the arc tangent to the line joining two specified points.
         * The arc radius is specified by `radius`.
         * @param x1 - The x-coordinate of the first point.
         * @param y1 - The y-coordinate of the first point.
         * @param x2 - The x-coordinate of the second point.
         * @param y2 - The y-coordinate of the second point.
         * @param radius - The radius of the arc.
         * @returns The instance of the current object for chaining.
         */
        arcTo(x1, y1, x2, y2, radius) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          buildArcTo(points, x1, y1, x2, y2, radius);
          return this;
        }
        /**
         * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
         * @param rx - The x-radius of the ellipse.
         * @param ry - The y-radius of the ellipse.
         * @param xAxisRotation - The rotation of the ellipse's x-axis relative
         * to the x-axis of the coordinate system, in degrees.
         * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
         * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
         * @param x - The x-coordinate of the arc's end point.
         * @param y - The y-coordinate of the arc's end point.
         * @returns The instance of the current object for chaining.
         */
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          const points = this._currentPoly.points;
          buildArcToSvg(
            points,
            this._currentPoly.lastX,
            this._currentPoly.lastY,
            x2,
            y2,
            rx,
            ry,
            xAxisRotation,
            largeArcFlag,
            sweepFlag
          );
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires three points: the first two are control points and the third one is the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the first control point.
         * @param cp1y - The y-coordinate of the first control point.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveBezier(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            cp2x,
            cp2y,
            x2,
            y2,
            smoothness
          );
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the control point.
         * @param cp1y - The y-coordinate of the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothing - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveTo(cp1x, cp1y, x2, y2, smoothing) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveQuadratic(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            x2,
            y2,
            smoothing
          );
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this.endPoly(true);
          return this;
        }
        /**
         * Adds another path to the current path. This method allows for the combination of multiple paths into one.
         * @param path - The `GraphicsPath` object representing the path to add.
         * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
         * @returns The instance of the current object for chaining.
         */
        addPath(path2, transform2) {
          this.endPoly();
          if (transform2 && !transform2.isIdentity()) {
            path2 = path2.clone(true);
            path2.transform(transform2);
          }
          const shapePrimitives = this.shapePrimitives;
          const start = shapePrimitives.length;
          for (let i3 = 0; i3 < path2.instructions.length; i3++) {
            const instruction = path2.instructions[i3];
            this[instruction.action](...instruction.data);
          }
          if (path2.checkForHoles && shapePrimitives.length - start > 1) {
            let mainShape = null;
            for (let i3 = start; i3 < shapePrimitives.length; i3++) {
              const shapePrimitive = shapePrimitives[i3];
              if (shapePrimitive.shape.type === "polygon") {
                const polygon = shapePrimitive.shape;
                const mainPolygon = mainShape == null ? void 0 : mainShape.shape;
                if (mainPolygon && mainPolygon.containsPolygon(polygon)) {
                  mainShape.holes || (mainShape.holes = []);
                  mainShape.holes.push(shapePrimitive);
                  shapePrimitives.copyWithin(i3, i3 + 1);
                  shapePrimitives.length--;
                  i3--;
                } else {
                  mainShape = shapePrimitive;
                }
              }
            }
          }
          return this;
        }
        /**
         * Finalizes the drawing of the current path. Optionally, it can close the path.
         * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
         */
        finish(closePath = false) {
          this.endPoly(closePath);
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2, transform2) {
          this.drawShape(new Rectangle(x2, y2, w2, h2), transform2);
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @param transform - An optional `Matrix` object to apply a transformation to the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius, transform2) {
          this.drawShape(new Circle(x2, y2, radius), transform2);
          return this;
        }
        /**
         * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
         * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
         * representing the x and y coordinates of the polygon's vertices, in sequence.
         * @param close - A boolean indicating whether to close the polygon path. True by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        poly(points, close, transform2) {
          const polygon = new Polygon(points);
          polygon.closePath = close;
          this.drawShape(polygon, transform2);
          return this;
        }
        /**
         * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
          sides = Math.max(sides | 0, 3);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const delta = Math.PI * 2 / sides;
          const polygon = [];
          for (let i3 = 0; i3 < sides; i3++) {
            const angle = startAngle - i3 * delta;
            polygon.push(
              x2 + radius * Math.cos(angle),
              y2 + radius * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform2);
          return this;
        }
        /**
         * Draws a polygon with rounded corners.
         * Similar to `regularPoly` but with the ability to round the corners of the polygon.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param corner - The radius of the rounding of the corners.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
         * @returns The instance of the current object for chaining.
         */
        roundPoly(x2, y2, radius, sides, corner, rotation = 0, smoothness) {
          sides = Math.max(sides | 0, 3);
          if (corner <= 0) {
            return this.regularPoly(x2, y2, radius, sides, rotation);
          }
          const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
          corner = Math.min(corner, sideLength);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const delta = Math.PI * 2 / sides;
          const internalAngle = (sides - 2) * Math.PI / sides / 2;
          for (let i3 = 0; i3 < sides; i3++) {
            const angle = i3 * delta + startAngle;
            const x0 = x2 + radius * Math.cos(angle);
            const y0 = y2 + radius * Math.sin(angle);
            const a1 = angle + Math.PI + internalAngle;
            const a2 = angle - Math.PI - internalAngle;
            const x1 = x0 + corner * Math.cos(a1);
            const y1 = y0 + corner * Math.sin(a1);
            const x3 = x0 + corner * Math.cos(a2);
            const y3 = y0 + corner * Math.sin(a2);
            if (i3 === 0) {
              this.moveTo(x1, y1);
            } else {
              this.lineTo(x1, y1);
            }
            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
          }
          return this.closePath();
        }
        /**
         * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
         * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
         * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
         * A minimum of 3 points is required.
         * @param radius - The default radius for the corners.
         * This radius is applied to all corners unless overridden in `points`.
         * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
         *  method instead of an arc method. Defaults to false.
         * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
         * Higher values make the curve smoother.
         * @returns The instance of the current object for chaining.
         */
        roundShape(points, radius, useQuadratic = false, smoothness) {
          if (points.length < 3) {
            return this;
          }
          if (useQuadratic) {
            roundedShapeQuadraticCurve(this, points, radius, smoothness);
          } else {
            roundedShapeArc(this, points, radius);
          }
          return this.closePath();
        }
        /**
         * Draw Rectangle with fillet corners. This is much like rounded rectangle
         * however it support negative numbers as well for the corner radius.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param fillet - accept negative or positive values
         */
        filletRect(x2, y2, width, height, fillet) {
          if (fillet === 0) {
            return this.rect(x2, y2, width, height);
          }
          const maxFillet = Math.min(width, height) / 2;
          const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
          const right = x2 + width;
          const bottom = y2 + height;
          const dir = inset < 0 ? -inset : 0;
          const size = Math.abs(inset);
          return this.moveTo(x2, y2 + size).arcTo(x2 + dir, y2 + dir, x2 + size, y2, size).lineTo(right - size, y2).arcTo(right - dir, y2 + dir, right, y2 + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x2 + width - size, bottom, size).lineTo(x2 + size, bottom).arcTo(x2 + dir, bottom - dir, x2, bottom - size, size).closePath();
        }
        /**
         * Draw Rectangle with chamfer corners. These are angled corners.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param chamfer - non-zero real number, size of corner cutout
         * @param transform
         */
        chamferRect(x2, y2, width, height, chamfer, transform2) {
          if (chamfer <= 0) {
            return this.rect(x2, y2, width, height);
          }
          const inset = Math.min(chamfer, Math.min(width, height) / 2);
          const right = x2 + width;
          const bottom = y2 + height;
          const points = [
            x2 + inset,
            y2,
            right - inset,
            y2,
            right,
            y2 + inset,
            right,
            bottom - inset,
            right - inset,
            bottom,
            x2 + inset,
            bottom,
            x2,
            bottom - inset,
            x2,
            y2 + inset
          ];
          for (let i3 = points.length - 1; i3 >= 2; i3 -= 2) {
            if (points[i3] === points[i3 - 2] && points[i3 - 1] === points[i3 - 3]) {
              points.splice(i3 - 1, 2);
            }
          }
          return this.poly(points, true, transform2);
        }
        /**
         * Draws an ellipse at the specified location and with the given x and y radii.
         * An optional transformation can be applied, allowing for rotation, scaling, and translation.
         * @param x - The x-coordinate of the center of the ellipse.
         * @param y - The y-coordinate of the center of the ellipse.
         * @param radiusX - The horizontal radius of the ellipse.
         * @param radiusY - The vertical radius of the ellipse.
         * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
         * @returns The instance of the current object for chaining.
         */
        ellipse(x2, y2, radiusX, radiusY, transform2) {
          this.drawShape(new Ellipse(x2, y2, radiusX, radiusY), transform2);
          return this;
        }
        /**
         * Draws a rectangle with rounded corners.
         * The corner radius can be specified to determine how rounded the corners should be.
         * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        roundRect(x2, y2, w2, h2, radius, transform2) {
          this.drawShape(new RoundedRectangle(x2, y2, w2, h2, radius), transform2);
          return this;
        }
        /**
         * Draws a given shape on the canvas.
         * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
         * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
         * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
         * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
         * scaling, and translations.
         * @returns The instance of the current object for chaining.
         */
        drawShape(shape, matrix) {
          this.endPoly();
          this.shapePrimitives.push({ shape, transform: matrix });
          return this;
        }
        /**
         * Starts a new polygon path from the specified starting point.
         * This method initializes a new polygon or ends the current one if it exists.
         * @param x - The x-coordinate of the starting point of the new polygon.
         * @param y - The y-coordinate of the starting point of the new polygon.
         * @returns The instance of the current object for chaining.
         */
        startPoly(x2, y2) {
          let currentPoly = this._currentPoly;
          if (currentPoly) {
            this.endPoly();
          }
          currentPoly = new Polygon();
          currentPoly.points.push(x2, y2);
          this._currentPoly = currentPoly;
          return this;
        }
        /**
         * Ends the current polygon path. If `closePath` is set to true,
         * the path is closed by connecting the last point to the first one.
         * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
         * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
         *  back to the starting point. False by default.
         * @returns The instance of the current object for chaining.
         */
        endPoly(closePath = false) {
          const shape = this._currentPoly;
          if (shape && shape.points.length > 2) {
            shape.closePath = closePath;
            this.shapePrimitives.push({ shape });
          }
          this._currentPoly = null;
          return this;
        }
        _ensurePoly(start = true) {
          if (this._currentPoly)
            return;
          this._currentPoly = new Polygon();
          if (start) {
            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
            if (lastShape) {
              let lx = lastShape.shape.x;
              let ly = lastShape.shape.y;
              if (lastShape.transform && !lastShape.transform.isIdentity()) {
                const t2 = lastShape.transform;
                const tempX = lx;
                lx = t2.a * lx + t2.c * ly + t2.tx;
                ly = t2.b * tempX + t2.d * ly + t2.ty;
              }
              this._currentPoly.points.push(lx, ly);
            } else {
              this._currentPoly.points.push(0, 0);
            }
          }
        }
        /** Builds the path. */
        buildPath() {
          const path2 = this._graphicsPath2D;
          this.shapePrimitives.length = 0;
          this._currentPoly = null;
          for (let i3 = 0; i3 < path2.instructions.length; i3++) {
            const instruction = path2.instructions[i3];
            this[instruction.action](...instruction.data);
          }
          this.finish();
        }
        /** Gets the bounds of the path. */
        get bounds() {
          const bounds = this._bounds;
          bounds.clear();
          const shapePrimitives = this.shapePrimitives;
          for (let i3 = 0; i3 < shapePrimitives.length; i3++) {
            const shapePrimitive = shapePrimitives[i3];
            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
            if (shapePrimitive.transform) {
              bounds.addRect(boundsRect, shapePrimitive.transform);
            } else {
              bounds.addRect(boundsRect);
            }
          }
          return bounds;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
  function adjustTransform(currentMatrix, transform2) {
    if (currentMatrix) {
      return currentMatrix.prepend(transform2);
    }
    return transform2.clone();
  }
  var GraphicsPath;
  var init_GraphicsPath = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
      init_Point();
      init_uid();
      init_warn();
      init_parseSVGPath();
      init_ShapePath();
      GraphicsPath = class _GraphicsPath {
        /**
         * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
         * @param instructions - An SVG path string or an array of `PathInstruction` objects.
         * @param signed
         */
        constructor(instructions, signed = false) {
          var _a2;
          this.instructions = [];
          this.uid = uid2("graphicsPath");
          this._dirty = true;
          this.checkForHoles = signed;
          if (typeof instructions === "string") {
            parseSVGPath(instructions, this);
          } else {
            this.instructions = (_a2 = instructions == null ? void 0 : instructions.slice()) != null ? _a2 : [];
          }
        }
        /**
         * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
         * @returns The `ShapePath` instance associated with this `GraphicsPath`.
         */
        get shapePath() {
          if (!this._shapePath) {
            this._shapePath = new ShapePath(this);
          }
          if (this._dirty) {
            this._dirty = false;
            this._shapePath.buildPath();
          }
          return this._shapePath;
        }
        /**
         * Adds another `GraphicsPath` to this path, optionally applying a transformation.
         * @param path - The `GraphicsPath` to add.
         * @param transform - An optional transformation to apply to the added path.
         * @returns The instance of the current object for chaining.
         */
        addPath(path2, transform2) {
          path2 = path2.clone();
          this.instructions.push({ action: "addPath", data: [path2, transform2] });
          this._dirty = true;
          return this;
        }
        arc(...args) {
          this.instructions.push({ action: "arc", data: args });
          this._dirty = true;
          return this;
        }
        arcTo(...args) {
          this.instructions.push({ action: "arcTo", data: args });
          this._dirty = true;
          return this;
        }
        arcToSvg(...args) {
          this.instructions.push({ action: "arcToSvg", data: args });
          this._dirty = true;
          return this;
        }
        bezierCurveTo(...args) {
          this.instructions.push({ action: "bezierCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires two points: the second control point and the end point. The first control point is assumed to be
         * The starting point is the last point in the current path.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveToShort(cp2x, cp2y, x2, y2, smoothness) {
          const last = this.instructions[this.instructions.length - 1];
          const lastPoint = this.getLastPoint(Point.shared);
          let cp1x = 0;
          let cp1y = 0;
          if (!last || last.action !== "bezierCurveTo") {
            cp1x = lastPoint.x;
            cp1y = lastPoint.y;
          } else {
            cp1x = last.data[2];
            cp1y = last.data[3];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cp1x = currentX + (currentX - cp1x);
            cp1y = currentY + (currentY - cp1y);
          }
          this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness] });
          this._dirty = true;
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this.instructions.push({ action: "closePath", data: [] });
          this._dirty = true;
          return this;
        }
        ellipse(...args) {
          this.instructions.push({ action: "ellipse", data: args });
          this._dirty = true;
          return this;
        }
        lineTo(...args) {
          this.instructions.push({ action: "lineTo", data: args });
          this._dirty = true;
          return this;
        }
        moveTo(...args) {
          this.instructions.push({ action: "moveTo", data: args });
          return this;
        }
        quadraticCurveTo(...args) {
          this.instructions.push({ action: "quadraticCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It uses the previous point as the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveToShort(x2, y2, smoothness) {
          const last = this.instructions[this.instructions.length - 1];
          const lastPoint = this.getLastPoint(Point.shared);
          let cpx1 = 0;
          let cpy1 = 0;
          if (!last || last.action !== "quadraticCurveTo") {
            cpx1 = lastPoint.x;
            cpy1 = lastPoint.y;
          } else {
            cpx1 = last.data[0];
            cpy1 = last.data[1];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cpx1 = currentX + (currentX - cpx1);
            cpy1 = currentY + (currentY - cpy1);
          }
          this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2, smoothness] });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2, transform2) {
          this.instructions.push({ action: "rect", data: [x2, y2, w2, h2, transform2] });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @param transform - An optional `Matrix` object to apply a transformation to the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius, transform2) {
          this.instructions.push({ action: "circle", data: [x2, y2, radius, transform2] });
          this._dirty = true;
          return this;
        }
        roundRect(...args) {
          this.instructions.push({ action: "roundRect", data: args });
          this._dirty = true;
          return this;
        }
        poly(...args) {
          this.instructions.push({ action: "poly", data: args });
          this._dirty = true;
          return this;
        }
        regularPoly(...args) {
          this.instructions.push({ action: "regularPoly", data: args });
          this._dirty = true;
          return this;
        }
        roundPoly(...args) {
          this.instructions.push({ action: "roundPoly", data: args });
          this._dirty = true;
          return this;
        }
        roundShape(...args) {
          this.instructions.push({ action: "roundShape", data: args });
          this._dirty = true;
          return this;
        }
        filletRect(...args) {
          this.instructions.push({ action: "filletRect", data: args });
          this._dirty = true;
          return this;
        }
        chamferRect(...args) {
          this.instructions.push({ action: "chamferRect", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a star shape centered at a specified location. This method allows for the creation
         *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
         * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
         * An optional transformation can be applied to scale, rotate, or translate the star as needed.
         * @param x - The x-coordinate of the center of the star.
         * @param y - The y-coordinate of the center of the star.
         * @param points - The number of points of the star.
         * @param radius - The outer radius of the star (distance from the center to the outer points).
         * @param innerRadius - Optional. The inner radius of the star
         * (distance from the center to the inner points between the outer points).
         * If not provided, defaults to half of the `radius`.
         * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
         * Defaults to 0, meaning one point is directly upward.
         * @param transform - An optional `Matrix` object to apply a transformation to the star.
         * This can include rotations, scaling, and translations.
         * @returns The instance of the current object for chaining further drawing commands.
         */
        // eslint-disable-next-line max-len
        star(x2, y2, points, radius, innerRadius, rotation, transform2) {
          innerRadius || (innerRadius = radius / 2);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const len = points * 2;
          const delta = Math.PI * 2 / len;
          const polygon = [];
          for (let i3 = 0; i3 < len; i3++) {
            const r2 = i3 % 2 ? innerRadius : radius;
            const angle = i3 * delta + startAngle;
            polygon.push(
              x2 + r2 * Math.cos(angle),
              y2 + r2 * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform2);
          return this;
        }
        /**
         * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
         * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
         * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
         * do not affect the original `GraphicsPath` and vice versa.
         * @param deep - A boolean flag indicating whether the clone should be deep.
         * @returns A new `GraphicsPath` instance that is a clone of the current instance.
         */
        clone(deep = false) {
          const newGraphicsPath2D = new _GraphicsPath();
          newGraphicsPath2D.checkForHoles = this.checkForHoles;
          if (!deep) {
            newGraphicsPath2D.instructions = this.instructions.slice();
          } else {
            for (let i3 = 0; i3 < this.instructions.length; i3++) {
              const instruction = this.instructions[i3];
              newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
            }
          }
          return newGraphicsPath2D;
        }
        clear() {
          this.instructions.length = 0;
          this._dirty = true;
          return this;
        }
        /**
         * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
         * This method enables the modification of the path's geometry according to the provided
         * transformation matrix, which can include translations, rotations, scaling, and skewing.
         *
         * Each drawing instruction in the path is updated to reflect the transformation,
         * ensuring the visual representation of the path is consistent with the applied matrix.
         *
         * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
         * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
         * allowing for fine-grained control over the path's appearance.
         * @param matrix - A `Matrix` object representing the transformation to apply.
         * @returns The instance of the current object for chaining further operations.
         */
        transform(matrix) {
          if (matrix.isIdentity())
            return this;
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let x2 = 0;
          let y2 = 0;
          let cpx1 = 0;
          let cpy1 = 0;
          let cpx2 = 0;
          let cpy2 = 0;
          let rx = 0;
          let ry = 0;
          for (let i3 = 0; i3 < this.instructions.length; i3++) {
            const instruction = this.instructions[i3];
            const data = instruction.data;
            switch (instruction.action) {
              case "moveTo":
              case "lineTo":
                x2 = data[0];
                y2 = data[1];
                data[0] = a2 * x2 + c2 * y2 + tx;
                data[1] = b2 * x2 + d2 * y2 + ty;
                break;
              case "bezierCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                cpx2 = data[2];
                cpy2 = data[3];
                x2 = data[4];
                y2 = data[5];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * cpx2 + c2 * cpy2 + tx;
                data[3] = b2 * cpx2 + d2 * cpy2 + ty;
                data[4] = a2 * x2 + c2 * y2 + tx;
                data[5] = b2 * x2 + d2 * y2 + ty;
                break;
              case "quadraticCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                x2 = data[2];
                y2 = data[3];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * x2 + c2 * y2 + tx;
                data[3] = b2 * x2 + d2 * y2 + ty;
                break;
              case "arcToSvg":
                x2 = data[5];
                y2 = data[6];
                rx = data[0];
                ry = data[1];
                data[0] = a2 * rx + c2 * ry;
                data[1] = b2 * rx + d2 * ry;
                data[5] = a2 * x2 + c2 * y2 + tx;
                data[6] = b2 * x2 + d2 * y2 + ty;
                break;
              case "circle":
                data[4] = adjustTransform(data[3], matrix);
                break;
              case "rect":
                data[4] = adjustTransform(data[4], matrix);
                break;
              case "ellipse":
                data[8] = adjustTransform(data[8], matrix);
                break;
              case "roundRect":
                data[5] = adjustTransform(data[5], matrix);
                break;
              case "addPath":
                data[0].transform(matrix);
                break;
              case "poly":
                data[2] = adjustTransform(data[2], matrix);
                break;
              default:
                warn("unknown transform action", instruction.action);
                break;
            }
          }
          this._dirty = true;
          return this;
        }
        get bounds() {
          return this.shapePath.bounds;
        }
        /**
         * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
         * This method is useful for operations that depend on the path's current endpoint,
         * such as connecting subsequent shapes or paths. It supports various drawing instructions,
         * ensuring the last point's position is accurately determined regardless of the path's complexity.
         *
         * If the last instruction is a `closePath`, the method iterates backward through the instructions
         *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
         * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
         * the last point from the nested path.
         * @param out - A `Point` object where the last point's coordinates will be stored.
         * This object is modified directly to contain the result.
         * @returns The `Point` object containing the last point's coordinates.
         */
        getLastPoint(out2) {
          let index = this.instructions.length - 1;
          let lastInstruction = this.instructions[index];
          if (!lastInstruction) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          while (lastInstruction.action === "closePath") {
            index--;
            if (index < 0) {
              out2.x = 0;
              out2.y = 0;
              return out2;
            }
            lastInstruction = this.instructions[index];
          }
          switch (lastInstruction.action) {
            case "moveTo":
            case "lineTo":
              out2.x = lastInstruction.data[0];
              out2.y = lastInstruction.data[1];
              break;
            case "quadraticCurveTo":
              out2.x = lastInstruction.data[2];
              out2.y = lastInstruction.data[3];
              break;
            case "bezierCurveTo":
              out2.x = lastInstruction.data[4];
              out2.y = lastInstruction.data[5];
              break;
            case "arc":
            case "arcToSvg":
              out2.x = lastInstruction.data[5];
              out2.y = lastInstruction.data[6];
              break;
            case "addPath":
              lastInstruction.data[0].getLastPoint(out2);
              break;
          }
          return out2;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs
  function parseSVGFloatAttribute(svg, id, defaultValue2) {
    const value = svg.getAttribute(id);
    return value ? Number(value) : defaultValue2;
  }
  var init_parseSVGFloatAttribute = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs
  function parseSVGDefinitions(svg, session) {
    const definitions = svg.querySelectorAll("defs");
    for (let i3 = 0; i3 < definitions.length; i3++) {
      const definition = definitions[i3];
      for (let j2 = 0; j2 < definition.children.length; j2++) {
        const child = definition.children[j2];
        switch (child.nodeName.toLowerCase()) {
          case "lineargradient":
            session.defs[child.id] = parseLinearGradient(child);
            break;
          case "radialgradient":
            session.defs[child.id] = parseRadialGradient(child);
            break;
          default:
            break;
        }
      }
    }
  }
  function parseLinearGradient(child) {
    const x0 = parseSVGFloatAttribute(child, "x1", 0);
    const y0 = parseSVGFloatAttribute(child, "y1", 0);
    const x1 = parseSVGFloatAttribute(child, "x2", 1);
    const y1 = parseSVGFloatAttribute(child, "y2", 0);
    const gradientUnit = child.getAttribute("gradientUnits") || "objectBoundingBox";
    const gradient = new FillGradient(
      x0,
      y0,
      x1,
      y1,
      gradientUnit === "objectBoundingBox" ? "local" : "global"
    );
    for (let k2 = 0; k2 < child.children.length; k2++) {
      const stop = child.children[k2];
      const offset = parseSVGFloatAttribute(stop, "offset", 0);
      const color = Color.shared.setValue(stop.getAttribute("stop-color")).toNumber();
      gradient.addColorStop(offset, color);
    }
    return gradient;
  }
  function parseRadialGradient(_child) {
    warn("[SVG Parser] Radial gradients are not yet supported");
    return new FillGradient(0, 0, 1, 0);
  }
  var init_parseSVGDefinitions = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs"() {
      init_Color();
      init_warn();
      init_FillGradient();
      init_parseSVGFloatAttribute();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs
  function extractSvgUrlId(url) {
    const match = url.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return match ? match[1] : "";
  }
  var init_extractSvgUrlId = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs
  function parseSVGStyle(svg, session) {
    const style = svg.getAttribute("style");
    const strokeStyle = {};
    const fillStyle = {};
    const result = {
      strokeStyle,
      fillStyle,
      useFill: false,
      useStroke: false
    };
    for (const key in styleAttributes) {
      const attribute = svg.getAttribute(key);
      if (attribute) {
        parseAttribute(session, result, key, attribute.trim());
      }
    }
    if (style) {
      const styleParts = style.split(";");
      for (let i3 = 0; i3 < styleParts.length; i3++) {
        const stylePart = styleParts[i3].trim();
        const [key, value] = stylePart.split(":");
        if (styleAttributes[key]) {
          parseAttribute(session, result, key, value.trim());
        }
      }
    }
    return {
      strokeStyle: result.useStroke ? strokeStyle : null,
      fillStyle: result.useFill ? fillStyle : null,
      useFill: result.useFill,
      useStroke: result.useStroke
    };
  }
  function parseAttribute(session, result, id, value) {
    switch (id) {
      case "stroke":
        if (value !== "none") {
          if (value.startsWith("url(")) {
            const id2 = extractSvgUrlId(value);
            result.strokeStyle.fill = session.defs[id2];
          } else {
            result.strokeStyle.color = Color.shared.setValue(value).toNumber();
          }
          result.useStroke = true;
        }
        break;
      case "stroke-width":
        result.strokeStyle.width = Number(value);
        break;
      case "fill":
        if (value !== "none") {
          if (value.startsWith("url(")) {
            const id2 = extractSvgUrlId(value);
            result.fillStyle.fill = session.defs[id2];
          } else {
            result.fillStyle.color = Color.shared.setValue(value).toNumber();
          }
          result.useFill = true;
        }
        break;
      case "fill-opacity":
        result.fillStyle.alpha = Number(value);
        break;
      case "stroke-opacity":
        result.strokeStyle.alpha = Number(value);
        break;
      case "opacity":
        result.fillStyle.alpha = Number(value);
        result.strokeStyle.alpha = Number(value);
        break;
    }
  }
  var styleAttributes;
  var init_parseSVGStyle = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs"() {
      init_Color();
      init_extractSvgUrlId();
      styleAttributes = {
        // Fill properties
        fill: { type: "paint", default: 0 },
        // Fill color/gradient
        "fill-opacity": { type: "number", default: 1 },
        // Fill transparency
        // Stroke properties
        stroke: { type: "paint", default: 0 },
        // Stroke color/gradient
        "stroke-width": { type: "number", default: 1 },
        // Width of stroke
        "stroke-opacity": { type: "number", default: 1 },
        // Stroke transparency
        "stroke-linecap": { type: "string", default: "butt" },
        // End cap style: butt, round, square
        "stroke-linejoin": { type: "string", default: "miter" },
        // Join style: miter, round, bevel
        "stroke-miterlimit": { type: "number", default: 10 },
        // Limit on miter join sharpness
        "stroke-dasharray": { type: "string", default: "none" },
        // Dash pattern
        "stroke-dashoffset": { type: "number", default: 0 },
        // Offset for dash pattern
        // Global properties
        opacity: { type: "number", default: 1 }
        // Overall opacity
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/fillOperations.mjs
  function checkForNestedPattern(subpathsWithArea) {
    if (subpathsWithArea.length <= 2) {
      return true;
    }
    const areas = subpathsWithArea.map((s2) => s2.area).sort((a2, b2) => b2 - a2);
    const [largestArea, secondArea] = areas;
    const smallestArea = areas[areas.length - 1];
    const largestToSecondRatio = largestArea / secondArea;
    const secondToSmallestRatio = secondArea / smallestArea;
    if (largestToSecondRatio > 3 && secondToSmallestRatio < 2) {
      return false;
    }
    return true;
  }
  function getFillInstructionData(context4, index = 0) {
    const instruction = context4.instructions[index];
    if (!instruction || instruction.action !== "fill") {
      throw new Error(`Expected fill instruction at index ${index}, got ${(instruction == null ? void 0 : instruction.action) || "undefined"}`);
    }
    return instruction.data;
  }
  var init_fillOperations = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/fillOperations.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/pathOperations.mjs
  function extractSubpaths(pathData) {
    const parts = pathData.split(/(?=[Mm])/);
    const subpaths = parts.filter((part) => part.trim().length > 0);
    return subpaths;
  }
  function calculatePathArea(pathData) {
    const coords = pathData.match(/[-+]?[0-9]*\.?[0-9]+/g);
    if (!coords || coords.length < 4)
      return 0;
    const numbers = coords.map(Number);
    const xs = [];
    const ys = [];
    for (let i3 = 0; i3 < numbers.length; i3 += 2) {
      if (i3 + 1 < numbers.length) {
        xs.push(numbers[i3]);
        ys.push(numbers[i3 + 1]);
      }
    }
    if (xs.length === 0 || ys.length === 0)
      return 0;
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    const area2 = (maxX - minX) * (maxY - minY);
    return area2;
  }
  function appendSVGPath(pathData, graphicsPath) {
    const tempPath = new GraphicsPath(pathData, false);
    for (const instruction of tempPath.instructions) {
      graphicsPath.instructions.push(instruction);
    }
  }
  var init_pathOperations = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/pathOperations.mjs"() {
      init_GraphicsPath();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
  function SVGParser(svg, graphicsContext) {
    if (typeof svg === "string") {
      const div = document.createElement("div");
      div.innerHTML = svg.trim();
      svg = div.querySelector("svg");
    }
    const session = {
      context: graphicsContext,
      defs: {},
      path: new GraphicsPath()
    };
    parseSVGDefinitions(svg, session);
    const children = svg.children;
    const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);
    for (let i3 = 0; i3 < children.length; i3++) {
      const child = children[i3];
      if (child.nodeName.toLowerCase() === "defs")
        continue;
      renderChildren(child, session, fillStyle, strokeStyle);
    }
    return graphicsContext;
  }
  function renderChildren(svg, session, fillStyle, strokeStyle) {
    const children = svg.children;
    const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);
    if (f1 && fillStyle) {
      fillStyle = __spreadValues(__spreadValues({}, fillStyle), f1);
    } else if (f1) {
      fillStyle = f1;
    }
    if (s1 && strokeStyle) {
      strokeStyle = __spreadValues(__spreadValues({}, strokeStyle), s1);
    } else if (s1) {
      strokeStyle = s1;
    }
    const noStyle = !fillStyle && !strokeStyle;
    if (noStyle) {
      fillStyle = { color: 0 };
    }
    let x2;
    let y2;
    let x1;
    let y1;
    let x22;
    let y22;
    let cx;
    let cy;
    let r2;
    let rx;
    let ry;
    let points;
    let pointsString;
    let d2;
    let graphicsPath;
    let width;
    let height;
    switch (svg.nodeName.toLowerCase()) {
      case "path": {
        d2 = svg.getAttribute("d");
        const fillRule = svg.getAttribute("fill-rule");
        const subpaths = extractSubpaths(d2);
        const hasExplicitEvenodd = fillRule === "evenodd";
        const hasMultipleSubpaths = subpaths.length > 1;
        const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;
        if (shouldProcessHoles) {
          const subpathsWithArea = subpaths.map((subpath) => ({
            path: subpath,
            area: calculatePathArea(subpath)
          }));
          subpathsWithArea.sort((a2, b2) => b2.area - a2.area);
          const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);
          if (useMultipleHolesApproach) {
            for (let i3 = 0; i3 < subpathsWithArea.length; i3++) {
              const subpath = subpathsWithArea[i3];
              const isMainShape = i3 === 0;
              session.context.beginPath();
              const newPath = new GraphicsPath(void 0, true);
              appendSVGPath(subpath.path, newPath);
              session.context.path(newPath);
              if (isMainShape) {
                if (fillStyle)
                  session.context.fill(fillStyle);
                if (strokeStyle)
                  session.context.stroke(strokeStyle);
              } else {
                session.context.cut();
              }
            }
          } else {
            for (let i3 = 0; i3 < subpathsWithArea.length; i3++) {
              const subpath = subpathsWithArea[i3];
              const isHole = i3 % 2 === 1;
              session.context.beginPath();
              const newPath = new GraphicsPath(void 0, true);
              appendSVGPath(subpath.path, newPath);
              session.context.path(newPath);
              if (isHole) {
                session.context.cut();
              } else {
                if (fillStyle)
                  session.context.fill(fillStyle);
                if (strokeStyle)
                  session.context.stroke(strokeStyle);
              }
            }
          }
        } else {
          const useEvenoddForGraphicsPath = fillRule ? fillRule === "evenodd" : true;
          graphicsPath = new GraphicsPath(d2, useEvenoddForGraphicsPath);
          session.context.path(graphicsPath);
          if (fillStyle)
            session.context.fill(fillStyle);
          if (strokeStyle)
            session.context.stroke(strokeStyle);
        }
        break;
      }
      case "circle":
        cx = parseSVGFloatAttribute(svg, "cx", 0);
        cy = parseSVGFloatAttribute(svg, "cy", 0);
        r2 = parseSVGFloatAttribute(svg, "r", 0);
        session.context.ellipse(cx, cy, r2, r2);
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "rect":
        x2 = parseSVGFloatAttribute(svg, "x", 0);
        y2 = parseSVGFloatAttribute(svg, "y", 0);
        width = parseSVGFloatAttribute(svg, "width", 0);
        height = parseSVGFloatAttribute(svg, "height", 0);
        rx = parseSVGFloatAttribute(svg, "rx", 0);
        ry = parseSVGFloatAttribute(svg, "ry", 0);
        if (rx || ry) {
          session.context.roundRect(x2, y2, width, height, rx || ry);
        } else {
          session.context.rect(x2, y2, width, height);
        }
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "ellipse":
        cx = parseSVGFloatAttribute(svg, "cx", 0);
        cy = parseSVGFloatAttribute(svg, "cy", 0);
        rx = parseSVGFloatAttribute(svg, "rx", 0);
        ry = parseSVGFloatAttribute(svg, "ry", 0);
        session.context.beginPath();
        session.context.ellipse(cx, cy, rx, ry);
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "line":
        x1 = parseSVGFloatAttribute(svg, "x1", 0);
        y1 = parseSVGFloatAttribute(svg, "y1", 0);
        x22 = parseSVGFloatAttribute(svg, "x2", 0);
        y22 = parseSVGFloatAttribute(svg, "y2", 0);
        session.context.beginPath();
        session.context.moveTo(x1, y1);
        session.context.lineTo(x22, y22);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "polygon":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/-?\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, true);
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "polyline":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/-?\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, false);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "g":
      case "svg":
        break;
      default: {
        warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);
        break;
      }
    }
    if (noStyle) {
      fillStyle = null;
    }
    for (let i3 = 0; i3 < children.length; i3++) {
      renderChildren(children[i3], session, fillStyle, strokeStyle);
    }
  }
  var init_SVGParser = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
      init_warn();
      init_GraphicsPath();
      init_parseSVGDefinitions();
      init_parseSVGFloatAttribute();
      init_parseSVGStyle();
      init_fillOperations();
      init_pathOperations();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
  function isColorLike(value) {
    return Color.isColorLike(value);
  }
  function isFillPattern(value) {
    return value instanceof FillPattern;
  }
  function isFillGradient(value) {
    return value instanceof FillGradient;
  }
  function isTexture(value) {
    return value instanceof Texture;
  }
  function handleColorLike(fill, value, defaultStyle) {
    const temp = Color.shared.setValue(value != null ? value : 0);
    fill.color = temp.toNumber();
    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
    fill.texture = Texture.WHITE;
    return __spreadValues(__spreadValues({}, defaultStyle), fill);
  }
  function handleTexture(fill, value, defaultStyle) {
    fill.texture = value;
    return __spreadValues(__spreadValues({}, defaultStyle), fill);
  }
  function handleFillPattern(fill, value, defaultStyle) {
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    return __spreadValues(__spreadValues({}, defaultStyle), fill);
  }
  function handleFillGradient(fill, value, defaultStyle) {
    value.buildGradient();
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    fill.textureSpace = value.textureSpace;
    return __spreadValues(__spreadValues({}, defaultStyle), fill);
  }
  function handleFillObject(value, defaultStyle) {
    const style = __spreadValues(__spreadValues({}, defaultStyle), value);
    const color = Color.shared.setValue(style.color);
    style.alpha *= color.alpha;
    style.color = color.toNumber();
    return style;
  }
  function toFillStyle(value, defaultStyle) {
    if (value === void 0 || value === null) {
      return null;
    }
    const fill = {};
    const objectStyle = value;
    if (isColorLike(value)) {
      return handleColorLike(fill, value, defaultStyle);
    } else if (isTexture(value)) {
      return handleTexture(fill, value, defaultStyle);
    } else if (isFillPattern(value)) {
      return handleFillPattern(fill, value, defaultStyle);
    } else if (isFillGradient(value)) {
      return handleFillGradient(fill, value, defaultStyle);
    } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
      return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
    } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
      return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
    }
    return handleFillObject(objectStyle, defaultStyle);
  }
  function toStrokeStyle(value, defaultStyle) {
    const _a2 = defaultStyle, { width, alignment, miterLimit, cap, join, pixelLine } = _a2, rest = __objRest(_a2, ["width", "alignment", "miterLimit", "cap", "join", "pixelLine"]);
    const fill = toFillStyle(value, rest);
    if (!fill) {
      return null;
    }
    return __spreadValues({
      width,
      alignment,
      miterLimit,
      cap,
      join,
      pixelLine
    }, fill);
  }
  var init_convertFillInputToFillStyle = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
      init_Color();
      init_Texture();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
  var tmpPoint, tempMatrix4, _GraphicsContext, GraphicsContext;
  var init_GraphicsContext = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"() {
      init_eventemitter3();
      init_Color();
      init_Matrix();
      init_Point();
      init_Texture();
      init_uid();
      init_deprecation();
      init_Bounds();
      init_GraphicsPath();
      init_SVGParser();
      init_convertFillInputToFillStyle();
      tmpPoint = new Point();
      tempMatrix4 = new Matrix();
      _GraphicsContext = class _GraphicsContext2 extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this._gpuData = /* @__PURE__ */ Object.create(null);
          this.autoGarbageCollect = true;
          this._gcLastUsed = -1;
          this.uid = uid2("graphicsContext");
          this.dirty = true;
          this.batchMode = "auto";
          this.instructions = [];
          this.destroyed = false;
          this._activePath = new GraphicsPath();
          this._transform = new Matrix();
          this._fillStyle = __spreadValues({}, _GraphicsContext2.defaultFillStyle);
          this._strokeStyle = __spreadValues({}, _GraphicsContext2.defaultStrokeStyle);
          this._stateStack = [];
          this._tick = 0;
          this._bounds = new Bounds();
          this._boundsDirty = true;
        }
        /**
         * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
         * including the current drawing state, transformations, styles, and instructions.
         * @returns A new GraphicsContext instance with the same properties and state as this one.
         */
        clone() {
          const clone = new _GraphicsContext2();
          clone.batchMode = this.batchMode;
          clone.instructions = this.instructions.slice();
          clone._activePath = this._activePath.clone();
          clone._transform = this._transform.clone();
          clone._fillStyle = __spreadValues({}, this._fillStyle);
          clone._strokeStyle = __spreadValues({}, this._strokeStyle);
          clone._stateStack = this._stateStack.slice();
          clone._bounds = this._bounds.clone();
          clone._boundsDirty = true;
          return clone;
        }
        /**
         * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
         */
        get fillStyle() {
          return this._fillStyle;
        }
        set fillStyle(value) {
          this._fillStyle = toFillStyle(value, _GraphicsContext2.defaultFillStyle);
        }
        /**
         * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         */
        get strokeStyle() {
          return this._strokeStyle;
        }
        set strokeStyle(value) {
          this._strokeStyle = toStrokeStyle(value, _GraphicsContext2.defaultStrokeStyle);
        }
        /**
         * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
         * pattern, or a more complex style defined by a FillStyle object.
         * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
         *                or a FillStyle or ConvertedFillStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setFillStyle(style) {
          this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
          return this;
        }
        /**
         * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
         * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
         *                or a StrokeStyle or ConvertedStrokeStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setStrokeStyle(style) {
          this._strokeStyle = toFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
          return this;
        }
        texture(texture, tint, dx, dy, dw, dh) {
          this.instructions.push({
            action: "texture",
            data: {
              image: texture,
              dx: dx || 0,
              dy: dy || 0,
              dw: dw || texture.frame.width,
              dh: dh || texture.frame.height,
              transform: this._transform.clone(),
              alpha: this._fillStyle.alpha,
              style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
            }
          });
          this.onUpdate();
          return this;
        }
        /**
         * Resets the current path. Any previous path and its commands are discarded and a new path is
         * started. This is typically called before beginning a new shape or series of drawing commands.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        beginPath() {
          this._activePath = new GraphicsPath();
          return this;
        }
        fill(style, alpha) {
          let path2;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && (lastInstruction == null ? void 0 : lastInstruction.action) === "stroke") {
            path2 = lastInstruction.data.path;
          } else {
            path2 = this._activePath.clone();
          }
          if (!path2)
            return this;
          if (style != null) {
            if (alpha !== void 0 && typeof style === "number") {
              deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
              style = { color: style, alpha };
            }
            this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
          }
          this.instructions.push({
            action: "fill",
            // TODO copy fill style!
            data: { style: this.fillStyle, path: path2 }
          });
          this.onUpdate();
          this._initNextPathLocation();
          this._tick = 0;
          return this;
        }
        _initNextPathLocation() {
          const { x: x2, y: y2 } = this._activePath.getLastPoint(Point.shared);
          this._activePath.clear();
          this._activePath.moveTo(x2, y2);
        }
        /**
         * Strokes the current path with the current stroke style. This method can take an optional
         * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
         * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        stroke(style) {
          let path2;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && (lastInstruction == null ? void 0 : lastInstruction.action) === "fill") {
            path2 = lastInstruction.data.path;
          } else {
            path2 = this._activePath.clone();
          }
          if (!path2)
            return this;
          if (style != null) {
            this._strokeStyle = toStrokeStyle(style, _GraphicsContext2.defaultStrokeStyle);
          }
          this.instructions.push({
            action: "stroke",
            // TODO copy fill style!
            data: { style: this.strokeStyle, path: path2 }
          });
          this.onUpdate();
          this._initNextPathLocation();
          this._tick = 0;
          return this;
        }
        /**
         * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
         * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
         * fail to cut correctly!
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        cut() {
          for (let i3 = 0; i3 < 2; i3++) {
            const lastInstruction = this.instructions[this.instructions.length - 1 - i3];
            const holePath = this._activePath.clone();
            if (lastInstruction) {
              if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
                if (lastInstruction.data.hole) {
                  lastInstruction.data.hole.addPath(holePath);
                } else {
                  lastInstruction.data.hole = holePath;
                  break;
                }
              }
            }
          }
          this._initNextPathLocation();
          return this;
        }
        /**
         * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
         * starting and ending angles, and direction.
         * @param x - The x-coordinate of the arc's center.
         * @param y - The y-coordinate of the arc's center.
         * @param radius - The arc's radius.
         * @param startAngle - The starting angle, in radians.
         * @param endAngle - The ending angle, in radians.
         * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arc(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            radius,
            startAngle,
            endAngle,
            counterclockwise
          );
          return this;
        }
        /**
         * Adds an arc to the current path with the given control points and radius, connected to the previous point
         * by a straight line if necessary.
         * @param x1 - The x-coordinate of the first control point.
         * @param y1 - The y-coordinate of the first control point.
         * @param x2 - The x-coordinate of the second control point.
         * @param y2 - The y-coordinate of the second control point.
         * @param radius - The arc's radius.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        arcTo(x1, y1, x2, y2, radius) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arcTo(
            t2.a * x1 + t2.c * y1 + t2.tx,
            t2.b * x1 + t2.d * y1 + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            radius
          );
          return this;
        }
        /**
         * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
         * @param rx - The x-radius of the ellipse.
         * @param ry - The y-radius of the ellipse.
         * @param xAxisRotation - The rotation of the ellipse's x-axis relative
         * to the x-axis of the coordinate system, in degrees.
         * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
         * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
         * @param x - The x-coordinate of the arc's end point.
         * @param y - The y-coordinate of the arc's end point.
         * @returns The instance of the current object for chaining.
         */
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arcToSvg(
            rx,
            ry,
            xAxisRotation,
            // should we rotate this with transform??
            largeArcFlag,
            sweepFlag,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires three points: the first two are control points and the third one is the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the first control point.
         * @param cp1y - The y-coordinate of the first control point.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.bezierCurveTo(
            t2.a * cp1x + t2.c * cp1y + t2.tx,
            t2.b * cp1x + t2.d * cp1y + t2.ty,
            t2.a * cp2x + t2.c * cp2y + t2.tx,
            t2.b * cp2x + t2.d * cp2y + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            smoothness
          );
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          var _a2;
          this._tick++;
          (_a2 = this._activePath) == null ? void 0 : _a2.closePath();
          return this;
        }
        /**
         * Draws an ellipse at the specified location and with the given x and y radii.
         * An optional transformation can be applied, allowing for rotation, scaling, and translation.
         * @param x - The x-coordinate of the center of the ellipse.
         * @param y - The y-coordinate of the center of the ellipse.
         * @param radiusX - The horizontal radius of the ellipse.
         * @param radiusY - The vertical radius of the ellipse.
         * @returns The instance of the current object for chaining.
         */
        ellipse(x2, y2, radiusX, radiusY) {
          this._tick++;
          this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius) {
          this._tick++;
          this._activePath.circle(x2, y2, radius, this._transform.clone());
          return this;
        }
        /**
         * Adds another `GraphicsPath` to this path, optionally applying a transformation.
         * @param path - The `GraphicsPath` to add.
         * @returns The instance of the current object for chaining.
         */
        path(path2) {
          this._tick++;
          this._activePath.addPath(path2, this._transform.clone());
          return this;
        }
        /**
         * Connects the current point to a new point with a straight line. This method updates the current path.
         * @param x - The x-coordinate of the new point to connect to.
         * @param y - The y-coordinate of the new point to connect to.
         * @returns The instance of the current object for chaining.
         */
        lineTo(x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.lineTo(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        /**
         * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
         * @param x - The x-coordinate for the starting point.
         * @param y - The y-coordinate for the starting point.
         * @returns The instance of the current object for chaining.
         */
        moveTo(x2, y2) {
          this._tick++;
          const t2 = this._transform;
          const instructions = this._activePath.instructions;
          const transformedX = t2.a * x2 + t2.c * y2 + t2.tx;
          const transformedY = t2.b * x2 + t2.d * y2 + t2.ty;
          if (instructions.length === 1 && instructions[0].action === "moveTo") {
            instructions[0].data[0] = transformedX;
            instructions[0].data[1] = transformedY;
            return this;
          }
          this._activePath.moveTo(
            transformedX,
            transformedY
          );
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
         * The starting point is the last point in the current path.
         * @param cpx - The x-coordinate of the control point.
         * @param cpy - The y-coordinate of the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveTo(cpx, cpy, x2, y2, smoothness) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.quadraticCurveTo(
            t2.a * cpx + t2.c * cpy + t2.tx,
            t2.b * cpx + t2.d * cpy + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            smoothness
          );
          return this;
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2) {
          this._tick++;
          this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
          return this;
        }
        /**
         * Draws a rectangle with rounded corners.
         * The corner radius can be specified to determine how rounded the corners should be.
         * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
         * @returns The instance of the current object for chaining.
         */
        roundRect(x2, y2, w2, h2, radius) {
          this._tick++;
          this._activePath.roundRect(x2, y2, w2, h2, radius, this._transform.clone());
          return this;
        }
        /**
         * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
         * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
         * rotated, or translated as needed.
         * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
         * representing the x and y coordinates, of the polygon's vertices, in sequence.
         * @param close - A boolean indicating whether to close the polygon path. True by default.
         */
        poly(points, close) {
          this._tick++;
          this._activePath.poly(points, close, this._transform.clone());
          return this;
        }
        /**
         * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
          this._tick++;
          this._activePath.regularPoly(x2, y2, radius, sides, rotation, transform2);
          return this;
        }
        /**
         * Draws a polygon with rounded corners.
         * Similar to `regularPoly` but with the ability to round the corners of the polygon.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param corner - The radius of the rounding of the corners.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @returns The instance of the current object for chaining.
         */
        roundPoly(x2, y2, radius, sides, corner, rotation) {
          this._tick++;
          this._activePath.roundPoly(x2, y2, radius, sides, corner, rotation);
          return this;
        }
        /**
         * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
         * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
         * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
         * A minimum of 3 points is required.
         * @param radius - The default radius for the corners.
         * This radius is applied to all corners unless overridden in `points`.
         * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
         *  method instead of an arc method. Defaults to false.
         * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
         * Higher values make the curve smoother.
         * @returns The instance of the current object for chaining.
         */
        roundShape(points, radius, useQuadratic, smoothness) {
          this._tick++;
          this._activePath.roundShape(points, radius, useQuadratic, smoothness);
          return this;
        }
        /**
         * Draw Rectangle with fillet corners. This is much like rounded rectangle
         * however it support negative numbers as well for the corner radius.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param fillet - accept negative or positive values
         */
        filletRect(x2, y2, width, height, fillet) {
          this._tick++;
          this._activePath.filletRect(x2, y2, width, height, fillet);
          return this;
        }
        /**
         * Draw Rectangle with chamfer corners. These are angled corners.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param chamfer - non-zero real number, size of corner cutout
         * @param transform
         */
        chamferRect(x2, y2, width, height, chamfer, transform2) {
          this._tick++;
          this._activePath.chamferRect(x2, y2, width, height, chamfer, transform2);
          return this;
        }
        /**
         * Draws a star shape centered at a specified location. This method allows for the creation
         *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
         * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
         * An optional transformation can be applied to scale, rotate, or translate the star as needed.
         * @param x - The x-coordinate of the center of the star.
         * @param y - The y-coordinate of the center of the star.
         * @param points - The number of points of the star.
         * @param radius - The outer radius of the star (distance from the center to the outer points).
         * @param innerRadius - Optional. The inner radius of the star
         * (distance from the center to the inner points between the outer points).
         * If not provided, defaults to half of the `radius`.
         * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
         * Defaults to 0, meaning one point is directly upward.
         * @returns The instance of the current object for chaining further drawing commands.
         */
        star(x2, y2, points, radius, innerRadius = 0, rotation = 0) {
          this._tick++;
          this._activePath.star(x2, y2, points, radius, innerRadius, rotation, this._transform.clone());
          return this;
        }
        /**
         * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
         * defined in SVG format to be drawn within the graphics context.
         * @param svg - The SVG string to be parsed and rendered.
         */
        svg(svg) {
          this._tick++;
          SVGParser(svg, this);
          return this;
        }
        /**
         * Restores the most recently saved graphics state by popping the top of the graphics state stack.
         * This includes transformations, fill styles, and stroke styles.
         */
        restore() {
          const state = this._stateStack.pop();
          if (state) {
            this._transform = state.transform;
            this._fillStyle = state.fillStyle;
            this._strokeStyle = state.strokeStyle;
          }
          return this;
        }
        /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
        save() {
          this._stateStack.push({
            transform: this._transform.clone(),
            fillStyle: __spreadValues({}, this._fillStyle),
            strokeStyle: __spreadValues({}, this._strokeStyle)
          });
          return this;
        }
        /**
         * Returns the current transformation matrix of the graphics context.
         * @returns The current transformation matrix.
         */
        getTransform() {
          return this._transform;
        }
        /**
         * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        resetTransform() {
          this._transform.identity();
          return this;
        }
        /**
         * Applies a rotation transformation to the graphics context around the current origin.
         * @param angle - The angle of rotation in radians.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        rotate(angle) {
          this._transform.rotate(angle);
          return this;
        }
        /**
         * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
         * @param x - The scale factor in the horizontal direction.
         * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        scale(x2, y2 = x2) {
          this._transform.scale(x2, y2);
          return this;
        }
        setTransform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix) {
            this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
            return this;
          }
          this._transform.set(a2, b2, c2, d2, dx, dy);
          return this;
        }
        transform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix) {
            this._transform.append(a2);
            return this;
          }
          tempMatrix4.set(a2, b2, c2, d2, dx, dy);
          this._transform.append(tempMatrix4);
          return this;
        }
        /**
         * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
         * @param x - The amount to translate in the horizontal direction.
         * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        translate(x2, y2 = x2) {
          this._transform.translate(x2, y2);
          return this;
        }
        /**
         * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
         * and optionally resetting transformations to the identity matrix.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        clear() {
          this._activePath.clear();
          this.instructions.length = 0;
          this.resetTransform();
          this.onUpdate();
          return this;
        }
        onUpdate() {
          this._boundsDirty = true;
          if (this.dirty)
            return;
          this.emit("update", this, 16);
          this.dirty = true;
        }
        /** The bounds of the graphic shape. */
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          this._boundsDirty = false;
          const bounds = this._bounds;
          bounds.clear();
          for (let i3 = 0; i3 < this.instructions.length; i3++) {
            const instruction = this.instructions[i3];
            const action = instruction.action;
            if (action === "fill") {
              const data = instruction.data;
              bounds.addBounds(data.path.bounds);
            } else if (action === "texture") {
              const data = instruction.data;
              bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
            }
            if (action === "stroke") {
              const data = instruction.data;
              const alignment = data.style.alignment;
              const outerPadding = data.style.width * (1 - alignment);
              const _bounds = data.path.bounds;
              bounds.addFrame(
                _bounds.minX - outerPadding,
                _bounds.minY - outerPadding,
                _bounds.maxX + outerPadding,
                _bounds.maxY + outerPadding
              );
            }
          }
          return bounds;
        }
        /**
         * Check to see if a point is contained within this geometry.
         * @param point - Point to check if it's contained.
         * @returns {boolean} `true` if the point is contained within geometry.
         */
        containsPoint(point) {
          var _a2;
          if (!this.bounds.containsPoint(point.x, point.y))
            return false;
          const instructions = this.instructions;
          let hasHit = false;
          for (let k2 = 0; k2 < instructions.length; k2++) {
            const instruction = instructions[k2];
            const data = instruction.data;
            const path2 = data.path;
            if (!instruction.action || !path2)
              continue;
            const style = data.style;
            const shapes = path2.shapePath.shapePrimitives;
            for (let i3 = 0; i3 < shapes.length; i3++) {
              const shape = shapes[i3].shape;
              if (!style || !shape)
                continue;
              const transform2 = shapes[i3].transform;
              const transformedPoint = transform2 ? transform2.applyInverse(point, tmpPoint) : point;
              if (instruction.action === "fill") {
                hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
              } else {
                const strokeStyle = style;
                hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);
              }
              const holes = data.hole;
              if (holes) {
                const holeShapes = (_a2 = holes.shapePath) == null ? void 0 : _a2.shapePrimitives;
                if (holeShapes) {
                  for (let j2 = 0; j2 < holeShapes.length; j2++) {
                    if (holeShapes[j2].shape.contains(transformedPoint.x, transformedPoint.y)) {
                      hasHit = false;
                    }
                  }
                }
              }
              if (hasHit) {
                return true;
              }
            }
          }
          return hasHit;
        }
        /** Unloads the GPU data from the graphics context. */
        unload() {
          var _a2;
          this.emit("unload", this);
          for (const key in this._gpuData) {
            (_a2 = this._gpuData[key]) == null ? void 0 : _a2.destroy();
          }
          this._gpuData = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Destroys the GraphicsData object.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @example
         * context.destroy();
         * context.destroy(true);
         * context.destroy({ texture: true, textureSource: true });
         */
        destroy(options = false) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          this._stateStack.length = 0;
          this._transform = null;
          this.unload();
          this.emit("destroy", this);
          this.removeAllListeners();
          const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
            if (this._fillStyle.texture) {
              this._fillStyle.fill && "uid" in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(destroyTextureSource);
            }
            if (this._strokeStyle.texture) {
              this._strokeStyle.fill && "uid" in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(destroyTextureSource);
            }
          }
          this._fillStyle = null;
          this._strokeStyle = null;
          this.instructions = null;
          this._activePath = null;
          this._bounds = null;
          this._stateStack = null;
          this.customShader = null;
          this._transform = null;
        }
      };
      _GraphicsContext.defaultFillStyle = {
        /** The color to use for the fill. */
        color: 16777215,
        /** The alpha value to use for the fill. */
        alpha: 1,
        /** The texture to use for the fill. */
        texture: Texture.WHITE,
        /** The matrix to apply. */
        matrix: null,
        /** The fill pattern to use. */
        fill: null,
        /** Whether coordinates are 'global' or 'local' */
        textureSpace: "local"
      };
      _GraphicsContext.defaultStrokeStyle = {
        /** The width of the stroke. */
        width: 1,
        /** The color to use for the stroke. */
        color: 16777215,
        /** The alpha value to use for the stroke. */
        alpha: 1,
        /** The alignment of the stroke. */
        alignment: 0.5,
        /** The miter limit to use. */
        miterLimit: 10,
        /** The line cap style to use. */
        cap: "butt",
        /** The line join style to use. */
        join: "miter",
        /** The texture to use for the fill. */
        texture: Texture.WHITE,
        /** The matrix to apply. */
        matrix: null,
        /** The fill pattern to use. */
        fill: null,
        /** Whether coordinates are 'global' or 'local' */
        textureSpace: "local",
        /** If the stroke is a pixel line. */
        pixelLine: false
      };
      GraphicsContext = _GraphicsContext;
    }
  });

  // node_modules/pixi.js/lib/scene/text/TextStyle.mjs
  function convertV7Tov8Style(style) {
    var _a2, _b, _c, _d, _e;
    const oldStyle = style;
    if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
      const defaults2 = TextStyle.defaultDropShadow;
      style.dropShadow = {
        alpha: (_a2 = oldStyle.dropShadowAlpha) != null ? _a2 : defaults2.alpha,
        angle: (_b = oldStyle.dropShadowAngle) != null ? _b : defaults2.angle,
        blur: (_c = oldStyle.dropShadowBlur) != null ? _c : defaults2.blur,
        color: (_d = oldStyle.dropShadowColor) != null ? _d : defaults2.color,
        distance: (_e = oldStyle.dropShadowDistance) != null ? _e : defaults2.distance
      };
    }
    if (oldStyle.strokeThickness !== void 0) {
      deprecation(v8_0_0, "strokeThickness is now a part of stroke");
      const color = oldStyle.stroke;
      let obj = {};
      if (Color.isColorLike(color)) {
        obj.color = color;
      } else if (color instanceof FillGradient || color instanceof FillPattern) {
        obj.fill = color;
      } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
        obj = color;
      } else {
        throw new Error("Invalid stroke value.");
      }
      style.stroke = __spreadProps(__spreadValues({}, obj), {
        width: oldStyle.strokeThickness
      });
    }
    if (Array.isArray(oldStyle.fillGradientStops)) {
      deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      if (!Array.isArray(oldStyle.fill) || oldStyle.fill.length === 0) {
        throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");
      }
      if (oldStyle.fill.length !== oldStyle.fillGradientStops.length) {
        warn("The number of fill colors must match the number of fill gradient stops.");
      }
      const gradientFill = new FillGradient({
        start: { x: 0, y: 0 },
        end: { x: 0, y: 1 },
        textureSpace: "local"
      });
      const fillGradientStops = oldStyle.fillGradientStops.slice();
      const fills = oldStyle.fill.map((color) => Color.shared.setValue(color).toNumber());
      fillGradientStops.forEach((stop, index) => {
        gradientFill.addColorStop(stop, fills[index]);
      });
      style.fill = {
        fill: gradientFill
      };
    }
  }
  var _TextStyle, TextStyle;
  var init_TextStyle = __esm({
    "node_modules/pixi.js/lib/scene/text/TextStyle.mjs"() {
      init_eventemitter3();
      init_Color();
      init_uid();
      init_deprecation();
      init_warn();
      init_FillGradient();
      init_FillPattern();
      init_GraphicsContext();
      init_convertFillInputToFillStyle();
      _TextStyle = class _TextStyle2 extends eventemitter3_default {
        constructor(style = {}) {
          super();
          this.uid = uid2("textStyle");
          this._tick = 0;
          convertV7Tov8Style(style);
          const fullStyle = __spreadValues(__spreadValues({}, _TextStyle2.defaultTextStyle), style);
          for (const key in fullStyle) {
            const thisKey = key;
            this[thisKey] = fullStyle[key];
          }
          this.update();
          this._tick = 0;
        }
        /**
         * Alignment for multiline text, does not affect single line text.
         * @type {'left'|'center'|'right'|'justify'}
         */
        get align() {
          return this._align;
        }
        set align(value) {
          if (this._align === value)
            return;
          this._align = value;
          this.update();
        }
        /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
        get breakWords() {
          return this._breakWords;
        }
        set breakWords(value) {
          if (this._breakWords === value)
            return;
          this._breakWords = value;
          this.update();
        }
        /** Set a drop shadow for the text. */
        get dropShadow() {
          return this._dropShadow;
        }
        set dropShadow(value) {
          if (this._dropShadow === value)
            return;
          if (value !== null && typeof value === "object") {
            this._dropShadow = this._createProxy(__spreadValues(__spreadValues({}, _TextStyle2.defaultDropShadow), value));
          } else {
            this._dropShadow = value ? this._createProxy(__spreadValues({}, _TextStyle2.defaultDropShadow)) : null;
          }
          this.update();
        }
        /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(value) {
          if (this._fontFamily === value)
            return;
          this._fontFamily = value;
          this.update();
        }
        /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(value) {
          if (this._fontSize === value)
            return;
          if (typeof value === "string") {
            this._fontSize = parseInt(value, 10);
          } else {
            this._fontSize = value;
          }
          this.update();
        }
        /**
         * The font style.
         * @type {'normal'|'italic'|'oblique'}
         */
        get fontStyle() {
          return this._fontStyle;
        }
        set fontStyle(value) {
          if (this._fontStyle === value)
            return;
          this._fontStyle = value.toLowerCase();
          this.update();
        }
        /**
         * The font variant.
         * @type {'normal'|'small-caps'}
         */
        get fontVariant() {
          return this._fontVariant;
        }
        set fontVariant(value) {
          if (this._fontVariant === value)
            return;
          this._fontVariant = value;
          this.update();
        }
        /**
         * The font weight.
         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
         */
        get fontWeight() {
          return this._fontWeight;
        }
        set fontWeight(value) {
          if (this._fontWeight === value)
            return;
          this._fontWeight = value;
          this.update();
        }
        /** The space between lines. */
        get leading() {
          return this._leading;
        }
        set leading(value) {
          if (this._leading === value)
            return;
          this._leading = value;
          this.update();
        }
        /** The amount of spacing between letters, default is 0. */
        get letterSpacing() {
          return this._letterSpacing;
        }
        set letterSpacing(value) {
          if (this._letterSpacing === value)
            return;
          this._letterSpacing = value;
          this.update();
        }
        /** The line height, a number that represents the vertical space that a letter uses. */
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(value) {
          if (this._lineHeight === value)
            return;
          this._lineHeight = value;
          this.update();
        }
        /**
         * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
         * by adding padding to all sides of the text.
         * > [!NOTE] This will NOT affect the positioning or bounds of the text.
         */
        get padding() {
          return this._padding;
        }
        set padding(value) {
          if (this._padding === value)
            return;
          this._padding = value;
          this.update();
        }
        /**
         * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.
         * These filters will be applied to the text as it is created, resulting in faster rendering for static text
         * compared to applying the filter directly to the text object (which would be applied at run time).
         * @default null
         */
        get filters() {
          return this._filters;
        }
        set filters(value) {
          if (this._filters === value)
            return;
          this._filters = Object.freeze(value);
          this.update();
        }
        /**
         * Trim transparent borders from the text texture.
         * > [!IMPORTANT] PERFORMANCE WARNING:
         * > This is a costly operation as it requires scanning pixel alpha values.
         * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.
         */
        get trim() {
          return this._trim;
        }
        set trim(value) {
          if (this._trim === value)
            return;
          this._trim = value;
          this.update();
        }
        /**
         * The baseline of the text that is rendered.
         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
         */
        get textBaseline() {
          return this._textBaseline;
        }
        set textBaseline(value) {
          if (this._textBaseline === value)
            return;
          this._textBaseline = value;
          this.update();
        }
        /**
         * How newlines and spaces should be handled.
         * Default is 'pre' (preserve, preserve).
         *
         *  value       | New lines     |   Spaces
         *  ---         | ---           |   ---
         * 'normal'     | Collapse      |   Collapse
         * 'pre'        | Preserve      |   Preserve
         * 'pre-line'   | Preserve      |   Collapse
         * @type {'normal'|'pre'|'pre-line'}
         */
        get whiteSpace() {
          return this._whiteSpace;
        }
        set whiteSpace(value) {
          if (this._whiteSpace === value)
            return;
          this._whiteSpace = value;
          this.update();
        }
        /** Indicates if word wrap should be used. */
        get wordWrap() {
          return this._wordWrap;
        }
        set wordWrap(value) {
          if (this._wordWrap === value)
            return;
          this._wordWrap = value;
          this.update();
        }
        /** The width at which text will wrap, it needs wordWrap to be set to true. */
        get wordWrapWidth() {
          return this._wordWrapWidth;
        }
        set wordWrapWidth(value) {
          if (this._wordWrapWidth === value)
            return;
          this._wordWrapWidth = value;
          this.update();
        }
        /**
         * The fill style that will be used to color the text.
         * This can be:
         * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'
         * - A hex number like 0xff0000 for red
         * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }
         * - A FillGradient for gradient fills
         * - A FillPattern for pattern/texture fills
         *
         * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,
         * while gradients at any other angle are spread across the entire text body as a whole.
         * @example
         * // Vertical gradient applied per line
         * const verticalGradient = new FillGradient(0, 0, 0, 1)
         *     .addColorStop(0, 0xff0000)
         *     .addColorStop(1, 0x0000ff);
         *
         * const text = new Text({
         *     text: 'Line 1\nLine 2',
         *     style: { fill: verticalGradient }
         * });
         *
         * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.
         * @type {string|number|FillStyle|FillGradient|FillPattern}
         */
        get fill() {
          return this._originalFill;
        }
        set fill(value) {
          if (value === this._originalFill)
            return;
          this._originalFill = value;
          if (this._isFillStyle(value)) {
            this._originalFill = this._createProxy(__spreadValues(__spreadValues({}, GraphicsContext.defaultFillStyle), value), () => {
              this._fill = toFillStyle(
                __spreadValues({}, this._originalFill),
                GraphicsContext.defaultFillStyle
              );
            });
          }
          this._fill = toFillStyle(
            value === 0 ? "black" : value,
            GraphicsContext.defaultFillStyle
          );
          this.update();
        }
        /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
        get stroke() {
          return this._originalStroke;
        }
        set stroke(value) {
          if (value === this._originalStroke)
            return;
          this._originalStroke = value;
          if (this._isFillStyle(value)) {
            this._originalStroke = this._createProxy(__spreadValues(__spreadValues({}, GraphicsContext.defaultStrokeStyle), value), () => {
              this._stroke = toStrokeStyle(
                __spreadValues({}, this._originalStroke),
                GraphicsContext.defaultStrokeStyle
              );
            });
          }
          this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);
          this.update();
        }
        update() {
          this._tick++;
          this.emit("update", this);
        }
        /** Resets all properties to the default values */
        reset() {
          const defaultStyle = _TextStyle2.defaultTextStyle;
          for (const key in defaultStyle) {
            this[key] = defaultStyle[key];
          }
        }
        /**
         * Returns a unique key for this instance.
         * This key is used for caching.
         * @returns {string} Unique key for the instance
         */
        get styleKey() {
          return `${this.uid}-${this._tick}`;
        }
        /**
         * Creates a new TextStyle object with the same values as this one.
         * @returns New cloned TextStyle object
         */
        clone() {
          return new _TextStyle2({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this._dropShadow ? __spreadValues({}, this._dropShadow) : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            filters: this._filters ? [...this._filters] : void 0
          });
        }
        /**
         * Returns the final padding for the text style, taking into account any filters applied.
         * Used internally for correct measurements
         * @internal
         * @returns {number} The final padding for the text style.
         */
        _getFinalPadding() {
          let filterPadding = 0;
          if (this._filters) {
            for (let i3 = 0; i3 < this._filters.length; i3++) {
              filterPadding += this._filters[i3].padding;
            }
          }
          return Math.max(this._padding, filterPadding);
        }
        /**
         * Destroys this text style.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @example
         * // Destroy the text style and its textures
         * textStyle.destroy({ texture: true, textureSource: true });
         * textStyle.destroy(true);
         */
        destroy(options = false) {
          var _a2, _b, _c, _d;
          this.removeAllListeners();
          const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
            if ((_a2 = this._fill) == null ? void 0 : _a2.texture) {
              this._fill.texture.destroy(destroyTextureSource);
            }
            if ((_b = this._originalFill) == null ? void 0 : _b.texture) {
              this._originalFill.texture.destroy(destroyTextureSource);
            }
            if ((_c = this._stroke) == null ? void 0 : _c.texture) {
              this._stroke.texture.destroy(destroyTextureSource);
            }
            if ((_d = this._originalStroke) == null ? void 0 : _d.texture) {
              this._originalStroke.texture.destroy(destroyTextureSource);
            }
          }
          this._fill = null;
          this._stroke = null;
          this.dropShadow = null;
          this._originalStroke = null;
          this._originalFill = null;
        }
        _createProxy(value, cb) {
          return new Proxy(value, {
            set: (target, property, newValue) => {
              if (target[property] === newValue)
                return true;
              target[property] = newValue;
              cb == null ? void 0 : cb(property, newValue);
              this.update();
              return true;
            }
          });
        }
        _isFillStyle(value) {
          return (value != null ? value : null) !== null && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);
        }
      };
      _TextStyle.defaultDropShadow = {
        alpha: 1,
        angle: Math.PI / 6,
        blur: 0,
        color: "black",
        distance: 5
      };
      _TextStyle.defaultTextStyle = {
        align: "left",
        breakWords: false,
        dropShadow: null,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: null,
        textBaseline: "alphabetic",
        trim: false,
        whiteSpace: "pre",
        wordWrap: false,
        wordWrapWidth: 100
      };
      TextStyle = _TextStyle;
    }
  });

  // node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs
  function getPo2TextureFromSource(image, width, height, resolution) {
    const bounds = tempBounds2;
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = image.width / resolution | 0;
    bounds.maxY = image.height / resolution | 0;
    const texture = TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      resolution,
      false
    );
    texture.source.uploadMethodId = "image";
    texture.source.resource = image;
    texture.source.alphaMode = "premultiply-alpha-on-upload";
    texture.frame.width = width / resolution;
    texture.frame.height = height / resolution;
    texture.source.emit("update", texture.source);
    texture.updateUvs();
    return texture;
  }
  var tempBounds2;
  var init_getPo2TextureFromSource = __esm({
    "node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"() {
      init_TexturePool();
      init_Bounds();
      tempBounds2 = new Bounds();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
  var CanvasPoolClass, CanvasPool;
  var init_CanvasPool = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
      init_adapter();
      init_pow2();
      init_GlobalResourceRegistry();
      CanvasPoolClass = class {
        constructor(canvasOptions) {
          this._canvasPool = /* @__PURE__ */ Object.create(null);
          this.canvasOptions = canvasOptions || {};
          this.enableFullScreen = false;
        }
        /**
         * Creates texture with params that were specified in pool constructor.
         * @param pixelWidth - Width of texture in pixels.
         * @param pixelHeight - Height of texture in pixels.
         */
        _createCanvasAndContext(pixelWidth, pixelHeight) {
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = pixelWidth;
          canvas.height = pixelHeight;
          const context4 = canvas.getContext("2d");
          return { canvas, context: context4 };
        }
        /**
         * Gets a Power-of-Two render texture or fullScreen texture
         * @param minWidth - The minimum width of the render texture.
         * @param minHeight - The minimum height of the render texture.
         * @param resolution - The resolution of the render texture.
         * @returns The new render texture.
         */
        getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
          minWidth = Math.ceil(minWidth * resolution - 1e-6);
          minHeight = Math.ceil(minHeight * resolution - 1e-6);
          minWidth = nextPow2(minWidth);
          minHeight = nextPow2(minHeight);
          const key = (minWidth << 17) + (minHeight << 1);
          if (!this._canvasPool[key]) {
            this._canvasPool[key] = [];
          }
          let canvasAndContext = this._canvasPool[key].pop();
          if (!canvasAndContext) {
            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
          }
          return canvasAndContext;
        }
        /**
         * Place a render texture back into the pool.
         * @param canvasAndContext
         */
        returnCanvasAndContext(canvasAndContext) {
          const canvas = canvasAndContext.canvas;
          const { width, height } = canvas;
          const key = (width << 17) + (height << 1);
          canvasAndContext.context.resetTransform();
          canvasAndContext.context.clearRect(0, 0, width, height);
          this._canvasPool[key].push(canvasAndContext);
        }
        clear() {
          this._canvasPool = {};
        }
      };
      CanvasPool = new CanvasPoolClass();
      GlobalResourceRegistry.register(CanvasPool);
    }
  });

  // node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs
  function ensureInternalCanvas(width, height) {
    if (!_internalCanvas) {
      _internalCanvas = DOMAdapter.get().createCanvas(256, 128);
      _internalContext = _internalCanvas.getContext("2d", { willReadFrequently: true });
      _internalContext.globalCompositeOperation = "copy";
      _internalContext.globalAlpha = 1;
    }
    if (_internalCanvas.width < width || _internalCanvas.height < height) {
      _internalCanvas.width = nextPow2(width);
      _internalCanvas.height = nextPow2(height);
    }
  }
  function checkRow(data, width, y2) {
    for (let x2 = 0, index = 4 * y2 * width; x2 < width; ++x2, index += 4) {
      if (data[index + 3] !== 0)
        return false;
    }
    return true;
  }
  function checkColumn(data, width, x2, top, bottom) {
    const stride = 4 * width;
    for (let y2 = top, index = top * stride + 4 * x2; y2 <= bottom; ++y2, index += stride) {
      if (data[index + 3] !== 0)
        return false;
    }
    return true;
  }
  function getCanvasBoundingBox(...args) {
    var _a2, _b, _c;
    let options = args[0];
    if (!options.canvas) {
      options = { canvas: args[0], resolution: args[1] };
    }
    const { canvas } = options;
    const resolution = Math.min((_a2 = options.resolution) != null ? _a2 : 1, 1);
    const width = (_b = options.width) != null ? _b : canvas.width;
    const height = (_c = options.height) != null ? _c : canvas.height;
    let output = options.output;
    ensureInternalCanvas(width, height);
    if (!_internalContext) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    _internalContext.drawImage(
      canvas,
      0,
      0,
      width,
      height,
      0,
      0,
      width * resolution,
      height * resolution
    );
    const imageData = _internalContext.getImageData(0, 0, width, height);
    const data = imageData.data;
    let left = 0;
    let top = 0;
    let right = width - 1;
    let bottom = height - 1;
    while (top < height && checkRow(data, width, top))
      ++top;
    if (top === height)
      return Rectangle.EMPTY;
    while (checkRow(data, width, bottom))
      --bottom;
    while (checkColumn(data, width, left, top, bottom))
      ++left;
    while (checkColumn(data, width, right, top, bottom))
      --right;
    ++right;
    ++bottom;
    _internalContext.globalCompositeOperation = "source-over";
    _internalContext.strokeRect(left, top, right - left, bottom - top);
    _internalContext.globalCompositeOperation = "copy";
    output != null ? output : output = new Rectangle();
    output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
    return output;
  }
  var _internalCanvas, _internalContext;
  var init_getCanvasBoundingBox = __esm({
    "node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs"() {
      init_adapter();
      init_pow2();
      init_Rectangle();
      _internalCanvas = null;
      _internalContext = null;
    }
  });

  // node_modules/tiny-lru/dist/tiny-lru.js
  function lru(max = 1e3, ttl = 0, resetTtl = false) {
    if (isNaN(max) || max < 0) {
      throw new TypeError("Invalid max value");
    }
    if (isNaN(ttl) || ttl < 0) {
      throw new TypeError("Invalid ttl value");
    }
    if (typeof resetTtl !== "boolean") {
      throw new TypeError("Invalid resetTtl value");
    }
    return new LRU(max, ttl, resetTtl);
  }
  var LRU;
  var init_tiny_lru = __esm({
    "node_modules/tiny-lru/dist/tiny-lru.js"() {
      LRU = class {
        /**
         * Creates a new LRU cache instance.
         * Note: Constructor does not validate parameters. Use lru() factory function for parameter validation.
         *
         * @constructor
         * @param {number} [max=0] - Maximum number of items to store. 0 means unlimited.
         * @param {number} [ttl=0] - Time to live in milliseconds. 0 means no expiration.
         * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().
         * @example
         * const cache = new LRU(1000, 60000, true); // 1000 items, 1 minute TTL, reset on access
         * @see {@link lru} For parameter validation
         * @since 1.0.0
         */
        constructor(max = 0, ttl = 0, resetTtl = false) {
          this.first = null;
          this.items = /* @__PURE__ */ Object.create(null);
          this.last = null;
          this.max = max;
          this.resetTtl = resetTtl;
          this.size = 0;
          this.ttl = ttl;
        }
        /**
         * Removes all items from the cache.
         *
         * @method clear
         * @memberof LRU
         * @returns {LRU} The LRU instance for method chaining.
         * @example
         * cache.clear();
         * console.log(cache.size); // 0
         * @since 1.0.0
         */
        clear() {
          this.first = null;
          this.items = /* @__PURE__ */ Object.create(null);
          this.last = null;
          this.size = 0;
          return this;
        }
        /**
         * Removes an item from the cache by key.
         *
         * @method delete
         * @memberof LRU
         * @param {string} key - The key of the item to delete.
         * @returns {LRU} The LRU instance for method chaining.
         * @example
         * cache.set('key1', 'value1');
         * cache.delete('key1');
         * console.log(cache.has('key1')); // false
         * @see {@link LRU#has}
         * @see {@link LRU#clear}
         * @since 1.0.0
         */
        delete(key) {
          if (this.has(key)) {
            const item = this.items[key];
            delete this.items[key];
            this.size--;
            if (item.prev !== null) {
              item.prev.next = item.next;
            }
            if (item.next !== null) {
              item.next.prev = item.prev;
            }
            if (this.first === item) {
              this.first = item.next;
            }
            if (this.last === item) {
              this.last = item.prev;
            }
          }
          return this;
        }
        /**
         * Returns an array of [key, value] pairs for the specified keys.
         * Order follows LRU order (least to most recently used).
         *
         * @method entries
         * @memberof LRU
         * @param {string[]} [keys=this.keys()] - Array of keys to get entries for. Defaults to all keys.
         * @returns {Array<Array<*>>} Array of [key, value] pairs in LRU order.
         * @example
         * cache.set('a', 1).set('b', 2);
         * console.log(cache.entries()); // [['a', 1], ['b', 2]]
         * console.log(cache.entries(['a'])); // [['a', 1]]
         * @see {@link LRU#keys}
         * @see {@link LRU#values}
         * @since 11.1.0
         */
        entries(keys = this.keys()) {
          return keys.map((key) => [key, this.get(key)]);
        }
        /**
         * Removes the least recently used item from the cache.
         *
         * @method evict
         * @memberof LRU
         * @param {boolean} [bypass=false] - Whether to force eviction even when cache is empty.
         * @returns {LRU} The LRU instance for method chaining.
         * @example
         * cache.set('old', 'value').set('new', 'value');
         * cache.evict(); // Removes 'old' item
         * @see {@link LRU#setWithEvicted}
         * @since 1.0.0
         */
        evict(bypass = false) {
          if (bypass || this.size > 0) {
            const item = this.first;
            delete this.items[item.key];
            if (--this.size === 0) {
              this.first = null;
              this.last = null;
            } else {
              this.first = item.next;
              this.first.prev = null;
            }
          }
          return this;
        }
        /**
         * Returns the expiration timestamp for a given key.
         *
         * @method expiresAt
         * @memberof LRU
         * @param {string} key - The key to check expiration for.
         * @returns {number|undefined} The expiration timestamp in milliseconds, or undefined if key doesn't exist.
         * @example
         * const cache = new LRU(100, 5000); // 5 second TTL
         * cache.set('key1', 'value1');
         * console.log(cache.expiresAt('key1')); // timestamp 5 seconds from now
         * @see {@link LRU#get}
         * @see {@link LRU#has}
         * @since 1.0.0
         */
        expiresAt(key) {
          let result;
          if (this.has(key)) {
            result = this.items[key].expiry;
          }
          return result;
        }
        /**
         * Retrieves a value from the cache by key. Updates the item's position to most recently used.
         *
         * @method get
         * @memberof LRU
         * @param {string} key - The key to retrieve.
         * @returns {*} The value associated with the key, or undefined if not found or expired.
         * @example
         * cache.set('key1', 'value1');
         * console.log(cache.get('key1')); // 'value1'
         * console.log(cache.get('nonexistent')); // undefined
         * @see {@link LRU#set}
         * @see {@link LRU#has}
         * @since 1.0.0
         */
        get(key) {
          const item = this.items[key];
          if (item !== void 0) {
            if (this.ttl > 0) {
              if (item.expiry <= Date.now()) {
                this.delete(key);
                return void 0;
              }
            }
            this.moveToEnd(item);
            return item.value;
          }
          return void 0;
        }
        /**
         * Checks if a key exists in the cache.
         *
         * @method has
         * @memberof LRU
         * @param {string} key - The key to check for.
         * @returns {boolean} True if the key exists, false otherwise.
         * @example
         * cache.set('key1', 'value1');
         * console.log(cache.has('key1')); // true
         * console.log(cache.has('nonexistent')); // false
         * @see {@link LRU#get}
         * @see {@link LRU#delete}
         * @since 9.0.0
         */
        has(key) {
          return key in this.items;
        }
        /**
         * Efficiently moves an item to the end of the LRU list (most recently used position).
         * This is an internal optimization method that avoids the overhead of the full set() operation
         * when only LRU position needs to be updated.
         *
         * @method moveToEnd
         * @memberof LRU
         * @param {Object} item - The cache item with prev/next pointers to reposition.
         * @private
         * @since 11.3.5
         */
        moveToEnd(item) {
          if (this.last === item) {
            return;
          }
          if (item.prev !== null) {
            item.prev.next = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          }
          if (this.first === item) {
            this.first = item.next;
          }
          item.prev = this.last;
          item.next = null;
          if (this.last !== null) {
            this.last.next = item;
          }
          this.last = item;
          if (this.first === null) {
            this.first = item;
          }
        }
        /**
         * Returns an array of all keys in the cache, ordered from least to most recently used.
         *
         * @method keys
         * @memberof LRU
         * @returns {string[]} Array of keys in LRU order.
         * @example
         * cache.set('a', 1).set('b', 2);
         * cache.get('a'); // Move 'a' to most recent
         * console.log(cache.keys()); // ['b', 'a']
         * @see {@link LRU#values}
         * @see {@link LRU#entries}
         * @since 9.0.0
         */
        keys() {
          const result = [];
          let x2 = this.first;
          while (x2 !== null) {
            result.push(x2.key);
            x2 = x2.next;
          }
          return result;
        }
        /**
         * Sets a value in the cache and returns any evicted item.
         *
         * @method setWithEvicted
         * @memberof LRU
         * @param {string} key - The key to set.
         * @param {*} value - The value to store.
         * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.
         * @returns {Object|null} The evicted item (if any) with shape {key, value, expiry, prev, next}, or null.
         * @example
         * const cache = new LRU(2);
         * cache.set('a', 1).set('b', 2);
         * const evicted = cache.setWithEvicted('c', 3); // evicted = {key: 'a', value: 1, ...}
         * @see {@link LRU#set}
         * @see {@link LRU#evict}
         * @since 11.3.0
         */
        setWithEvicted(key, value, resetTtl = this.resetTtl) {
          let evicted = null;
          if (this.has(key)) {
            this.set(key, value, true, resetTtl);
          } else {
            if (this.max > 0 && this.size === this.max) {
              evicted = __spreadValues({}, this.first);
              this.evict(true);
            }
            let item = this.items[key] = {
              expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
              key,
              prev: this.last,
              next: null,
              value
            };
            if (++this.size === 1) {
              this.first = item;
            } else {
              this.last.next = item;
            }
            this.last = item;
          }
          return evicted;
        }
        /**
         * Sets a value in the cache. Updates the item's position to most recently used.
         *
         * @method set
         * @memberof LRU
         * @param {string} key - The key to set.
         * @param {*} value - The value to store.
         * @param {boolean} [bypass=false] - Internal parameter for setWithEvicted method.
         * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.
         * @returns {LRU} The LRU instance for method chaining.
         * @example
         * cache.set('key1', 'value1')
         *      .set('key2', 'value2')
         *      .set('key3', 'value3');
         * @see {@link LRU#get}
         * @see {@link LRU#setWithEvicted}
         * @since 1.0.0
         */
        set(key, value, bypass = false, resetTtl = this.resetTtl) {
          let item = this.items[key];
          if (bypass || item !== void 0) {
            item.value = value;
            if (bypass === false && resetTtl) {
              item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
            }
            this.moveToEnd(item);
          } else {
            if (this.max > 0 && this.size === this.max) {
              this.evict(true);
            }
            item = this.items[key] = {
              expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
              key,
              prev: this.last,
              next: null,
              value
            };
            if (++this.size === 1) {
              this.first = item;
            } else {
              this.last.next = item;
            }
            this.last = item;
          }
          return this;
        }
        /**
         * Returns an array of all values in the cache for the specified keys.
         * Order follows LRU order (least to most recently used).
         *
         * @method values
         * @memberof LRU
         * @param {string[]} [keys=this.keys()] - Array of keys to get values for. Defaults to all keys.
         * @returns {Array<*>} Array of values corresponding to the keys in LRU order.
         * @example
         * cache.set('a', 1).set('b', 2);
         * console.log(cache.values()); // [1, 2]
         * console.log(cache.values(['a'])); // [1]
         * @see {@link LRU#keys}
         * @see {@link LRU#entries}
         * @since 11.1.0
         */
        values(keys = this.keys()) {
          return keys.map((key) => this.get(key));
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
  function fontStringFromTextStyle(style) {
    const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
    let fontFamilies = style.fontFamily;
    if (!Array.isArray(style.fontFamily)) {
      fontFamilies = style.fontFamily.split(",");
    }
    for (let i3 = fontFamilies.length - 1; i3 >= 0; i3--) {
      let fontFamily = fontFamilies[i3].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i3] = fontFamily;
    }
    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
  var genericFontFamilies;
  var init_fontStringFromTextStyle = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
      "use strict";
      genericFontFamilies = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui"
      ];
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
  var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
  var init_CanvasTextMetrics = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
      init_tiny_lru();
      init_adapter();
      init_fontStringFromTextStyle();
      contextSettings = {
        // TextMetrics requires getImageData readback for measuring fonts.
        willReadFrequently: true
      };
      _CanvasTextMetrics = class _CanvasTextMetrics2 {
        /**
         * Checking that we can use modern canvas 2D API.
         *
         * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
         * @see TextMetrics.experimentalLetterSpacing
         * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
         * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
         */
        static get experimentalLetterSpacingSupported() {
          let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
          if (result === void 0) {
            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
            result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
          }
          return result;
        }
        /**
         * @param text - the text that was measured
         * @param style - the style that was measured
         * @param width - the measured width of the text
         * @param height - the measured height of the text
         * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
         * @param lineWidths - an array of the line widths for each line matched to `lines`
         * @param lineHeight - the measured line height for this style
         * @param maxLineWidth - the maximum line width for all measured lines
         * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
         */
        constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
          this.text = text;
          this.style = style;
          this.width = width;
          this.height = height;
          this.lines = lines;
          this.lineWidths = lineWidths;
          this.lineHeight = lineHeight;
          this.maxLineWidth = maxLineWidth;
          this.fontProperties = fontProperties;
        }
        /**
         * Measures the supplied string of text and returns a Rectangle.
         * @param text - The text to measure.
         * @param style - The text style to use for measuring
         * @param canvas - optional specification of the canvas to use for measuring.
         * @param wordWrap
         * @returns Measured width and height of the text.
         */
        static measureText(text = " ", style, canvas = _CanvasTextMetrics2._canvas, wordWrap = style.wordWrap) {
          var _a2;
          const textKey = `${text}-${style.styleKey}-wordWrap-${wordWrap}`;
          if (_CanvasTextMetrics2._measurementCache.has(textKey)) {
            return _CanvasTextMetrics2._measurementCache.get(textKey);
          }
          const font = fontStringFromTextStyle(style);
          const fontProperties = _CanvasTextMetrics2.measureFont(font);
          if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
          }
          const context4 = _CanvasTextMetrics2.__context;
          context4.font = font;
          const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text, style, canvas) : text;
          const lines = outputText.split(/(?:\r\n|\r|\n)/);
          const lineWidths = new Array(lines.length);
          let maxLineWidth = 0;
          for (let i3 = 0; i3 < lines.length; i3++) {
            const lineWidth = _CanvasTextMetrics2._measureText(lines[i3], style.letterSpacing, context4);
            lineWidths[i3] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
          }
          const strokeWidth = ((_a2 = style._stroke) == null ? void 0 : _a2.width) || 0;
          let width = maxLineWidth + strokeWidth;
          if (style.dropShadow) {
            width += style.dropShadow.distance;
          }
          const lineHeight = style.lineHeight || fontProperties.fontSize;
          let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
          if (style.dropShadow) {
            height += style.dropShadow.distance;
          }
          const measurements = new _CanvasTextMetrics2(
            text,
            style,
            width,
            height,
            lines,
            lineWidths,
            lineHeight + style.leading,
            maxLineWidth,
            fontProperties
          );
          _CanvasTextMetrics2._measurementCache.set(textKey, measurements);
          return measurements;
        }
        static _measureText(text, letterSpacing, context4) {
          let useExperimentalLetterSpacing = false;
          if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
            if (_CanvasTextMetrics2.experimentalLetterSpacing) {
              context4.letterSpacing = `${letterSpacing}px`;
              context4.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context4.letterSpacing = "0px";
              context4.textLetterSpacing = "0px";
            }
          }
          const metrics = context4.measureText(text);
          let metricWidth = metrics.width;
          const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;
          const actualBoundingBoxRight = metrics.actualBoundingBoxRight;
          let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
          if (metricWidth > 0) {
            if (useExperimentalLetterSpacing) {
              metricWidth -= letterSpacing;
              boundsWidth -= letterSpacing;
            } else {
              const val = (_CanvasTextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing;
              metricWidth += val;
              boundsWidth += val;
            }
          }
          return Math.max(metricWidth, boundsWidth);
        }
        /**
         * Applies newlines to a string to have it optimally fit into the horizontal
         * bounds set by the Text object's wordWrapWidth property.
         * @param text - String to apply word wrapping to
         * @param style - the style to use when wrapping
         * @param canvas - optional specification of the canvas to use for measuring.
         * @returns New string with new lines applied where required
         */
        static _wordWrap(text, style, canvas = _CanvasTextMetrics2._canvas) {
          const context4 = canvas.getContext("2d", contextSettings);
          let width = 0;
          let line = "";
          let lines = "";
          const cache = /* @__PURE__ */ Object.create(null);
          const { letterSpacing, whiteSpace } = style;
          const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
          const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
          let canPrependSpaces = !collapseSpaces;
          const wordWrapWidth = style.wordWrapWidth + letterSpacing;
          const tokens = _CanvasTextMetrics2._tokenize(text);
          for (let i3 = 0; i3 < tokens.length; i3++) {
            let token = tokens[i3];
            if (_CanvasTextMetrics2._isNewline(token)) {
              if (!collapseNewlines) {
                lines += _CanvasTextMetrics2._addLine(line);
                canPrependSpaces = !collapseSpaces;
                line = "";
                width = 0;
                continue;
              }
              token = " ";
            }
            if (collapseSpaces) {
              const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
              const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
              if (currIsBreakingSpace && lastIsBreakingSpace) {
                continue;
              }
            }
            const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache, context4);
            if (tokenWidth > wordWrapWidth) {
              if (line !== "") {
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              if (_CanvasTextMetrics2.canBreakWords(token, style.breakWords)) {
                const characters = _CanvasTextMetrics2.wordWrapSplit(token);
                for (let j2 = 0; j2 < characters.length; j2++) {
                  let char = characters[j2];
                  let lastChar = char;
                  let k2 = 1;
                  while (characters[j2 + k2]) {
                    const nextChar = characters[j2 + k2];
                    if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                      char += nextChar;
                    } else {
                      break;
                    }
                    lastChar = nextChar;
                    k2++;
                  }
                  j2 += k2 - 1;
                  const characterWidth = _CanvasTextMetrics2._getFromCache(char, letterSpacing, cache, context4);
                  if (characterWidth + width > wordWrapWidth) {
                    lines += _CanvasTextMetrics2._addLine(line);
                    canPrependSpaces = false;
                    line = "";
                    width = 0;
                  }
                  line += char;
                  width += characterWidth;
                }
              } else {
                if (line.length > 0) {
                  lines += _CanvasTextMetrics2._addLine(line);
                  line = "";
                  width = 0;
                }
                const isLastToken = i3 === tokens.length - 1;
                lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
                canPrependSpaces = false;
                line = "";
                width = 0;
              }
            } else {
              if (tokenWidth + width > wordWrapWidth) {
                canPrependSpaces = false;
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
                line += token;
                width += tokenWidth;
              }
            }
          }
          lines += _CanvasTextMetrics2._addLine(line, false);
          return lines;
        }
        /**
         * Convenience function for logging each line added during the wordWrap method.
         * @param line    - The line of text to add
         * @param newLine - Add new line character to end
         * @returns A formatted line
         */
        static _addLine(line, newLine = true) {
          line = _CanvasTextMetrics2._trimRight(line);
          line = newLine ? `${line}
` : line;
          return line;
        }
        /**
         * Gets & sets the widths of calculated characters in a cache object
         * @param key            - The key
         * @param letterSpacing  - The letter spacing
         * @param cache          - The cache
         * @param context        - The canvas context
         * @returns The from cache.
         */
        static _getFromCache(key, letterSpacing, cache, context4) {
          let width = cache[key];
          if (typeof width !== "number") {
            width = _CanvasTextMetrics2._measureText(key, letterSpacing, context4) + letterSpacing;
            cache[key] = width;
          }
          return width;
        }
        /**
         * Determines whether we should collapse breaking spaces.
         * @param whiteSpace - The TextStyle property whiteSpace
         * @returns Should collapse
         */
        static _collapseSpaces(whiteSpace) {
          return whiteSpace === "normal" || whiteSpace === "pre-line";
        }
        /**
         * Determines whether we should collapse newLine chars.
         * @param whiteSpace - The white space
         * @returns should collapse
         */
        static _collapseNewlines(whiteSpace) {
          return whiteSpace === "normal";
        }
        /**
         * Trims breaking whitespaces from string.
         * @param text - The text
         * @returns Trimmed string
         */
        static _trimRight(text) {
          if (typeof text !== "string") {
            return "";
          }
          for (let i3 = text.length - 1; i3 >= 0; i3--) {
            const char = text[i3];
            if (!_CanvasTextMetrics2.isBreakingSpace(char)) {
              break;
            }
            text = text.slice(0, -1);
          }
          return text;
        }
        /**
         * Determines if char is a newline.
         * @param char - The character
         * @returns True if newline, False otherwise.
         */
        static _isNewline(char) {
          if (typeof char !== "string") {
            return false;
          }
          return _CanvasTextMetrics2._newlines.includes(char.charCodeAt(0));
        }
        /**
         * Determines if char is a breaking whitespace.
         *
         * It allows one to determine whether char should be a breaking whitespace
         * For example certain characters in CJK langs or numbers.
         * It must return a boolean.
         * @param char - The character
         * @param [_nextChar] - The next character
         * @returns True if whitespace, False otherwise.
         */
        static isBreakingSpace(char, _nextChar) {
          if (typeof char !== "string") {
            return false;
          }
          return _CanvasTextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
        }
        /**
         * Splits a string into words, breaking-spaces and newLine characters
         * @param text - The text
         * @returns A tokenized array
         */
        static _tokenize(text) {
          const tokens = [];
          let token = "";
          if (typeof text !== "string") {
            return tokens;
          }
          for (let i3 = 0; i3 < text.length; i3++) {
            const char = text[i3];
            const nextChar = text[i3 + 1];
            if (_CanvasTextMetrics2.isBreakingSpace(char, nextChar) || _CanvasTextMetrics2._isNewline(char)) {
              if (token !== "") {
                tokens.push(token);
                token = "";
              }
              if (char === "\r" && nextChar === "\n") {
                tokens.push("\r\n");
                i3++;
              } else {
                tokens.push(char);
              }
              continue;
            }
            token += char;
          }
          if (token !== "") {
            tokens.push(token);
          }
          return tokens;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It allows one to customise which words should break
         * Examples are if the token is CJK or numbers.
         * It must return a boolean.
         * @param _token - The token
         * @param breakWords - The style attr break words
         * @returns Whether to break word or not
         */
        static canBreakWords(_token, breakWords) {
          return breakWords;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It allows one to determine whether a pair of characters
         * should be broken by newlines
         * For example certain characters in CJK langs or numbers.
         * It must return a boolean.
         * @param _char - The character
         * @param _nextChar - The next character
         * @param _token - The token/word the characters are from
         * @param _index - The index in the token of the char
         * @param _breakWords - The style attr break words
         * @returns whether to break word or not
         */
        static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
          return true;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It is called when a token (usually a word) has to be split into separate pieces
         * in order to determine the point to break a word.
         * It must return an array of characters.
         * @param token - The token to split
         * @returns The characters of the token
         * @see CanvasTextMetrics.graphemeSegmenter
         */
        static wordWrapSplit(token) {
          return _CanvasTextMetrics2.graphemeSegmenter(token);
        }
        /**
         * Calculates the ascent, descent and fontSize of a given font-style
         * @param font - String representing the style of the font
         * @returns Font properties object
         */
        static measureFont(font) {
          if (_CanvasTextMetrics2._fonts[font]) {
            return _CanvasTextMetrics2._fonts[font];
          }
          const context4 = _CanvasTextMetrics2._context;
          context4.font = font;
          const metrics = context4.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
          const properties = {
            ascent: metrics.actualBoundingBoxAscent,
            descent: metrics.actualBoundingBoxDescent,
            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
          };
          _CanvasTextMetrics2._fonts[font] = properties;
          return properties;
        }
        /**
         * Clear font metrics in metrics cache.
         * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
         */
        static clearMetrics(font = "") {
          if (font) {
            delete _CanvasTextMetrics2._fonts[font];
          } else {
            _CanvasTextMetrics2._fonts = {};
          }
        }
        /**
         * Cached canvas element for measuring text
         * TODO: this should be private, but isn't because of backward compat, will fix later.
         * @ignore
         */
        static get _canvas() {
          if (!_CanvasTextMetrics2.__canvas) {
            let canvas;
            try {
              const c2 = new OffscreenCanvas(0, 0);
              const context4 = c2.getContext("2d", contextSettings);
              if (context4 == null ? void 0 : context4.measureText) {
                _CanvasTextMetrics2.__canvas = c2;
                return c2;
              }
              canvas = DOMAdapter.get().createCanvas();
            } catch (_cx) {
              canvas = DOMAdapter.get().createCanvas();
            }
            canvas.width = canvas.height = 10;
            _CanvasTextMetrics2.__canvas = canvas;
          }
          return _CanvasTextMetrics2.__canvas;
        }
        /**
         * TODO: this should be private, but isn't because of backward compat, will fix later.
         * @ignore
         */
        static get _context() {
          if (!_CanvasTextMetrics2.__context) {
            _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings);
          }
          return _CanvasTextMetrics2.__context;
        }
      };
      _CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
      _CanvasTextMetrics.BASELINE_SYMBOL = "M";
      _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
      _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
      _CanvasTextMetrics.graphemeSegmenter = (() => {
        if (typeof (Intl == null ? void 0 : Intl.Segmenter) === "function") {
          const segmenter = new Intl.Segmenter();
          return (s2) => {
            const segments = segmenter.segment(s2);
            const result = [];
            let i3 = 0;
            for (const segment of segments) {
              result[i3++] = segment.segment;
            }
            return result;
          };
        }
        return (s2) => [...s2];
      })();
      _CanvasTextMetrics.experimentalLetterSpacing = false;
      _CanvasTextMetrics._fonts = {};
      _CanvasTextMetrics._newlines = [
        10,
        // line feed
        13
        // carriage return
      ];
      _CanvasTextMetrics._breakingSpaces = [
        9,
        // character tabulation
        32,
        // space
        8192,
        // en quad
        8193,
        // em quad
        8194,
        // en space
        8195,
        // em space
        8196,
        // three-per-em space
        8197,
        // four-per-em space
        8198,
        // six-per-em space
        8200,
        // punctuation space
        8201,
        // thin space
        8202,
        // hair space
        8287,
        // medium mathematical space
        12288
        // ideographic space
      ];
      _CanvasTextMetrics._measurementCache = lru(1e3);
      CanvasTextMetrics = _CanvasTextMetrics;
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
  function getCanvasFillStyle(fillStyle, context4, textMetrics, padding = 0) {
    var _a2;
    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
      return Color.shared.setValue(fillStyle.color).setAlpha((_a2 = fillStyle.alpha) != null ? _a2 : 1).toHexa();
    } else if (!fillStyle.fill) {
      const pattern = context4.createPattern(fillStyle.texture.source.resource, "repeat");
      const tempMatrix8 = fillStyle.matrix.copyTo(Matrix.shared);
      tempMatrix8.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
      pattern.setTransform(tempMatrix8);
      return pattern;
    } else if (fillStyle.fill instanceof FillPattern) {
      const fillPattern = fillStyle.fill;
      const pattern = context4.createPattern(fillPattern.texture.source.resource, "repeat");
      const tempMatrix8 = fillPattern.transform.copyTo(Matrix.shared);
      tempMatrix8.scale(
        fillPattern.texture.frame.width,
        fillPattern.texture.frame.height
      );
      pattern.setTransform(tempMatrix8);
      return pattern;
    } else if (fillStyle.fill instanceof FillGradient) {
      const fillGradient = fillStyle.fill;
      const isLinear = fillGradient.type === "linear";
      const isLocal = fillGradient.textureSpace === "local";
      let width = 1;
      let height = 1;
      if (isLocal && textMetrics) {
        width = textMetrics.width + padding;
        height = textMetrics.height + padding;
      }
      let gradient;
      let isNearlyVertical = false;
      if (isLinear) {
        const { start, end } = fillGradient;
        gradient = context4.createLinearGradient(
          start.x * width,
          start.y * height,
          end.x * width,
          end.y * height
        );
        isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);
      } else {
        const { center, innerRadius, outerCenter, outerRadius } = fillGradient;
        gradient = context4.createRadialGradient(
          center.x * width,
          center.y * height,
          innerRadius * width,
          outerCenter.x * width,
          outerCenter.y * height,
          outerRadius * width
        );
      }
      if (isNearlyVertical && isLocal && textMetrics) {
        const ratio = textMetrics.lineHeight / height;
        for (let i3 = 0; i3 < textMetrics.lines.length; i3++) {
          const start = (i3 * textMetrics.lineHeight + padding / 2) / height;
          fillGradient.colorStops.forEach((stop) => {
            const globalStop = start + stop.offset * ratio;
            gradient.addColorStop(
              // fix to 5 decimal places to avoid floating point precision issues
              Math.floor(globalStop * PRECISION) / PRECISION,
              Color.shared.setValue(stop.color).toHex()
            );
          });
        }
      } else {
        fillGradient.colorStops.forEach((stop) => {
          gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
        });
      }
      return gradient;
    }
    warn("FillStyle not recognised", fillStyle);
    return "red";
  }
  var PRECISION;
  var init_getCanvasFillStyle = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
      init_Color();
      init_Matrix();
      init_Texture();
      init_warn();
      init_FillGradient();
      init_FillPattern();
      PRECISION = 1e5;
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs
  var tempRect4, CanvasTextGeneratorClass, CanvasTextGenerator;
  var init_CanvasTextGenerator = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs"() {
      init_Color();
      init_Rectangle();
      init_CanvasPool();
      init_getCanvasBoundingBox();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      tempRect4 = new Rectangle();
      CanvasTextGeneratorClass = class {
        /**
         * Creates a canvas with the specified text rendered to it.
         *
         * Generates a canvas of appropriate size, renders the text with the provided style,
         * and returns both the canvas/context and a Rectangle representing the text bounds.
         *
         * When trim is enabled in the style, the frame will represent the bounds of the
         * non-transparent pixels, which can be smaller than the full canvas.
         * @param options - The options for generating the text canvas
         * @param options.text - The text to render
         * @param options.style - The style to apply to the text
         * @param options.resolution - The resolution of the canvas (defaults to 1)
         * @param options.padding
         * @returns An object containing the canvas/context and the frame (bounds) of the text
         */
        getCanvasAndContext(options) {
          const { text, style, resolution = 1 } = options;
          const padding = style._getFinalPadding();
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + padding * 2) * resolution);
          const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + padding * 2) * resolution);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
          this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);
          const frame = style.trim ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect4 }) : tempRect4.set(0, 0, width, height);
          return {
            canvasAndContext,
            frame
          };
        }
        /**
         * Returns a canvas and context to the pool.
         *
         * This should be called when you're done with the canvas to allow reuse
         * and prevent memory leaks.
         * @param canvasAndContext - The canvas and context to return to the pool
         */
        returnCanvasAndContext(canvasAndContext) {
          CanvasPool.returnCanvasAndContext(canvasAndContext);
        }
        /**
         * Renders text to its canvas, and updates its texture.
         * @param text - The text to render
         * @param style - The style of the text
         * @param padding - The padding of the text
         * @param resolution - The resolution of the text
         * @param canvasAndContext - The canvas and context to render the text to
         */
        _renderTextToCanvas(text, style, padding, resolution, canvasAndContext) {
          var _a2, _b, _c, _d, _e;
          const { canvas, context: context4 } = canvasAndContext;
          const font = fontStringFromTextStyle(style);
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          const lines = measured.lines;
          const lineHeight = measured.lineHeight;
          const lineWidths = measured.lineWidths;
          const maxLineWidth = measured.maxLineWidth;
          const fontProperties = measured.fontProperties;
          const height = canvas.height;
          context4.resetTransform();
          context4.scale(resolution, resolution);
          context4.textBaseline = style.textBaseline;
          if ((_a2 = style._stroke) == null ? void 0 : _a2.width) {
            const strokeStyle = style._stroke;
            context4.lineWidth = strokeStyle.width;
            context4.miterLimit = strokeStyle.miterLimit;
            context4.lineJoin = strokeStyle.join;
            context4.lineCap = strokeStyle.cap;
          }
          context4.font = font;
          let linePositionX;
          let linePositionY;
          const passesCount = style.dropShadow ? 2 : 1;
          for (let i3 = 0; i3 < passesCount; ++i3) {
            const isShadowPass = style.dropShadow && i3 === 0;
            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + padding * 2) : 0;
            const dsOffsetShadow = dsOffsetText * resolution;
            if (isShadowPass) {
              context4.fillStyle = "black";
              context4.strokeStyle = "black";
              const shadowOptions = style.dropShadow;
              const dropShadowColor = shadowOptions.color;
              const dropShadowAlpha = shadowOptions.alpha;
              context4.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
              const dropShadowBlur = shadowOptions.blur * resolution;
              const dropShadowDistance = shadowOptions.distance * resolution;
              context4.shadowBlur = dropShadowBlur;
              context4.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
              context4.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
            } else {
              context4.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context4, measured, padding * 2) : null;
              if ((_b = style._stroke) == null ? void 0 : _b.width) {
                const strokePadding = style._stroke.width * 0.5 + padding * 2;
                context4.strokeStyle = getCanvasFillStyle(style._stroke, context4, measured, strokePadding);
              }
              context4.shadowColor = "black";
            }
            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
            if (lineHeight - fontProperties.fontSize < 0) {
              linePositionYShift = 0;
            }
            const strokeWidth = (_d = (_c = style._stroke) == null ? void 0 : _c.width) != null ? _d : 0;
            for (let i22 = 0; i22 < lines.length; i22++) {
              linePositionX = strokeWidth / 2;
              linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
              if (style.align === "right") {
                linePositionX += maxLineWidth - lineWidths[i22];
              } else if (style.align === "center") {
                linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
              }
              if ((_e = style._stroke) == null ? void 0 : _e.width) {
                this._drawLetterSpacing(
                  lines[i22],
                  style,
                  canvasAndContext,
                  linePositionX + padding,
                  linePositionY + padding - dsOffsetText,
                  true
                );
              }
              if (style._fill !== void 0) {
                this._drawLetterSpacing(
                  lines[i22],
                  style,
                  canvasAndContext,
                  linePositionX + padding,
                  linePositionY + padding - dsOffsetText
                );
              }
            }
          }
        }
        /**
         * Render the text with letter-spacing.
         *
         * This method handles rendering text with the correct letter spacing, using either:
         * 1. Native letter spacing if supported by the browser
         * 2. Manual letter spacing calculation if not natively supported
         *
         * For manual letter spacing, it calculates the position of each character
         * based on its width and the desired spacing.
         * @param text - The text to draw
         * @param style - The text style to apply
         * @param canvasAndContext - The canvas and context to draw to
         * @param x - Horizontal position to draw the text
         * @param y - Vertical position to draw the text
         * @param isStroke - Whether to render the stroke (true) or fill (false)
         * @private
         */
        _drawLetterSpacing(text, style, canvasAndContext, x2, y2, isStroke = false) {
          const { context: context4 } = canvasAndContext;
          const letterSpacing = style.letterSpacing;
          let useExperimentalLetterSpacing = false;
          if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
            if (CanvasTextMetrics.experimentalLetterSpacing) {
              context4.letterSpacing = `${letterSpacing}px`;
              context4.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context4.letterSpacing = "0px";
              context4.textLetterSpacing = "0px";
            }
          }
          if (letterSpacing === 0 || useExperimentalLetterSpacing) {
            if (isStroke) {
              context4.strokeText(text, x2, y2);
            } else {
              context4.fillText(text, x2, y2);
            }
            return;
          }
          let currentPosition = x2;
          const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
          let previousWidth = context4.measureText(text).width;
          let currentWidth = 0;
          for (let i3 = 0; i3 < stringArray.length; ++i3) {
            const currentChar = stringArray[i3];
            if (isStroke) {
              context4.strokeText(currentChar, currentPosition, y2);
            } else {
              context4.fillText(currentChar, currentPosition, y2);
            }
            let textStr = "";
            for (let j2 = i3 + 1; j2 < stringArray.length; ++j2) {
              textStr += stringArray[j2];
            }
            currentWidth = context4.measureText(textStr).width;
            currentPosition += previousWidth - currentWidth + letterSpacing;
            previousWidth = currentWidth;
          }
        }
      };
      CanvasTextGenerator = new CanvasTextGeneratorClass();
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
  var CanvasTextSystem;
  var init_CanvasTextSystem = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
      init_Extensions();
      init_TexturePool();
      init_TextureStyle();
      init_deprecation();
      init_TextStyle();
      init_getPo2TextureFromSource();
      init_CanvasTextGenerator();
      CanvasTextSystem = class {
        constructor(_renderer) {
          this._activeTextures = {};
          this._renderer = _renderer;
        }
        getTexture(options, _resolution, _style, _textKey) {
          var _a2;
          if (typeof options === "string") {
            deprecation("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
            options = {
              text: options,
              style: _style,
              resolution: _resolution
            };
          }
          if (!(options.style instanceof TextStyle)) {
            options.style = new TextStyle(options.style);
          }
          if (!(options.textureStyle instanceof TextureStyle)) {
            options.textureStyle = new TextureStyle(options.textureStyle);
          }
          if (typeof options.text !== "string") {
            options.text = options.text.toString();
          }
          const { text, style, textureStyle } = options;
          const resolution = (_a2 = options.resolution) != null ? _a2 : this._renderer.resolution;
          const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({
            text,
            style,
            resolution
          });
          const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);
          if (textureStyle)
            texture.source.style = textureStyle;
          if (style.trim) {
            frame.pad(style.padding);
            texture.frame.copyFrom(frame);
            texture.frame.scale(1 / resolution);
            texture.updateUvs();
          }
          if (style.filters) {
            const filteredTexture = this._applyFilters(texture, style.filters);
            this.returnTexture(texture);
            CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
            return filteredTexture;
          }
          this._renderer.texture.initSource(texture._source);
          CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
          return texture;
        }
        /**
         * Returns a texture that was created wit the above `getTexture` function.
         * Handy if you are done with a texture and want to return it to the pool.
         * @param texture - The texture to be returned.
         */
        returnTexture(texture) {
          const source11 = texture.source;
          source11.resource = null;
          source11.uploadMethodId = "unknown";
          source11.alphaMode = "no-premultiply-alpha";
          TexturePool.returnTexture(texture, true);
        }
        /**
         * Renders text to its canvas, and updates its texture.
         * @deprecated since 8.10.0
         */
        renderTextToCanvas() {
          deprecation(
            "8.10.0",
            "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead"
          );
        }
        /**
         * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.
         * @param text - The Text object that needs a texture
         * @returns A Texture instance that represents the rendered text
         * @remarks
         * This method performs the following:
         * 1. Sets the appropriate resolution based on auto-resolution settings
         * 2. Checks if a texture already exists for the text's style
         * 3. Creates a new texture if needed or returns an existing one
         * 4. Manages reference counting for texture reuse
         */
        getManagedTexture(text) {
          text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
          const textKey = text.styleKey;
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].texture;
          }
          const texture = this.getTexture({
            text: text.text,
            style: text.style,
            resolution: text._resolution,
            textureStyle: text.textureStyle
          });
          this._activeTextures[textKey] = {
            texture,
            usageCount: 1
          };
          return texture;
        }
        /**
         * Decreases the reference count for a texture associated with a text key.
         * When the reference count reaches zero, the texture is returned to the pool.
         * @param textKey - The unique key identifying the text style configuration
         * @remarks
         * This method is crucial for memory management, ensuring textures are properly
         * cleaned up when they are no longer needed by any Text instances.
         */
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            this.returnTexture(activeTexture.texture);
            this._activeTextures[textKey] = null;
          }
        }
        /**
         * Gets the current reference count for a texture associated with a text key.
         * @param textKey - The unique key identifying the text style configuration
         * @returns The number of Text instances currently using this texture
         */
        getReferenceCount(textKey) {
          var _a2, _b;
          return (_b = (_a2 = this._activeTextures[textKey]) == null ? void 0 : _a2.usageCount) != null ? _b : 0;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        /**
         * Applies the specified filters to the given texture.
         *
         * This method takes a texture and a list of filters, applies the filters to the texture,
         * and returns the resulting texture. It also ensures that the alpha mode of the resulting
         * texture is set to 'premultiplied-alpha'.
         * @param {Texture} texture - The texture to which the filters will be applied.
         * @param {Filter[]} filters - The filters to apply to the texture.
         * @returns {Texture} The resulting texture after all filters have been applied.
         */
        _applyFilters(texture, filters) {
          const currentRenderTarget = this._renderer.renderTarget.renderTarget;
          const resultTexture = this._renderer.filter.generateFilteredTexture({
            texture,
            filters
          });
          this._renderer.renderTarget.bind(currentRenderTarget, false);
          return resultTexture;
        }
        destroy() {
          this._renderer = null;
          for (const key in this._activeTextures) {
            if (this._activeTextures[key])
              this.returnTexture(this._activeTextures[key].texture);
          }
          this._activeTextures = null;
        }
      };
      CanvasTextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "canvasText"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/init.mjs
  var init_init10 = __esm({
    "node_modules/pixi.js/lib/scene/text/init.mjs"() {
      init_Extensions();
      init_CanvasTextPipe();
      init_CanvasTextSystem();
      extensions.add(CanvasTextSystem);
      extensions.add(CanvasTextPipe);
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
  var Graphics;
  var init_Graphics = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs"() {
      init_deprecation();
      init_ViewContainer();
      init_GraphicsContext();
      Graphics = class _Graphics extends ViewContainer {
        /**
         * Creates a new Graphics object.
         * @param options - Options for the Graphics.
         */
        constructor(options) {
          if (options instanceof GraphicsContext) {
            options = { context: options };
          }
          const _a2 = options || {}, { context: context4, roundPixels } = _a2, rest = __objRest(_a2, ["context", "roundPixels"]);
          super(__spreadValues({
            label: "Graphics"
          }, rest));
          this.renderPipeId = "graphics";
          if (!context4) {
            this.context = this._ownedContext = new GraphicsContext();
            this.context.autoGarbageCollect = this.autoGarbageCollect;
          } else {
            this.context = context4;
          }
          this.didViewUpdate = true;
          this.allowChildren = false;
          this.roundPixels = roundPixels != null ? roundPixels : false;
        }
        set context(context4) {
          if (context4 === this._context)
            return;
          if (this._context) {
            this._context.off("update", this.onViewUpdate, this);
            this._context.off("unload", this.unload, this);
          }
          this._context = context4;
          this._context.on("update", this.onViewUpdate, this);
          this._context.on("unload", this.unload, this);
          this.onViewUpdate();
        }
        /**
         * The underlying graphics context used for drawing operations.
         * Controls how shapes and paths are rendered.
         * @example
         * ```ts
         * // Create a shared context
         * const sharedContext = new GraphicsContext();
         *
         * // Create graphics objects sharing the same context
         * const graphics1 = new Graphics();
         * const graphics2 = new Graphics();
         *
         * // Assign shared context
         * graphics1.context = sharedContext;
         * graphics2.context = sharedContext;
         *
         * // Both graphics will show the same shapes
         * sharedContext
         *     .rect(0, 0, 100, 100)
         *     .fill({ color: 0xff0000 });
         * ```
         * @see {@link GraphicsContext} For drawing operations
         * @see {@link GraphicsOptions} For context configuration
         */
        get context() {
          return this._context;
        }
        /**
         * The local bounds of the graphics object.
         * Returns the boundaries after all graphical operations but before any transforms.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Draw a shape
         * graphics
         *     .rect(0, 0, 100, 100)
         *     .fill({ color: 0xff0000 });
         *
         * // Get bounds information
         * const bounds = graphics.bounds;
         * console.log(bounds.width);  // 100
         * console.log(bounds.height); // 100
         * ```
         * @readonly
         * @see {@link Bounds} For bounds operations
         * @see {@link Container#getBounds} For transformed bounds
         */
        get bounds() {
          return this._context.bounds;
        }
        /**
         * Graphics objects do not need to update their bounds as the context handles this.
         * @private
         */
        updateBounds() {
        }
        /**
         * Checks if the object contains the given point.
         * Returns true if the point lies within the Graphics object's rendered area.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Draw a shape
         * graphics
         *     .rect(0, 0, 100, 100)
         *     .fill({ color: 0xff0000 });
         *
         * // Check point intersection
         * if (graphics.containsPoint({ x: 50, y: 50 })) {
         *     console.log('Point is inside rectangle!');
         * }
         * ```
         * @param point - The point to check in local coordinates
         * @returns True if the point is inside the Graphics object
         * @see {@link Graphics#bounds} For bounding box checks
         * @see {@link PointData} For point data structure
         */
        containsPoint(point) {
          return this._context.containsPoint(point);
        }
        /**
         * Destroys this graphics renderable and optionally its context.
         * @param options - Options parameter. A boolean will act as if all options
         *
         * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
         * then the context will still be destroyed.
         *
         * If you want to explicitly not destroy this context that this graphics created,
         * then you should pass destroy({ context: false })
         *
         * If the context was passed in as an argument to the constructor then it will not be destroyed
         * @example
         * ```ts
         * // Destroy the graphics and its context
         * graphics.destroy();
         * graphics.destroy(true);
         * graphics.destroy({ context: true, texture: true, textureSource: true });
         * ```
         */
        destroy(options) {
          if (this._ownedContext && !options) {
            this._ownedContext.destroy(options);
          } else if (options === true || (options == null ? void 0 : options.context) === true) {
            this._context.destroy(options);
          }
          this._ownedContext = null;
          this._context = null;
          super.destroy(options);
        }
        /**
         * @param now - The current time in milliseconds.
         * @internal
         */
        _onTouch(now) {
          this._gcLastUsed = now;
          this._context._gcLastUsed = now;
        }
        _callContextMethod(method, args) {
          this.context[method](...args);
          return this;
        }
        // --------------------------------------- GraphicsContext methods ---------------------------------------
        /**
         * Sets the current fill style of the graphics context.
         * The fill style can be a color, gradient, pattern, or a complex style object.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Basic color fill
         * graphics
         *     .setFillStyle({ color: 0xff0000 }) // Red fill
         *     .rect(0, 0, 100, 100)
         *     .fill();
         *
         * // Gradient fill
         * const gradient = new FillGradient({
         *    end: { x: 1, y: 0 },
         *    colorStops: [
         *         { offset: 0, color: 0xff0000 }, // Red at start
         *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
         *         { offset: 1, color: 0x0000ff }, // Blue at end
         *    ],
         * });
         *
         * graphics
         *     .setFillStyle(gradient)
         *     .circle(100, 100, 50)
         *     .fill();
         *
         * // Pattern fill
         * const pattern = new FillPattern(texture);
         * graphics
         *     .setFillStyle({
         *         fill: pattern,
         *         alpha: 0.5
         *     })
         *     .rect(0, 0, 200, 200)
         *     .fill();
         * ```
         * @param {FillInput} args - The fill style to apply
         * @returns The Graphics instance for chaining
         * @see {@link FillStyle} For fill style options
         * @see {@link FillGradient} For gradient fills
         * @see {@link FillPattern} For pattern fills
         */
        setFillStyle(...args) {
          return this._callContextMethod("setFillStyle", args);
        }
        /**
         * Sets the current stroke style of the graphics context.
         * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Basic color stroke
         * graphics
         *     .setStrokeStyle({
         *         width: 2,
         *         color: 0x000000
         *     })
         *     .rect(0, 0, 100, 100)
         *     .stroke();
         *
         * // Complex stroke style
         * graphics
         *     .setStrokeStyle({
         *         width: 4,
         *         color: 0xff0000,
         *         alpha: 0.5,
         *         join: 'round',
         *         cap: 'round',
         *         alignment: 0.5
         *     })
         *     .circle(100, 100, 50)
         *     .stroke();
         *
         * // Gradient stroke
         * const gradient = new FillGradient({
         *    end: { x: 1, y: 0 },
         *    colorStops: [
         *         { offset: 0, color: 0xff0000 }, // Red at start
         *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
         *         { offset: 1, color: 0x0000ff }, // Blue at end
         *    ],
         * });
         *
         * graphics
         *     .setStrokeStyle({
         *         width: 10,
         *         fill: gradient
         *     })
         *     .poly([0,0, 100,50, 0,100])
         *     .stroke();
         * ```
         * @param {StrokeInput} args - The stroke style to apply
         * @returns The Graphics instance for chaining
         * @see {@link StrokeStyle} For stroke style options
         * @see {@link FillGradient} For gradient strokes
         * @see {@link FillPattern} For pattern strokes
         */
        setStrokeStyle(...args) {
          return this._callContextMethod("setStrokeStyle", args);
        }
        fill(...args) {
          return this._callContextMethod("fill", args);
        }
        /**
         * Strokes the current path with the current stroke style or specified style.
         * Outlines the shape using the stroke settings.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Stroke with direct color
         * graphics
         *     .circle(50, 50, 25)
         *     .stroke({
         *         width: 2,
         *         color: 0xff0000
         *     }); // 2px red stroke
         *
         * // Fill with texture
         * graphics
         *    .rect(0, 0, 100, 100)
         *    .stroke(myTexture); // Fill with texture
         *
         * // Stroke with gradient
         * const gradient = new FillGradient({
         *     end: { x: 1, y: 0 },
         *     colorStops: [
         *         { offset: 0, color: 0xff0000 },
         *         { offset: 0.5, color: 0x00ff00 },
         *         { offset: 1, color: 0x0000ff },
         *     ],
         * });
         *
         * graphics
         *     .rect(0, 0, 100, 100)
         *     .stroke({
         *         width: 4,
         *         fill: gradient,
         *         alignment: 0.5,
         *         join: 'round'
         *     });
         * ```
         * @param {StrokeStyle} args - Optional stroke style to apply. Can be:
         * - A stroke style object with width, color, etc.
         * - A gradient
         * - A pattern
         * If omitted, uses current stroke style.
         * @returns The Graphics instance for chaining
         * @see {@link StrokeStyle} For stroke style options
         * @see {@link FillGradient} For gradient strokes
         * @see {@link setStrokeStyle} For setting default stroke style
         */
        stroke(...args) {
          return this._callContextMethod("stroke", args);
        }
        texture(...args) {
          return this._callContextMethod("texture", args);
        }
        /**
         * Resets the current path. Any previous path and its commands are discarded and a new path is
         * started. This is typically called before beginning a new shape or series of drawing commands.
         * @example
         * ```ts
         * const graphics = new Graphics();
         * graphics
         *     .circle(150, 150, 50)
         *     .fill({ color: 0x00ff00 })
         *     .beginPath() // Starts a new path
         *     .circle(250, 150, 50)
         *     .fill({ color: 0x0000ff });
         * ```
         * @returns The Graphics instance for chaining
         * @see {@link Graphics#moveTo} For starting a new subpath
         * @see {@link Graphics#closePath} For closing the current path
         */
        beginPath() {
          return this._callContextMethod("beginPath", []);
        }
        /**
         * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
         * subtracting a path from the previously drawn path.
         *
         * If a hole is not completely in a shape, it will fail to cut correctly.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Draw outer circle
         * graphics
         *     .circle(100, 100, 50)
         *     .fill({ color: 0xff0000 });
         *     .circle(100, 100, 25) // Inner circle
         *     .cut() // Cuts out the inner circle from the outer circle
         * ```
         */
        cut() {
          return this._callContextMethod("cut", []);
        }
        arc(...args) {
          return this._callContextMethod("arc", args);
        }
        arcTo(...args) {
          return this._callContextMethod("arcTo", args);
        }
        arcToSvg(...args) {
          return this._callContextMethod("arcToSvg", args);
        }
        bezierCurveTo(...args) {
          return this._callContextMethod("bezierCurveTo", args);
        }
        /**
         * Closes the current path by drawing a straight line back to the start point.
         *
         * This is useful for completing shapes and ensuring they are properly closed for fills.
         * @example
         * ```ts
         * // Create a triangle with closed path
         * const graphics = new Graphics();
         * graphics
         *     .moveTo(50, 50)
         *     .lineTo(100, 100)
         *     .lineTo(0, 100)
         *     .closePath()
         * ```
         * @returns The Graphics instance for method chaining
         * @see {@link Graphics#beginPath} For starting a new path
         * @see {@link Graphics#fill} For filling closed paths
         * @see {@link Graphics#stroke} For stroking paths
         */
        closePath() {
          return this._callContextMethod("closePath", []);
        }
        ellipse(...args) {
          return this._callContextMethod("ellipse", args);
        }
        circle(...args) {
          return this._callContextMethod("circle", args);
        }
        path(...args) {
          return this._callContextMethod("path", args);
        }
        lineTo(...args) {
          return this._callContextMethod("lineTo", args);
        }
        moveTo(...args) {
          return this._callContextMethod("moveTo", args);
        }
        quadraticCurveTo(...args) {
          return this._callContextMethod("quadraticCurveTo", args);
        }
        rect(...args) {
          return this._callContextMethod("rect", args);
        }
        roundRect(...args) {
          return this._callContextMethod("roundRect", args);
        }
        poly(...args) {
          return this._callContextMethod("poly", args);
        }
        regularPoly(...args) {
          return this._callContextMethod("regularPoly", args);
        }
        roundPoly(...args) {
          return this._callContextMethod("roundPoly", args);
        }
        roundShape(...args) {
          return this._callContextMethod("roundShape", args);
        }
        filletRect(...args) {
          return this._callContextMethod("filletRect", args);
        }
        chamferRect(...args) {
          return this._callContextMethod("chamferRect", args);
        }
        star(...args) {
          return this._callContextMethod("star", args);
        }
        svg(...args) {
          return this._callContextMethod("svg", args);
        }
        restore(...args) {
          return this._callContextMethod("restore", args);
        }
        /**
         * Saves the current graphics state onto a stack. The state includes:
         * - Current transformation matrix
         * - Current fill style
         * - Current stroke style
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Save state before complex operations
         * graphics.save();
         *
         * // Create transformed and styled shape
         * graphics
         *     .translateTransform(100, 100)
         *     .rotateTransform(Math.PI / 4)
         *     .setFillStyle({
         *         color: 0xff0000,
         *         alpha: 0.5
         *     })
         *     .rect(-25, -25, 50, 50)
         *     .fill();
         *
         * // Restore to original state
         * graphics.restore();
         *
         * // Continue drawing with previous state
         * graphics
         *     .circle(50, 50, 25)
         *     .fill();
         * ```
         * @returns The Graphics instance for method chaining
         * @see {@link Graphics#restore} For restoring the saved state
         * @see {@link Graphics#setTransform} For setting transformations
         */
        save() {
          return this._callContextMethod("save", []);
        }
        /**
         * Returns the current transformation matrix of the graphics context.
         * This matrix represents all accumulated transformations including translate, scale, and rotate.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Apply some transformations
         * graphics
         *     .translateTransform(100, 100)
         *     .rotateTransform(Math.PI / 4);
         *
         * // Get the current transform matrix
         * const matrix = graphics.getTransform();
         * console.log(matrix.tx, matrix.ty); // 100, 100
         *
         * // Use the matrix for other operations
         * graphics
         *     .setTransform(matrix)
         *     .circle(0, 0, 50)
         *     .fill({ color: 0xff0000 });
         * ```
         * @returns The current transformation matrix.
         * @see {@link Graphics#setTransform} For setting the transform matrix
         * @see {@link Matrix} For matrix operations
         */
        getTransform() {
          return this.context.getTransform();
        }
        /**
         * Resets the current transformation matrix to the identity matrix, effectively removing
         * any transformations (rotation, scaling, translation) previously applied.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Apply transformations
         * graphics
         *     .translateTransform(100, 100)
         *     .scaleTransform(2, 2)
         *     .circle(0, 0, 25)
         *     .fill({ color: 0xff0000 });
         * // Reset transform to default state
         * graphics
         *     .resetTransform()
         *     .circle(50, 50, 25) // Will draw at actual coordinates
         *     .fill({ color: 0x00ff00 });
         * ```
         * @returns The Graphics instance for method chaining
         * @see {@link Graphics#getTransform} For getting the current transform
         * @see {@link Graphics#setTransform} For setting a specific transform
         * @see {@link Graphics#save} For saving the current transform state
         * @see {@link Graphics#restore} For restoring a previous transform state
         */
        resetTransform() {
          return this._callContextMethod("resetTransform", []);
        }
        rotateTransform(...args) {
          return this._callContextMethod("rotate", args);
        }
        scaleTransform(...args) {
          return this._callContextMethod("scale", args);
        }
        setTransform(...args) {
          return this._callContextMethod("setTransform", args);
        }
        transform(...args) {
          return this._callContextMethod("transform", args);
        }
        translateTransform(...args) {
          return this._callContextMethod("translate", args);
        }
        /**
         * Clears all drawing commands from the graphics context, effectively resetting it.
         * This includes clearing the current path, fill style, stroke style, and transformations.
         *
         * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.
         * > Instead, they are intended to be used for static or semi-static graphics that
         * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Draw some shapes
         * graphics
         *     .circle(100, 100, 50)
         *     .fill({ color: 0xff0000 })
         *     .rect(200, 100, 100, 50)
         *     .fill({ color: 0x00ff00 });
         *
         * // Clear all graphics
         * graphics.clear();
         *
         * // Start fresh with new shapes
         * graphics
         *     .circle(150, 150, 30)
         *     .fill({ color: 0x0000ff });
         * ```
         * @returns The Graphics instance for method chaining
         * @see {@link Graphics#beginPath} For starting a new path without clearing styles
         * @see {@link Graphics#save} For saving the current state
         * @see {@link Graphics#restore} For restoring a previous state
         */
        clear() {
          return this._callContextMethod("clear", []);
        }
        /**
         * Gets or sets the current fill style for the graphics context. The fill style determines
         * how shapes are filled when using the fill() method.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Basic color fill
         * graphics.fillStyle = {
         *     color: 0xff0000,  // Red
         *     alpha: 1
         * };
         *
         * // Using gradients
         * const gradient = new FillGradient({
         *     end: { x: 0, y: 1 }, // Vertical gradient
         *     stops: [
         *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color
         *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color
         *     ]
         * });
         *
         * graphics.fillStyle = {
         *     fill: gradient,
         *     alpha: 0.8
         * };
         *
         * // Using patterns
         * graphics.fillStyle = {
         *     texture: myTexture,
         *     alpha: 1,
         *     matrix: new Matrix()
         *         .scale(0.5, 0.5)
         *         .rotate(Math.PI / 4)
         * };
         * ```
         * @type {ConvertedFillStyle}
         * @see {@link FillStyle} For all available fill style options
         * @see {@link FillGradient} For creating gradient fills
         * @see {@link Graphics#fill} For applying the fill to paths
         */
        get fillStyle() {
          return this._context.fillStyle;
        }
        set fillStyle(value) {
          this._context.fillStyle = value;
        }
        /**
         * Gets or sets the current stroke style for the graphics context. The stroke style determines
         * how paths are outlined when using the stroke() method.
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Basic stroke style
         * graphics.strokeStyle = {
         *     width: 2,
         *     color: 0xff0000,
         *     alpha: 1
         * };
         *
         * // Using with gradients
         * const gradient = new FillGradient({
         *   end: { x: 0, y: 1 },
         *   stops: [
         *       { offset: 0, color: 0xff0000, alpha: 1 },
         *       { offset: 1, color: 0x0000ff, alpha: 1 }
         *   ]
         * });
         *
         * graphics.strokeStyle = {
         *     width: 4,
         *     fill: gradient,
         *     alignment: 0.5,
         *     join: 'round',
         *     cap: 'round'
         * };
         *
         * // Complex stroke settings
         * graphics.strokeStyle = {
         *     width: 6,
         *     color: 0x00ff00,
         *     alpha: 0.5,
         *     join: 'miter',
         *     miterLimit: 10,
         * };
         * ```
         * @see {@link StrokeStyle} For all available stroke style options
         * @see {@link Graphics#stroke} For applying the stroke to paths
         */
        get strokeStyle() {
          return this._context.strokeStyle;
        }
        set strokeStyle(value) {
          this._context.strokeStyle = value;
        }
        /**
         * Creates a new Graphics object that copies the current graphics content.
         * The clone can either share the same context (shallow clone) or have its own independent
         * context (deep clone).
         * @example
         * ```ts
         * const graphics = new Graphics();
         *
         * // Create original graphics content
         * graphics
         *     .circle(100, 100, 50)
         *     .fill({ color: 0xff0000 });
         *
         * // Create a shallow clone (shared context)
         * const shallowClone = graphics.clone();
         *
         * // Changes to original affect the clone
         * graphics
         *     .circle(200, 100, 30)
         *     .fill({ color: 0x00ff00 });
         *
         * // Create a deep clone (independent context)
         * const deepClone = graphics.clone(true);
         *
         * // Modify deep clone independently
         * deepClone
         *     .translateTransform(100, 100)
         *     .circle(0, 0, 40)
         *     .fill({ color: 0x0000ff });
         * ```
         * @param deep - Whether to create a deep clone of the graphics object.
         *              If false (default), the context will be shared between objects.
         *              If true, creates an independent copy of the context.
         * @returns A new Graphics instance with either shared or copied context
         * @see {@link Graphics#context} For accessing the underlying graphics context
         * @see {@link GraphicsContext} For understanding the shared context behavior
         */
        clone(deep = false) {
          if (deep) {
            return new _Graphics(this._context.clone());
          }
          this._ownedContext = null;
          const clone = new _Graphics(this._context);
          return clone;
        }
        // -------- v7 deprecations ---------
        /**
         * @param width
         * @param color
         * @param alpha
         * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
         */
        lineStyle(width, color, alpha) {
          deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
          const strokeStyle = {};
          width && (strokeStyle.width = width);
          color && (strokeStyle.color = color);
          alpha && (strokeStyle.alpha = alpha);
          this.context.strokeStyle = strokeStyle;
          return this;
        }
        /**
         * @param color
         * @param alpha
         * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
         */
        beginFill(color, alpha) {
          deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
          const fillStyle = {};
          if (color !== void 0)
            fillStyle.color = color;
          if (alpha !== void 0)
            fillStyle.alpha = alpha;
          this.context.fillStyle = fillStyle;
          return this;
        }
        /**
         * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
         */
        endFill() {
          deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
          this.context.fill();
          const strokeStyle = this.context.strokeStyle;
          if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
            this.context.stroke();
          }
          return this;
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
         */
        drawCircle(...args) {
          deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
          return this._callContextMethod("circle", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
         */
        drawEllipse(...args) {
          deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
          return this._callContextMethod("ellipse", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
         */
        drawPolygon(...args) {
          deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
          return this._callContextMethod("poly", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
         */
        drawRect(...args) {
          deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
          return this._callContextMethod("rect", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
         */
        drawRoundedRect(...args) {
          deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
          return this._callContextMethod("roundRect", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#star} instead
         */
        drawStar(...args) {
          deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
          return this._callContextMethod("star", args);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
  var localUniformMSDFBit, localUniformMSDFBitGl;
  var init_localUniformMSDFBit = __esm({
    "node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
      "use strict";
      localUniformMSDFBit = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
          ),
          end: (
            /* wgsl */
            `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
          ),
          main: (
            /* wgsl */
            `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
          )
        }
      };
      localUniformMSDFBitGl = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `
          ),
          end: (
            /* glsl */
            `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
            uniform float uDistance;
         `
          ),
          main: (
            /* glsl */
            `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
  var mSDFBit, mSDFBitGl;
  var init_mSDFBit = __esm({
    "node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
      "use strict";
      mSDFBit = {
        name: "msdf-bit",
        fragment: {
          header: (
            /* wgsl */
            `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `
          )
        }
      };
      mSDFBitGl = {
        name: "msdf-bit",
        fragment: {
          header: (
            /* glsl */
            `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
  var gpuProgram, glProgram, SdfShader;
  var init_SdfShader = __esm({
    "node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs"() {
      init_Matrix();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      init_localUniformMSDFBit();
      init_mSDFBit();
      SdfShader = class extends Shader {
        constructor(maxTextures) {
          const uniforms = new UniformGroup({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uDistance: { value: 4, type: "f32" },
            uRound: { value: 0, type: "f32" }
          });
          gpuProgram != null ? gpuProgram : gpuProgram = compileHighShaderGpuProgram({
            name: "sdf-shader",
            bits: [
              colorBit,
              generateTextureBatchBit(maxTextures),
              localUniformMSDFBit,
              mSDFBit,
              roundPixelsBit
            ]
          });
          glProgram != null ? glProgram : glProgram = compileHighShaderGlProgram({
            name: "sdf-shader",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures),
              localUniformMSDFBitGl,
              mSDFBitGl,
              roundPixelsBitGl
            ]
          });
          super({
            glProgram,
            gpuProgram,
            resources: {
              localUniforms: uniforms,
              batchSamplers: getBatchSamplersUniformGroup(maxTextures)
            }
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs
  var AbstractBitmapFont;
  var init_AbstractBitmapFont = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs"() {
      init_eventemitter3();
      init_deprecation();
      AbstractBitmapFont = class extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.chars = /* @__PURE__ */ Object.create(null);
          this.lineHeight = 0;
          this.fontFamily = "";
          this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
          this.baseLineOffset = 0;
          this.distanceField = { type: "none", range: 0 };
          this.pages = [];
          this.applyFillAsTint = true;
          this.baseMeasurementFontSize = 100;
          this.baseRenderedFontSize = 100;
        }
        /**
         * The name of the font face.
         * @deprecated since 8.0.0 Use `fontFamily` instead.
         */
        get font() {
          deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
          return this.fontFamily;
        }
        /**
         * The map of base page textures (i.e., sheets of glyphs).
         * @deprecated since 8.0.0 Use `pages` instead.
         */
        get pageTextures() {
          deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        /**
         * The size of the font face in pixels.
         * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
         */
        get size() {
          deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
          return this.fontMetrics.fontSize;
        }
        /**
         * The kind of distance field for this font or "none".
         * @deprecated since 8.0.0 Use `distanceField.type` instead.
         */
        get distanceFieldRange() {
          deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
          return this.distanceField.range;
        }
        /**
         * The range of the distance field in pixels.
         * @deprecated since 8.0.0 Use `distanceField.range` instead.
         */
        get distanceFieldType() {
          deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
          return this.distanceField.type;
        }
        destroy(destroyTextures = false) {
          var _a2;
          this.emit("destroy", this);
          this.removeAllListeners();
          for (const i3 in this.chars) {
            (_a2 = this.chars[i3].texture) == null ? void 0 : _a2.destroy();
          }
          this.chars = null;
          if (destroyTextures) {
            this.pages.forEach((page) => page.texture.destroy(true));
            this.pages = null;
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs
  var _DynamicBitmapFont, DynamicBitmapFont;
  var init_DynamicBitmapFont = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs"() {
      init_Color();
      init_Rectangle();
      init_CanvasPool();
      init_ImageSource();
      init_Texture();
      init_TextureStyle();
      init_deprecation();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      init_TextStyle();
      init_AbstractBitmapFont();
      _DynamicBitmapFont = class _DynamicBitmapFont2 extends AbstractBitmapFont {
        /**
         * @param options - The options for the dynamic bitmap font.
         */
        constructor(options) {
          var _a2, _b, _c;
          super();
          this.resolution = 1;
          this.pages = [];
          this._padding = 0;
          this._measureCache = /* @__PURE__ */ Object.create(null);
          this._currentChars = [];
          this._currentX = 0;
          this._currentY = 0;
          this._currentMaxCharHeight = 0;
          this._currentPageIndex = -1;
          this._skipKerning = false;
          const dynamicOptions = __spreadValues(__spreadValues({}, _DynamicBitmapFont2.defaultOptions), options);
          this._textureSize = dynamicOptions.textureSize;
          this._mipmap = dynamicOptions.mipmap;
          const style = dynamicOptions.style.clone();
          if (dynamicOptions.overrideFill) {
            style._fill.color = 16777215;
            style._fill.alpha = 1;
            style._fill.texture = Texture.WHITE;
            style._fill.fill = null;
          }
          this.applyFillAsTint = dynamicOptions.overrideFill;
          const requestedFontSize = style.fontSize;
          style.fontSize = this.baseMeasurementFontSize;
          const font = fontStringFromTextStyle(style);
          if (dynamicOptions.overrideSize) {
            if (style._stroke) {
              style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
            }
          } else {
            style.fontSize = this.baseRenderedFontSize = requestedFontSize;
          }
          this._style = style;
          this._skipKerning = (_a2 = dynamicOptions.skipKerning) != null ? _a2 : false;
          this.resolution = (_b = dynamicOptions.resolution) != null ? _b : 1;
          this._padding = (_c = dynamicOptions.padding) != null ? _c : 4;
          if (dynamicOptions.textureStyle) {
            this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle ? dynamicOptions.textureStyle : new TextureStyle(dynamicOptions.textureStyle);
          }
          this.fontMetrics = CanvasTextMetrics.measureFont(font);
          this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
        }
        ensureCharacters(chars) {
          var _a2, _b, _c, _d;
          const charList = CanvasTextMetrics.graphemeSegmenter(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
          if (!charList.length)
            return;
          this._currentChars = [...this._currentChars, ...charList];
          let pageData;
          if (this._currentPageIndex === -1) {
            pageData = this._nextPage();
          } else {
            pageData = this.pages[this._currentPageIndex];
          }
          let { canvas, context: context4 } = pageData.canvasAndContext;
          let textureSource = pageData.texture.source;
          const style = this._style;
          let currentX = this._currentX;
          let currentY = this._currentY;
          let currentMaxCharHeight = this._currentMaxCharHeight;
          const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
          const padding = this._padding * fontScale;
          let skipTexture = false;
          const maxTextureWidth = canvas.width / this.resolution;
          const maxTextureHeight = canvas.height / this.resolution;
          for (let i3 = 0; i3 < charList.length; i3++) {
            const char = charList[i3];
            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);
            metrics.lineHeight = metrics.height;
            const width = metrics.width * fontScale;
            const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
            const height = metrics.height * fontScale;
            const paddedWidth = textureGlyphWidth + padding * 2;
            const paddedHeight = height + padding * 2;
            skipTexture = false;
            if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
              skipTexture = true;
              currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));
            }
            if (currentX + paddedWidth > maxTextureWidth) {
              currentY += currentMaxCharHeight;
              currentMaxCharHeight = paddedHeight;
              currentX = 0;
              if (currentY + currentMaxCharHeight > maxTextureHeight) {
                textureSource.update();
                const pageData2 = this._nextPage();
                canvas = pageData2.canvasAndContext.canvas;
                context4 = pageData2.canvasAndContext.context;
                textureSource = pageData2.texture.source;
                currentX = 0;
                currentY = 0;
                currentMaxCharHeight = 0;
              }
            }
            const xAdvance = width / fontScale - ((_b = (_a2 = style.dropShadow) == null ? void 0 : _a2.distance) != null ? _b : 0) - ((_d = (_c = style._stroke) == null ? void 0 : _c.width) != null ? _d : 0);
            this.chars[char] = {
              id: char.codePointAt(0),
              xOffset: -this._padding,
              yOffset: -this._padding,
              xAdvance,
              kerning: {}
            };
            if (skipTexture) {
              this._drawGlyph(
                context4,
                metrics,
                currentX + padding,
                currentY + padding,
                fontScale,
                style
              );
              const px = textureSource.width * fontScale;
              const py = textureSource.height * fontScale;
              const frame = new Rectangle(
                currentX / px * textureSource.width,
                currentY / py * textureSource.height,
                paddedWidth / px * textureSource.width,
                paddedHeight / py * textureSource.height
              );
              this.chars[char].texture = new Texture({
                source: textureSource,
                frame
              });
              currentX += Math.ceil(paddedWidth);
            }
          }
          textureSource.update();
          this._currentX = currentX;
          this._currentY = currentY;
          this._currentMaxCharHeight = currentMaxCharHeight;
          this._skipKerning && this._applyKerning(charList, context4);
        }
        /**
         * @deprecated since 8.0.0
         * The map of base page textures (i.e., sheets of glyphs).
         */
        get pageTextures() {
          deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        _applyKerning(newChars, context4) {
          const measureCache = this._measureCache;
          for (let i3 = 0; i3 < newChars.length; i3++) {
            const first = newChars[i3];
            for (let j2 = 0; j2 < this._currentChars.length; j2++) {
              const second = this._currentChars[j2];
              let c1 = measureCache[first];
              if (!c1)
                c1 = measureCache[first] = context4.measureText(first).width;
              let c2 = measureCache[second];
              if (!c2)
                c2 = measureCache[second] = context4.measureText(second).width;
              let total = context4.measureText(first + second).width;
              let amount = total - (c1 + c2);
              if (amount) {
                this.chars[first].kerning[second] = amount;
              }
              total = context4.measureText(first + second).width;
              amount = total - (c1 + c2);
              if (amount) {
                this.chars[second].kerning[first] = amount;
              }
            }
          }
        }
        _nextPage() {
          this._currentPageIndex++;
          const textureResolution = this.resolution;
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
            this._textureSize,
            this._textureSize,
            textureResolution
          );
          this._setupContext(canvasAndContext.context, this._style, textureResolution);
          const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
          const texture = new Texture({
            source: new ImageSource({
              resource: canvasAndContext.canvas,
              resolution,
              alphaMode: "premultiply-alpha-on-upload",
              autoGenerateMipmaps: this._mipmap
            })
          });
          if (this._textureStyle) {
            texture.source.style = this._textureStyle;
          }
          const pageData = {
            canvasAndContext,
            texture
          };
          this.pages[this._currentPageIndex] = pageData;
          return pageData;
        }
        // canvas style!
        _setupContext(context4, style, resolution) {
          var _a2;
          style.fontSize = this.baseRenderedFontSize;
          context4.scale(resolution, resolution);
          context4.font = fontStringFromTextStyle(style);
          style.fontSize = this.baseMeasurementFontSize;
          context4.textBaseline = style.textBaseline;
          const stroke = style._stroke;
          const strokeThickness = (_a2 = stroke == null ? void 0 : stroke.width) != null ? _a2 : 0;
          if (stroke) {
            context4.lineWidth = strokeThickness;
            context4.lineJoin = stroke.join;
            context4.miterLimit = stroke.miterLimit;
            context4.strokeStyle = getCanvasFillStyle(stroke, context4);
          }
          if (style._fill) {
            context4.fillStyle = getCanvasFillStyle(style._fill, context4);
          }
          if (style.dropShadow) {
            const shadowOptions = style.dropShadow;
            const rgb = Color.shared.setValue(shadowOptions.color).toArray();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context4.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
            context4.shadowBlur = dropShadowBlur;
            context4.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context4.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
          } else {
            context4.shadowColor = "black";
            context4.shadowBlur = 0;
            context4.shadowOffsetX = 0;
            context4.shadowOffsetY = 0;
          }
        }
        _drawGlyph(context4, metrics, x2, y2, fontScale, style) {
          var _a2;
          const char = metrics.text;
          const fontProperties = metrics.fontProperties;
          const stroke = style._stroke;
          const strokeThickness = ((_a2 = stroke == null ? void 0 : stroke.width) != null ? _a2 : 0) * fontScale;
          const tx = x2 + strokeThickness / 2;
          const ty = y2 - strokeThickness / 2;
          const descent = fontProperties.descent * fontScale;
          const lineHeight = metrics.lineHeight * fontScale;
          let removeShadow = false;
          if (style.stroke && strokeThickness) {
            removeShadow = true;
            context4.strokeText(char, tx, ty + lineHeight - descent);
          }
          const { shadowBlur, shadowOffsetX, shadowOffsetY } = context4;
          if (style._fill) {
            if (removeShadow) {
              context4.shadowBlur = 0;
              context4.shadowOffsetX = 0;
              context4.shadowOffsetY = 0;
            }
            context4.fillText(char, tx, ty + lineHeight - descent);
          }
          if (removeShadow) {
            context4.shadowBlur = shadowBlur;
            context4.shadowOffsetX = shadowOffsetX;
            context4.shadowOffsetY = shadowOffsetY;
          }
        }
        destroy() {
          super.destroy();
          for (let i3 = 0; i3 < this.pages.length; i3++) {
            const { canvasAndContext, texture } = this.pages[i3];
            CanvasPool.returnCanvasAndContext(canvasAndContext);
            texture.destroy(true);
          }
          this.pages = null;
        }
      };
      _DynamicBitmapFont.defaultOptions = {
        textureSize: 512,
        style: new TextStyle(),
        mipmap: true
      };
      DynamicBitmapFont = _DynamicBitmapFont;
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs
  function getBitmapTextLayout(chars, style, font, trimEnd) {
    const layoutData = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: style.fontSize / font.baseMeasurementFontSize,
      lines: [{
        width: 0,
        charPositions: [],
        spaceWidth: 0,
        spacesIndex: [],
        chars: []
      }]
    };
    layoutData.offsetY = font.baseLineOffset;
    let currentLine = layoutData.lines[0];
    let previousChar = null;
    let firstWord = true;
    const currentWord = {
      spaceWord: false,
      width: 0,
      start: 0,
      index: 0,
      // use index to not modify the array as we use it a lot!
      positions: [],
      chars: []
    };
    const scale = font.baseMeasurementFontSize / style.fontSize;
    const adjustedLetterSpacing = style.letterSpacing * scale;
    const adjustedWordWrapWidth = style.wordWrapWidth * scale;
    const adjustedLineHeight = style.lineHeight ? style.lineHeight * scale : font.lineHeight;
    const breakWords = style.wordWrap && style.breakWords;
    const nextWord = (word) => {
      const start = currentLine.width;
      for (let j2 = 0; j2 < currentWord.index; j2++) {
        const position = word.positions[j2];
        currentLine.chars.push(word.chars[j2]);
        currentLine.charPositions.push(position + start);
      }
      currentLine.width += word.width;
      firstWord = false;
      currentWord.width = 0;
      currentWord.index = 0;
      currentWord.chars.length = 0;
    };
    const nextLine = () => {
      let index = currentLine.chars.length - 1;
      if (trimEnd) {
        let lastChar = currentLine.chars[index];
        while (lastChar === " ") {
          currentLine.width -= font.chars[lastChar].xAdvance;
          lastChar = currentLine.chars[--index];
        }
      }
      layoutData.width = Math.max(layoutData.width, currentLine.width);
      currentLine = {
        width: 0,
        charPositions: [],
        chars: [],
        spaceWidth: 0,
        spacesIndex: []
      };
      firstWord = true;
      layoutData.lines.push(currentLine);
      layoutData.height += adjustedLineHeight;
    };
    const checkIsOverflow = (lineWidth) => lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;
    for (let i3 = 0; i3 < chars.length + 1; i3++) {
      let char;
      const isEnd = i3 === chars.length;
      if (!isEnd) {
        char = chars[i3];
      }
      const charData = font.chars[char] || font.chars[" "];
      const isSpace = /(?:\s)/.test(char);
      const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
      if (isWordBreak) {
        const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);
        if (addWordToNextLine) {
          nextLine();
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        } else {
          currentWord.start = currentLine.width;
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        }
        if (char === "\r" || char === "\n") {
          nextLine();
        } else if (!isEnd) {
          const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
          currentLine.width += spaceWidth;
          currentLine.spaceWidth = spaceWidth;
          currentLine.spacesIndex.push(currentLine.charPositions.length);
          currentLine.chars.push(char);
        }
      } else {
        const kerning = charData.kerning[previousChar] || 0;
        const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
        const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);
        if (addWordToNextLine) {
          nextWord(currentWord);
          nextLine();
        }
        currentWord.positions[currentWord.index++] = currentWord.width + kerning;
        currentWord.chars.push(char);
        currentWord.width += nextCharWidth;
      }
      previousChar = char;
    }
    nextLine();
    if (style.align === "center") {
      alignCenter(layoutData);
    } else if (style.align === "right") {
      alignRight(layoutData);
    } else if (style.align === "justify") {
      alignJustify(layoutData);
    }
    return layoutData;
  }
  function alignCenter(measurementData) {
    for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
      const line = measurementData.lines[i3];
      const offset = measurementData.width / 2 - line.width / 2;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignRight(measurementData) {
    for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
      const line = measurementData.lines[i3];
      const offset = measurementData.width - line.width;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignJustify(measurementData) {
    const width = measurementData.width;
    for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
      const line = measurementData.lines[i3];
      let indy = 0;
      let spaceIndex = line.spacesIndex[indy++];
      let offset = 0;
      const totalSpaces = line.spacesIndex.length;
      const newSpaceWidth = (width - line.width) / totalSpaces;
      const spaceWidth = newSpaceWidth;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        if (j2 === spaceIndex) {
          spaceIndex = line.spacesIndex[indy++];
          offset += spaceWidth;
        }
        line.charPositions[j2] += offset;
      }
    }
  }
  var init_getBitmapTextLayout = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs
  function resolveCharacters(chars) {
    if (chars === "") {
      return [];
    }
    if (typeof chars === "string") {
      chars = [chars];
    }
    const result = [];
    for (let i3 = 0, j2 = chars.length; i3 < j2; i3++) {
      const item = chars[i3];
      if (Array.isArray(item)) {
        if (item.length !== 2) {
          throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
        }
        if (item[0].length === 0 || item[1].length === 0) {
          throw new Error("[BitmapFont]: Invalid character delimiter.");
        }
        const startCode = item[0].charCodeAt(0);
        const endCode = item[1].charCodeAt(0);
        if (endCode < startCode) {
          throw new Error("[BitmapFont]: Invalid character range.");
        }
        for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
          result.push(String.fromCharCode(i22));
        }
      } else {
        result.push(...Array.from(item));
      }
    }
    if (result.length === 0) {
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result;
  }
  var init_resolveCharacters = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs
  var fontCount, BitmapFontManagerClass, BitmapFontManager;
  var init_BitmapFontManager = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs"() {
      init_tiny_lru();
      init_Cache();
      init_deprecation();
      init_warn();
      init_CanvasTextMetrics();
      init_TextStyle();
      init_DynamicBitmapFont();
      init_getBitmapTextLayout();
      init_resolveCharacters();
      fontCount = 0;
      BitmapFontManagerClass = class {
        constructor() {
          this.ALPHA = [["a", "z"], ["A", "Z"], " "];
          this.NUMERIC = [["0", "9"]];
          this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
          this.ASCII = [[" ", "~"]];
          this.defaultOptions = {
            chars: this.ALPHANUMERIC,
            resolution: 1,
            padding: 4,
            skipKerning: false,
            textureStyle: null
          };
          this.measureCache = lru(1e3);
        }
        /**
         * Get a font for the specified text and style.
         * @param text - The text to get the font for
         * @param style - The style to use
         */
        getFont(text, style) {
          var _a2;
          let fontFamilyKey = `${style.fontFamily}-bitmap`;
          let overrideFill = true;
          if (style._fill.fill && !style._stroke) {
            fontFamilyKey += style._fill.fill.styleKey;
            overrideFill = false;
          } else if (style._stroke || style.dropShadow) {
            fontFamilyKey = `${style.styleKey}-bitmap`;
            overrideFill = false;
          }
          if (!Cache.has(fontFamilyKey)) {
            const styleCopy = Object.create(style);
            styleCopy.lineHeight = 0;
            const fnt = new DynamicBitmapFont(__spreadValues({
              style: styleCopy,
              overrideFill,
              overrideSize: true
            }, this.defaultOptions));
            fontCount++;
            if (fontCount > 50) {
              warn("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
            }
            fnt.once("destroy", () => {
              fontCount--;
              Cache.remove(fontFamilyKey);
            });
            Cache.set(
              fontFamilyKey,
              fnt
            );
          }
          const dynamicFont = Cache.get(fontFamilyKey);
          (_a2 = dynamicFont.ensureCharacters) == null ? void 0 : _a2.call(dynamicFont, text);
          return dynamicFont;
        }
        /**
         * Get the layout of a text for the specified style.
         * @param text - The text to get the layout for
         * @param style - The style to use
         * @param trimEnd - Whether to ignore whitespaces at the end of each line
         */
        getLayout(text, style, trimEnd = true) {
          const bitmapFont = this.getFont(text, style);
          const id = `${text}-${style.styleKey}-${trimEnd}`;
          if (this.measureCache.has(id)) {
            return this.measureCache.get(id);
          }
          const segments = CanvasTextMetrics.graphemeSegmenter(text);
          const layoutData = getBitmapTextLayout(segments, style, bitmapFont, trimEnd);
          this.measureCache.set(id, layoutData);
          return layoutData;
        }
        /**
         * Measure the text using the specified style.
         * @param text - The text to measure
         * @param style - The style to use
         * @param trimEnd - Whether to ignore whitespaces at the end of each line
         */
        measureText(text, style, trimEnd = true) {
          return this.getLayout(text, style, trimEnd);
        }
        // eslint-disable-next-line max-len
        install(...args) {
          var _a2, _b, _c, _d, _e;
          let options = args[0];
          if (typeof options === "string") {
            options = {
              name: options,
              style: args[1],
              chars: (_a2 = args[2]) == null ? void 0 : _a2.chars,
              resolution: (_b = args[2]) == null ? void 0 : _b.resolution,
              padding: (_c = args[2]) == null ? void 0 : _c.padding,
              skipKerning: (_d = args[2]) == null ? void 0 : _d.skipKerning
            };
            deprecation(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
          }
          const name = options == null ? void 0 : options.name;
          if (!name) {
            throw new Error("[BitmapFontManager] Property `name` is required.");
          }
          options = __spreadValues(__spreadValues({}, this.defaultOptions), options);
          const textStyle = options.style;
          const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
          const overrideFill = (_e = options.dynamicFill) != null ? _e : this._canUseTintForStyle(style);
          const font = new DynamicBitmapFont({
            style,
            overrideFill,
            skipKerning: options.skipKerning,
            padding: options.padding,
            resolution: options.resolution,
            overrideSize: false,
            textureStyle: options.textureStyle
          });
          const flatChars = resolveCharacters(options.chars);
          font.ensureCharacters(flatChars.join(""));
          Cache.set(`${name}-bitmap`, font);
          font.once("destroy", () => Cache.remove(`${name}-bitmap`));
          return font;
        }
        /**
         * Uninstalls a bitmap font from the cache.
         * @param {string} name - The name of the bitmap font to uninstall.
         */
        uninstall(name) {
          const cacheKey = `${name}-bitmap`;
          const font = Cache.get(cacheKey);
          if (font) {
            font.destroy();
          }
        }
        /**
         * Determines if a style can use tinting instead of baking colors into the bitmap.
         * Tinting is more efficient as it allows reusing the same bitmap with different colors.
         * @param style - The text style to evaluate
         * @returns true if the style can use tinting, false if colors must be baked in
         * @private
         */
        _canUseTintForStyle(style) {
          return !style._stroke && (!style.dropShadow || style.dropShadow.color === 0) && !style._fill.fill && style._fill.color === 16777215;
        }
      };
      BitmapFontManager = new BitmapFontManagerClass();
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs
  function syncWithProxy(container, proxy) {
    proxy.groupTransform = container.groupTransform;
    proxy.groupColorAlpha = container.groupColorAlpha;
    proxy.groupColor = container.groupColor;
    proxy.groupBlendMode = container.groupBlendMode;
    proxy.globalDisplayStatus = container.globalDisplayStatus;
    proxy.groupTransform = container.groupTransform;
    proxy.localDisplayStatus = container.localDisplayStatus;
    proxy.groupAlpha = container.groupAlpha;
    proxy._roundPixels = container._roundPixels;
  }
  var BitmapTextGraphics, BitmapTextPipe;
  var init_BitmapTextPipe = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs"() {
      init_Cache();
      init_Extensions();
      init_GCManagedHash();
      init_Graphics();
      init_CanvasTextMetrics();
      init_SdfShader();
      init_BitmapFontManager();
      init_getBitmapTextLayout();
      BitmapTextGraphics = class extends Graphics {
        destroy() {
          if (this.context.customShader) {
            this.context.customShader.destroy();
          }
          super.destroy();
        }
      };
      BitmapTextPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
          this._managedBitmapTexts = new GCManagedHash({ renderer, type: "renderable", priority: -2, name: "bitmapText" });
        }
        validateRenderable(bitmapText) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
        }
        addRenderable(bitmapText, instructionSet) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          syncWithProxy(bitmapText, graphicsRenderable);
          if (bitmapText._didTextUpdate) {
            bitmapText._didTextUpdate = false;
            this._updateContext(bitmapText, graphicsRenderable);
          }
          this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
          if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
          }
        }
        updateRenderable(bitmapText) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          syncWithProxy(bitmapText, graphicsRenderable);
          this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
          if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
          }
        }
        _updateContext(bitmapText, proxyGraphics) {
          const { context: context4 } = proxyGraphics;
          const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
          context4.clear();
          if (bitmapFont.distanceField.type !== "none") {
            if (!context4.customShader) {
              context4.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);
            }
          }
          const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);
          const style = bitmapText._style;
          let currentY = bitmapFont.baseLineOffset;
          const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);
          const padding = style.padding;
          const scale = bitmapTextLayout.scale;
          let tx = bitmapTextLayout.width;
          let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
          if (style._stroke) {
            tx += style._stroke.width / scale;
            ty += style._stroke.width / scale;
          }
          context4.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
          const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
          let fontSize = bitmapFont.fontMetrics.fontSize;
          let lineHeight = bitmapFont.lineHeight;
          if (style.lineHeight) {
            fontSize = style.fontSize / scale;
            lineHeight = style.lineHeight / scale;
          }
          let linePositionYShift = (lineHeight - fontSize) / 2;
          if (linePositionYShift - bitmapFont.baseLineOffset < 0) {
            linePositionYShift = 0;
          }
          for (let i3 = 0; i3 < bitmapTextLayout.lines.length; i3++) {
            const line = bitmapTextLayout.lines[i3];
            for (let j2 = 0; j2 < line.charPositions.length; j2++) {
              const char = line.chars[j2];
              const charData = bitmapFont.chars[char];
              if (charData == null ? void 0 : charData.texture) {
                const texture = charData.texture;
                context4.texture(
                  texture,
                  tint ? tint : "black",
                  Math.round(line.charPositions[j2] + charData.xOffset),
                  Math.round(currentY + charData.yOffset + linePositionYShift),
                  texture.orig.width,
                  texture.orig.height
                );
              }
            }
            currentY += lineHeight;
          }
        }
        _getGpuBitmapText(bitmapText) {
          return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);
        }
        initGpuText(bitmapText) {
          const proxyRenderable = new BitmapTextGraphics();
          bitmapText._gpuData[this._renderer.uid] = proxyRenderable;
          this._updateContext(bitmapText, proxyRenderable);
          this._managedBitmapTexts.add(bitmapText);
          return proxyRenderable;
        }
        _updateDistanceField(bitmapText) {
          const context4 = this._getGpuBitmapText(bitmapText).context;
          const fontFamily = bitmapText._style.fontFamily;
          const dynamicFont = Cache.get(`${fontFamily}-bitmap`);
          const { a: a2, b: b2, c: c2, d: d2 } = bitmapText.groupTransform;
          const dx = Math.sqrt(a2 * a2 + b2 * b2);
          const dy = Math.sqrt(c2 * c2 + d2 * d2);
          const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
          const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
          const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
          context4.customShader.resources.localUniforms.uniforms.uDistance = distance;
        }
        destroy() {
          this._managedBitmapTexts.destroy();
          this._renderer = null;
          this._managedBitmapTexts = null;
        }
      };
      BitmapTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "bitmapText"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/init.mjs
  var init_init11 = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/init.mjs"() {
      init_Extensions();
      init_BitmapTextPipe();
      extensions.add(BitmapTextPipe);
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs
  var BatchableHTMLText;
  var init_BatchableHTMLText = __esm({
    "node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs"() {
      init_BatchableSprite();
      BatchableHTMLText = class extends BatchableSprite {
        constructor() {
          super(...arguments);
          this.generatingTexture = false;
          this.currentKey = "--";
        }
        /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */
        destroy() {
          this.texturePromise = null;
          this.generatingTexture = false;
          this.currentKey = "--";
          super.destroy();
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs
  var HTMLTextPipe;
  var init_HTMLTextPipe = __esm({
    "node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs"() {
      init_Extensions();
      init_Texture();
      init_GCManagedHash();
      init_updateTextBounds();
      init_BatchableHTMLText();
      HTMLTextPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
          renderer.runners.resolutionChange.add(this);
          this._managedTexts = new GCManagedHash({
            renderer,
            type: "renderable",
            onUnload: this.onTextUnload.bind(this),
            name: "htmlText"
          });
        }
        resolutionChange() {
          for (const key in this._managedTexts.items) {
            const text = this._managedTexts.items[key];
            if (text == null ? void 0 : text._autoResolution) {
              text.onViewUpdate();
            }
          }
        }
        validateRenderable(htmlText) {
          const gpuText = this._getGpuText(htmlText);
          const newKey = htmlText.styleKey;
          if (gpuText.currentKey !== newKey) {
            return true;
          }
          return false;
        }
        addRenderable(htmlText, instructionSet) {
          const batchableHTMLText = this._getGpuText(htmlText);
          if (htmlText._didTextUpdate) {
            const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
            if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution) {
              this._updateGpuText(htmlText).catch((e2) => {
                console.error(e2);
              });
            }
            htmlText._didTextUpdate = false;
            updateTextBounds(batchableHTMLText, htmlText);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);
        }
        updateRenderable(htmlText) {
          const batchableHTMLText = this._getGpuText(htmlText);
          batchableHTMLText._batcher.updateElement(batchableHTMLText);
        }
        _updateGpuText(htmlText) {
          return __async(this, null, function* () {
            htmlText._didTextUpdate = false;
            const batchableHTMLText = this._getGpuText(htmlText);
            if (batchableHTMLText.generatingTexture)
              return;
            const oldTexturePromise = batchableHTMLText.texturePromise;
            batchableHTMLText.texturePromise = null;
            batchableHTMLText.generatingTexture = true;
            htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
            let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);
            if (oldTexturePromise) {
              texturePromise = texturePromise.finally(() => {
                this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);
                this._renderer.htmlText.returnTexturePromise(oldTexturePromise);
              });
            }
            batchableHTMLText.texturePromise = texturePromise;
            batchableHTMLText.currentKey = htmlText.styleKey;
            batchableHTMLText.texture = yield texturePromise;
            const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;
            if (renderGroup) {
              renderGroup.structureDidChange = true;
            }
            batchableHTMLText.generatingTexture = false;
            updateTextBounds(batchableHTMLText, htmlText);
          });
        }
        _getGpuText(htmlText) {
          return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);
        }
        initGpuText(htmlText) {
          const batchableHTMLText = new BatchableHTMLText();
          batchableHTMLText.renderable = htmlText;
          batchableHTMLText.transform = htmlText.groupTransform;
          batchableHTMLText.texture = Texture.EMPTY;
          batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
          htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
          htmlText._gpuData[this._renderer.uid] = batchableHTMLText;
          this._managedTexts.add(htmlText);
          return batchableHTMLText;
        }
        onTextUnload(text) {
          const gpuData = text._gpuData[this._renderer.uid];
          if (!gpuData)
            return;
          const { htmlText } = this._renderer;
          htmlText.getReferenceCount(gpuData.currentKey) === null ? htmlText.returnTexturePromise(gpuData.texturePromise) : htmlText.decreaseReferenceCount(gpuData.currentKey);
        }
        destroy() {
          this._managedTexts.destroy();
          this._renderer = null;
        }
      };
      HTMLTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "htmlText"
      };
    }
  });

  // node_modules/pixi.js/lib/utils/browser/isSafari.mjs
  function isSafari() {
    const { userAgent } = DOMAdapter.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  var init_isSafari = __esm({
    "node_modules/pixi.js/lib/utils/browser/isSafari.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs
  var nssvg, nsxhtml, HTMLTextRenderData;
  var init_HTMLTextRenderData = __esm({
    "node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs"() {
      init_adapter();
      nssvg = "http://www.w3.org/2000/svg";
      nsxhtml = "http://www.w3.org/1999/xhtml";
      HTMLTextRenderData = class {
        constructor() {
          this.svgRoot = document.createElementNS(nssvg, "svg");
          this.foreignObject = document.createElementNS(nssvg, "foreignObject");
          this.domElement = document.createElementNS(nsxhtml, "div");
          this.styleElement = document.createElementNS(nsxhtml, "style");
          const { foreignObject, svgRoot, styleElement, domElement } = this;
          foreignObject.setAttribute("width", "10000");
          foreignObject.setAttribute("height", "10000");
          foreignObject.style.overflow = "hidden";
          svgRoot.appendChild(foreignObject);
          foreignObject.appendChild(styleElement);
          foreignObject.appendChild(domElement);
          this.image = DOMAdapter.get().createImage();
        }
        destroy() {
          this.svgRoot.remove();
          this.foreignObject.remove();
          this.styleElement.remove();
          this.domElement.remove();
          this.image.src = "";
          this.image.remove();
          this.svgRoot = null;
          this.foreignObject = null;
          this.styleElement = null;
          this.domElement = null;
          this.image = null;
          this.canvasAndContext = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs
  function extractFontFamilies(text, style) {
    const fontFamily = style.fontFamily;
    const fontFamilies = [];
    const dedupe = {};
    const regex = /font-family:([^;"\s]+)/g;
    const matches = text.match(regex);
    function addFontFamily(fontFamily2) {
      if (!dedupe[fontFamily2]) {
        fontFamilies.push(fontFamily2);
        dedupe[fontFamily2] = true;
      }
    }
    if (Array.isArray(fontFamily)) {
      for (let i3 = 0; i3 < fontFamily.length; i3++) {
        addFontFamily(fontFamily[i3]);
      }
    } else {
      addFontFamily(fontFamily);
    }
    if (matches) {
      matches.forEach((match) => {
        const fontFamily2 = match.split(":")[1].trim();
        addFontFamily(fontFamily2);
      });
    }
    for (const i3 in style.tagStyles) {
      const fontFamily2 = style.tagStyles[i3].fontFamily;
      addFontFamily(fontFamily2);
    }
    return fontFamilies;
  }
  var init_extractFontFamilies = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs
  function loadFontAsBase64(url) {
    return __async(this, null, function* () {
      const response = yield DOMAdapter.get().fetch(url);
      const blob = yield response.blob();
      const reader = new FileReader();
      const dataSrc = yield new Promise((resolve, reject) => {
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
      return dataSrc;
    });
  }
  var init_loadFontAsBase64 = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs
  function loadFontCSS(style, url) {
    return __async(this, null, function* () {
      const dataSrc = yield loadFontAsBase64(url);
      return `@font-face {
        font-family: "${style.fontFamily}";
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
        src: url('${dataSrc}');
    }`;
    });
  }
  var init_loadFontCSS = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs"() {
      init_loadFontAsBase64();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs
  function getFontCss(fontFamilies) {
    return __async(this, null, function* () {
      const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily) => {
        if (!FontStylePromiseCache.has(fontFamily)) {
          const { entries } = Cache.get(`${fontFamily}-and-url`);
          const promises = [];
          entries.forEach((entry) => {
            const url = entry.url;
            const faces = entry.faces;
            const out2 = faces.map((face) => ({ weight: face.weight, style: face.style }));
            promises.push(
              ...out2.map(
                (style) => loadFontCSS(
                  {
                    fontWeight: style.weight,
                    fontStyle: style.style,
                    fontFamily
                  },
                  url
                )
              )
            );
          });
          FontStylePromiseCache.set(
            fontFamily,
            Promise.all(promises).then((css) => css.join("\n"))
          );
        }
        return FontStylePromiseCache.get(fontFamily);
      });
      return (yield Promise.all(fontPromises)).join("\n");
    });
  }
  var FontStylePromiseCache;
  var init_getFontCss = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs"() {
      init_Cache();
      init_loadFontCSS();
      FontStylePromiseCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs
  function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
    const { domElement, styleElement, svgRoot } = htmlTextData;
    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;
    domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
    styleElement.textContent = fontCSS;
    const { width, height } = htmlTextData.image;
    svgRoot.setAttribute("width", width.toString());
    svgRoot.setAttribute("height", height.toString());
    return new XMLSerializer().serializeToString(svgRoot);
  }
  var init_getSVGUrl = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs
  function getTemporaryCanvasFromImage(image, resolution) {
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
      image.width,
      image.height,
      resolution
    );
    const { context: context4 } = canvasAndContext;
    context4.clearRect(0, 0, image.width, image.height);
    context4.drawImage(image, 0, 0);
    return canvasAndContext;
  }
  var init_getTemporaryCanvasFromImage = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs"() {
      init_CanvasPool();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs
  function loadSVGImage(image, url, delay) {
    return new Promise((resolve) => __async(null, null, function* () {
      if (delay) {
        yield new Promise((resolve2) => setTimeout(resolve2, 100));
      }
      image.onload = () => {
        resolve();
      };
      image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
      image.crossOrigin = "anonymous";
    }));
  }
  var init_loadSVGImage = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs
  function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
    htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData()));
    const { domElement, styleElement, svgRoot } = htmlTextRenderData;
    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;
    domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
    if (fontStyleCSS) {
      styleElement.textContent = fontStyleCSS;
    }
    document.body.appendChild(svgRoot);
    const contentBounds = domElement.getBoundingClientRect();
    svgRoot.remove();
    const doublePadding = style.padding * 2;
    return {
      width: contentBounds.width - doublePadding,
      height: contentBounds.height - doublePadding
    };
  }
  var tempHTMLTextRenderData;
  var init_measureHtmlText = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs"() {
      init_HTMLTextRenderData();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs
  var HTMLTextSystem;
  var init_HTMLTextSystem = __esm({
    "node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs"() {
      init_Extensions();
      init_CanvasPool();
      init_TexturePool();
      init_types2();
      init_isSafari();
      init_warn();
      init_PoolGroup();
      init_getPo2TextureFromSource();
      init_HTMLTextRenderData();
      init_extractFontFamilies();
      init_getFontCss();
      init_getSVGUrl();
      init_getTemporaryCanvasFromImage();
      init_loadSVGImage();
      init_measureHtmlText();
      HTMLTextSystem = class {
        constructor(renderer) {
          this._activeTextures = {};
          this._renderer = renderer;
          this._createCanvas = renderer.type === RendererType.WEBGPU;
        }
        /**
         * @param options
         * @deprecated Use getTexturePromise instead
         */
        getTexture(options) {
          return this.getTexturePromise(options);
        }
        /**
         * Increases the reference count for a texture.
         * @param text - The HTMLText instance associated with the texture.
         */
        getManagedTexture(text) {
          const textKey = text.styleKey;
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].promise;
          }
          const promise2 = this._buildTexturePromise(text).then((texture) => {
            this._activeTextures[textKey].texture = texture;
            return texture;
          });
          this._activeTextures[textKey] = {
            texture: null,
            promise: promise2,
            usageCount: 1
          };
          return promise2;
        }
        /**
         * Gets the current reference count for a texture associated with a text key.
         * @param textKey - The unique key identifying the text style configuration
         * @returns The number of Text instances currently using this texture
         */
        getReferenceCount(textKey) {
          var _a2, _b;
          return (_b = (_a2 = this._activeTextures[textKey]) == null ? void 0 : _a2.usageCount) != null ? _b : null;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        /**
         * Decreases the reference count for a texture.
         * If the count reaches zero, the texture is cleaned up.
         * @param textKey - The key associated with the HTMLText instance.
         */
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          if (!activeTexture)
            return;
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            if (activeTexture.texture) {
              this._cleanUp(activeTexture.texture);
            } else {
              activeTexture.promise.then((texture) => {
                activeTexture.texture = texture;
                this._cleanUp(activeTexture.texture);
              }).catch(() => {
                warn("HTMLTextSystem: Failed to clean texture");
              });
            }
            this._activeTextures[textKey] = null;
          }
        }
        /**
         * Returns a promise that resolves to a texture for the given HTMLText options.
         * @param options - The options for the HTMLText.
         * @returns A promise that resolves to a Texture.
         */
        getTexturePromise(options) {
          return this._buildTexturePromise(options);
        }
        _buildTexturePromise(options) {
          return __async(this, null, function* () {
            const { text, style, resolution, textureStyle } = options;
            const htmlTextData = BigPool.get(HTMLTextRenderData);
            const fontFamilies = extractFontFamilies(text, style);
            const fontCSS = yield getFontCss(fontFamilies);
            const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
            const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
            const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
            const image = htmlTextData.image;
            const uvSafeOffset = 2;
            image.width = (width | 0) + uvSafeOffset;
            image.height = (height | 0) + uvSafeOffset;
            const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
            yield loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
            const resource = image;
            let canvasAndContext;
            if (this._createCanvas) {
              canvasAndContext = getTemporaryCanvasFromImage(image, resolution);
            }
            const texture = getPo2TextureFromSource(
              canvasAndContext ? canvasAndContext.canvas : resource,
              image.width - uvSafeOffset,
              image.height - uvSafeOffset,
              resolution
            );
            if (textureStyle)
              texture.source.style = textureStyle;
            if (this._createCanvas) {
              this._renderer.texture.initSource(texture.source);
              CanvasPool.returnCanvasAndContext(canvasAndContext);
            }
            BigPool.return(htmlTextData);
            return texture;
          });
        }
        returnTexturePromise(texturePromise) {
          texturePromise.then((texture) => {
            this._cleanUp(texture);
          }).catch(() => {
            warn("HTMLTextSystem: Failed to clean texture");
          });
        }
        _cleanUp(texture) {
          TexturePool.returnTexture(texture, true);
          texture.source.resource = null;
          texture.source.uploadMethodId = "unknown";
        }
        destroy() {
          this._renderer = null;
          for (const key in this._activeTextures) {
            if (this._activeTextures[key])
              this.returnTexturePromise(this._activeTextures[key].promise);
          }
          this._activeTextures = null;
        }
      };
      HTMLTextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "htmlText"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/init.mjs
  var init_init12 = __esm({
    "node_modules/pixi.js/lib/scene/text-html/init.mjs"() {
      init_Extensions();
      init_HTMLTextPipe();
      init_HTMLTextSystem();
      extensions.add(HTMLTextSystem);
      extensions.add(HTMLTextPipe);
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
  var _MeshGeometry, MeshGeometry;
  var init_MeshGeometry = __esm({
    "node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"() {
      init_Buffer();
      init_const4();
      init_Geometry();
      init_deprecation();
      _MeshGeometry = class _MeshGeometry2 extends Geometry {
        constructor(...args) {
          var _a2;
          let options = (_a2 = args[0]) != null ? _a2 : {};
          if (options instanceof Float32Array) {
            deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
            options = {
              positions: options,
              uvs: args[1],
              indices: args[2]
            };
          }
          options = __spreadValues(__spreadValues({}, _MeshGeometry2.defaultOptions), options);
          const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          let uvs = options.uvs;
          if (!uvs) {
            if (options.positions) {
              uvs = new Float32Array(positions.length);
            } else {
              uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
            }
          }
          const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
          const shrinkToFit = options.shrinkBuffersToFit;
          const positionBuffer = new Buffer2({
            data: positions,
            label: "attribute-mesh-positions",
            shrinkToFit,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const uvBuffer = new Buffer2({
            data: uvs,
            label: "attribute-mesh-uvs",
            shrinkToFit,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const indexBuffer = new Buffer2({
            data: indices,
            label: "index-mesh-buffer",
            shrinkToFit,
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST
          });
          super({
            attributes: {
              aPosition: {
                buffer: positionBuffer,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              },
              aUV: {
                buffer: uvBuffer,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              }
            },
            indexBuffer,
            topology: options.topology
          });
          this.batchMode = "auto";
        }
        /** The positions of the mesh. */
        get positions() {
          return this.attributes.aPosition.buffer.data;
        }
        /**
         * Set the positions of the mesh.
         * When setting the positions, its important that the uvs array is at least as long as the positions array.
         * otherwise the geometry will not be valid.
         * @param {Float32Array} value - The positions of the mesh.
         */
        set positions(value) {
          this.attributes.aPosition.buffer.data = value;
        }
        /** The UVs of the mesh. */
        get uvs() {
          return this.attributes.aUV.buffer.data;
        }
        /**
         * Set the UVs of the mesh.
         * Its important that the uvs array you set is at least as long as the positions array.
         * otherwise the geometry will not be valid.
         * @param {Float32Array} value - The UVs of the mesh.
         */
        set uvs(value) {
          this.attributes.aUV.buffer.data = value;
        }
        /** The indices of the mesh. */
        get indices() {
          return this.indexBuffer.data;
        }
        set indices(value) {
          this.indexBuffer.data = value;
        }
      };
      _MeshGeometry.defaultOptions = {
        topology: "triangle-list",
        shrinkBuffersToFit: false
      };
      MeshGeometry = _MeshGeometry;
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
  var localUniformBit, localUniformBitGroup2, localUniformBitGl;
  var init_localUniformBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
      "use strict";
      localUniformBit = {
        name: "local-uniform-bit",
        vertex: {
          header: (
            /* wgsl */
            `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
          ),
          end: (
            /* wgsl */
            `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
          )
        }
      };
      localUniformBitGroup2 = __spreadProps(__spreadValues({}, localUniformBit), {
        vertex: __spreadProps(__spreadValues({}, localUniformBit.vertex), {
          // replace the group!
          header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
        })
      });
      localUniformBitGl = {
        name: "local-uniform-bit",
        vertex: {
          header: (
            /* glsl */
            `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
          ),
          end: (
            /* glsl */
            `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
  var tilingBit, tilingBitGl;
  var init_tilingBit = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
      "use strict";
      tilingBit = {
        name: "tiling-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
          ),
          main: (
            /* wgsl */
            `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
          ),
          main: (
            /* wgsl */
            `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
          )
        }
      };
      tilingBitGl = {
        name: "tiling-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `
          ),
          main: (
            /* glsl */
            `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
          ),
          main: (
            /* glsl */
            `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
  var gpuProgram2, glProgram2, TilingSpriteShader;
  var init_TilingSpriteShader = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader();
      init_UniformGroup();
      init_Texture();
      init_tilingBit();
      TilingSpriteShader = class extends Shader {
        constructor() {
          gpuProgram2 != null ? gpuProgram2 : gpuProgram2 = compileHighShaderGpuProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBit,
              tilingBit,
              roundPixelsBit
            ]
          });
          glProgram2 != null ? glProgram2 : glProgram2 = compileHighShaderGlProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBitGl,
              tilingBitGl,
              roundPixelsBitGl
            ]
          });
          const tilingUniforms = new UniformGroup({
            uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
            uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
            uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
          });
          super({
            glProgram: glProgram2,
            gpuProgram: gpuProgram2,
            resources: {
              localUniforms: new UniformGroup({
                uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
                uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
                uRound: { value: 0, type: "f32" }
              }),
              tilingUniforms,
              uTexture: Texture.EMPTY.source,
              uSampler: Texture.EMPTY.source.style
            }
          });
        }
        updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
          const tilingUniforms = this.resources.tilingUniforms;
          const textureWidth = texture.width;
          const textureHeight = texture.height;
          const textureMatrix = texture.textureMatrix;
          const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
          uTextureTransform.set(
            matrix.a * textureWidth / width,
            matrix.b * textureWidth / height,
            matrix.c * textureHeight / width,
            matrix.d * textureHeight / height,
            matrix.tx / width,
            matrix.ty / height
          );
          uTextureTransform.invert();
          tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
          tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
          tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
          tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
          tilingUniforms.uniforms.uSizeAnchor[0] = width;
          tilingUniforms.uniforms.uSizeAnchor[1] = height;
          tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
          tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
          if (texture) {
            this.resources.uTexture = texture.source;
            this.resources.uSampler = texture.source.style;
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs
  var QuadGeometry;
  var init_QuadGeometry = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs"() {
      init_MeshGeometry();
      QuadGeometry = class extends MeshGeometry {
        constructor() {
          super({
            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            indices: new Uint32Array([0, 1, 2, 0, 2, 3])
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs
  function setPositions(tilingSprite, positions) {
    const anchorX = tilingSprite.anchor.x;
    const anchorY = tilingSprite.anchor.y;
    positions[0] = -anchorX * tilingSprite.width;
    positions[1] = -anchorY * tilingSprite.height;
    positions[2] = (1 - anchorX) * tilingSprite.width;
    positions[3] = -anchorY * tilingSprite.height;
    positions[4] = (1 - anchorX) * tilingSprite.width;
    positions[5] = (1 - anchorY) * tilingSprite.height;
    positions[6] = -anchorX * tilingSprite.width;
    positions[7] = (1 - anchorY) * tilingSprite.height;
  }
  var init_setPositions = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs
  function applyMatrix(array, stride, offset, matrix) {
    let index = 0;
    const size = array.length / (stride || 2);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    offset *= stride;
    while (index < size) {
      const x2 = array[offset];
      const y2 = array[offset + 1];
      array[offset] = a2 * x2 + c2 * y2 + tx;
      array[offset + 1] = b2 * x2 + d2 * y2 + ty;
      offset += stride;
      index++;
    }
  }
  var init_applyMatrix = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs
  function setUvs(tilingSprite, uvs) {
    const texture = tilingSprite.texture;
    const width = texture.frame.width;
    const height = texture.frame.height;
    let anchorX = 0;
    let anchorY = 0;
    if (tilingSprite.applyAnchorToTexture) {
      anchorX = tilingSprite.anchor.x;
      anchorY = tilingSprite.anchor.y;
    }
    uvs[0] = uvs[6] = -anchorX;
    uvs[2] = uvs[4] = 1 - anchorX;
    uvs[1] = uvs[3] = -anchorY;
    uvs[5] = uvs[7] = 1 - anchorY;
    const textureMatrix = Matrix.shared;
    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
    textureMatrix.tx /= tilingSprite.width;
    textureMatrix.ty /= tilingSprite.height;
    textureMatrix.invert();
    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
    applyMatrix(uvs, 2, 0, textureMatrix);
  }
  var init_setUvs = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs"() {
      init_Matrix();
      init_applyMatrix();
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
  var sharedQuad, TilingSpriteGpuData, TilingSpritePipe;
  var init_TilingSpritePipe = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
      init_Extensions();
      init_getAdjustedBlendModeBlend();
      init_State();
      init_types2();
      init_GCManagedHash();
      init_colorToUniform();
      init_BatchableMesh();
      init_MeshGeometry();
      init_TilingSpriteShader();
      init_QuadGeometry();
      init_setPositions();
      init_setUvs();
      sharedQuad = new QuadGeometry();
      TilingSpriteGpuData = class {
        constructor() {
          this.canBatch = true;
          this.geometry = new MeshGeometry({
            indices: sharedQuad.indices.slice(),
            positions: sharedQuad.positions.slice(),
            uvs: sharedQuad.uvs.slice()
          });
        }
        destroy() {
          var _a2;
          this.geometry.destroy();
          (_a2 = this.shader) == null ? void 0 : _a2.destroy();
        }
      };
      TilingSpritePipe = class {
        constructor(renderer) {
          this._state = State.default2d;
          this._renderer = renderer;
          this._managedTilingSprites = new GCManagedHash({ renderer, type: "renderable", name: "tilingSprite" });
        }
        validateRenderable(renderable) {
          const tilingSpriteData = this._getTilingSpriteData(renderable);
          const couldBatch = tilingSpriteData.canBatch;
          this._updateCanBatch(renderable);
          const canBatch = tilingSpriteData.canBatch;
          if (canBatch && canBatch === couldBatch) {
            const { batchableMesh } = tilingSpriteData;
            return !batchableMesh._batcher.checkAndUpdateTexture(
              batchableMesh,
              renderable.texture
            );
          }
          return couldBatch !== canBatch;
        }
        addRenderable(tilingSprite, instructionSet) {
          const batcher = this._renderer.renderPipes.batch;
          this._updateCanBatch(tilingSprite);
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          const { geometry, canBatch } = tilingSpriteData;
          if (canBatch) {
            tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());
            const batchableMesh = tilingSpriteData.batchableMesh;
            if (tilingSprite.didViewUpdate) {
              this._updateBatchableMesh(tilingSprite);
              batchableMesh.geometry = geometry;
              batchableMesh.renderable = tilingSprite;
              batchableMesh.transform = tilingSprite.groupTransform;
              batchableMesh.setTexture(tilingSprite._texture);
            }
            batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
            batcher.addToBatch(batchableMesh, instructionSet);
          } else {
            batcher.break(instructionSet);
            tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());
            this.updateRenderable(tilingSprite);
            instructionSet.add(tilingSprite);
          }
        }
        execute(tilingSprite) {
          const { shader } = this._getTilingSpriteData(tilingSprite);
          shader.groups[0] = this._renderer.globalUniforms.bindGroup;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = tilingSprite.groupTransform;
          localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
          color32BitToUniform(
            tilingSprite.groupColorAlpha,
            localUniforms.uColor,
            0
          );
          this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);
          this._renderer.encoder.draw({
            geometry: sharedQuad,
            shader,
            state: this._state
          });
        }
        updateRenderable(tilingSprite) {
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          const { canBatch } = tilingSpriteData;
          if (canBatch) {
            const { batchableMesh } = tilingSpriteData;
            if (tilingSprite.didViewUpdate)
              this._updateBatchableMesh(tilingSprite);
            batchableMesh._batcher.updateElement(batchableMesh);
          } else if (tilingSprite.didViewUpdate) {
            const { shader } = tilingSpriteData;
            shader.updateUniforms(
              tilingSprite.width,
              tilingSprite.height,
              tilingSprite._tileTransform.matrix,
              tilingSprite.anchor.x,
              tilingSprite.anchor.y,
              tilingSprite.texture
            );
          }
        }
        _getTilingSpriteData(renderable) {
          return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);
        }
        _initTilingSpriteData(tilingSprite) {
          const gpuData = new TilingSpriteGpuData();
          gpuData.renderable = tilingSprite;
          tilingSprite._gpuData[this._renderer.uid] = gpuData;
          this._managedTilingSprites.add(tilingSprite);
          return gpuData;
        }
        _updateBatchableMesh(tilingSprite) {
          const renderableData = this._getTilingSpriteData(tilingSprite);
          const { geometry } = renderableData;
          const style = tilingSprite.texture.source.style;
          if (style.addressMode !== "repeat") {
            style.addressMode = "repeat";
            style.update();
          }
          setUvs(tilingSprite, geometry.uvs);
          setPositions(tilingSprite, geometry.positions);
        }
        destroy() {
          this._managedTilingSprites.destroy();
          this._renderer = null;
        }
        _updateCanBatch(tilingSprite) {
          const renderableData = this._getTilingSpriteData(tilingSprite);
          const texture = tilingSprite.texture;
          let _nonPowOf2wrapping = true;
          if (this._renderer.type === RendererType.WEBGL) {
            _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
          }
          renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
          return renderableData.canBatch;
        }
      };
      TilingSpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "tilingSprite"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs
  var init_init13 = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs"() {
      init_Extensions();
      init_TilingSpritePipe();
      extensions.add(TilingSpritePipe);
    }
  });

  // node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs
  var _PlaneGeometry, PlaneGeometry;
  var init_PlaneGeometry = __esm({
    "node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs"() {
      init_deprecation();
      init_MeshGeometry();
      _PlaneGeometry = class _PlaneGeometry2 extends MeshGeometry {
        constructor(...args) {
          var _a2;
          super({});
          let options = (_a2 = args[0]) != null ? _a2 : {};
          if (typeof options === "number") {
            deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
            options = {
              width: options,
              height: args[1],
              verticesX: args[2],
              verticesY: args[3]
            };
          }
          this.build(options);
        }
        /**
         * Refreshes plane coordinates
         * @param options - Options to be applied to plane geometry
         */
        build(options) {
          var _a2, _b, _c, _d;
          options = __spreadValues(__spreadValues({}, _PlaneGeometry2.defaultOptions), options);
          this.verticesX = (_a2 = this.verticesX) != null ? _a2 : options.verticesX;
          this.verticesY = (_b = this.verticesY) != null ? _b : options.verticesY;
          this.width = (_c = this.width) != null ? _c : options.width;
          this.height = (_d = this.height) != null ? _d : options.height;
          const total = this.verticesX * this.verticesY;
          const verts = [];
          const uvs = [];
          const indices = [];
          const verticesX = this.verticesX - 1;
          const verticesY = this.verticesY - 1;
          const sizeX = this.width / verticesX;
          const sizeY = this.height / verticesY;
          for (let i3 = 0; i3 < total; i3++) {
            const x2 = i3 % this.verticesX;
            const y2 = i3 / this.verticesX | 0;
            verts.push(x2 * sizeX, y2 * sizeY);
            uvs.push(x2 / verticesX, y2 / verticesY);
          }
          const totalSub = verticesX * verticesY;
          for (let i3 = 0; i3 < totalSub; i3++) {
            const xpos = i3 % verticesX;
            const ypos = i3 / verticesX | 0;
            const value = ypos * this.verticesX + xpos;
            const value2 = ypos * this.verticesX + xpos + 1;
            const value3 = (ypos + 1) * this.verticesX + xpos;
            const value4 = (ypos + 1) * this.verticesX + xpos + 1;
            indices.push(
              value,
              value2,
              value3,
              value2,
              value4,
              value3
            );
          }
          this.buffers[0].data = new Float32Array(verts);
          this.buffers[1].data = new Float32Array(uvs);
          this.indexBuffer.data = new Uint32Array(indices);
          this.buffers[0].update();
          this.buffers[1].update();
          this.indexBuffer.update();
        }
      };
      _PlaneGeometry.defaultOptions = {
        width: 100,
        height: 100,
        verticesX: 10,
        verticesY: 10
      };
      PlaneGeometry = _PlaneGeometry;
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs
  var _NineSliceGeometry, NineSliceGeometry;
  var init_NineSliceGeometry = __esm({
    "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs"() {
      init_PlaneGeometry();
      _NineSliceGeometry = class _NineSliceGeometry2 extends PlaneGeometry {
        constructor(options = {}) {
          options = __spreadValues(__spreadValues({}, _NineSliceGeometry2.defaultOptions), options);
          super({
            width: options.width,
            height: options.height,
            verticesX: 4,
            verticesY: 4
          });
          this.update(options);
        }
        /**
         * Updates the NineSliceGeometry with the options.
         * @param options - The options of the NineSliceGeometry.
         */
        update(options) {
          var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
          this.width = (_a2 = options.width) != null ? _a2 : this.width;
          this.height = (_b = options.height) != null ? _b : this.height;
          this._originalWidth = (_c = options.originalWidth) != null ? _c : this._originalWidth;
          this._originalHeight = (_d = options.originalHeight) != null ? _d : this._originalHeight;
          this._leftWidth = (_e = options.leftWidth) != null ? _e : this._leftWidth;
          this._rightWidth = (_f = options.rightWidth) != null ? _f : this._rightWidth;
          this._topHeight = (_g = options.topHeight) != null ? _g : this._topHeight;
          this._bottomHeight = (_h = options.bottomHeight) != null ? _h : this._bottomHeight;
          this._anchorX = (_i = options.anchor) == null ? void 0 : _i.x;
          this._anchorY = (_j = options.anchor) == null ? void 0 : _j.y;
          this.updateUvs();
          this.updatePositions();
        }
        /** Updates the positions of the vertices. */
        updatePositions() {
          const p3 = this.positions;
          const {
            width,
            height,
            _leftWidth,
            _rightWidth,
            _topHeight,
            _bottomHeight,
            _anchorX,
            _anchorY
          } = this;
          const w2 = _leftWidth + _rightWidth;
          const scaleW = width > w2 ? 1 : width / w2;
          const h2 = _topHeight + _bottomHeight;
          const scaleH = height > h2 ? 1 : height / h2;
          const scale = Math.min(scaleW, scaleH);
          const anchorOffsetX = _anchorX * width;
          const anchorOffsetY = _anchorY * height;
          p3[0] = p3[8] = p3[16] = p3[24] = -anchorOffsetX;
          p3[2] = p3[10] = p3[18] = p3[26] = _leftWidth * scale - anchorOffsetX;
          p3[4] = p3[12] = p3[20] = p3[28] = width - _rightWidth * scale - anchorOffsetX;
          p3[6] = p3[14] = p3[22] = p3[30] = width - anchorOffsetX;
          p3[1] = p3[3] = p3[5] = p3[7] = -anchorOffsetY;
          p3[9] = p3[11] = p3[13] = p3[15] = _topHeight * scale - anchorOffsetY;
          p3[17] = p3[19] = p3[21] = p3[23] = height - _bottomHeight * scale - anchorOffsetY;
          p3[25] = p3[27] = p3[29] = p3[31] = height - anchorOffsetY;
          this.getBuffer("aPosition").update();
        }
        /** Updates the UVs of the vertices. */
        updateUvs() {
          const uvs = this.uvs;
          uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
          uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
          uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
          uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
          const _uvw = 1 / this._originalWidth;
          const _uvh = 1 / this._originalHeight;
          uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
          uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
          uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
          uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
          this.getBuffer("aUV").update();
        }
      };
      _NineSliceGeometry.defaultOptions = {
        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
        width: 100,
        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
        height: 100,
        /** The width of the left column. */
        leftWidth: 10,
        /** The height of the top row. */
        topHeight: 10,
        /** The width of the right column. */
        rightWidth: 10,
        /** The height of the bottom row. */
        bottomHeight: 10,
        /** The original width of the texture */
        originalWidth: 100,
        /** The original height of the texture */
        originalHeight: 100
      };
      NineSliceGeometry = _NineSliceGeometry;
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs
  var NineSliceSpriteGpuData, NineSliceSpritePipe;
  var init_NineSliceSpritePipe = __esm({
    "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs"() {
      init_Extensions();
      init_GCManagedHash();
      init_BatchableMesh();
      init_NineSliceGeometry();
      NineSliceSpriteGpuData = class extends BatchableMesh {
        constructor() {
          super();
          this.geometry = new NineSliceGeometry();
        }
        destroy() {
          this.geometry.destroy();
        }
      };
      NineSliceSpritePipe = class {
        constructor(renderer) {
          this._renderer = renderer;
          this._managedSprites = new GCManagedHash({ renderer, type: "renderable", name: "nineSliceSprite" });
        }
        addRenderable(sprite, instructionSet) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
        }
        updateRenderable(sprite) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          gpuSprite._batcher.updateElement(gpuSprite);
        }
        validateRenderable(sprite) {
          const gpuSprite = this._getGpuSprite(sprite);
          return !gpuSprite._batcher.checkAndUpdateTexture(
            gpuSprite,
            sprite._texture
          );
        }
        _updateBatchableSprite(sprite, batchableSprite) {
          batchableSprite.geometry.update(sprite);
          batchableSprite.setTexture(sprite._texture);
        }
        _getGpuSprite(sprite) {
          return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
        }
        _initGPUSprite(sprite) {
          const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();
          const batchableMesh = gpuData;
          batchableMesh.renderable = sprite;
          batchableMesh.transform = sprite.groupTransform;
          batchableMesh.texture = sprite._texture;
          batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
          this._managedSprites.add(sprite);
          if (!sprite.didViewUpdate) {
            this._updateBatchableSprite(sprite, batchableMesh);
          }
          return gpuData;
        }
        destroy() {
          this._managedSprites.destroy();
          this._renderer = null;
        }
      };
      NineSliceSpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "nineSliceSprite"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs
  var init_init14 = __esm({
    "node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs"() {
      init_Extensions();
      init_NineSliceSpritePipe();
      extensions.add(NineSliceSpritePipe);
    }
  });

  // node_modules/pixi.js/lib/filters/FilterPipe.mjs
  var FilterPipe;
  var init_FilterPipe = __esm({
    "node_modules/pixi.js/lib/filters/FilterPipe.mjs"() {
      init_Extensions();
      FilterPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        push(filterEffect, container, instructionSet) {
          const renderPipes3 = this._renderer.renderPipes;
          renderPipes3.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            canBundle: false,
            action: "pushFilter",
            container,
            filterEffect
          });
        }
        pop(_filterEffect, _container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        execute(instruction) {
          if (instruction.action === "pushFilter") {
            this._renderer.filter.push(instruction);
          } else if (instruction.action === "popFilter") {
            this._renderer.filter.pop();
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      FilterPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "filter"
      };
    }
  });

  // node_modules/pixi.js/lib/filters/Filter.mjs
  var _Filter, Filter;
  var init_Filter = __esm({
    "node_modules/pixi.js/lib/filters/Filter.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_Shader();
      init_State();
      _Filter = class _Filter2 extends Shader {
        /**
         * @param options - The optional parameters of this filter.
         */
        constructor(options) {
          options = __spreadValues(__spreadValues({}, _Filter2.defaultOptions), options);
          super(options);
          this.enabled = true;
          this._state = State.for2d();
          this.blendMode = options.blendMode;
          this.padding = options.padding;
          if (typeof options.antialias === "boolean") {
            this.antialias = options.antialias ? "on" : "off";
          } else {
            this.antialias = options.antialias;
          }
          this.resolution = options.resolution;
          this.blendRequired = options.blendRequired;
          this.clipToViewport = options.clipToViewport;
          this.addResource("uTexture", 0, 1);
          if (options.blendRequired) {
            this.addResource("uBackTexture", 0, 3);
          }
        }
        /**
         * Applies the filter
         * @param filterManager - The renderer to retrieve the filter from
         * @param input - The input render target.
         * @param output - The target to output to.
         * @param clearMode - Should the output be cleared before rendering to it
         */
        apply(filterManager, input, output, clearMode) {
          filterManager.applyFilter(this, input, output, clearMode);
        }
        /**
         * Get the blend mode of the filter.
         * @default "normal"
         */
        get blendMode() {
          return this._state.blendMode;
        }
        /** Sets the blend mode of the filter. */
        set blendMode(value) {
          this._state.blendMode = value;
        }
        /**
         * A short hand function to create a filter based of a vertex and fragment shader src.
         * @param options
         * @returns A shiny new PixiJS filter!
         */
        static from(options) {
          const _a2 = options, { gpu, gl } = _a2, rest = __objRest(_a2, ["gpu", "gl"]);
          let gpuProgram3;
          let glProgram3;
          if (gpu) {
            gpuProgram3 = GpuProgram.from(gpu);
          }
          if (gl) {
            glProgram3 = GlProgram.from(gl);
          }
          return new _Filter2(__spreadValues({
            gpuProgram: gpuProgram3,
            glProgram: glProgram3
          }, rest));
        }
      };
      _Filter.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: false,
        clipToViewport: true
      };
      Filter = _Filter;
    }
  });

  // node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs
  var vertex2;
  var init_defaultFilter_vert = __esm({
    "node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs"() {
      vertex2 = "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    }
  });

  // node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs
  var fragment2;
  var init_passthrough_frag = __esm({
    "node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs"() {
      fragment2 = "in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n";
    }
  });

  // node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs
  var source;
  var init_passthrough_wgsl = __esm({
    "node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs"() {
      source = "struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n";
    }
  });

  // node_modules/pixi.js/lib/filters/defaults/passthrough/PassthroughFilter.mjs
  var PassthroughFilter;
  var init_PassthroughFilter = __esm({
    "node_modules/pixi.js/lib/filters/defaults/passthrough/PassthroughFilter.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_Filter();
      init_defaultFilter_vert();
      init_passthrough_frag();
      init_passthrough_wgsl();
      PassthroughFilter = class extends Filter {
        constructor() {
          const gpuProgram3 = GpuProgram.from({
            vertex: { source, entryPoint: "mainVertex" },
            fragment: { source, entryPoint: "mainFragment" },
            name: "passthrough-filter"
          });
          const glProgram3 = GlProgram.from({
            vertex: vertex2,
            fragment: fragment2,
            name: "passthrough-filter"
          });
          super({
            gpuProgram: gpuProgram3,
            glProgram: glProgram3
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs
  function pointInTriangle2(px, py, x1, y1, x2, y2, x3, y3) {
    const v2x = x3 - x1;
    const v2y = y3 - y1;
    const v1x = x2 - x1;
    const v1y = y2 - y1;
    const v0x = px - x1;
    const v0y = py - y1;
    const dot00 = v2x * v2x + v2y * v2y;
    const dot01 = v2x * v1x + v2y * v1y;
    const dot02 = v2x * v0x + v2y * v0y;
    const dot11 = v1x * v1x + v1y * v1y;
    const dot12 = v1x * v0x + v1y * v0y;
    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return u2 >= 0 && v2 >= 0 && u2 + v2 < 1;
  }
  var init_pointInTriangle = __esm({
    "node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/Triangle.mjs
  var Triangle;
  var init_Triangle = __esm({
    "node_modules/pixi.js/lib/maths/shapes/Triangle.mjs"() {
      init_squaredDistanceToLineSegment();
      init_Rectangle();
      Triangle = class _Triangle {
        /**
         * @param x - The X coord of the first point.
         * @param y - The Y coord of the first point.
         * @param x2 - The X coord of the second point.
         * @param y2 - The Y coord of the second point.
         * @param x3 - The X coord of the third point.
         * @param y3 - The Y coord of the third point.
         */
        constructor(x2 = 0, y2 = 0, x22 = 0, y22 = 0, x3 = 0, y3 = 0) {
          this.type = "triangle";
          this.x = x2;
          this.y = y2;
          this.x2 = x22;
          this.y2 = y22;
          this.x3 = x3;
          this.y3 = y3;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this triangle
         * @example
         * ```ts
         * // Basic containment check
         * const triangle = new Triangle(0, 0, 100, 0, 50, 100);
         * const isInside = triangle.contains(25, 25); // true
         * ```
         * @remarks
         * - Uses barycentric coordinate system
         * - Works with any triangle shape
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Triangle
         * @see {@link Triangle.strokeContains} For checking stroke intersection
         * @see {@link Triangle.getBounds} For getting containing rectangle
         */
        contains(x2, y2) {
          const s2 = (this.x - this.x3) * (y2 - this.y3) - (this.y - this.y3) * (x2 - this.x3);
          const t2 = (this.x2 - this.x) * (y2 - this.y) - (this.y2 - this.y) * (x2 - this.x);
          if (s2 < 0 !== t2 < 0 && s2 !== 0 && t2 !== 0) {
            return false;
          }
          const d2 = (this.x3 - this.x2) * (y2 - this.y2) - (this.y3 - this.y2) * (x2 - this.x2);
          return d2 === 0 || d2 < 0 === s2 + t2 <= 0;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this triangle including the stroke.
         * @example
         * ```ts
         * // Basic stroke check
         * const triangle = new Triangle(0, 0, 100, 0, 50, 100);
         * const isOnStroke = triangle.strokeContains(25, 25, 4); // 4px line width
         *
         * // Check with different alignments
         * const innerStroke = triangle.strokeContains(25, 25, 4, 1);   // Inside
         * const centerStroke = triangle.strokeContains(25, 25, 4, 0.5); // Centered
         * const outerStroke = triangle.strokeContains(25, 25, 4, 0);   // Outside
         * ```
         * @param pointX - The X coordinate of the point to test
         * @param pointY - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @param _alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
         * @returns Whether the x/y coordinates are within this triangle's stroke
         * @see {@link Triangle.contains} For checking fill containment
         * @see {@link Triangle.getBounds} For getting stroke bounds
         */
        strokeContains(pointX, pointY, strokeWidth, _alignment = 0.5) {
          const halfStrokeWidth = strokeWidth / 2;
          const halfStrokeWidthSquared = halfStrokeWidth * halfStrokeWidth;
          const { x: x2, x2: x22, x3, y: y2, y2: y22, y3 } = this;
          if (squaredDistanceToLineSegment(pointX, pointY, x2, y2, x22, y3) <= halfStrokeWidthSquared || squaredDistanceToLineSegment(pointX, pointY, x22, y22, x3, y3) <= halfStrokeWidthSquared || squaredDistanceToLineSegment(pointX, pointY, x3, y3, x2, y2) <= halfStrokeWidthSquared) {
            return true;
          }
          return false;
        }
        /**
         * Creates a clone of this Triangle
         * @example
         * ```ts
         * // Basic cloning
         * const original = new Triangle(0, 0, 100, 0, 50, 100);
         * const copy = original.clone();
         *
         * // Clone and modify
         * const modified = original.clone();
         * modified.x3 = 75;
         * modified.y3 = 150;
         *
         * // Verify independence
         * console.log(original.y3);  // 100
         * console.log(modified.y3);  // 150
         * ```
         * @returns A copy of the triangle
         * @see {@link Triangle.copyFrom} For copying into existing triangle
         * @see {@link Triangle.copyTo} For copying to another triangle
         */
        clone() {
          const triangle = new _Triangle(
            this.x,
            this.y,
            this.x2,
            this.y2,
            this.x3,
            this.y3
          );
          return triangle;
        }
        /**
         * Copies another triangle to this one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Triangle(0, 0, 100, 0, 50, 100);
         * const target = new Triangle();
         * target.copyFrom(source);
         *
         * // Chain with other operations
         * const triangle = new Triangle()
         *     .copyFrom(source)
         *     .getBounds(rect);
         * ```
         * @param triangle - The triangle to copy from
         * @returns Returns itself
         * @see {@link Triangle.copyTo} For copying to another triangle
         * @see {@link Triangle.clone} For creating new triangle copy
         */
        copyFrom(triangle) {
          this.x = triangle.x;
          this.y = triangle.y;
          this.x2 = triangle.x2;
          this.y2 = triangle.y2;
          this.x3 = triangle.x3;
          this.y3 = triangle.y3;
          return this;
        }
        /**
         * Copies this triangle to another one.
         * @example
         * ```ts
         * // Basic copying
         * const source = new Triangle(0, 0, 100, 0, 50, 100);
         * const target = new Triangle();
         * source.copyTo(target);
         *
         * // Chain with other operations
         * const result = source
         *     .copyTo(new Triangle())
         *     .getBounds();
         * ```
         * @remarks
         * - Updates target triangle values
         * - Copies all point coordinates
         * - Returns target for chaining
         * - More efficient than clone()
         * @param triangle - The triangle to copy to
         * @returns Returns given parameter
         * @see {@link Triangle.copyFrom} For copying from another triangle
         * @see {@link Triangle.clone} For creating new triangle copy
         */
        copyTo(triangle) {
          triangle.copyFrom(this);
          return triangle;
        }
        /**
         * Returns the framing rectangle of the triangle as a Rectangle object
         * @example
         * ```ts
         * // Basic bounds calculation
         * const triangle = new Triangle(0, 0, 100, 0, 50, 100);
         * const bounds = triangle.getBounds();
         * // bounds: x=0, y=0, width=100, height=100
         *
         * // Reuse existing rectangle
         * const rect = new Rectangle();
         * triangle.getBounds(rect);
         * ```
         * @param out - Optional rectangle to store the result
         * @returns The framing rectangle
         * @see {@link Rectangle} For rectangle properties
         * @see {@link Triangle.contains} For checking if a point is inside
         */
        getBounds(out2) {
          out2 || (out2 = new Rectangle());
          const minX = Math.min(this.x, this.x2, this.x3);
          const maxX = Math.max(this.x, this.x2, this.x3);
          const minY = Math.min(this.y, this.y2, this.y3);
          const maxY = Math.max(this.y, this.y2, this.y3);
          out2.x = minX;
          out2.y = minY;
          out2.width = maxX - minX;
          out2.height = maxY - minY;
          return out2;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
  function getGlobalRenderableBounds(renderables, bounds) {
    var _a2;
    bounds.clear();
    const actualMatrix = bounds.matrix;
    for (let i3 = 0; i3 < renderables.length; i3++) {
      const renderable = renderables[i3];
      if (renderable.globalDisplayStatus < 7) {
        continue;
      }
      const renderGroup = (_a2 = renderable.renderGroup) != null ? _a2 : renderable.parentRenderGroup;
      if (renderGroup == null ? void 0 : renderGroup.isCachedAsTexture) {
        bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform);
      } else if (renderGroup == null ? void 0 : renderGroup._parentCacheAsTextureRenderGroup) {
        bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform);
      } else {
        bounds.matrix = renderable.worldTransform;
      }
      bounds.addBounds(renderable.bounds);
    }
    bounds.matrix = actualMatrix;
    return bounds;
  }
  var tempProjectionMatrix;
  var init_getRenderableBounds = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs"() {
      init_Matrix();
      tempProjectionMatrix = new Matrix();
    }
  });

  // node_modules/pixi.js/lib/filters/FilterSystem.mjs
  var quadGeometry, FilterData, FilterSystem;
  var init_FilterSystem = __esm({
    "node_modules/pixi.js/lib/filters/FilterSystem.mjs"() {
      init_Extensions();
      init_PassthroughFilter();
      init_Matrix();
      init_BindGroup();
      init_Geometry();
      init_UniformGroup();
      init_Texture();
      init_TexturePool();
      init_types2();
      init_Bounds();
      init_getRenderableBounds();
      init_warn();
      quadGeometry = new Geometry({
        attributes: {
          aPosition: {
            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
      });
      FilterData = class {
        constructor() {
          this.skip = false;
          this.inputTexture = null;
          this.backTexture = null;
          this.filters = null;
          this.bounds = new Bounds();
          this.container = null;
          this.blendRequired = false;
          this.outputRenderSurface = null;
          this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };
          this.firstEnabledIndex = -1;
          this.lastEnabledIndex = -1;
        }
      };
      FilterSystem = class {
        constructor(renderer) {
          this._filterStackIndex = 0;
          this._filterStack = [];
          this._filterGlobalUniforms = new UniformGroup({
            uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
            uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
            uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
            uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
          });
          this._globalFilterBindGroup = new BindGroup({});
          this.renderer = renderer;
        }
        /**
         * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
         * @readonly
         */
        get activeBackTexture() {
          var _a2;
          return (_a2 = this._activeFilterData) == null ? void 0 : _a2.backTexture;
        }
        /**
         * Pushes a filter instruction onto the filter stack.
         * @param instruction - The instruction containing the filter effect and container.
         * @internal
         */
        push(instruction) {
          const renderer = this.renderer;
          const filters = instruction.filterEffect.filters;
          const filterData = this._pushFilterData();
          filterData.skip = false;
          filterData.filters = filters;
          filterData.container = instruction.container;
          filterData.outputRenderSurface = renderer.renderTarget.renderSurface;
          const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
          const rootResolution = colorTextureSource.resolution;
          const rootAntialias = colorTextureSource.antialias;
          if (filters.every((filter) => !filter.enabled)) {
            filterData.skip = true;
            return;
          }
          const bounds = filterData.bounds;
          this._calculateFilterArea(instruction, bounds);
          this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);
          if (filterData.skip) {
            return;
          }
          const previousFilterData = this._getPreviousFilterData();
          const globalResolution = this._findFilterResolution(rootResolution);
          let offsetX = 0;
          let offsetY = 0;
          if (previousFilterData) {
            offsetX = previousFilterData.bounds.minX;
            offsetY = previousFilterData.bounds.minY;
          }
          this._calculateGlobalFrame(
            filterData,
            offsetX,
            offsetY,
            globalResolution,
            colorTextureSource.width,
            colorTextureSource.height
          );
          this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);
        }
        /**
         * Applies filters to a texture.
         *
         * This method takes a texture and a list of filters, applies the filters to the texture,
         * and returns the resulting texture.
         * @param {object} params - The parameters for applying filters.
         * @param {Texture} params.texture - The texture to apply filters to.
         * @param {Filter[]} params.filters - The filters to apply.
         * @returns {Texture} The resulting texture after all filters have been applied.
         * @example
         *
         * ```ts
         * // Create a texture and a list of filters
         * const texture = new Texture(...);
         * const filters = [new BlurFilter(), new ColorMatrixFilter()];
         *
         * // Apply the filters to the texture
         * const resultTexture = filterSystem.applyToTexture({ texture, filters });
         *
         * // Use the resulting texture
         * sprite.texture = resultTexture;
         * ```
         *
         * Key Points:
         * 1. padding is not currently supported here - so clipping may occur with filters that use padding.
         * 2. If all filters are disabled or skipped, the original texture is returned.
         */
        generateFilteredTexture({ texture, filters }) {
          const filterData = this._pushFilterData();
          this._activeFilterData = filterData;
          filterData.skip = false;
          filterData.filters = filters;
          const colorTextureSource = texture.source;
          const rootResolution = colorTextureSource.resolution;
          const rootAntialias = colorTextureSource.antialias;
          if (filters.every((filter) => !filter.enabled)) {
            filterData.skip = true;
            return texture;
          }
          const bounds = filterData.bounds;
          bounds.addRect(texture.frame);
          this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);
          if (filterData.skip) {
            return texture;
          }
          const globalResolution = rootResolution;
          const offsetX = 0;
          const offsetY = 0;
          this._calculateGlobalFrame(
            filterData,
            offsetX,
            offsetY,
            globalResolution,
            colorTextureSource.width,
            colorTextureSource.height
          );
          filterData.outputRenderSurface = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            filterData.resolution,
            filterData.antialias
          );
          filterData.backTexture = Texture.EMPTY;
          filterData.inputTexture = texture;
          const renderer = this.renderer;
          renderer.renderTarget.finishRenderPass();
          this._applyFiltersToTexture(filterData, true);
          const outputTexture = filterData.outputRenderSurface;
          outputTexture.source.alphaMode = "premultiplied-alpha";
          return outputTexture;
        }
        /** @internal */
        pop() {
          const renderer = this.renderer;
          const filterData = this._popFilterData();
          if (filterData.skip) {
            return;
          }
          renderer.globalUniforms.pop();
          renderer.renderTarget.finishRenderPass();
          this._activeFilterData = filterData;
          this._applyFiltersToTexture(filterData, false);
          if (filterData.blendRequired) {
            TexturePool.returnTexture(filterData.backTexture);
          }
          TexturePool.returnTexture(filterData.inputTexture);
        }
        /**
         * Copies the last render surface to a texture.
         * @param lastRenderSurface - The last render surface to copy from.
         * @param bounds - The bounds of the area to copy.
         * @param previousBounds - The previous bounds to use for offsetting the copy.
         */
        getBackTexture(lastRenderSurface, bounds, previousBounds) {
          const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
          const backTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            backgroundResolution,
            false
          );
          let x2 = bounds.minX;
          let y2 = bounds.minY;
          if (previousBounds) {
            x2 -= previousBounds.minX;
            y2 -= previousBounds.minY;
          }
          x2 = Math.floor(x2 * backgroundResolution);
          y2 = Math.floor(y2 * backgroundResolution);
          const width = Math.ceil(bounds.width * backgroundResolution);
          const height = Math.ceil(bounds.height * backgroundResolution);
          this.renderer.renderTarget.copyToTexture(
            lastRenderSurface,
            backTexture,
            { x: x2, y: y2 },
            { width, height },
            { x: 0, y: 0 }
          );
          return backTexture;
        }
        /**
         * Applies a filter to a texture.
         * @param filter - The filter to apply.
         * @param input - The input texture.
         * @param output - The output render surface.
         * @param clear - Whether to clear the output surface before applying the filter.
         */
        applyFilter(filter, input, output, clear) {
          const renderer = this.renderer;
          const filterData = this._activeFilterData;
          const outputRenderSurface = filterData.outputRenderSurface;
          const isFinalTarget = outputRenderSurface === output;
          const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
          const resolution = this._findFilterResolution(rootResolution);
          let offsetX = 0;
          let offsetY = 0;
          if (isFinalTarget) {
            const offset = this._findPreviousFilterOffset();
            offsetX = offset.x;
            offsetY = offset.y;
          }
          this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);
          const filterToApply = filter.enabled ? filter : this._getPassthroughFilter();
          this._setupBindGroupsAndRender(filterToApply, input, renderer);
        }
        /**
         * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
         *
         * Use `outputMatrix * vTextureCoord` in the shader.
         * @param outputMatrix - The matrix to output to.
         * @param {Sprite} sprite - The sprite to map to.
         * @returns The mapped matrix.
         */
        calculateSpriteMatrix(outputMatrix, sprite) {
          const data = this._activeFilterData;
          const mappedMatrix = outputMatrix.set(
            data.inputTexture._source.width,
            0,
            0,
            data.inputTexture._source.height,
            data.bounds.minX,
            data.bounds.minY
          );
          const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
          const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;
          if (renderGroup && renderGroup.cacheToLocalTransform) {
            worldTransform.prepend(renderGroup.cacheToLocalTransform);
          }
          worldTransform.invert();
          mappedMatrix.prepend(worldTransform);
          mappedMatrix.scale(
            1 / sprite.texture.orig.width,
            1 / sprite.texture.orig.height
          );
          mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
          return mappedMatrix;
        }
        destroy() {
          var _a2;
          (_a2 = this._passthroughFilter) == null ? void 0 : _a2.destroy(true);
          this._passthroughFilter = null;
        }
        _getPassthroughFilter() {
          var _a2;
          (_a2 = this._passthroughFilter) != null ? _a2 : this._passthroughFilter = new PassthroughFilter();
          return this._passthroughFilter;
        }
        /**
         * Sets up the bind groups and renders the filter.
         * @param filter - The filter to apply
         * @param input - The input texture
         * @param renderer - The renderer instance
         */
        _setupBindGroupsAndRender(filter, input, renderer) {
          if (renderer.renderPipes.uniformBatch) {
            const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
            this._globalFilterBindGroup.setResource(batchUniforms, 0);
          } else {
            this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
          }
          this._globalFilterBindGroup.setResource(input.source, 1);
          this._globalFilterBindGroup.setResource(input.source.style, 2);
          filter.groups[0] = this._globalFilterBindGroup;
          renderer.encoder.draw({
            geometry: quadGeometry,
            shader: filter,
            state: filter._state,
            topology: "triangle-list"
          });
          if (renderer.type === RendererType.WEBGL) {
            renderer.renderTarget.finishRenderPass();
          }
        }
        /**
         * Sets up the filter textures including input texture and back texture if needed.
         * @param filterData - The filter data to update
         * @param bounds - The bounds for the texture
         * @param renderer - The renderer instance
         * @param previousFilterData - The previous filter data for back texture calculation
         */
        _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {
          filterData.backTexture = Texture.EMPTY;
          filterData.inputTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            filterData.resolution,
            filterData.antialias
          );
          if (filterData.blendRequired) {
            renderer.renderTarget.finishRenderPass();
            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);
            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData == null ? void 0 : previousFilterData.bounds);
          }
          renderer.renderTarget.bind(filterData.inputTexture, true);
          renderer.globalUniforms.push({
            offset: bounds
          });
        }
        /**
         * Calculates and sets the global frame for the filter.
         * @param filterData - The filter data to update
         * @param offsetX - The X offset
         * @param offsetY - The Y offset
         * @param globalResolution - The global resolution
         * @param sourceWidth - The source texture width
         * @param sourceHeight - The source texture height
         */
        _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {
          const globalFrame = filterData.globalFrame;
          globalFrame.x = offsetX * globalResolution;
          globalFrame.y = offsetY * globalResolution;
          globalFrame.width = sourceWidth * globalResolution;
          globalFrame.height = sourceHeight * globalResolution;
        }
        /**
         * Updates the filter uniforms with the current filter state.
         * @param input - The input texture
         * @param output - The output render surface
         * @param filterData - The current filter data
         * @param offsetX - The X offset for positioning
         * @param offsetY - The Y offset for positioning
         * @param resolution - The current resolution
         * @param isFinalTarget - Whether this is the final render target
         * @param clear - Whether to clear the output surface
         */
        _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {
          const uniforms = this._filterGlobalUniforms.uniforms;
          const outputFrame = uniforms.uOutputFrame;
          const inputSize = uniforms.uInputSize;
          const inputPixel = uniforms.uInputPixel;
          const inputClamp = uniforms.uInputClamp;
          const globalFrame = uniforms.uGlobalFrame;
          const outputTexture = uniforms.uOutputTexture;
          if (isFinalTarget) {
            outputFrame[0] = filterData.bounds.minX - offsetX;
            outputFrame[1] = filterData.bounds.minY - offsetY;
          } else {
            outputFrame[0] = 0;
            outputFrame[1] = 0;
          }
          outputFrame[2] = input.frame.width;
          outputFrame[3] = input.frame.height;
          inputSize[0] = input.source.width;
          inputSize[1] = input.source.height;
          inputSize[2] = 1 / inputSize[0];
          inputSize[3] = 1 / inputSize[1];
          inputPixel[0] = input.source.pixelWidth;
          inputPixel[1] = input.source.pixelHeight;
          inputPixel[2] = 1 / inputPixel[0];
          inputPixel[3] = 1 / inputPixel[1];
          inputClamp[0] = 0.5 * inputPixel[2];
          inputClamp[1] = 0.5 * inputPixel[3];
          inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
          inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
          const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
          globalFrame[0] = offsetX * resolution;
          globalFrame[1] = offsetY * resolution;
          globalFrame[2] = rootTexture.source.width * resolution;
          globalFrame[3] = rootTexture.source.height * resolution;
          if (output instanceof Texture)
            output.source.resource = null;
          const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
          this.renderer.renderTarget.bind(output, !!clear);
          if (output instanceof Texture) {
            outputTexture[0] = output.frame.width;
            outputTexture[1] = output.frame.height;
          } else {
            outputTexture[0] = renderTarget.width;
            outputTexture[1] = renderTarget.height;
          }
          outputTexture[2] = renderTarget.isRoot ? -1 : 1;
          this._filterGlobalUniforms.update();
        }
        /**
         * Finds the correct resolution by looking back through the filter stack.
         * @param rootResolution - The fallback root resolution to use
         * @returns The resolution from the previous filter or root resolution
         */
        _findFilterResolution(rootResolution) {
          let currentIndex = this._filterStackIndex - 1;
          while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
            --currentIndex;
          }
          return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;
        }
        /**
         * Finds the offset from the previous non-skipped filter in the stack.
         * @returns The offset coordinates from the previous filter
         */
        _findPreviousFilterOffset() {
          let offsetX = 0;
          let offsetY = 0;
          let lastIndex = this._filterStackIndex;
          while (lastIndex > 0) {
            lastIndex--;
            const prevFilterData = this._filterStack[lastIndex];
            if (!prevFilterData.skip) {
              offsetX = prevFilterData.bounds.minX;
              offsetY = prevFilterData.bounds.minY;
              break;
            }
          }
          return { x: offsetX, y: offsetY };
        }
        /**
         * Calculates the filter area bounds based on the instruction type.
         * @param instruction - The filter instruction
         * @param bounds - The bounds object to populate
         */
        _calculateFilterArea(instruction, bounds) {
          if (instruction.renderables) {
            getGlobalRenderableBounds(instruction.renderables, bounds);
          } else if (instruction.filterEffect.filterArea) {
            bounds.clear();
            bounds.addRect(instruction.filterEffect.filterArea);
            bounds.applyMatrix(instruction.container.worldTransform);
          } else {
            instruction.container.getFastGlobalBounds(true, bounds);
          }
          if (instruction.container) {
            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;
            const filterFrameTransform = renderGroup.cacheToLocalTransform;
            if (filterFrameTransform) {
              bounds.applyMatrix(filterFrameTransform);
            }
          }
        }
        _applyFiltersToTexture(filterData, clear) {
          const inputTexture = filterData.inputTexture;
          const bounds = filterData.bounds;
          const filters = filterData.filters;
          const firstEnabled = filterData.firstEnabledIndex;
          const lastEnabled = filterData.lastEnabledIndex;
          this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
          this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);
          if (firstEnabled === lastEnabled) {
            filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);
          } else {
            let flip = filterData.inputTexture;
            const tempTexture = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              flip.source._resolution,
              false
            );
            let flop = tempTexture;
            for (let i3 = firstEnabled; i3 < lastEnabled; i3++) {
              const filter = filters[i3];
              if (!filter.enabled)
                continue;
              filter.apply(this, flip, flop, true);
              const t2 = flip;
              flip = flop;
              flop = t2;
            }
            filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);
            TexturePool.returnTexture(tempTexture);
          }
        }
        _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {
          var _a2, _b;
          const renderer = this.renderer;
          const bounds = filterData.bounds;
          const filters = filterData.filters;
          let resolution = Infinity;
          let padding = 0;
          let antialias = true;
          let blendRequired = false;
          let enabled = false;
          let clipToViewport = true;
          let firstEnabledIndex = -1;
          let lastEnabledIndex = -1;
          for (let i3 = 0; i3 < filters.length; i3++) {
            const filter = filters[i3];
            if (!filter.enabled)
              continue;
            if (firstEnabledIndex === -1)
              firstEnabledIndex = i3;
            lastEnabledIndex = i3;
            resolution = Math.min(resolution, filter.resolution === "inherit" ? rootResolution : filter.resolution);
            padding += filter.padding;
            if (filter.antialias === "off") {
              antialias = false;
            } else if (filter.antialias === "inherit") {
              antialias && (antialias = rootAntialias);
            }
            if (!filter.clipToViewport) {
              clipToViewport = false;
            }
            const isCompatible = !!(filter.compatibleRenderers & renderer.type);
            if (!isCompatible) {
              enabled = false;
              break;
            }
            if (filter.blendRequired && !((_b = (_a2 = renderer.backBuffer) == null ? void 0 : _a2.useBackBuffer) != null ? _b : true)) {
              warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
              enabled = false;
              break;
            }
            enabled = true;
            blendRequired || (blendRequired = filter.blendRequired);
          }
          if (!enabled) {
            filterData.skip = true;
            return;
          }
          if (clipToViewport) {
            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);
          }
          bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);
          if (!bounds.isPositive) {
            filterData.skip = true;
            return;
          }
          filterData.antialias = antialias;
          filterData.resolution = resolution;
          filterData.blendRequired = blendRequired;
          filterData.firstEnabledIndex = firstEnabledIndex;
          filterData.lastEnabledIndex = lastEnabledIndex;
        }
        _popFilterData() {
          this._filterStackIndex--;
          return this._filterStack[this._filterStackIndex];
        }
        _getPreviousFilterData() {
          let previousFilterData;
          let index = this._filterStackIndex - 1;
          while (index > 0) {
            index--;
            previousFilterData = this._filterStack[index];
            if (!previousFilterData.skip) {
              break;
            }
          }
          return previousFilterData;
        }
        _pushFilterData() {
          let filterData = this._filterStack[this._filterStackIndex];
          if (!filterData) {
            filterData = this._filterStack[this._filterStackIndex] = new FilterData();
          }
          this._filterStackIndex++;
          return filterData;
        }
      };
      FilterSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "filter"
      };
    }
  });

  // node_modules/pixi.js/lib/filters/init.mjs
  var init_init15 = __esm({
    "node_modules/pixi.js/lib/filters/init.mjs"() {
      init_Extensions();
      init_FilterPipe();
      init_FilterSystem();
      extensions.add(FilterSystem);
      extensions.add(FilterPipe);
    }
  });

  // node_modules/pixi.js/lib/environment-browser/browserAll.mjs
  var browserAll_exports = {};
  var init_browserAll = __esm({
    "node_modules/pixi.js/lib/environment-browser/browserAll.mjs"() {
      init_init();
      init_init2();
      init_init3();
      init_init4();
      init_init5();
      init_init6();
      init_init7();
      init_init8();
      init_init9();
      init_init10();
      init_init11();
      init_init12();
      init_init13();
      init_init14();
      init_init15();
    }
  });

  // node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs
  var webworkerAll_exports = {};
  var init_webworkerAll = __esm({
    "node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs"() {
      init_init2();
      init_init5();
      init_init6();
      init_init7();
      init_init8();
      init_init9();
      init_init10();
      init_init11();
      init_init12();
      init_init13();
      init_init14();
      init_init15();
    }
  });

  // node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs
  function loadEnvironmentExtensions(skip) {
    return __async(this, null, function* () {
      if (skip)
        return;
      for (let i3 = 0; i3 < environments.length; i3++) {
        const env = environments[i3];
        if (env.value.test()) {
          yield env.value.load();
          return;
        }
      }
    });
  }
  function autoDetectEnvironment(add) {
    return __async(this, null, function* () {
      return loadEnvironmentExtensions(!add);
    });
  }
  var environments;
  var init_autoDetectEnvironment = __esm({
    "node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs"() {
      init_Extensions();
      environments = [];
      extensions.handleByNamedList(ExtensionType.Environment, environments);
    }
  });

  // node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs
  function unsafeEvalSupported() {
    if (typeof unsafeEval === "boolean") {
      return unsafeEval;
    }
    try {
      const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval = func({ a: "b" }, "a", "b") === true;
    } catch (_e) {
      unsafeEval = false;
    }
    return unsafeEval;
  }
  var unsafeEval;
  var init_unsafeEvalSupported = __esm({
    "node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
  var CLEAR;
  var init_const7 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"() {
      "use strict";
      CLEAR = /* @__PURE__ */ ((CLEAR2) => {
        CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
        CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
        CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
        CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
        CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
        CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
        CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
        CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
        return CLEAR2;
      })(CLEAR || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
  var SystemRunner;
  var init_SystemRunner = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
      "use strict";
      SystemRunner = class {
        /**
         * @param name - The function name that will be executed on the listeners added to this Runner.
         */
        constructor(name) {
          this.items = [];
          this._name = name;
        }
        /* jsdoc/check-param-names */
        /**
         * Dispatch/Broadcast Runner to all listeners added to the queue.
         * @param {...any} params - (optional) parameters to pass to each listener
         */
        /* jsdoc/check-param-names */
        emit(a0, a1, a2, a3, a4, a5, a6, a7) {
          const { name, items } = this;
          for (let i3 = 0, len = items.length; i3 < len; i3++) {
            items[i3][name](a0, a1, a2, a3, a4, a5, a6, a7);
          }
          return this;
        }
        /**
         * Add a listener to the Runner
         *
         * Runners do not need to have scope or functions passed to them.
         * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
         * as the name provided to the Runner when it was created.
         *
         * Eg A listener passed to this Runner will require a 'complete' function.
         *
         * ```ts
         * import { Runner } from 'pixi.js';
         *
         * const complete = new Runner('complete');
         * ```
         *
         * The scope used will be the object itself.
         * @param {any} item - The object that will be listening.
         */
        add(item) {
          if (item[this._name]) {
            this.remove(item);
            this.items.push(item);
          }
          return this;
        }
        /**
         * Remove a single listener from the dispatch queue.
         * @param {any} item - The listener that you would like to remove.
         */
        remove(item) {
          const index = this.items.indexOf(item);
          if (index !== -1) {
            this.items.splice(index, 1);
          }
          return this;
        }
        /**
         * Check to see if the listener is already in the Runner
         * @param {any} item - The listener that you would like to check.
         */
        contains(item) {
          return this.items.indexOf(item) !== -1;
        }
        /** Remove all listeners from the Runner */
        removeAll() {
          this.items.length = 0;
          return this;
        }
        /** Remove all references, don't use after this. */
        destroy() {
          this.removeAll();
          this.items = null;
          this._name = null;
        }
        /**
         * `true` if there are no this Runner contains no listeners
         * @readonly
         */
        get empty() {
          return this.items.length === 0;
        }
        /**
         * The name of the runner.
         * @readonly
         */
        get name() {
          return this._name;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
  var defaultRunners, _AbstractRenderer, AbstractRenderer;
  var init_AbstractRenderer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
      init_Color();
      init_autoDetectEnvironment();
      init_Container();
      init_unsafeEvalSupported();
      init_uid();
      init_deprecation();
      init_GlobalResourceRegistry();
      init_const7();
      init_SystemRunner();
      init_eventemitter3();
      defaultRunners = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "resetState",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender"
      ];
      _AbstractRenderer = class _AbstractRenderer2 extends eventemitter3_default {
        /**
         * Set up a system with a collection of SystemClasses and runners.
         * Systems are attached dynamically to this class when added.
         * @param config - the config for the system manager
         */
        constructor(config3) {
          var _a2;
          super();
          this.tick = 0;
          this.uid = uid2("renderer");
          this.runners = /* @__PURE__ */ Object.create(null);
          this.renderPipes = /* @__PURE__ */ Object.create(null);
          this._initOptions = {};
          this._systemsHash = /* @__PURE__ */ Object.create(null);
          this.type = config3.type;
          this.name = config3.name;
          this.config = config3;
          const combinedRunners = [...defaultRunners, ...(_a2 = this.config.runners) != null ? _a2 : []];
          this._addRunners(...combinedRunners);
          this._unsafeEvalCheck();
        }
        /**
         * Initialize the renderer.
         * @param options - The options to use to create the renderer.
         */
        init() {
          return __async(this, arguments, function* (options = {}) {
            const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
            yield loadEnvironmentExtensions(skip);
            this._addSystems(this.config.systems);
            this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
            for (const systemName in this._systemsHash) {
              const system = this._systemsHash[systemName];
              const defaultSystemOptions = system.constructor.defaultOptions;
              options = __spreadValues(__spreadValues({}, defaultSystemOptions), options);
            }
            options = __spreadValues(__spreadValues({}, _AbstractRenderer2.defaultOptions), options);
            this._roundPixels = options.roundPixels ? 1 : 0;
            for (let i3 = 0; i3 < this.runners.init.items.length; i3++) {
              yield this.runners.init.items[i3].init(options);
            }
            this._initOptions = options;
          });
        }
        render(args, deprecated) {
          var _a2, _b;
          this.tick++;
          let options = args;
          if (options instanceof Container) {
            options = { container: options };
            if (deprecated) {
              deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
              options.target = deprecated.renderTexture;
            }
          }
          options.target || (options.target = this.view.renderTarget);
          if (options.target === this.view.renderTarget) {
            this._lastObjectRendered = options.container;
            (_a2 = options.clearColor) != null ? _a2 : options.clearColor = this.background.colorRgba;
            (_b = options.clear) != null ? _b : options.clear = this.background.clearBeforeRender;
          }
          if (options.clearColor) {
            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
          }
          if (!options.transform) {
            options.container.updateLocalTransform();
            options.transform = options.container.localTransform;
          }
          if (!options.container.visible) {
            return;
          }
          options.container.enableRenderGroup();
          this.runners.prerender.emit(options);
          this.runners.renderStart.emit(options);
          this.runners.render.emit(options);
          this.runners.renderEnd.emit(options);
          this.runners.postrender.emit(options);
        }
        /**
         * Resizes the WebGL view to the specified width and height.
         * @param desiredScreenWidth - The desired width of the screen.
         * @param desiredScreenHeight - The desired height of the screen.
         * @param resolution - The resolution / device pixel ratio of the renderer.
         */
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          const previousResolution = this.view.resolution;
          this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
          if (resolution !== void 0 && resolution !== previousResolution) {
            this.runners.resolutionChange.emit(resolution);
          }
        }
        /**
         * Clears the render target.
         * @param options - The options to use when clearing the render target.
         * @param options.target - The render target to clear.
         * @param options.clearColor - The color to clear with.
         * @param options.clear - The clear mode to use.
         * @advanced
         */
        clear(options = {}) {
          var _a2;
          const renderer = this;
          options.target || (options.target = renderer.renderTarget.renderTarget);
          options.clearColor || (options.clearColor = this.background.colorRgba);
          (_a2 = options.clear) != null ? _a2 : options.clear = CLEAR.ALL;
          const { clear, clearColor, target } = options;
          Color.shared.setValue(clearColor != null ? clearColor : this.background.colorRgba);
          renderer.renderTarget.clear(target, clear, Color.shared.toArray());
        }
        /** The resolution / device pixel ratio of the renderer. */
        get resolution() {
          return this.view.resolution;
        }
        set resolution(value) {
          this.view.resolution = value;
          this.runners.resolutionChange.emit(value);
        }
        /**
         * Same as view.width, actual number of pixels in the canvas by horizontal.
         * @type {number}
         * @readonly
         * @default 800
         */
        get width() {
          return this.view.texture.frame.width;
        }
        /**
         * Same as view.height, actual number of pixels in the canvas by vertical.
         * @default 600
         */
        get height() {
          return this.view.texture.frame.height;
        }
        // NOTE: this was `view` in v7
        /**
         * The canvas element that everything is drawn to.
         * @type {environment.ICanvas}
         */
        get canvas() {
          return this.view.canvas;
        }
        /**
         * the last object rendered by the renderer. Useful for other plugins like interaction managers
         * @readonly
         */
        get lastObjectRendered() {
          return this._lastObjectRendered;
        }
        /**
         * Flag if we are rendering to the screen vs renderTexture
         * @readonly
         * @default true
         */
        get renderingToScreen() {
          const renderer = this;
          return renderer.renderTarget.renderingToScreen;
        }
        /**
         * Measurements of the screen. (0, 0, screenWidth, screenHeight).
         *
         * Its safe to use as filterArea or hitArea for the whole stage.
         */
        get screen() {
          return this.view.screen;
        }
        /**
         * Create a bunch of runners based of a collection of ids
         * @param runnerIds - the runner ids to add
         */
        _addRunners(...runnerIds) {
          runnerIds.forEach((runnerId) => {
            this.runners[runnerId] = new SystemRunner(runnerId);
          });
        }
        _addSystems(systems3) {
          let i3;
          for (i3 in systems3) {
            const val = systems3[i3];
            this._addSystem(val.value, val.name);
          }
        }
        /**
         * Add a new system to the renderer.
         * @param ClassRef - Class reference
         * @param name - Property name for system, if not specified
         *        will use a static `name` property on the class itself. This
         *        name will be assigned as s property on the Renderer so make
         *        sure it doesn't collide with properties on Renderer.
         * @returns Return instance of renderer
         */
        _addSystem(ClassRef, name) {
          const system = new ClassRef(this);
          if (this[name]) {
            throw new Error(`Whoops! The name "${name}" is already in use`);
          }
          this[name] = system;
          this._systemsHash[name] = system;
          for (const i3 in this.runners) {
            this.runners[i3].add(system);
          }
          return this;
        }
        _addPipes(pipes, pipeAdaptors) {
          const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
            acc[adaptor.name] = adaptor.value;
            return acc;
          }, {});
          pipes.forEach((pipe3) => {
            const PipeClass = pipe3.value;
            const name = pipe3.name;
            const Adaptor = adaptors[name];
            this.renderPipes[name] = new PipeClass(
              this,
              Adaptor ? new Adaptor() : null
            );
            this.runners.destroy.add(this.renderPipes[name]);
          });
        }
        destroy(options = false) {
          this.runners.destroy.items.reverse();
          this.runners.destroy.emit(options);
          if (options === true || typeof options === "object" && options.releaseGlobalResources) {
            GlobalResourceRegistry.release();
          }
          Object.values(this.runners).forEach((runner) => {
            runner.destroy();
          });
          this._systemsHash = null;
          this.renderPipes = null;
        }
        /**
         * Generate a texture from a container.
         * @param options - options or container target to use when generating the texture
         * @returns a texture
         */
        generateTexture(options) {
          return this.textureGenerator.generateTexture(options);
        }
        /**
         * Whether the renderer will round coordinates to whole pixels when rendering.
         * Can be overridden on a per scene item basis.
         */
        get roundPixels() {
          return !!this._roundPixels;
        }
        /**
         * Overridable function by `pixi.js/unsafe-eval` to silence
         * throwing an error if platform doesn't support unsafe-evals.
         * @private
         * @ignore
         */
        _unsafeEvalCheck() {
          if (!unsafeEvalSupported()) {
            throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
          }
        }
        /**
         * Resets the rendering state of the renderer.
         * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state
         * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi
         * render will reset all internal caches and ensure it executes correctly.
         *
         * This is particularly useful when combining PixiJS with other rendering engines like Three.js:
         * ```js
         * // Reset Three.js state
         * threeRenderer.resetState();
         *
         * // Render a Three.js scene
         * threeRenderer.render(threeScene, threeCamera);
         *
         * // Reset PixiJS state since Three.js modified the WebGL context
         * pixiRenderer.resetState();
         *
         * // Now render Pixi content
         * pixiRenderer.render(pixiScene);
         * ```
         * @advanced
         */
        resetState() {
          this.runners.resetState.emit();
        }
      };
      _AbstractRenderer.defaultOptions = {
        /**
         * Default resolution / device pixel ratio of the renderer.
         * @default 1
         */
        resolution: 1,
        /**
         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
         * performance issues when using WebGL.
         *
         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
         * driver version blacklisted by the
         * browser.
         *
         * If your application requires high performance rendering, you may wish to set this to false.
         * We recommend one of two options if you decide to set this flag to false:
         *
         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
         *    not supported.
         *
         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
         *    device & browser combination does not support high performance WebGL.
         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
         * @default false
         */
        failIfMajorPerformanceCaveat: false,
        /**
         * Should round pixels be forced when rendering?
         * @default false
         */
        roundPixels: false
      };
      AbstractRenderer = _AbstractRenderer;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
  var GpuGraphicsAdaptor;
  var init_GpuGraphicsAdaptor = __esm({
    "node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_getTextureBatchBindGroup();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader();
      init_UniformGroup();
      GpuGraphicsAdaptor = class {
        constructor() {
          this._maxTextures = 0;
        }
        contextChange(renderer) {
          const localUniforms = new UniformGroup({
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          this._maxTextures = renderer.limits.maxBatchableTextures;
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "graphics",
            bits: [
              colorBit,
              generateTextureBatchBit(this._maxTextures),
              localUniformBitGroup2,
              roundPixelsBit
            ]
          });
          this.shader = new Shader({
            gpuProgram: gpuProgram3,
            resources: {
              // added on the fly!
              localUniforms
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context4 = renderable.context;
          const shader = context4.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            batcher,
            instructions
          } = contextSystem.getContextRenderData(context4);
          const encoder = renderer.encoder;
          encoder.setGeometry(batcher.geometry, shader.gpuProgram);
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
          const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
          encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
          const batches = instructions.instructions;
          let topology = null;
          for (let i3 = 0; i3 < instructions.instructionSize; i3++) {
            const batch = batches[i3];
            if (batch.topology !== topology) {
              topology = batch.topology;
              encoder.setPipelineFromGeometryProgramAndState(
                batcher.geometry,
                shader.gpuProgram,
                graphicsPipe.state,
                batch.topology
              );
            }
            shader.groups[1] = batch.bindGroup;
            if (!batch.gpuBindGroup) {
              const textureBatch = batch.textures;
              batch.bindGroup = getTextureBatchBindGroup(
                textureBatch.textures,
                textureBatch.count,
                this._maxTextures
              );
              batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
                batch.bindGroup,
                shader.gpuProgram,
                1
              );
            }
            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GpuGraphicsAdaptor.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
  var textureBit, textureBitGl;
  var init_textureBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
      "use strict";
      textureBit = {
        name: "texture-bit",
        vertex: {
          header: (
            /* wgsl */
            `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `
          ),
          main: (
            /* wgsl */
            `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
          )
        }
      };
      textureBitGl = {
        name: "texture-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTextureMatrix;
        `
          ),
          main: (
            /* glsl */
            `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
        uniform sampler2D uTexture;


        `
          ),
          main: (
            /* glsl */
            `
            outColor = texture(uTexture, vUV);
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
  var GpuMeshAdapter;
  var init_GpuMeshAdapter = __esm({
    "node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
      init_Extensions();
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader();
      init_Texture();
      init_warn();
      GpuMeshAdapter = class {
        init() {
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "mesh",
            bits: [
              localUniformBit,
              textureBit,
              roundPixelsBit
            ]
          });
          this._shader = new Shader({
            gpuProgram: gpuProgram3,
            resources: {
              uTexture: Texture.EMPTY._source,
              uSampler: Texture.EMPTY._source.style,
              textureUniforms: {
                uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
              }
            }
          });
        }
        execute(meshPipe, mesh) {
          const renderer = meshPipe.renderer;
          let shader = mesh._shader;
          if (!shader) {
            shader = this._shader;
            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
          } else if (!shader.gpuProgram) {
            warn("Mesh shader has no gpuProgram", mesh.shader);
            return;
          }
          const gpuProgram3 = shader.gpuProgram;
          if (gpuProgram3.autoAssignGlobalUniforms) {
            shader.groups[0] = renderer.globalUniforms.bindGroup;
          }
          if (gpuProgram3.autoAssignLocalUniforms) {
            const localUniforms = meshPipe.localUniforms;
            shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
          }
          renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GpuMeshAdapter.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
  var tempState, GpuBatchAdaptor;
  var init_GpuBatchAdaptor = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
      init_Extensions();
      init_State();
      init_getTextureBatchBindGroup();
      tempState = State.for2d();
      GpuBatchAdaptor = class {
        start(batchPipe, geometry, shader) {
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          const program = shader.gpuProgram;
          this._shader = shader;
          this._geometry = geometry;
          encoder.setGeometry(geometry, program);
          tempState.blendMode = "normal";
          renderer.pipeline.getPipeline(
            geometry,
            program,
            tempState
          );
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.resetBindGroup(1);
          encoder.setBindGroup(0, globalUniformsBindGroup, program);
        }
        execute(batchPipe, batch) {
          const program = this._shader.gpuProgram;
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          if (!batch.bindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(
              textureBatch.textures,
              textureBatch.count,
              renderer.limits.maxBatchableTextures
            );
          }
          tempState.blendMode = batch.blendMode;
          const gpuBindGroup = renderer.bindGroup.getBindGroup(
            batch.bindGroup,
            program,
            1
          );
          const pipeline = renderer.pipeline.getPipeline(
            this._geometry,
            program,
            tempState,
            batch.topology
          );
          batch.bindGroup._touch(renderer.gc.now, renderer.tick);
          encoder.setPipeline(pipeline);
          encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
      };
      GpuBatchAdaptor.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs
  var CustomRenderPipe;
  var init_CustomRenderPipe = __esm({
    "node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs"() {
      init_Extensions();
      CustomRenderPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        updateRenderable() {
        }
        destroyRenderable() {
        }
        validateRenderable() {
          return false;
        }
        addRenderable(container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(container);
        }
        execute(container) {
          if (!container.isRenderable)
            return;
          container.render(this._renderer);
        }
        destroy() {
          this._renderer = null;
        }
      };
      CustomRenderPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "customRender"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
  function executeInstructions(renderGroup, renderer) {
    const instructionSet = renderGroup.instructionSet;
    const instructions = instructionSet.instructions;
    for (let i3 = 0; i3 < instructionSet.instructionSize; i3++) {
      const instruction = instructions[i3];
      renderer[instruction.renderPipeId].execute(instruction);
    }
  }
  var init_executeInstructions = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs
  var tempMatrix5, RenderGroupPipe;
  var init_RenderGroupPipe = __esm({
    "node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs"() {
      init_Extensions();
      init_Matrix();
      init_PoolGroup();
      init_BatchableSprite();
      init_executeInstructions();
      tempMatrix5 = new Matrix();
      RenderGroupPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        addRenderGroup(renderGroup, instructionSet) {
          if (renderGroup.isCachedAsTexture) {
            this._addRenderableCacheAsTexture(renderGroup, instructionSet);
          } else {
            this._addRenderableDirect(renderGroup, instructionSet);
          }
        }
        execute(renderGroup) {
          if (!renderGroup.isRenderable)
            return;
          if (renderGroup.isCachedAsTexture) {
            this._executeCacheAsTexture(renderGroup);
          } else {
            this._executeDirect(renderGroup);
          }
        }
        destroy() {
          this._renderer = null;
        }
        _addRenderableDirect(renderGroup, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          if (renderGroup._batchableRenderGroup) {
            BigPool.return(renderGroup._batchableRenderGroup);
            renderGroup._batchableRenderGroup = null;
          }
          instructionSet.add(renderGroup);
        }
        _addRenderableCacheAsTexture(renderGroup, instructionSet) {
          var _a2;
          const batchableRenderGroup = (_a2 = renderGroup._batchableRenderGroup) != null ? _a2 : renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite);
          batchableRenderGroup.renderable = renderGroup.root;
          batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;
          batchableRenderGroup.texture = renderGroup.texture;
          batchableRenderGroup.bounds = renderGroup._textureBounds;
          instructionSet.add(renderGroup);
          this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);
          this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);
          this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);
        }
        _executeCacheAsTexture(renderGroup) {
          if (renderGroup.textureNeedsUpdate) {
            renderGroup.textureNeedsUpdate = false;
            const worldTransformMatrix = tempMatrix5.identity().translate(
              -renderGroup._textureBounds.x,
              -renderGroup._textureBounds.y
            );
            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);
            this._renderer.globalUniforms.push({
              worldTransformMatrix,
              worldColor: 4294967295,
              offset: { x: 0, y: 0 }
            });
            executeInstructions(renderGroup, this._renderer.renderPipes);
            this._renderer.renderTarget.finishRenderPass();
            this._renderer.renderTarget.pop();
            this._renderer.globalUniforms.pop();
          }
          renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);
          renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();
        }
        _executeDirect(renderGroup) {
          this._renderer.globalUniforms.push({
            worldTransformMatrix: renderGroup.inverseParentTextureTransform,
            worldColor: renderGroup.worldColorAlpha
          });
          executeInstructions(renderGroup, this._renderer.renderPipes);
          this._renderer.globalUniforms.pop();
        }
      };
      RenderGroupPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "renderGroup"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/clearList.mjs
  function clearList(list, index) {
    index || (index = 0);
    for (let j2 = index; j2 < list.length; j2++) {
      if (list[j2]) {
        list[j2] = null;
      } else {
        break;
      }
    }
  }
  var init_clearList = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/clearList.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs
  function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
    updateRenderGroupTransform(renderGroup);
    const childrenToUpdate = renderGroup.childrenToUpdate;
    const updateTick = renderGroup.updateTick++;
    for (const j2 in childrenToUpdate) {
      const renderGroupDepth = Number(j2);
      const childrenAtDepth = childrenToUpdate[j2];
      const list = childrenAtDepth.list;
      const index = childrenAtDepth.index;
      for (let i3 = 0; i3 < index; i3++) {
        const child = list[i3];
        if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
          updateTransformAndChildren(child, updateTick, 0);
        }
      }
      clearList(list, index);
      childrenAtDepth.index = 0;
    }
    if (updateChildRenderGroups) {
      for (let i3 = 0; i3 < renderGroup.renderGroupChildren.length; i3++) {
        updateRenderGroupTransforms(renderGroup.renderGroupChildren[i3], updateChildRenderGroups);
      }
    }
  }
  function updateRenderGroupTransform(renderGroup) {
    const root = renderGroup.root;
    let worldAlpha;
    if (renderGroup.renderGroupParent) {
      const renderGroupParent = renderGroup.renderGroupParent;
      renderGroup.worldTransform.appendFrom(
        root.relativeGroupTransform,
        renderGroupParent.worldTransform
      );
      renderGroup.worldColor = multiplyColors(
        root.groupColor,
        renderGroupParent.worldColor
      );
      worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
    } else {
      renderGroup.worldTransform.copyFrom(root.localTransform);
      renderGroup.worldColor = root.localColor;
      worldAlpha = root.localAlpha;
    }
    worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
    renderGroup.worldAlpha = worldAlpha;
    renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
  }
  function updateTransformAndChildren(container, updateTick, updateFlags) {
    if (updateTick === container.updateTick)
      return;
    container.updateTick = updateTick;
    container.didChange = false;
    const localTransform = container.localTransform;
    container.updateLocalTransform();
    const parent = container.parent;
    if (parent && !parent.renderGroup) {
      updateFlags |= container._updateFlags;
      container.relativeGroupTransform.appendFrom(
        localTransform,
        parent.relativeGroupTransform
      );
      if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
        updateColorBlendVisibility(container, parent, updateFlags);
      }
    } else {
      updateFlags = container._updateFlags;
      container.relativeGroupTransform.copyFrom(localTransform);
      if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
        updateColorBlendVisibility(container, tempContainer, updateFlags);
      }
    }
    if (!container.renderGroup) {
      const children = container.children;
      const length = children.length;
      for (let i3 = 0; i3 < length; i3++) {
        updateTransformAndChildren(children[i3], updateTick, updateFlags);
      }
      const renderGroup = container.parentRenderGroup;
      const renderable = container;
      if (renderable.renderPipeId && !renderGroup.structureDidChange) {
        renderGroup.updateRenderable(renderable);
      }
    }
  }
  function updateColorBlendVisibility(container, parent, updateFlags) {
    if (updateFlags & UPDATE_COLOR) {
      container.groupColor = multiplyColors(
        container.localColor,
        parent.groupColor
      );
      let groupAlpha = container.localAlpha * parent.groupAlpha;
      groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
      container.groupAlpha = groupAlpha;
      container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
    }
    if (updateFlags & UPDATE_BLEND) {
      container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
    }
    if (updateFlags & UPDATE_VISIBLE) {
      container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
    }
    container._updateFlags = 0;
  }
  var tempContainer, UPDATE_BLEND_COLOR_VISIBLE;
  var init_updateRenderGroupTransforms = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs"() {
      init_Container();
      init_clearList();
      init_multiplyColors();
      tempContainer = new Container();
      UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
  function validateRenderables(renderGroup, renderPipes3) {
    const { list } = renderGroup.childrenRenderablesToUpdate;
    let rebuildRequired = false;
    for (let i3 = 0; i3 < renderGroup.childrenRenderablesToUpdate.index; i3++) {
      const container = list[i3];
      const renderable = container;
      const pipe3 = renderPipes3[renderable.renderPipeId];
      rebuildRequired = pipe3.validateRenderable(container);
      if (rebuildRequired) {
        break;
      }
    }
    renderGroup.structureDidChange = rebuildRequired;
    return rebuildRequired;
  }
  var init_validateRenderables = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs
  var tempMatrix6, RenderGroupSystem;
  var init_RenderGroupSystem = __esm({
    "node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_TexturePool();
      init_TextureStyle();
      init_Bounds();
      init_clearList();
      init_executeInstructions();
      init_updateRenderGroupTransforms();
      init_validateRenderables();
      tempMatrix6 = new Matrix();
      RenderGroupSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        render({ container, transform: transform2 }) {
          const parent = container.parent;
          const renderGroupParent = container.renderGroup.renderGroupParent;
          container.parent = null;
          container.renderGroup.renderGroupParent = null;
          const renderer = this._renderer;
          const originalLocalTransform = tempMatrix6;
          if (transform2) {
            originalLocalTransform.copyFrom(container.renderGroup.localTransform);
            container.renderGroup.localTransform.copyFrom(transform2);
          }
          const renderPipes3 = renderer.renderPipes;
          this._updateCachedRenderGroups(container.renderGroup, null);
          this._updateRenderGroups(container.renderGroup);
          renderer.globalUniforms.start({
            worldTransformMatrix: transform2 ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
            worldColor: container.renderGroup.worldColorAlpha
          });
          executeInstructions(container.renderGroup, renderPipes3);
          if (renderPipes3.uniformBatch) {
            renderPipes3.uniformBatch.renderEnd();
          }
          if (transform2) {
            container.renderGroup.localTransform.copyFrom(originalLocalTransform);
          }
          container.parent = parent;
          container.renderGroup.renderGroupParent = renderGroupParent;
        }
        destroy() {
          this._renderer = null;
        }
        _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {
          var _a2, _b;
          renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;
          if (renderGroup.isCachedAsTexture) {
            if (!renderGroup.textureNeedsUpdate)
              return;
            closestCacheAsTexture = renderGroup;
          }
          for (let i3 = renderGroup.renderGroupChildren.length - 1; i3 >= 0; i3--) {
            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i3], closestCacheAsTexture);
          }
          renderGroup.invalidateMatrices();
          if (renderGroup.isCachedAsTexture) {
            if (renderGroup.textureNeedsUpdate) {
              const bounds = renderGroup.root.getLocalBounds();
              bounds.ceil();
              const lastTexture = renderGroup.texture;
              if (renderGroup.texture) {
                TexturePool.returnTexture(renderGroup.texture, true);
              }
              const renderer = this._renderer;
              const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;
              const antialias = (_a2 = renderGroup.textureOptions.antialias) != null ? _a2 : renderer.view.antialias;
              const scaleMode = (_b = renderGroup.textureOptions.scaleMode) != null ? _b : "linear";
              const texture = TexturePool.getOptimalTexture(
                bounds.width,
                bounds.height,
                resolution,
                antialias
              );
              texture._source.style = new TextureStyle({ scaleMode });
              renderGroup.texture = texture;
              renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());
              renderGroup._textureBounds.copyFrom(bounds);
              if (lastTexture !== renderGroup.texture) {
                if (renderGroup.renderGroupParent) {
                  renderGroup.renderGroupParent.structureDidChange = true;
                }
              }
            }
          } else if (renderGroup.texture) {
            TexturePool.returnTexture(renderGroup.texture, true);
            renderGroup.texture = null;
          }
        }
        _updateRenderGroups(renderGroup) {
          const renderer = this._renderer;
          const renderPipes3 = renderer.renderPipes;
          renderGroup.runOnRender(renderer);
          renderGroup.instructionSet.renderPipes = renderPipes3;
          if (!renderGroup.structureDidChange) {
            validateRenderables(renderGroup, renderPipes3);
          } else {
            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);
          }
          updateRenderGroupTransforms(renderGroup);
          if (renderGroup.structureDidChange) {
            renderGroup.structureDidChange = false;
            this._buildInstructions(renderGroup, renderer);
          } else {
            this._updateRenderables(renderGroup);
          }
          renderGroup.childrenRenderablesToUpdate.index = 0;
          renderer.renderPipes.batch.upload(renderGroup.instructionSet);
          if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)
            return;
          for (let i3 = 0; i3 < renderGroup.renderGroupChildren.length; i3++) {
            this._updateRenderGroups(renderGroup.renderGroupChildren[i3]);
          }
        }
        _updateRenderables(renderGroup) {
          const { list, index } = renderGroup.childrenRenderablesToUpdate;
          for (let i3 = 0; i3 < index; i3++) {
            const container = list[i3];
            if (container.didViewUpdate) {
              renderGroup.updateRenderable(container);
            }
          }
          clearList(list, index);
        }
        _buildInstructions(renderGroup, rendererOrPipes) {
          const root = renderGroup.root;
          const instructionSet = renderGroup.instructionSet;
          instructionSet.reset();
          const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
          const renderPipes3 = renderer.renderPipes;
          renderPipes3.batch.buildStart(instructionSet);
          renderPipes3.blendMode.buildStart();
          renderPipes3.colorMask.buildStart();
          if (root.sortableChildren) {
            root.sortChildren();
          }
          root.collectRenderablesWithEffects(instructionSet, renderer, null);
          renderPipes3.batch.buildEnd(instructionSet);
          renderPipes3.blendMode.buildEnd(instructionSet);
        }
      };
      RenderGroupSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "renderGroup"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
  var SpritePipe;
  var init_SpritePipe = __esm({
    "node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs"() {
      init_Extensions();
      init_BatchableSprite();
      SpritePipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        addRenderable(sprite, instructionSet) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
        }
        updateRenderable(sprite) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          gpuSprite._batcher.updateElement(gpuSprite);
        }
        validateRenderable(sprite) {
          const gpuSprite = this._getGpuSprite(sprite);
          return !gpuSprite._batcher.checkAndUpdateTexture(
            gpuSprite,
            sprite._texture
          );
        }
        _updateBatchableSprite(sprite, batchableSprite) {
          batchableSprite.bounds = sprite.visualBounds;
          batchableSprite.texture = sprite._texture;
        }
        _getGpuSprite(sprite) {
          return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
        }
        _initGPUSprite(sprite) {
          const batchableSprite = new BatchableSprite();
          batchableSprite.renderable = sprite;
          batchableSprite.transform = sprite.groupTransform;
          batchableSprite.texture = sprite._texture;
          batchableSprite.bounds = sprite.visualBounds;
          batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
          sprite._gpuData[this._renderer.uid] = batchableSprite;
          return batchableSprite;
        }
        destroy() {
          this._renderer = null;
        }
      };
      SpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "sprite"
      };
    }
  });

  // node_modules/pixi.js/lib/utils/const.mjs
  var DATA_URI, VERSION;
  var init_const8 = __esm({
    "node_modules/pixi.js/lib/utils/const.mjs"() {
      init_eventemitter3();
      DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
      VERSION = "8.15.0";
    }
  });

  // node_modules/pixi.js/lib/utils/global/globalHooks.mjs
  var ApplicationInitHook, RendererInitHook;
  var init_globalHooks = __esm({
    "node_modules/pixi.js/lib/utils/global/globalHooks.mjs"() {
      init_Extensions();
      init_const8();
      ApplicationInitHook = class {
        static init() {
          var _a2;
          (_a2 = globalThis.__PIXI_APP_INIT__) == null ? void 0 : _a2.call(globalThis, this, VERSION);
        }
        static destroy() {
        }
      };
      ApplicationInitHook.extension = ExtensionType.Application;
      RendererInitHook = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        init() {
          var _a2;
          (_a2 = globalThis.__PIXI_RENDERER_INIT__) == null ? void 0 : _a2.call(globalThis, this._renderer, VERSION);
        }
        destroy() {
          this._renderer = null;
        }
      };
      RendererInitHook.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "initHook",
        priority: -10
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
  var _BatcherPipe, BatcherPipe;
  var init_BatcherPipe = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
      init_Extensions();
      init_State();
      init_DefaultBatcher();
      _BatcherPipe = class _BatcherPipe2 {
        constructor(renderer, adaptor) {
          var _a2, _b;
          this.state = State.for2d();
          this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
          this._activeBatches = /* @__PURE__ */ Object.create(null);
          this.renderer = renderer;
          this._adaptor = adaptor;
          (_b = (_a2 = this._adaptor).init) == null ? void 0 : _b.call(_a2, this);
        }
        static getBatcher(name) {
          return new this._availableBatchers[name]();
        }
        buildStart(instructionSet) {
          let batchers = this._batchersByInstructionSet[instructionSet.uid];
          if (!batchers) {
            batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);
            batchers.default || (batchers.default = new DefaultBatcher({
              maxTextures: this.renderer.limits.maxBatchableTextures
            }));
          }
          this._activeBatches = batchers;
          this._activeBatch = this._activeBatches.default;
          for (const i3 in this._activeBatches) {
            this._activeBatches[i3].begin();
          }
        }
        addToBatch(batchableObject, instructionSet) {
          if (this._activeBatch.name !== batchableObject.batcherName) {
            this._activeBatch.break(instructionSet);
            let batch = this._activeBatches[batchableObject.batcherName];
            if (!batch) {
              batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe2.getBatcher(batchableObject.batcherName);
              batch.begin();
            }
            this._activeBatch = batch;
          }
          this._activeBatch.add(batchableObject);
        }
        break(instructionSet) {
          this._activeBatch.break(instructionSet);
        }
        buildEnd(instructionSet) {
          this._activeBatch.break(instructionSet);
          const batches = this._activeBatches;
          for (const i3 in batches) {
            const batch = batches[i3];
            const geometry = batch.geometry;
            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);
            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);
          }
        }
        upload(instructionSet) {
          const batchers = this._batchersByInstructionSet[instructionSet.uid];
          for (const i3 in batchers) {
            const batcher = batchers[i3];
            const geometry = batcher.geometry;
            if (batcher.dirty) {
              batcher.dirty = false;
              geometry.buffers[0].update(batcher.attributeSize * 4);
            }
          }
        }
        execute(batch) {
          if (batch.action === "startBatch") {
            const batcher = batch.batcher;
            const geometry = batcher.geometry;
            const shader = batcher.shader;
            this._adaptor.start(this, geometry, shader);
          }
          this._adaptor.execute(this, batch);
        }
        destroy() {
          this.state = null;
          this.renderer = null;
          this._adaptor = null;
          for (const i3 in this._activeBatches) {
            this._activeBatches[i3].destroy();
          }
          this._activeBatches = null;
        }
      };
      _BatcherPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "batch"
      };
      _BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);
      BatcherPipe = _BatcherPipe;
      extensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);
      extensions.add(DefaultBatcher);
    }
  });

  // node_modules/pixi.js/lib/filters/mask/mask.frag.mjs
  var fragment3;
  var init_mask_frag = __esm({
    "node_modules/pixi.js/lib/filters/mask/mask.frag.mjs"() {
      fragment3 = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n";
    }
  });

  // node_modules/pixi.js/lib/filters/mask/mask.vert.mjs
  var vertex3;
  var init_mask_vert = __esm({
    "node_modules/pixi.js/lib/filters/mask/mask.vert.mjs"() {
      vertex3 = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
    }
  });

  // node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs
  var source2;
  var init_mask_wgsl = __esm({
    "node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs"() {
      source2 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";
    }
  });

  // node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
  var MaskFilter;
  var init_MaskFilter = __esm({
    "node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs"() {
      init_Matrix();
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_TextureMatrix();
      init_Filter();
      init_mask_frag();
      init_mask_vert();
      init_mask_wgsl();
      MaskFilter = class extends Filter {
        constructor(options) {
          const _a2 = options, { sprite } = _a2, rest = __objRest(_a2, ["sprite"]);
          const textureMatrix = new TextureMatrix(sprite.texture);
          const filterUniforms = new UniformGroup({
            uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
            uAlpha: { value: 1, type: "f32" },
            uInverse: { value: options.inverse ? 1 : 0, type: "f32" }
          });
          const gpuProgram3 = GpuProgram.from({
            vertex: {
              source: source2,
              entryPoint: "mainVertex"
            },
            fragment: {
              source: source2,
              entryPoint: "mainFragment"
            }
          });
          const glProgram3 = GlProgram.from({
            vertex: vertex3,
            fragment: fragment3,
            name: "mask-filter"
          });
          super(__spreadProps(__spreadValues({}, rest), {
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            clipToViewport: false,
            resources: {
              filterUniforms,
              uMaskTexture: sprite.texture.source
            }
          }));
          this.sprite = sprite;
          this._textureMatrix = textureMatrix;
        }
        set inverse(value) {
          this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;
        }
        get inverse() {
          return this.resources.filterUniforms.uniforms.uInverse === 1;
        }
        apply(filterManager, input, output, clearMode) {
          this._textureMatrix.texture = this.sprite.texture;
          filterManager.calculateSpriteMatrix(
            this.resources.filterUniforms.uniforms.uFilterMatrix,
            this.sprite
          ).prepend(this._textureMatrix.mapCoord);
          this.resources.uMaskTexture = this.sprite.texture.source;
          filterManager.applyFilter(this, input, output, clearMode);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
  var tempBounds3, AlphaMaskEffect, AlphaMaskPipe;
  var init_AlphaMaskPipe = __esm({
    "node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_MaskFilter();
      init_Bounds();
      init_getGlobalBounds();
      init_Sprite();
      init_PoolGroup();
      init_Texture();
      init_TexturePool();
      init_types2();
      tempBounds3 = new Bounds();
      AlphaMaskEffect = class extends FilterEffect {
        constructor() {
          super();
          this.filters = [new MaskFilter({
            sprite: new Sprite(Texture.EMPTY),
            inverse: false,
            resolution: "inherit",
            antialias: "inherit"
          })];
        }
        get sprite() {
          return this.filters[0].sprite;
        }
        set sprite(value) {
          this.filters[0].sprite = value;
        }
        get inverse() {
          return this.filters[0].inverse;
        }
        set inverse(value) {
          this.filters[0].inverse = value;
        }
      };
      AlphaMaskPipe = class {
        constructor(renderer) {
          this._activeMaskStage = [];
          this._renderer = renderer;
        }
        push(mask, maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "pushMaskBegin",
            mask,
            inverse: maskedContainer._maskOptions.inverse,
            canBundle: false,
            maskedContainer
          });
          mask.inverse = maskedContainer._maskOptions.inverse;
          if (mask.renderMaskToTexture) {
            const maskContainer = mask.mask;
            maskContainer.includeInBuild = true;
            maskContainer.collectRenderables(
              instructionSet,
              renderer,
              null
            );
            maskContainer.includeInBuild = false;
          }
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "pushMaskEnd",
            mask,
            maskedContainer,
            inverse: maskedContainer._maskOptions.inverse,
            canBundle: false
          });
        }
        pop(mask, _maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "popMaskEnd",
            mask,
            inverse: _maskedContainer._maskOptions.inverse,
            canBundle: false
          });
        }
        execute(instruction) {
          const renderer = this._renderer;
          const renderMask = instruction.mask.renderMaskToTexture;
          if (instruction.action === "pushMaskBegin") {
            const filterEffect = BigPool.get(AlphaMaskEffect);
            filterEffect.inverse = instruction.inverse;
            if (renderMask) {
              instruction.mask.mask.measurable = true;
              const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
              instruction.mask.mask.measurable = false;
              bounds.ceil();
              const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
              const filterTexture = TexturePool.getOptimalTexture(
                bounds.width,
                bounds.height,
                colorTextureSource._resolution,
                colorTextureSource.antialias
              );
              renderer.renderTarget.push(filterTexture, true);
              renderer.globalUniforms.push({
                offset: bounds,
                worldColor: 4294967295
              });
              const sprite = filterEffect.sprite;
              sprite.texture = filterTexture;
              sprite.worldTransform.tx = bounds.minX;
              sprite.worldTransform.ty = bounds.minY;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer,
                filterTexture
              });
            } else {
              filterEffect.sprite = instruction.mask.mask;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer
              });
            }
          } else if (instruction.action === "pushMaskEnd") {
            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
            if (renderMask) {
              if (renderer.type === RendererType.WEBGL) {
                renderer.renderTarget.finishRenderPass();
              }
              renderer.renderTarget.pop();
              renderer.globalUniforms.pop();
            }
            renderer.filter.push({
              renderPipeId: "filter",
              action: "pushFilter",
              container: maskData.maskedContainer,
              filterEffect: maskData.filterEffect,
              canBundle: false
            });
          } else if (instruction.action === "popMaskEnd") {
            renderer.filter.pop();
            const maskData = this._activeMaskStage.pop();
            if (renderMask) {
              TexturePool.returnTexture(maskData.filterTexture);
            }
            BigPool.return(maskData.filterEffect);
          }
        }
        destroy() {
          this._renderer = null;
          this._activeMaskStage = null;
        }
      };
      AlphaMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "alphaMask"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
  var ColorMaskPipe;
  var init_ColorMaskPipe = __esm({
    "node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
      init_Extensions();
      ColorMaskPipe = class {
        constructor(renderer) {
          this._colorStack = [];
          this._colorStackIndex = 0;
          this._currentColor = 0;
          this._renderer = renderer;
        }
        buildStart() {
          this._colorStack[0] = 15;
          this._colorStackIndex = 1;
          this._currentColor = 15;
        }
        push(mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
          const currentColor = this._colorStack[this._colorStackIndex];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              renderPipeId: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
          this._colorStackIndex++;
        }
        pop(_mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          this._colorStackIndex--;
          const currentColor = colorStack[this._colorStackIndex - 1];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              renderPipeId: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
        }
        execute(instruction) {
          const renderer = this._renderer;
          renderer.colorMask.setMask(instruction.colorMask);
        }
        destroy() {
          this._renderer = null;
          this._colorStack = null;
        }
      };
      ColorMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
  var StencilMaskPipe;
  var init_StencilMaskPipe = __esm({
    "node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
      init_Extensions();
      init_const7();
      init_const3();
      StencilMaskPipe = class {
        constructor(renderer) {
          this._maskStackHash = {};
          this._maskHash = /* @__PURE__ */ new WeakMap();
          this._renderer = renderer;
        }
        push(mask, _container, instructionSet) {
          var _a3;
          var _a2;
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "pushMaskBegin",
            mask,
            inverse: _container._maskOptions.inverse,
            canBundle: false
          });
          const maskContainer = effect.mask;
          maskContainer.includeInBuild = true;
          if (!this._maskHash.has(effect)) {
            this._maskHash.set(effect, {
              instructionsStart: 0,
              instructionsLength: 0
            });
          }
          const maskData = this._maskHash.get(effect);
          maskData.instructionsStart = instructionSet.instructionSize;
          maskContainer.collectRenderables(
            instructionSet,
            renderer,
            null
          );
          maskContainer.includeInBuild = false;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "pushMaskEnd",
            mask,
            inverse: _container._maskOptions.inverse,
            canBundle: false
          });
          const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
          maskData.instructionsLength = instructionsLength;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          (_a3 = (_a2 = this._maskStackHash)[renderTargetUid]) != null ? _a3 : _a2[renderTargetUid] = 0;
        }
        pop(mask, _container, instructionSet) {
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "popMaskBegin",
            inverse: _container._maskOptions.inverse,
            canBundle: false
          });
          const maskData = this._maskHash.get(mask);
          for (let i3 = 0; i3 < maskData.instructionsLength; i3++) {
            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
          }
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "popMaskEnd",
            canBundle: false
          });
        }
        execute(instruction) {
          var _a3;
          var _a2;
          const renderer = this._renderer;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          let maskStackIndex = (_a3 = (_a2 = this._maskStackHash)[renderTargetUid]) != null ? _a3 : _a2[renderTargetUid] = 0;
          if (instruction.action === "pushMaskBegin") {
            renderer.renderTarget.ensureDepthStencil();
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
            maskStackIndex++;
            renderer.colorMask.setMask(0);
          } else if (instruction.action === "pushMaskEnd") {
            if (instruction.inverse) {
              renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
            } else {
              renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            }
            renderer.colorMask.setMask(15);
          } else if (instruction.action === "popMaskBegin") {
            renderer.colorMask.setMask(0);
            if (maskStackIndex !== 0) {
              renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
            } else {
              renderer.renderTarget.clear(null, CLEAR.STENCIL);
              renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
            }
            maskStackIndex--;
          } else if (instruction.action === "popMaskEnd") {
            if (instruction.inverse) {
              renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
            } else {
              renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            }
            renderer.colorMask.setMask(15);
          }
          this._maskStackHash[renderTargetUid] = maskStackIndex;
        }
        destroy() {
          this._renderer = null;
          this._maskStackHash = null;
          this._maskHash = null;
        }
      };
      StencilMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "stencilMask"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
  var _BackgroundSystem, BackgroundSystem;
  var init_BackgroundSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
      init_Color();
      init_Extensions();
      init_warn();
      _BackgroundSystem = class _BackgroundSystem2 {
        constructor() {
          this.clearBeforeRender = true;
          this._backgroundColor = new Color(0);
          this.color = this._backgroundColor;
          this.alpha = 1;
        }
        /**
         * initiates the background system
         * @param options - the options for the background colors
         */
        init(options) {
          options = __spreadValues(__spreadValues({}, _BackgroundSystem2.defaultOptions), options);
          this.clearBeforeRender = options.clearBeforeRender;
          this.color = options.background || options.backgroundColor || this._backgroundColor;
          this.alpha = options.backgroundAlpha;
          this._backgroundColor.setAlpha(options.backgroundAlpha);
        }
        /** The background color to fill if not transparent */
        get color() {
          return this._backgroundColor;
        }
        set color(value) {
          const incoming = Color.shared.setValue(value);
          if (incoming.alpha < 1 && this._backgroundColor.alpha === 1) {
            warn(
              "Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application."
            );
          }
          this._backgroundColor.setValue(value);
        }
        /** The background color alpha. Setting this to 0 will make the canvas transparent. */
        get alpha() {
          return this._backgroundColor.alpha;
        }
        set alpha(value) {
          this._backgroundColor.setAlpha(value);
        }
        /** The background color as an [R, G, B, A] array. */
        get colorRgba() {
          return this._backgroundColor.toArray();
        }
        /**
         * destroys the background system
         * @internal
         */
        destroy() {
        }
      };
      _BackgroundSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "background",
        priority: 0
      };
      _BackgroundSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.backgroundAlpha}
         * @default 1
         */
        backgroundAlpha: 1,
        /**
         * {@link WebGLOptions.backgroundColor}
         * @default 0x000000
         */
        backgroundColor: 0,
        /**
         * {@link WebGLOptions.clearBeforeRender}
         * @default true
         */
        clearBeforeRender: true
      };
      BackgroundSystem = _BackgroundSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
  var BLEND_MODE_FILTERS, BlendModePipe;
  var init_BlendModePipe = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_RenderGroup();
      init_warn();
      BLEND_MODE_FILTERS = {};
      extensions.handle(ExtensionType.BlendMode, (value) => {
        if (!value.name) {
          throw new Error("BlendMode extension must have a name property");
        }
        BLEND_MODE_FILTERS[value.name] = value.ref;
      }, (value) => {
        delete BLEND_MODE_FILTERS[value.name];
      });
      BlendModePipe = class {
        constructor(renderer) {
          this._blendModeStack = [];
          this._isAdvanced = false;
          this._filterHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._renderer.runners.prerender.add(this);
        }
        prerender() {
          this._activeBlendMode = "normal";
          this._isAdvanced = false;
        }
        /**
         * Push a blend mode onto the internal stack and apply it to the instruction set if needed.
         * @param renderable - The renderable or {@link RenderGroup} associated with the change.
         * @param blendMode - The blend mode to activate.
         * @param instructionSet - The instruction set being built.
         */
        pushBlendMode(renderable, blendMode, instructionSet) {
          this._blendModeStack.push(blendMode);
          this.setBlendMode(renderable, blendMode, instructionSet);
        }
        /**
         * Pop the last blend mode from the stack and apply the new top-of-stack mode.
         * @param instructionSet - The instruction set being built.
         */
        popBlendMode(instructionSet) {
          var _a2;
          this._blendModeStack.pop();
          const blendMode = (_a2 = this._blendModeStack[this._activeBlendMode.length - 1]) != null ? _a2 : "normal";
          this.setBlendMode(null, blendMode, instructionSet);
        }
        /**
         * Ensure a blend mode switch is added to the instruction set when the mode changes.
         * If an advanced blend mode is active, subsequent renderables will be collected so they can be
         * rendered within a single filter pass.
         * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.
         * @param blendMode - The target blend mode.
         * @param instructionSet - The instruction set being built.
         */
        setBlendMode(renderable, blendMode, instructionSet) {
          var _a2;
          const isRenderGroup = renderable instanceof RenderGroup;
          if (this._activeBlendMode === blendMode) {
            if (this._isAdvanced && renderable && !isRenderGroup) {
              (_a2 = this._renderableList) == null ? void 0 : _a2.push(renderable);
            }
            return;
          }
          if (this._isAdvanced)
            this._endAdvancedBlendMode(instructionSet);
          this._activeBlendMode = blendMode;
          if (!renderable)
            return;
          this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
          if (this._isAdvanced)
            this._beginAdvancedBlendMode(renderable, instructionSet);
        }
        _beginAdvancedBlendMode(renderable, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          const blendMode = this._activeBlendMode;
          if (!BLEND_MODE_FILTERS[blendMode]) {
            warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
            return;
          }
          const filterEffect = this._ensureFilterEffect(blendMode);
          const isRenderGroup = renderable instanceof RenderGroup;
          const instruction = {
            renderPipeId: "filter",
            action: "pushFilter",
            filterEffect,
            renderables: isRenderGroup ? null : [renderable],
            container: isRenderGroup ? renderable.root : null,
            canBundle: false
          };
          this._renderableList = instruction.renderables;
          instructionSet.add(instruction);
        }
        _ensureFilterEffect(blendMode) {
          let filterEffect = this._filterHash[blendMode];
          if (!filterEffect) {
            filterEffect = this._filterHash[blendMode] = new FilterEffect();
            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
          }
          return filterEffect;
        }
        _endAdvancedBlendMode(instructionSet) {
          this._isAdvanced = false;
          this._renderableList = null;
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        /**
         * called when the instruction build process is starting this will reset internally to the default blend mode
         * @internal
         */
        buildStart() {
          this._isAdvanced = false;
        }
        /**
         * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
         * active, we add the final render instructions added to the instruction set
         * @param instructionSet - The instruction set we are adding to
         * @internal
         */
        buildEnd(instructionSet) {
          if (!this._isAdvanced)
            return;
          this._endAdvancedBlendMode(instructionSet);
        }
        /** @internal */
        destroy() {
          this._renderer = null;
          this._renderableList = null;
          for (const i3 in this._filterHash) {
            this._filterHash[i3].destroy();
          }
          this._filterHash = null;
        }
      };
      BlendModePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "blendMode"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
  var imageTypes, _ExtractSystem, ExtractSystem;
  var init_ExtractSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_Container();
      init_Texture();
      imageTypes = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
      };
      _ExtractSystem = class _ExtractSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._renderer = renderer;
        }
        _normalizeOptions(options, defaults2 = {}) {
          if (options instanceof Container || options instanceof Texture) {
            return __spreadValues({
              target: options
            }, defaults2);
          }
          return __spreadValues(__spreadValues({}, defaults2), options);
        }
        /**
         * Creates an IImage from a display object or texture.
         * @param options - Options for creating the image, or the target to extract
         * @returns Promise that resolves with the generated IImage
         * @example
         * ```ts
         * // Basic usage with a sprite
         * const sprite = new Sprite(texture);
         * const image = await renderer.extract.image(sprite);
         * document.body.appendChild(image);
         *
         * // Advanced usage with options
         * const image = await renderer.extract.image({
         *     target: container,
         *     format: 'webp',
         *     quality: 0.8,
         *     frame: new Rectangle(0, 0, 100, 100),
         *     resolution: 2,
         *     clearColor: '#ff0000',
         *     antialias: true
         * });
         *
         * // Extract directly from a texture
         * const texture = Texture.from('myTexture.png');
         * const image = await renderer.extract.image(texture);
         * ```
         * @see {@link ExtractImageOptions} For detailed options
         * @see {@link ExtractSystem.base64} For base64 string output
         * @see {@link ExtractSystem.canvas} For canvas output
         * @see {@link ImageLike} For the image interface
         * @category rendering
         */
        image(options) {
          return __async(this, null, function* () {
            const image = DOMAdapter.get().createImage();
            image.src = yield this.base64(options);
            return image;
          });
        }
        /**
         * Converts the target into a base64 encoded string.
         *
         * This method works by first creating
         * a canvas using `Extract.canvas` and then converting it to a base64 string.
         * @param options - The options for creating the base64 string, or the target to extract
         * @returns Promise that resolves with the base64 encoded string
         * @example
         * ```ts
         * // Basic usage with a sprite
         * const sprite = new Sprite(texture);
         * const base64 = await renderer.extract.base64(sprite);
         * console.log(base64); // data:image/png;base64,...
         *
         * // Advanced usage with options
         * const base64 = await renderer.extract.base64({
         *     target: container,
         *     format: 'webp',
         *     quality: 0.8,
         *     frame: new Rectangle(0, 0, 100, 100),
         *     resolution: 2
         * });
         * ```
         * @throws Will throw an error if the platform doesn't support any of:
         * - ICanvas.toDataURL
         * - ICanvas.toBlob
         * - ICanvas.convertToBlob
         * @see {@link ExtractImageOptions} For detailed options
         * @see {@link ExtractSystem.canvas} For canvas output
         * @see {@link ExtractSystem.image} For HTMLImage output
         * @category rendering
         */
        base64(options) {
          return __async(this, null, function* () {
            options = this._normalizeOptions(
              options,
              _ExtractSystem2.defaultImageOptions
            );
            const { format, quality } = options;
            const canvas = this.canvas(options);
            if (canvas.toBlob !== void 0) {
              return new Promise((resolve, reject) => {
                canvas.toBlob((blob) => {
                  if (!blob) {
                    reject(new Error("ICanvas.toBlob failed!"));
                    return;
                  }
                  const reader = new FileReader();
                  reader.onload = () => resolve(reader.result);
                  reader.onerror = reject;
                  reader.readAsDataURL(blob);
                }, imageTypes[format], quality);
              });
            }
            if (canvas.toDataURL !== void 0) {
              return canvas.toDataURL(imageTypes[format], quality);
            }
            if (canvas.convertToBlob !== void 0) {
              const blob = yield canvas.convertToBlob({ type: imageTypes[format], quality });
              return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              });
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
          });
        }
        /**
         * Creates a Canvas element, renders the target to it and returns it.
         * This method is useful for creating static images or when you need direct canvas access.
         * @param options - The options for creating the canvas, or the target to extract
         * @returns A Canvas element with the texture rendered on
         * @example
         * ```ts
         * // Basic canvas extraction from a sprite
         * const sprite = new Sprite(texture);
         * const canvas = renderer.extract.canvas(sprite);
         * document.body.appendChild(canvas);
         *
         * // Extract with custom region
         * const canvas = renderer.extract.canvas({
         *     target: container,
         *     frame: new Rectangle(0, 0, 100, 100)
         * });
         *
         * // Extract with high resolution
         * const canvas = renderer.extract.canvas({
         *     target: sprite,
         *     resolution: 2,
         *     clearColor: '#ff0000'
         * });
         *
         * // Extract directly from a texture
         * const texture = Texture.from('myTexture.png');
         * const canvas = renderer.extract.canvas(texture);
         *
         * // Extract with anti-aliasing
         * const canvas = renderer.extract.canvas({
         *     target: graphics,
         *     antialias: true
         * });
         * ```
         * @see {@link ExtractOptions} For detailed options
         * @see {@link ExtractSystem.image} For HTMLImage output
         * @see {@link ExtractSystem.pixels} For raw pixel data
         * @category rendering
         */
        canvas(options) {
          options = this._normalizeOptions(options);
          const target = options.target;
          const renderer = this._renderer;
          if (target instanceof Texture) {
            return renderer.texture.generateCanvas(target);
          }
          const texture = renderer.textureGenerator.generateTexture(options);
          const canvas = renderer.texture.generateCanvas(texture);
          texture.destroy(true);
          return canvas;
        }
        /**
         * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,
         * with integer values between 0 and 255 (inclusive).
         * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA
         * @param options - The options for extracting the image, or the target to extract
         * @returns One-dimensional Uint8Array containing the pixel data in RGBA format
         * @example
         * ```ts
         * // Basic pixel extraction
         * const sprite = new Sprite(texture);
         * const pixels = renderer.extract.pixels(sprite);
         * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values
         *
         * // Extract with custom region
         * const pixels = renderer.extract.pixels({
         *     target: sprite,
         *     frame: new Rectangle(0, 0, 100, 100)
         * });
         *
         * // Extract with high resolution
         * const pixels = renderer.extract.pixels({
         *     target: sprite,
         *     resolution: 2
         * });
         * ```
         * @see {@link ExtractOptions} For detailed options
         * @see {@link ExtractSystem.canvas} For canvas output
         * @see {@link ExtractSystem.image} For image output
         * @category rendering
         */
        pixels(options) {
          options = this._normalizeOptions(options);
          const target = options.target;
          const renderer = this._renderer;
          const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
          const pixelInfo = renderer.texture.getPixels(texture);
          if (target instanceof Container) {
            texture.destroy(true);
          }
          return pixelInfo;
        }
        /**
         * Creates a texture from a display object or existing texture.
         *
         * This is useful for creating
         * reusable textures from rendered content or making copies of existing textures.
         * > [!NOTE] The returned texture should be destroyed when no longer needed
         * @param options - The options for creating the texture, or the target to extract
         * @returns A new texture containing the extracted content
         * @example
         * ```ts
         * // Basic texture extraction from a sprite
         * const sprite = new Sprite(texture);
         * const extractedTexture = renderer.extract.texture(sprite);
         *
         * // Extract with custom region
         * const regionTexture = renderer.extract.texture({
         *     target: container,
         *     frame: new Rectangle(0, 0, 100, 100)
         * });
         *
         * // Extract with high resolution
         * const hiResTexture = renderer.extract.texture({
         *     target: sprite,
         *     resolution: 2,
         *     clearColor: '#ff0000'
         * });
         *
         * // Create a new sprite from extracted texture
         * const newSprite = new Sprite(
         *     renderer.extract.texture({
         *         target: graphics,
         *         antialias: true
         *     })
         * );
         *
         * // Clean up when done
         * extractedTexture.destroy(true);
         * ```
         * @see {@link ExtractOptions} For detailed options
         * @see {@link Texture} For texture management
         * @see {@link GenerateTextureSystem} For texture generation
         * @category rendering
         */
        texture(options) {
          options = this._normalizeOptions(options);
          if (options.target instanceof Texture)
            return options.target;
          return this._renderer.textureGenerator.generateTexture(options);
        }
        /**
         * Extracts and downloads content from the renderer as an image file.
         * This is a convenient way to save screenshots or export rendered content.
         * > [!NOTE] The download will use PNG format regardless of the filename extension
         * @param options - The options for downloading and extracting the image, or the target to extract
         * @example
         * ```ts
         * // Basic download with default filename
         * const sprite = new Sprite(texture);
         * renderer.extract.download(sprite); // Downloads as 'image.png'
         *
         * // Download with custom filename
         * renderer.extract.download({
         *     target: sprite,
         *     filename: 'screenshot.png'
         * });
         *
         * // Download with custom region
         * renderer.extract.download({
         *     target: container,
         *     filename: 'region.png',
         *     frame: new Rectangle(0, 0, 100, 100)
         * });
         *
         * // Download with high resolution and background
         * renderer.extract.download({
         *     target: stage,
         *     filename: 'hd-screenshot.png',
         *     resolution: 2,
         *     clearColor: '#ff0000'
         * });
         *
         * // Download with anti-aliasing
         * renderer.extract.download({
         *     target: graphics,
         *     filename: 'smooth.png',
         *     antialias: true
         * });
         * ```
         * @see {@link ExtractDownloadOptions} For detailed options
         * @see {@link ExtractSystem.image} For creating images without download
         * @see {@link ExtractSystem.canvas} For canvas output
         * @category rendering
         */
        download(options) {
          var _a2;
          options = this._normalizeOptions(options);
          const canvas = this.canvas(options);
          const link = document.createElement("a");
          link.download = (_a2 = options.filename) != null ? _a2 : "image.png";
          link.href = canvas.toDataURL("image/png");
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
        /**
         * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
         * The image will be displayed in the browser's console using CSS background images.
         * @param options - The options for logging the image, or the target to log
         * @param options.width - The width of the logged image preview in the console (in pixels)
         * @example
         * ```ts
         * // Basic usage
         * const sprite = new Sprite(texture);
         * renderer.extract.log(sprite);
         * ```
         * @see {@link ExtractSystem.canvas} For getting raw canvas output
         * @see {@link ExtractSystem.pixels} For raw pixel data
         * @category rendering
         * @advanced
         */
        log(options) {
          var _a2;
          const width = (_a2 = options.width) != null ? _a2 : 200;
          options = this._normalizeOptions(options);
          const canvas = this.canvas(options);
          const base64 = canvas.toDataURL();
          console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
          const style = [
            "font-size: 1px;",
            `padding: ${width}px ${300}px;`,
            `background: url(${base64}) no-repeat;`,
            "background-size: contain;"
          ].join(" ");
          console.log("%c ", style);
        }
        destroy() {
          this._renderer = null;
        }
      };
      _ExtractSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "extract"
      };
      _ExtractSystem.defaultImageOptions = {
        format: "png",
        quality: 1
      };
      ExtractSystem = _ExtractSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
  var RenderTexture;
  var init_RenderTexture = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
      init_TextureSource();
      init_Texture();
      RenderTexture = class _RenderTexture extends Texture {
        /**
         * Creates a RenderTexture. Pass `dynamic: true` in options to allow resizing after creation.
         * @param options - Options for the RenderTexture, including width, height, and dynamic.
         * @returns A new RenderTexture instance.
         * @example
         * const rt = RenderTexture.create({ width: 100, height: 100, dynamic: true });
         * rt.resize(500, 500);
         */
        static create(options) {
          const _a2 = options, { dynamic } = _a2, rest = __objRest(_a2, ["dynamic"]);
          return new _RenderTexture({
            source: new TextureSource(rest),
            dynamic: dynamic != null ? dynamic : false
          });
        }
        /**
         * Resizes the render texture.
         * @param width - The new width of the render texture.
         * @param height - The new height of the render texture.
         * @param resolution - The new resolution of the render texture.
         * @returns This texture.
         */
        resize(width, height, resolution) {
          this.source.resize(width, height, resolution);
          return this;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
  var tempRect5, tempBounds4, noColor, GenerateTextureSystem;
  var init_GenerateTextureSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
      init_Color();
      init_Extensions();
      init_Matrix();
      init_Rectangle();
      init_Bounds();
      init_getLocalBounds();
      init_Container();
      init_RenderTexture();
      tempRect5 = new Rectangle();
      tempBounds4 = new Bounds();
      noColor = [0, 0, 0, 0];
      GenerateTextureSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        /**
         * Creates a texture from a display object that can be used for creating sprites and other textures.
         * This is particularly useful for optimizing performance when a complex container needs to be reused.
         * @param options - Generate texture options or a container to convert to texture
         * @returns A new RenderTexture containing the rendered display object
         * @example
         * ```ts
         * // Basic usage with a container
         * const container = new Container();
         * container.addChild(
         *     new Graphics()
         *         .circle(0, 0, 50)
         *         .fill('red')
         * );
         *
         * const texture = renderer.textureGenerator.generateTexture(container);
         *
         * // Advanced usage with options
         * const texture = renderer.textureGenerator.generateTexture({
         *     target: container,
         *     frame: new Rectangle(0, 0, 100, 100), // Specific region
         *     resolution: 2,                        // High DPI
         *     clearColor: '#ff0000',               // Red background
         *     antialias: true                      // Smooth edges
         * });
         *
         * // Create a sprite from the generated texture
         * const sprite = new Sprite(texture);
         *
         * // Clean up when done
         * texture.destroy(true);
         * ```
         * @see {@link GenerateTextureOptions} For detailed texture generation options
         * @see {@link RenderTexture} For the type of texture created
         * @category rendering
         */
        generateTexture(options) {
          var _a2;
          if (options instanceof Container) {
            options = {
              target: options,
              frame: void 0,
              textureSourceOptions: {},
              resolution: void 0
            };
          }
          const resolution = options.resolution || this._renderer.resolution;
          const antialias = options.antialias || this._renderer.view.antialias;
          const container = options.target;
          let clearColor = options.clearColor;
          if (clearColor) {
            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
          } else {
            clearColor = noColor;
          }
          const region = ((_a2 = options.frame) == null ? void 0 : _a2.copyTo(tempRect5)) || getLocalBounds(container, tempBounds4).rectangle;
          region.width = Math.max(region.width, 1 / resolution) | 0;
          region.height = Math.max(region.height, 1 / resolution) | 0;
          const target = RenderTexture.create(__spreadProps(__spreadValues({}, options.textureSourceOptions), {
            width: region.width,
            height: region.height,
            resolution,
            antialias
          }));
          const transform2 = Matrix.shared.translate(-region.x, -region.y);
          this._renderer.render({
            container,
            transform: transform2,
            target,
            clearColor
          });
          target.source.updateMipmaps();
          return target;
        }
        destroy() {
          this._renderer = null;
        }
      };
      GenerateTextureSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "textureGenerator"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/GCSystem.mjs
  var _GCSystem, GCSystem;
  var init_GCSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/GCSystem.mjs"() {
      init_Extensions();
      _GCSystem = class _GCSystem2 {
        /**
         * Creates a new GCSystem instance.
         * @param renderer - The renderer this garbage collection system works for
         */
        constructor(renderer) {
          this._managedResources = [];
          this._managedResourceHashes = [];
          this._ready = false;
          this._renderer = renderer;
        }
        /**
         * Initializes the garbage collection system with the provided options.
         * @param options - Configuration options
         */
        init(options) {
          options = __spreadValues(__spreadValues({}, _GCSystem2.defaultOptions), options);
          this.maxUnusedTime = options.gcMaxUnusedTime;
          this._frequency = options.gcFrequency;
          this.enabled = options.gcActive;
          this.now = performance.now();
        }
        /**
         * Gets whether the garbage collection system is currently enabled.
         * @returns True if GC is enabled, false otherwise
         */
        get enabled() {
          return !!this._handler;
        }
        /**
         * Enables or disables the garbage collection system.
         * When enabled, schedules periodic cleanup of resources.
         * When disabled, cancels all scheduled cleanups.
         */
        set enabled(value) {
          if (this.enabled === value)
            return;
          if (value) {
            this._handler = this._renderer.scheduler.repeat(
              () => {
                this._ready = true;
              },
              this._frequency,
              false
            );
          } else {
            this._renderer.scheduler.cancel(this._handler);
            this._handler = 0;
          }
        }
        /**
         * Called before rendering. Updates the current timestamp.
         * @param options - The render options
         * @param options.container - The container to render
         */
        prerender({ container }) {
          this.now = performance.now();
          container.renderGroup.gcTick = this._renderer.tick++;
          this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);
        }
        /** Performs garbage collection after rendering. */
        postrender() {
          if (!this._ready || !this.enabled)
            return;
          this.run();
          this._ready = false;
        }
        /**
         * Updates the GC tick counter for a render group and its children.
         * @param renderGroup - The render group to update
         * @param gcTick - The new tick value
         */
        _updateInstructionGCTick(renderGroup, gcTick) {
          renderGroup.instructionSet.gcTick = gcTick;
          for (const child of renderGroup.renderGroupChildren) {
            this._updateInstructionGCTick(child, gcTick);
          }
        }
        /**
         * Registers a resource for garbage collection tracking.
         * @param resource - The resource to track
         * @param type - The type of resource to track
         */
        addResource(resource, type) {
          var _a2, _b;
          if (resource._gcLastUsed !== -1) {
            resource._gcLastUsed = this.now;
            (_a2 = resource._onTouch) == null ? void 0 : _a2.call(resource, this.now);
            return;
          }
          const index = this._managedResources.length;
          resource._gcData = {
            index,
            type
          };
          resource._gcLastUsed = this.now;
          (_b = resource._onTouch) == null ? void 0 : _b.call(resource, this.now);
          resource.once("unload", this.removeResource, this);
          this._managedResources.push(resource);
        }
        /**
         * Removes a resource from garbage collection tracking.
         * Call this when manually destroying a resource.
         * @param resource - The resource to stop tracking
         */
        removeResource(resource) {
          const gcData = resource._gcData;
          if (!gcData)
            return;
          const index = gcData.index;
          const last = this._managedResources.length - 1;
          if (index !== last) {
            const lastResource = this._managedResources[last];
            this._managedResources[index] = lastResource;
            lastResource._gcData.index = index;
          }
          this._managedResources.length--;
          resource._gcData = null;
          resource._gcLastUsed = -1;
        }
        /**
         * Registers a hash-based resource collection for garbage collection tracking.
         * Resources in the hash will be automatically tracked and cleaned up when unused.
         * @param context - The object containing the hash property
         * @param hash - The property name on context that holds the resource hash
         * @param type - The type of resources in the hash ('resource' or 'renderable')
         * @param priority - Processing priority (lower values are processed first)
         */
        addResourceHash(context4, hash, type, priority = 0) {
          this._managedResourceHashes.push({
            context: context4,
            hash,
            type,
            priority
          });
          this._managedResourceHashes.sort((a2, b2) => a2.priority - b2.priority);
        }
        /**
         * Performs garbage collection by cleaning up unused resources.
         * Removes resources that haven't been used for longer than maxUnusedTime.
         */
        run() {
          const now = performance.now();
          const managedResourceHashes = this._managedResourceHashes;
          for (const hashEntry of managedResourceHashes) {
            this.runOnHash(hashEntry, now);
          }
          let writeIndex = 0;
          for (let i3 = 0; i3 < this._managedResources.length; i3++) {
            const resource = this._managedResources[i3];
            writeIndex = this.runOnResource(resource, now, writeIndex);
          }
          this._managedResources.length = writeIndex;
        }
        updateRenderableGCTick(renderable, now) {
          var _a2, _b, _c, _d, _e;
          const renderGroup = (_a2 = renderable.renderGroup) != null ? _a2 : renderable.parentRenderGroup;
          const currentTick = (_c = (_b = renderGroup == null ? void 0 : renderGroup.instructionSet) == null ? void 0 : _b.gcTick) != null ? _c : -1;
          if (((_d = renderGroup == null ? void 0 : renderGroup.gcTick) != null ? _d : 0) === currentTick) {
            renderable._gcLastUsed = now;
            (_e = renderable._onTouch) == null ? void 0 : _e.call(renderable, now);
          }
        }
        runOnResource(resource, now, writeIndex) {
          const gcData = resource._gcData;
          if (gcData.type === "renderable") {
            this.updateRenderableGCTick(resource, now);
          }
          const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;
          if (isRecentlyUsed || !resource.autoGarbageCollect) {
            this._managedResources[writeIndex] = resource;
            gcData.index = writeIndex;
            writeIndex++;
          } else {
            resource.unload();
            resource._gcData = null;
            resource._gcLastUsed = -1;
            resource.off("unload", this.removeResource, this);
          }
          return writeIndex;
        }
        /**
         * Creates a clone of the hash, copying all non-null entries up to (but not including) the stop key.
         * @param hashValue - The original hash to clone from
         * @param stopKey - The key to stop at (exclusive)
         * @returns A new hash object with copied entries
         */
        _createHashClone(hashValue, stopKey) {
          const hashClone = /* @__PURE__ */ Object.create(null);
          for (const k2 in hashValue) {
            if (k2 === stopKey)
              break;
            if (hashValue[k2] !== null)
              hashClone[k2] = hashValue[k2];
          }
          return hashClone;
        }
        runOnHash(hashEntry, now) {
          var _a2;
          const { context: context4, hash, type } = hashEntry;
          const hashValue = context4[hash];
          let hashClone = null;
          let nullCount = 0;
          for (const key in hashValue) {
            const resource = hashValue[key];
            if (resource === null) {
              nullCount++;
              if (nullCount === 1e4 && !hashClone) {
                hashClone = this._createHashClone(hashValue, key);
              }
              continue;
            }
            if (resource._gcLastUsed === -1) {
              resource._gcLastUsed = now;
              (_a2 = resource._onTouch) == null ? void 0 : _a2.call(resource, now);
              if (hashClone)
                hashClone[key] = resource;
              continue;
            }
            if (type === "renderable") {
              this.updateRenderableGCTick(resource, now);
            }
            const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;
            if (!isRecentlyUsed && resource.autoGarbageCollect) {
              if (!hashClone) {
                if (nullCount + 1 !== 1e4) {
                  hashValue[key] = null;
                  nullCount++;
                } else {
                  hashClone = this._createHashClone(hashValue, key);
                }
              }
              resource.unload();
              resource._gcData = null;
              resource._gcLastUsed = -1;
            } else if (hashClone) {
              hashClone[key] = resource;
            }
          }
          if (hashClone) {
            context4[hash] = hashClone;
          }
        }
        /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */
        destroy() {
          this.enabled = false;
          this._managedResources.forEach((resource) => {
            resource.off("unload", this.removeResource, this);
          });
          this._managedResources.length = 0;
          this._managedResourceHashes.length = 0;
          this._renderer = null;
        }
      };
      _GCSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "gc",
        priority: 0
      };
      _GCSystem.defaultOptions = {
        /** Enable/disable the garbage collector */
        gcActive: true,
        /** Time in ms before an unused resource is collected (default 1 minute) */
        gcMaxUnusedTime: 6e4,
        /** How often to run garbage collection in ms (default 30 seconds) */
        gcFrequency: 3e4
      };
      GCSystem = _GCSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
  var GlobalUniformSystem;
  var init_GlobalUniformSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_Point();
      init_colorToUniform();
      init_BindGroup();
      init_types2();
      init_UniformGroup();
      GlobalUniformSystem = class {
        constructor(renderer) {
          this._stackIndex = 0;
          this._globalUniformDataStack = [];
          this._uniformsPool = [];
          this._activeUniforms = [];
          this._bindGroupPool = [];
          this._activeBindGroups = [];
          this._renderer = renderer;
        }
        reset() {
          this._stackIndex = 0;
          for (let i3 = 0; i3 < this._activeUniforms.length; i3++) {
            this._uniformsPool.push(this._activeUniforms[i3]);
          }
          for (let i3 = 0; i3 < this._activeBindGroups.length; i3++) {
            this._bindGroupPool.push(this._activeBindGroups[i3]);
          }
          this._activeUniforms.length = 0;
          this._activeBindGroups.length = 0;
        }
        start(options) {
          this.reset();
          this.push(options);
        }
        bind({
          size,
          projectionMatrix,
          worldTransformMatrix,
          worldColor,
          offset
        }) {
          const renderTarget = this._renderer.renderTarget.renderTarget;
          const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
            projectionData: renderTarget,
            worldTransformMatrix: new Matrix(),
            worldColor: 4294967295,
            offset: new Point()
          };
          const globalUniformData = {
            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
            resolution: size || renderTarget.size,
            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
            worldColor: worldColor || currentGlobalUniformData.worldColor,
            offset: offset || currentGlobalUniformData.offset,
            bindGroup: null
          };
          const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
          this._activeUniforms.push(uniformGroup);
          const uniforms = uniformGroup.uniforms;
          uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
          uniforms.uResolution = globalUniformData.resolution;
          uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
          uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
          uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
          color32BitToUniform(
            globalUniformData.worldColor,
            uniforms.uWorldColorAlpha,
            0
          );
          uniformGroup.update();
          let bindGroup;
          if (this._renderer.renderPipes.uniformBatch) {
            bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
          } else {
            bindGroup = this._bindGroupPool.pop() || new BindGroup();
            this._activeBindGroups.push(bindGroup);
            bindGroup.setResource(uniformGroup, 0);
          }
          globalUniformData.bindGroup = bindGroup;
          this._currentGlobalUniformData = globalUniformData;
        }
        push(options) {
          this.bind(options);
          this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
        }
        pop() {
          this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
          if (this._renderer.type === RendererType.WEBGL) {
            this._currentGlobalUniformData.bindGroup.resources[0].update();
          }
        }
        get bindGroup() {
          return this._currentGlobalUniformData.bindGroup;
        }
        get globalUniformData() {
          return this._currentGlobalUniformData;
        }
        get uniformGroup() {
          return this._currentGlobalUniformData.bindGroup.resources[0];
        }
        _createUniforms() {
          const globalUniforms = new UniformGroup({
            uProjectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uWorldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
            uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
            uResolution: { value: [0, 0], type: "vec2<f32>" }
          }, {
            isStatic: true
          });
          return globalUniforms;
        }
        destroy() {
          this._renderer = null;
          this._globalUniformDataStack.length = 0;
          this._uniformsPool.length = 0;
          this._activeUniforms.length = 0;
          this._bindGroupPool.length = 0;
          this._activeBindGroups.length = 0;
          this._currentGlobalUniformData = null;
        }
      };
      GlobalUniformSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "globalUniforms"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs
  var uid3, SchedulerSystem;
  var init_SchedulerSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs"() {
      init_Extensions();
      init_Ticker();
      uid3 = 1;
      SchedulerSystem = class {
        constructor() {
          this._tasks = [];
          this._offset = 0;
        }
        /** Initializes the scheduler system and starts the ticker. */
        init() {
          Ticker.system.add(this._update, this);
        }
        /**
         * Schedules a repeating task.
         * @param func - The function to execute.
         * @param duration - The interval duration in milliseconds.
         * @param useOffset - this will spread out tasks so that they do not all run at the same time
         * @returns The unique identifier for the scheduled task.
         */
        repeat(func, duration, useOffset = true) {
          const id = uid3++;
          let offset = 0;
          if (useOffset) {
            this._offset += 1e3;
            offset = this._offset;
          }
          this._tasks.push({
            func,
            duration,
            start: performance.now(),
            offset,
            last: performance.now(),
            repeat: true,
            id
          });
          return id;
        }
        /**
         * Cancels a scheduled task.
         * @param id - The unique identifier of the task to cancel.
         */
        cancel(id) {
          for (let i3 = 0; i3 < this._tasks.length; i3++) {
            if (this._tasks[i3].id === id) {
              this._tasks.splice(i3, 1);
              return;
            }
          }
        }
        /**
         * Updates and executes the scheduled tasks.
         * @private
         */
        _update() {
          const now = performance.now();
          for (let i3 = 0; i3 < this._tasks.length; i3++) {
            const task = this._tasks[i3];
            if (now - task.offset - task.last >= task.duration) {
              const elapsed = now - task.start;
              task.func(elapsed);
              task.last = now;
            }
          }
        }
        /**
         * Destroys the scheduler system and removes all tasks.
         * @internal
         */
        destroy() {
          Ticker.system.remove(this._update, this);
          this._tasks.length = 0;
        }
      };
      SchedulerSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "scheduler",
        priority: 0
      };
    }
  });

  // node_modules/pixi.js/lib/utils/sayHello.mjs
  function sayHello(type) {
    if (saidHello) {
      return;
    }
    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      const args = [
        `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
        "background: #E72264; padding:5px 0;",
        "background: #6CA2EA; padding:5px 0;",
        "background: #B5D33D; padding:5px 0;",
        "background: #FED23F; padding:5px 0;",
        "color: #FFFFFF; background: #E72264; padding:5px 0;",
        "color: #E72264; background: #FFFFFF; padding:5px 0;"
      ];
      globalThis.console.log(...args);
    } else if (globalThis.console) {
      globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
    }
    saidHello = true;
  }
  var saidHello;
  var init_sayHello = __esm({
    "node_modules/pixi.js/lib/utils/sayHello.mjs"() {
      init_adapter();
      init_const8();
      saidHello = false;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
  var HelloSystem;
  var init_HelloSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
      init_Extensions();
      init_sayHello();
      init_types2();
      HelloSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        /**
         * It all starts here! This initiates every system, passing in the options for any system by name.
         * @param options - the config for the renderer and all its systems
         */
        init(options) {
          if (options.hello) {
            let name = this._renderer.name;
            if (this._renderer.type === RendererType.WEBGL) {
              name += ` ${this._renderer.context.webGLVersion}`;
            }
            sayHello(name);
          }
        }
      };
      HelloSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "hello",
        priority: -2
      };
      HelloSystem.defaultOptions = {
        /** {@link WebGLOptions.hello} */
        hello: false
      };
    }
  });

  // node_modules/pixi.js/lib/utils/data/clean.mjs
  function cleanHash(hash) {
    let clean = false;
    for (const i3 in hash) {
      if (hash[i3] == void 0) {
        clean = true;
        break;
      }
    }
    if (!clean)
      return hash;
    const cleanHash2 = /* @__PURE__ */ Object.create(null);
    for (const i3 in hash) {
      const value = hash[i3];
      if (value) {
        cleanHash2[i3] = value;
      }
    }
    return cleanHash2;
  }
  function cleanArray(arr) {
    let offset = 0;
    for (let i3 = 0; i3 < arr.length; i3++) {
      if (arr[i3] == void 0) {
        offset++;
      } else {
        arr[i3 - offset] = arr[i3];
      }
    }
    arr.length -= offset;
    return arr;
  }
  var init_clean = __esm({
    "node_modules/pixi.js/lib/utils/data/clean.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs
  var renderableGCTick, _RenderableGCSystem, RenderableGCSystem;
  var init_RenderableGCSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs"() {
      init_Extensions();
      init_clean();
      renderableGCTick = 0;
      _RenderableGCSystem = class _RenderableGCSystem2 {
        /**
         * Creates a new RenderableGCSystem instance.
         * @param renderer - The renderer this garbage collection system works for
         */
        constructor(renderer) {
          this._managedRenderables = [];
          this._managedHashes = [];
          this._managedArrays = [];
          this._renderer = renderer;
        }
        /**
         * Initializes the garbage collection system with the provided options.
         * @param options - Configuration options for the renderer
         */
        init(options) {
          options = __spreadValues(__spreadValues({}, _RenderableGCSystem2.defaultOptions), options);
          this.maxUnusedTime = options.renderableGCMaxUnusedTime;
          this._frequency = options.renderableGCFrequency;
          this.enabled = options.renderableGCActive;
        }
        /**
         * Gets whether the garbage collection system is currently enabled.
         * @returns True if GC is enabled, false otherwise
         */
        get enabled() {
          return !!this._handler;
        }
        /**
         * Enables or disables the garbage collection system.
         * When enabled, schedules periodic cleanup of resources.
         * When disabled, cancels all scheduled cleanups.
         */
        set enabled(value) {
          if (this.enabled === value)
            return;
          if (value) {
            this._handler = this._renderer.scheduler.repeat(
              () => this.run(),
              this._frequency,
              false
            );
            this._hashHandler = this._renderer.scheduler.repeat(
              () => {
                for (const hash of this._managedHashes) {
                  hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);
                }
              },
              this._frequency
            );
            this._arrayHandler = this._renderer.scheduler.repeat(
              () => {
                for (const array of this._managedArrays) {
                  cleanArray(array.context[array.hash]);
                }
              },
              this._frequency
            );
          } else {
            this._renderer.scheduler.cancel(this._handler);
            this._renderer.scheduler.cancel(this._hashHandler);
            this._renderer.scheduler.cancel(this._arrayHandler);
          }
        }
        /**
         * Adds a hash table to be managed by the garbage collector.
         * @param context - The object containing the hash table
         * @param hash - The property name of the hash table
         */
        addManagedHash(context4, hash) {
          this._managedHashes.push({ context: context4, hash });
        }
        /**
         * Adds an array to be managed by the garbage collector.
         * @param context - The object containing the array
         * @param hash - The property name of the array
         */
        addManagedArray(context4, hash) {
          this._managedArrays.push({ context: context4, hash });
        }
        /**
         * Updates the GC timestamp and tracking before rendering.
         * @param options - The render options
         * @param options.container - The container to render
         */
        prerender({
          container
        }) {
          this._now = performance.now();
          container.renderGroup.gcTick = renderableGCTick++;
          this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);
        }
        /**
         * Starts tracking a renderable for garbage collection.
         * @param renderable - The renderable to track
         */
        addRenderable(renderable) {
          if (!this.enabled)
            return;
          if (renderable._lastUsed === -1) {
            this._managedRenderables.push(renderable);
            renderable.once("destroyed", this._removeRenderable, this);
          }
          renderable._lastUsed = this._now;
        }
        /**
         * Performs garbage collection by cleaning up unused renderables.
         * Removes renderables that haven't been used for longer than maxUnusedTime.
         */
        run() {
          var _a2, _b, _c, _d;
          const now = this._now;
          const managedRenderables = this._managedRenderables;
          const renderPipes3 = this._renderer.renderPipes;
          let offset = 0;
          for (let i3 = 0; i3 < managedRenderables.length; i3++) {
            const renderable = managedRenderables[i3];
            if (renderable === null) {
              offset++;
              continue;
            }
            const renderGroup = (_a2 = renderable.renderGroup) != null ? _a2 : renderable.parentRenderGroup;
            const currentTick = (_c = (_b = renderGroup == null ? void 0 : renderGroup.instructionSet) == null ? void 0 : _b.gcTick) != null ? _c : -1;
            if (((_d = renderGroup == null ? void 0 : renderGroup.gcTick) != null ? _d : 0) === currentTick) {
              renderable._lastUsed = now;
            }
            if (now - renderable._lastUsed > this.maxUnusedTime) {
              if (!renderable.destroyed) {
                const rp = renderPipes3;
                if (renderGroup)
                  renderGroup.structureDidChange = true;
                rp[renderable.renderPipeId].destroyRenderable(renderable);
              }
              renderable._lastUsed = -1;
              offset++;
              renderable.off("destroyed", this._removeRenderable, this);
            } else {
              managedRenderables[i3 - offset] = renderable;
            }
          }
          managedRenderables.length -= offset;
        }
        /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */
        destroy() {
          this.enabled = false;
          this._renderer = null;
          this._managedRenderables.length = 0;
          this._managedHashes.length = 0;
          this._managedArrays.length = 0;
        }
        /**
         * Removes a renderable from being tracked when it's destroyed.
         * @param renderable - The renderable to stop tracking
         */
        _removeRenderable(renderable) {
          const index = this._managedRenderables.indexOf(renderable);
          if (index >= 0) {
            renderable.off("destroyed", this._removeRenderable, this);
            this._managedRenderables[index] = null;
          }
        }
        /**
         * Updates the GC tick counter for a render group and its children.
         * @param renderGroup - The render group to update
         * @param gcTick - The new tick value
         */
        _updateInstructionGCTick(renderGroup, gcTick) {
          renderGroup.instructionSet.gcTick = gcTick;
          for (const child of renderGroup.renderGroupChildren) {
            this._updateInstructionGCTick(child, gcTick);
          }
        }
      };
      _RenderableGCSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "renderableGC",
        priority: 0
      };
      _RenderableGCSystem.defaultOptions = {
        /** Enable/disable the garbage collector */
        renderableGCActive: true,
        /** Time in ms before an unused resource is collected (default 1 minute) */
        renderableGCMaxUnusedTime: 6e4,
        /** How often to run garbage collection in ms (default 30 seconds) */
        renderableGCFrequency: 3e4
      };
      RenderableGCSystem = _RenderableGCSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
  var _TextureGCSystem, TextureGCSystem;
  var init_TextureGCSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
      init_Extensions();
      init_deprecation();
      _TextureGCSystem = class _TextureGCSystem2 {
        /**
         * Frame count since started.
         * @readonly
         * @deprecated since 8.15.0
         */
        get count() {
          return this._renderer.tick;
        }
        /**
         * Frame count since last garbage collection.
         * @readonly
         * @deprecated since 8.15.0
         */
        get checkCount() {
          return this._checkCount;
        }
        set checkCount(value) {
          deprecation("8.15.0", "TextureGCSystem.run is deprecated, please use the GCSystem instead.");
          this._checkCount = value;
        }
        /**
         * Maximum idle frames before a texture is destroyed by garbage collection.
         * @see TextureGCSystem.defaultMaxIdle
         * @deprecated since 8.15.0
         */
        get maxIdle() {
          return this._renderer.gc.maxUnusedTime / 1e3 * 60;
        }
        set maxIdle(value) {
          deprecation("8.15.0", "TextureGCSystem.run is deprecated, please use the GCSystem instead.");
          this._renderer.gc.maxUnusedTime = value / 60 * 1e3;
        }
        /**
         * Frames between two garbage collections.
         * @see TextureGCSystem.defaultCheckCountMax
         * @deprecated since 8.15.0
         */
        // eslint-disable-next-line dot-notation
        get checkCountMax() {
          return Math.floor(this._renderer.gc["_frequency"] / 1e3);
        }
        set checkCountMax(_value) {
          deprecation("8.15.0", "TextureGCSystem.run is deprecated, please use the GCSystem instead.");
        }
        /**
         * Current garbage collection mode.
         * @see TextureGCSystem.defaultMode
         * @deprecated since 8.15.0
         */
        get active() {
          return this._renderer.gc.enabled;
        }
        set active(value) {
          deprecation("8.15.0", "TextureGCSystem.run is deprecated, please use the GCSystem instead.");
          this._renderer.gc.enabled = value;
        }
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._renderer = renderer;
          this._checkCount = 0;
        }
        init(options) {
          if (options.textureGCActive !== _TextureGCSystem2.defaultOptions.textureGCActive) {
            this.active = options.textureGCActive;
          }
          if (options.textureGCMaxIdle !== _TextureGCSystem2.defaultOptions.textureGCMaxIdle) {
            this.maxIdle = options.textureGCMaxIdle;
          }
          if (options.textureGCCheckCountMax !== _TextureGCSystem2.defaultOptions.textureGCCheckCountMax) {
            this.checkCountMax = options.textureGCCheckCountMax;
          }
        }
        /**
         * Checks to see when the last time a texture was used.
         * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
         * @deprecated since 8.15.0
         */
        run() {
          deprecation("8.15.0", "TextureGCSystem.run is deprecated, please use the GCSystem instead.");
          this._renderer.gc.run();
        }
        destroy() {
          this._renderer = null;
        }
      };
      _TextureGCSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "textureGC"
      };
      _TextureGCSystem.defaultOptions = {
        /**
         * If set to true, this will enable the garbage collector on the GPU.
         * @default true
         */
        textureGCActive: true,
        /**
         * @deprecated since 8.3.0
         * @see {@link TextureGCSystemOptions.textureGCMaxIdle}
         */
        textureGCAMaxIdle: null,
        /**
         * The maximum idle frames before a texture is destroyed by garbage collection.
         * @default 60 * 60
         */
        textureGCMaxIdle: 60 * 60,
        /**
         * Frames between two garbage collections.
         * @default 600
         */
        textureGCCheckCountMax: 600
      };
      TextureGCSystem = _TextureGCSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
  var _RenderTarget, RenderTarget;
  var init_RenderTarget = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
      init_uid();
      init_TextureSource();
      init_Texture();
      _RenderTarget = class _RenderTarget2 {
        /**
         * @param [descriptor] - Options for creating a render target.
         */
        constructor(descriptor = {}) {
          this.uid = uid2("renderTarget");
          this.colorTextures = [];
          this.dirtyId = 0;
          this.isRoot = false;
          this._size = new Float32Array(2);
          this._managedColorTextures = false;
          descriptor = __spreadValues(__spreadValues({}, _RenderTarget2.defaultOptions), descriptor);
          this.stencil = descriptor.stencil;
          this.depth = descriptor.depth;
          this.isRoot = descriptor.isRoot;
          if (typeof descriptor.colorTextures === "number") {
            this._managedColorTextures = true;
            for (let i3 = 0; i3 < descriptor.colorTextures; i3++) {
              this.colorTextures.push(
                new TextureSource({
                  width: descriptor.width,
                  height: descriptor.height,
                  resolution: descriptor.resolution,
                  antialias: descriptor.antialias
                })
              );
            }
          } else {
            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
            const colorSource = this.colorTexture.source;
            this.resize(colorSource.width, colorSource.height, colorSource._resolution);
          }
          this.colorTexture.source.on("resize", this.onSourceResize, this);
          if (descriptor.depthStencilTexture || this.stencil) {
            if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {
              this.depthStencilTexture = descriptor.depthStencilTexture.source;
            } else {
              this.ensureDepthStencilTexture();
            }
          }
        }
        get size() {
          const _size = this._size;
          _size[0] = this.pixelWidth;
          _size[1] = this.pixelHeight;
          return _size;
        }
        get width() {
          return this.colorTexture.source.width;
        }
        get height() {
          return this.colorTexture.source.height;
        }
        get pixelWidth() {
          return this.colorTexture.source.pixelWidth;
        }
        get pixelHeight() {
          return this.colorTexture.source.pixelHeight;
        }
        get resolution() {
          return this.colorTexture.source._resolution;
        }
        get colorTexture() {
          return this.colorTextures[0];
        }
        onSourceResize(source11) {
          this.resize(source11.width, source11.height, source11._resolution, true);
        }
        /**
         * This will ensure a depthStencil texture is created for this render target.
         * Most likely called by the mask system to make sure we have stencil buffer added.
         * @internal
         */
        ensureDepthStencilTexture() {
          if (!this.depthStencilTexture) {
            this.depthStencilTexture = new TextureSource({
              width: this.width,
              height: this.height,
              resolution: this.resolution,
              format: "depth24plus-stencil8",
              autoGenerateMipmaps: false,
              antialias: false,
              mipLevelCount: 1
              // sampleCount: handled by the render target system..
            });
          }
        }
        resize(width, height, resolution = this.resolution, skipColorTexture = false) {
          this.dirtyId++;
          this.colorTextures.forEach((colorTexture, i3) => {
            if (skipColorTexture && i3 === 0)
              return;
            colorTexture.source.resize(width, height, resolution);
          });
          if (this.depthStencilTexture) {
            this.depthStencilTexture.source.resize(width, height, resolution);
          }
        }
        destroy() {
          this.colorTexture.source.off("resize", this.onSourceResize, this);
          if (this._managedColorTextures) {
            this.colorTextures.forEach((texture) => {
              texture.destroy();
            });
          }
          if (this.depthStencilTexture) {
            this.depthStencilTexture.destroy();
            delete this.depthStencilTexture;
          }
        }
      };
      _RenderTarget.defaultOptions = {
        /** the width of the RenderTarget */
        width: 0,
        /** the height of the RenderTarget */
        height: 0,
        /** the resolution of the RenderTarget */
        resolution: 1,
        /** an array of textures, or a number indicating how many color textures there should be */
        colorTextures: 1,
        /** should this render target have a stencil buffer? */
        stencil: false,
        /** should this render target have a depth buffer? */
        depth: false,
        /** should this render target be antialiased? */
        antialias: false,
        // save on perf by default!
        /** is this a root element, true if this is gl context owners render target */
        isRoot: false
      };
      RenderTarget = _RenderTarget;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
  function getCanvasTexture(canvas, options) {
    if (!canvasCache.has(canvas)) {
      const texture = new Texture({
        source: new CanvasSource(__spreadValues({
          resource: canvas
        }, options))
      });
      const onDestroy = () => {
        if (canvasCache.get(canvas) === texture) {
          canvasCache.delete(canvas);
        }
      };
      texture.once("destroy", onDestroy);
      texture.source.once("destroy", onDestroy);
      canvasCache.set(canvas, texture);
    }
    return canvasCache.get(canvas);
  }
  function hasCachedCanvasTexture(canvas) {
    return canvasCache.has(canvas);
  }
  var canvasCache;
  var init_getCanvasTexture = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
      init_GlobalResourceRegistry();
      init_CanvasSource();
      init_Texture();
      canvasCache = /* @__PURE__ */ new Map();
      GlobalResourceRegistry.register(canvasCache);
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
  var _ViewSystem, ViewSystem;
  var init_ViewSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_Rectangle();
      init_deprecation();
      init_RenderTarget();
      init_getCanvasTexture();
      _ViewSystem = class _ViewSystem2 {
        /**
         * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
         * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.
         * @type {boolean}
         */
        get autoDensity() {
          return this.texture.source.autoDensity;
        }
        set autoDensity(value) {
          this.texture.source.autoDensity = value;
        }
        /** The resolution / device pixel ratio of the renderer. */
        get resolution() {
          return this.texture.source._resolution;
        }
        set resolution(value) {
          this.texture.source.resize(
            this.texture.source.width,
            this.texture.source.height,
            value
          );
        }
        /**
         * initiates the view system
         * @param options - the options for the view
         */
        init(options) {
          options = __spreadValues(__spreadValues({}, _ViewSystem2.defaultOptions), options);
          if (options.view) {
            deprecation(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
            options.canvas = options.view;
          }
          this.screen = new Rectangle(0, 0, options.width, options.height);
          this.canvas = options.canvas || DOMAdapter.get().createCanvas();
          this.antialias = !!options.antialias;
          this.texture = getCanvasTexture(this.canvas, options);
          this.renderTarget = new RenderTarget({
            colorTextures: [this.texture],
            depth: !!options.depth,
            isRoot: true
          });
          this.texture.source.transparent = options.backgroundAlpha < 1;
          this.resolution = options.resolution;
        }
        /**
         * Resizes the screen and canvas to the specified dimensions.
         * @param desiredScreenWidth - The new width of the screen.
         * @param desiredScreenHeight - The new height of the screen.
         * @param resolution
         */
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.screen.width = this.texture.frame.width;
          this.screen.height = this.texture.frame.height;
        }
        /**
         * Destroys this System and optionally removes the canvas from the dom.
         * @param {options | false} options - The options for destroying the view, or "false".
         * @example
         * viewSystem.destroy();
         * viewSystem.destroy(true);
         * viewSystem.destroy({ removeView: true });
         */
        destroy(options = false) {
          const removeView = typeof options === "boolean" ? options : !!(options == null ? void 0 : options.removeView);
          if (removeView && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
          }
          this.texture.destroy();
        }
      };
      _ViewSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "view",
        priority: 0
      };
      _ViewSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.width}
         * @default 800
         */
        width: 800,
        /**
         * {@link WebGLOptions.height}
         * @default 600
         */
        height: 600,
        /**
         * {@link WebGLOptions.autoDensity}
         * @default false
         */
        autoDensity: false,
        /**
         * {@link WebGLOptions.antialias}
         * @default false
         */
        antialias: false
      };
      ViewSystem = _ViewSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
  var SharedSystems, SharedRenderPipes;
  var init_SharedSystems = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
      init_CustomRenderPipe();
      init_RenderGroupPipe();
      init_RenderGroupSystem();
      init_SpritePipe();
      init_globalHooks();
      init_BatcherPipe();
      init_AlphaMaskPipe();
      init_ColorMaskPipe();
      init_StencilMaskPipe();
      init_BackgroundSystem();
      init_BlendModePipe();
      init_ExtractSystem();
      init_GenerateTextureSystem();
      init_GCSystem();
      init_GlobalUniformSystem();
      init_SchedulerSystem();
      init_HelloSystem();
      init_RenderableGCSystem();
      init_TextureGCSystem();
      init_ViewSystem();
      SharedSystems = [
        BackgroundSystem,
        GlobalUniformSystem,
        HelloSystem,
        ViewSystem,
        RenderGroupSystem,
        GCSystem,
        TextureGCSystem,
        GenerateTextureSystem,
        ExtractSystem,
        RendererInitHook,
        RenderableGCSystem,
        SchedulerSystem
      ];
      SharedRenderPipes = [
        BlendModePipe,
        BatcherPipe,
        SpritePipe,
        RenderGroupPipe,
        AlphaMaskPipe,
        StencilMaskPipe,
        ColorMaskPipe,
        CustomRenderPipe
      ];
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
  var BindGroupSystem;
  var init_BindGroupSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
      init_Extensions();
      BindGroupSystem = class {
        constructor(renderer) {
          this._hash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getBindGroup(bindGroup, program, groupIndex) {
          bindGroup._updateKey();
          const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
          return gpuBindGroup;
        }
        _createBindGroup(group, program, groupIndex) {
          var _a2;
          const device = this._gpu.device;
          const groupLayout = program.layout[groupIndex];
          const entries = [];
          const renderer = this._renderer;
          for (const j2 in groupLayout) {
            const resource = (_a2 = group.resources[j2]) != null ? _a2 : group.resources[groupLayout[j2]];
            let gpuResource;
            if (resource._resourceType === "uniformGroup") {
              const uniformGroup = resource;
              renderer.ubo.updateUniformGroup(uniformGroup);
              const buffer = uniformGroup.buffer;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource._resourceType === "buffer") {
              const buffer = resource;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource._resourceType === "bufferResource") {
              const bufferResource = resource;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
                offset: bufferResource.offset,
                size: bufferResource.size
              };
            } else if (resource._resourceType === "textureSampler") {
              const sampler = resource;
              gpuResource = renderer.texture.getGpuSampler(sampler);
            } else if (resource._resourceType === "textureSource") {
              const texture = resource;
              gpuResource = renderer.texture.getGpuSource(texture).createView();
            }
            entries.push({
              binding: groupLayout[j2],
              resource: gpuResource
            });
          }
          const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
          const gpuBindGroup = device.createBindGroup({
            layout,
            entries
          });
          this._hash[group._key] = gpuBindGroup;
          return gpuBindGroup;
        }
        destroy() {
          this._hash = null;
          this._renderer = null;
        }
      };
      BindGroupSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "bindGroup"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
  var GpuBufferData, GpuBufferSystem;
  var init_GpuBufferSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
      init_Extensions();
      init_GCManagedHash();
      init_uid();
      init_fastCopy();
      GpuBufferData = class {
        constructor(gpuBuffer) {
          this.gpuBuffer = gpuBuffer;
        }
        destroy() {
          this.gpuBuffer.destroy();
          this.gpuBuffer = null;
        }
      };
      GpuBufferSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
          this._managedBuffers = new GCManagedHash({
            renderer,
            type: "resource",
            onUnload: this.onBufferUnload.bind(this),
            name: "gpuBuffer"
          });
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getGPUBuffer(buffer) {
          var _a2;
          buffer._gcLastUsed = this._renderer.gc.now;
          return ((_a2 = buffer._gpuData[this._renderer.uid]) == null ? void 0 : _a2.gpuBuffer) || this.createGPUBuffer(buffer);
        }
        updateBuffer(buffer) {
          const gpuBuffer = this.getGPUBuffer(buffer);
          const data = buffer.data;
          if (buffer._updateID && data) {
            buffer._updateID = 0;
            this._gpu.device.queue.writeBuffer(
              gpuBuffer,
              0,
              data.buffer,
              0,
              // round to the nearest 4 bytes
              (buffer._updateSize || data.byteLength) + 3 & ~3
            );
          }
          return gpuBuffer;
        }
        /** dispose all WebGL resources of all managed buffers */
        destroyAll() {
          this._managedBuffers.removeAll();
        }
        onBufferUnload(buffer) {
          buffer.off("update", this.updateBuffer, this);
          buffer.off("change", this.onBufferChange, this);
        }
        createGPUBuffer(buffer) {
          const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
          buffer._updateID = 0;
          buffer._resourceId = uid2("resource");
          if (buffer.data) {
            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
            gpuBuffer.unmap();
          }
          buffer._gpuData[this._renderer.uid] = new GpuBufferData(gpuBuffer);
          if (this._managedBuffers.add(buffer)) {
            buffer.on("update", this.updateBuffer, this);
            buffer.on("change", this.onBufferChange, this);
          }
          return gpuBuffer;
        }
        onBufferChange(buffer) {
          this._managedBuffers.remove(buffer);
          buffer._updateID = 0;
          this.createGPUBuffer(buffer);
        }
        destroy() {
          this._managedBuffers.destroy();
          this._renderer = null;
          this._gpu = null;
        }
      };
      GpuBufferSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "buffer"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
  var GpuColorMaskSystem;
  var init_GpuColorMaskSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
      init_Extensions();
      GpuColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.pipeline.setColorMask(colorMask);
        }
        destroy() {
          this._renderer = null;
          this._colorMaskCache = null;
        }
      };
      GpuColorMaskSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
  var GpuDeviceSystem;
  var init_GpuDeviceSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
      init_adapter();
      init_Extensions();
      GpuDeviceSystem = class {
        /**
         * @param {WebGPURenderer} renderer - The renderer this System works for.
         */
        constructor(renderer) {
          this._renderer = renderer;
        }
        init(options) {
          return __async(this, null, function* () {
            if (this._initPromise)
              return this._initPromise;
            this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options)).then((gpu) => {
              this.gpu = gpu;
              this._renderer.runners.contextChange.emit(this.gpu);
            });
            return this._initPromise;
          });
        }
        /**
         * Handle the context change event
         * @param gpu
         */
        contextChange(gpu) {
          this._renderer.gpu = gpu;
        }
        /**
         * Helper class to create a WebGL Context
         * @param {object} options - An options object that gets passed in to the canvas element containing the
         *    context attributes
         * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
         * @returns {WebGLRenderingContext} the WebGL context
         */
        _createDeviceAndAdaptor(options) {
          return __async(this, null, function* () {
            const adapter = yield DOMAdapter.get().getNavigator().gpu.requestAdapter({
              powerPreference: options.powerPreference,
              forceFallbackAdapter: options.forceFallbackAdapter
            });
            const requiredFeatures = [
              "texture-compression-bc",
              "texture-compression-astc",
              "texture-compression-etc2"
            ].filter((feature) => adapter.features.has(feature));
            const device = yield adapter.requestDevice({
              requiredFeatures
            });
            return { adapter, device };
          });
        }
        destroy() {
          this.gpu = null;
          this._renderer = null;
        }
      };
      GpuDeviceSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "device"
      };
      GpuDeviceSystem.defaultOptions = {
        /**
         * {@link WebGPUOptions.powerPreference}
         * @default default
         */
        powerPreference: void 0,
        /**
         * Force the use of the fallback adapter
         * @default false
         */
        forceFallbackAdapter: false
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
  var GpuEncoderSystem;
  var init_GpuEncoderSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
      init_Extensions();
      GpuEncoderSystem = class {
        constructor(renderer) {
          this._boundBindGroup = /* @__PURE__ */ Object.create(null);
          this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        renderStart() {
          this.commandFinished = new Promise((resolve) => {
            this._resolveCommandFinished = resolve;
          });
          this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        }
        beginRenderPass(gpuRenderTarget) {
          this.endRenderPass();
          this._clearCache();
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
        }
        endRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
          }
          this.renderPassEncoder = null;
        }
        setViewport(viewport) {
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        }
        setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
          const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
          this.setPipeline(pipeline);
        }
        setPipeline(pipeline) {
          if (this._boundPipeline === pipeline)
            return;
          this._boundPipeline = pipeline;
          this.renderPassEncoder.setPipeline(pipeline);
        }
        _setVertexBuffer(index, buffer) {
          if (this._boundVertexBuffer[index] === buffer)
            return;
          this._boundVertexBuffer[index] = buffer;
          this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
        }
        _setIndexBuffer(buffer) {
          if (this._boundIndexBuffer === buffer)
            return;
          this._boundIndexBuffer = buffer;
          const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
          this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
        }
        resetBindGroup(index) {
          this._boundBindGroup[index] = null;
        }
        setBindGroup(index, bindGroup, program) {
          if (this._boundBindGroup[index] === bindGroup)
            return;
          this._boundBindGroup[index] = bindGroup;
          bindGroup._touch(this._renderer.gc.now, this._renderer.tick);
          const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
          this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
        }
        setGeometry(geometry, program) {
          const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
          for (const i3 in buffersToBind) {
            this._setVertexBuffer(parseInt(i3, 10), geometry.attributes[buffersToBind[i3]].buffer);
          }
          if (geometry.indexBuffer) {
            this._setIndexBuffer(geometry.indexBuffer);
          }
        }
        _setShaderBindGroups(shader, skipSync) {
          for (const i3 in shader.groups) {
            const bindGroup = shader.groups[i3];
            if (!skipSync) {
              this._syncBindGroup(bindGroup);
            }
            this.setBindGroup(i3, bindGroup, shader.gpuProgram);
          }
        }
        _syncBindGroup(bindGroup) {
          for (const j2 in bindGroup.resources) {
            const resource = bindGroup.resources[j2];
            if (resource.isUniformGroup) {
              this._renderer.ubo.updateUniformGroup(resource);
            }
          }
        }
        draw(options) {
          const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;
          this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
          this.setGeometry(geometry, shader.gpuProgram);
          this._setShaderBindGroups(shader, skipSync);
          if (geometry.indexBuffer) {
            this.renderPassEncoder.drawIndexed(
              size || geometry.indexBuffer.data.length,
              instanceCount != null ? instanceCount : geometry.instanceCount,
              start || 0
            );
          } else {
            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount != null ? instanceCount : geometry.instanceCount, start || 0);
          }
        }
        finishRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
            this.renderPassEncoder = null;
          }
        }
        postrender() {
          this.finishRenderPass();
          this._gpu.device.queue.submit([this.commandEncoder.finish()]);
          this._resolveCommandFinished();
          this.commandEncoder = null;
        }
        // restores a render pass if finishRenderPass was called
        // not optimised as really used for debugging!
        // used when we want to stop drawing and log a texture..
        restoreRenderPass() {
          const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(
            this._renderer.renderTarget.renderTarget,
            false,
            [0, 0, 0, 1]
          );
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
          const boundPipeline = this._boundPipeline;
          const boundVertexBuffer = __spreadValues({}, this._boundVertexBuffer);
          const boundIndexBuffer = this._boundIndexBuffer;
          const boundBindGroup = __spreadValues({}, this._boundBindGroup);
          this._clearCache();
          const viewport = this._renderer.renderTarget.viewport;
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
          this.setPipeline(boundPipeline);
          for (const i3 in boundVertexBuffer) {
            this._setVertexBuffer(i3, boundVertexBuffer[i3]);
          }
          for (const i3 in boundBindGroup) {
            this.setBindGroup(i3, boundBindGroup[i3], null);
          }
          this._setIndexBuffer(boundIndexBuffer);
        }
        _clearCache() {
          for (let i3 = 0; i3 < 16; i3++) {
            this._boundBindGroup[i3] = null;
            this._boundVertexBuffer[i3] = null;
          }
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        destroy() {
          this._renderer = null;
          this._gpu = null;
          this._boundBindGroup = null;
          this._boundVertexBuffer = null;
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
      };
      GpuEncoderSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "encoder",
        priority: 1
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs
  var GpuLimitsSystem;
  var init_GpuLimitsSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs"() {
      init_Extensions();
      GpuLimitsSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        contextChange() {
          this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;
          this.maxBatchableTextures = this.maxTextures;
        }
        destroy() {
        }
      };
      GpuLimitsSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "limits"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
  var GpuStencilSystem;
  var init_GpuStencilSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
      init_Extensions();
      init_const3();
      GpuStencilSystem = class {
        constructor(renderer) {
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(renderTarget) {
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this._activeRenderTarget = renderTarget;
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          const renderer = this._renderer;
          renderer.pipeline.setStencilMode(stencilMode);
          renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
        }
        destroy() {
          this._renderer.renderTarget.onRenderTargetChange.remove(this);
          this._renderer = null;
          this._activeRenderTarget = null;
          this._renderTargetStencilState = null;
        }
      };
      GpuStencilSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "stencil"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs
  var UboSystem;
  var init_UboSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs"() {
      init_unsafeEvalSupported();
      init_Buffer();
      init_const4();
      UboSystem = class {
        constructor(adaptor) {
          this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
          this._adaptor = adaptor;
          this._systemCheck();
        }
        /**
         * Overridable function by `pixi.js/unsafe-eval` to silence
         * throwing an error if platform doesn't support unsafe-evals.
         * @private
         */
        _systemCheck() {
          if (!unsafeEvalSupported()) {
            throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
          }
        }
        ensureUniformGroup(uniformGroup) {
          const uniformData = this.getUniformGroupData(uniformGroup);
          uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
            data: new Float32Array(uniformData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          }));
        }
        getUniformGroupData(uniformGroup) {
          return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
        }
        _initUniformGroup(uniformGroup) {
          const uniformGroupSignature = uniformGroup._signature;
          let uniformData = this._syncFunctionHash[uniformGroupSignature];
          if (!uniformData) {
            const elements = Object.keys(uniformGroup.uniformStructures).map((i3) => uniformGroup.uniformStructures[i3]);
            const layout = this._adaptor.createUboElements(elements);
            const syncFunction = this._generateUboSync(layout.uboElements);
            uniformData = this._syncFunctionHash[uniformGroupSignature] = {
              layout,
              syncFunction
            };
          }
          return this._syncFunctionHash[uniformGroupSignature];
        }
        _generateUboSync(uboElements) {
          return this._adaptor.generateUboSync(uboElements);
        }
        syncUniformGroup(uniformGroup, data, offset) {
          const uniformGroupData = this.getUniformGroupData(uniformGroup);
          uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
            data: new Float32Array(uniformGroupData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          }));
          let dataInt32 = null;
          if (!data) {
            data = uniformGroup.buffer.data;
            dataInt32 = uniformGroup.buffer.dataInt32;
          }
          offset || (offset = 0);
          uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);
          return true;
        }
        updateUniformGroup(uniformGroup) {
          if (uniformGroup.isStatic && !uniformGroup._dirtyId)
            return false;
          uniformGroup._dirtyId = 0;
          const synced = this.syncUniformGroup(uniformGroup);
          uniformGroup.buffer.update();
          return synced;
        }
        destroy() {
          this._syncFunctionHash = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs
  function createUboElementsWGSL(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let offset = 0;
    for (let i3 = 0; i3 < uboElements.length; i3++) {
      const uboElement = uboElements[i3];
      let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
      const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
      if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
        throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size = Math.max(size, align) * uboElement.data.size;
      }
      offset = Math.ceil(offset / align) * align;
      uboElement.size = size;
      uboElement.offset = offset;
      offset += size;
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_ALIGN_SIZE_DATA;
  var init_createUboElementsWGSL = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs"() {
      "use strict";
      WGSL_ALIGN_SIZE_DATA = {
        i32: { align: 4, size: 4 },
        u32: { align: 4, size: 4 },
        f32: { align: 4, size: 4 },
        f16: { align: 2, size: 2 },
        "vec2<i32>": { align: 8, size: 8 },
        "vec2<u32>": { align: 8, size: 8 },
        "vec2<f32>": { align: 8, size: 8 },
        "vec2<f16>": { align: 4, size: 4 },
        "vec3<i32>": { align: 16, size: 12 },
        "vec3<u32>": { align: 16, size: 12 },
        "vec3<f32>": { align: 16, size: 12 },
        "vec3<f16>": { align: 8, size: 6 },
        "vec4<i32>": { align: 16, size: 16 },
        "vec4<u32>": { align: 16, size: 16 },
        "vec4<f32>": { align: 16, size: 16 },
        "vec4<f16>": { align: 8, size: 8 },
        "mat2x2<f32>": { align: 8, size: 16 },
        "mat2x2<f16>": { align: 4, size: 8 },
        "mat3x2<f32>": { align: 8, size: 24 },
        "mat3x2<f16>": { align: 4, size: 12 },
        "mat4x2<f32>": { align: 8, size: 32 },
        "mat4x2<f16>": { align: 4, size: 16 },
        "mat2x3<f32>": { align: 16, size: 32 },
        "mat2x3<f16>": { align: 8, size: 16 },
        "mat3x3<f32>": { align: 16, size: 48 },
        "mat3x3<f16>": { align: 8, size: 24 },
        "mat4x3<f32>": { align: 16, size: 64 },
        "mat4x3<f16>": { align: 8, size: 32 },
        "mat2x4<f32>": { align: 16, size: 32 },
        "mat2x4<f16>": { align: 8, size: 16 },
        "mat3x4<f32>": { align: 16, size: 48 },
        "mat3x4<f16>": { align: 8, size: 24 },
        "mat4x4<f32>": { align: 16, size: 64 },
        "mat4x4<f16>": { align: 8, size: 32 }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs
  var uniformParsers;
  var init_uniformParsers = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs"() {
      "use strict";
      uniformParsers = [
        // uploading pixi matrix object to mat3
        {
          type: "mat3x3<f32>",
          test: (data) => {
            const value = data.value;
            return value.a !== void 0;
          },
          ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
          uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
        },
        // uploading a pixi rectangle as a vec4
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
        },
        // uploading a pixi point as a vec2
        {
          type: "vec2<f32>",
          test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
        },
        // uploading a pixi color as a vec4
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
        },
        // uploading a pixi color as a vec3
        {
          type: "vec3<f32>",
          test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
        }
      ];
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs
  function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
    const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
    let prev = 0;
    for (let i3 = 0; i3 < uboElements.length; i3++) {
      const uboElement = uboElements[i3];
      const name = uboElement.data.name;
      let parsed = false;
      let offset = 0;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const uniformParser = uniformParsers[j2];
        if (uniformParser.test(uboElement.data)) {
          offset = uboElement.offset / 4;
          funcFragments.push(
            `name = "${name}";`,
            `offset += ${offset - prev};`,
            uniformParsers[j2][parserCode] || uniformParsers[j2].ubo
          );
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          offset = uboElement.offset / 4;
          funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
        } else {
          const template = singleSettersMap[uboElement.data.type];
          offset = uboElement.offset / 4;
          funcFragments.push(
            /* wgsl */
            `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
          );
        }
      }
      prev = offset;
    }
    const fragmentSrc = funcFragments.join("\n");
    return new Function(
      "uv",
      "data",
      "dataInt32",
      "offset",
      fragmentSrc
    );
  }
  var init_createUboSyncFunction = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs"() {
      init_uniformParsers();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs
  function loopMatrix(col, row) {
    const total = col * row;
    return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
  }
  var uboSyncFunctionsSTD40, uboSyncFunctionsWGSL;
  var init_uboSyncFunctions = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs"() {
      "use strict";
      uboSyncFunctionsSTD40 = {
        f32: `
        data[offset] = v;`,
        i32: `
        dataInt32[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
        "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
        "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": loopMatrix(3, 2),
        "mat4x2<f32>": loopMatrix(4, 2),
        "mat2x3<f32>": loopMatrix(2, 3),
        "mat4x3<f32>": loopMatrix(4, 3),
        "mat2x4<f32>": loopMatrix(2, 4),
        "mat3x4<f32>": loopMatrix(3, 4)
      };
      uboSyncFunctionsWGSL = __spreadProps(__spreadValues({}, uboSyncFunctionsSTD40), {
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
      });
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs
  function generateArraySyncWGSL(uboElement, offsetToAdd) {
    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
    const remainder = (align - size) / 4;
    const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 ${data}[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
  }
  var init_generateArraySyncWGSL = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs"() {
      init_createUboElementsWGSL();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs
  function createUboSyncFunctionWGSL(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboWgsl",
      generateArraySyncWGSL,
      uboSyncFunctionsWGSL
    );
  }
  var init_createUboSyncFunctionWGSL = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs"() {
      init_createUboSyncFunction();
      init_uboSyncFunctions();
      init_generateArraySyncWGSL();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs
  var GpuUboSystem;
  var init_GpuUboSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs"() {
      init_Extensions();
      init_UboSystem();
      init_createUboElementsWGSL();
      init_createUboSyncFunctionWGSL();
      GpuUboSystem = class extends UboSystem {
        constructor() {
          super({
            createUboElements: createUboElementsWGSL,
            generateUboSync: createUboSyncFunctionWGSL
          });
        }
      };
      GpuUboSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "ubo"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
  var BufferResource;
  var init_BufferResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
      init_eventemitter3();
      init_uid();
      BufferResource = class extends eventemitter3_default {
        /**
         * Create a new Buffer Resource.
         * @param options - The options for the buffer resource
         * @param options.buffer - The underlying buffer that this resource is using
         * @param options.offset - The offset of the buffer this resource is using.
         * If not provided, then it will use the offset of the buffer.
         * @param options.size - The size of the buffer this resource is using.
         * If not provided, then it will use the size of the buffer.
         */
        constructor({ buffer, offset, size }) {
          super();
          this.uid = uid2("buffer");
          this._resourceType = "bufferResource";
          this._touched = 0;
          this._resourceId = uid2("resource");
          this._bufferResource = true;
          this.destroyed = false;
          this.buffer = buffer;
          this.offset = offset | 0;
          this.size = size;
          this.buffer.on("change", this.onBufferChange, this);
        }
        onBufferChange() {
          this._resourceId = uid2("resource");
          this.emit("change", this);
        }
        /**
         * Destroys this resource. Make sure the underlying buffer is not used anywhere else
         * if you want to destroy it as well, or code will explode
         * @param destroyBuffer - Should the underlying buffer be destroyed as well?
         */
        destroy(destroyBuffer = false) {
          this.destroyed = true;
          if (destroyBuffer) {
            this.buffer.destroy();
          }
          this.emit("change", this);
          this.buffer = null;
          this.removeAllListeners();
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs
  var UboBatch;
  var init_UboBatch = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs"() {
      "use strict";
      UboBatch = class {
        constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
          this._minUniformOffsetAlignment = 256;
          this.byteIndex = 0;
          this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
          this.data = new Float32Array(65535);
        }
        clear() {
          this.byteIndex = 0;
        }
        addEmptyGroup(size) {
          if (size > this._minUniformOffsetAlignment / 4) {
            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
          }
          const start = this.byteIndex;
          let newSize = start + size * 4;
          newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
          if (newSize > this.data.length * 4) {
            throw new Error("UniformBufferBatch: ubo batch got too big");
          }
          this.byteIndex = newSize;
          return start;
        }
        addGroup(array) {
          const offset = this.addEmptyGroup(array.length);
          for (let i3 = 0; i3 < array.length; i3++) {
            this.data[offset / 4 + i3] = array[i3];
          }
          return offset;
        }
        destroy() {
          this.data = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
  var minUniformOffsetAlignment, GpuUniformBatchPipe;
  var init_GpuUniformBatchPipe = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
      init_Extensions();
      init_Buffer();
      init_BufferResource();
      init_const4();
      init_UboBatch();
      init_BindGroup();
      minUniformOffsetAlignment = 128;
      GpuUniformBatchPipe = class {
        constructor(renderer) {
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._buffers = [];
          this._bindGroups = [];
          this._bufferResources = [];
          this._renderer = renderer;
          this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
          const totalBuffers = 256 / minUniformOffsetAlignment;
          for (let i3 = 0; i3 < totalBuffers; i3++) {
            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
            if (i3 === 0)
              usage |= BufferUsage.COPY_SRC;
            this._buffers.push(new Buffer2({
              data: this._batchBuffer.data,
              usage
            }));
          }
        }
        renderEnd() {
          this._uploadBindGroups();
          this._resetBindGroups();
        }
        _resetBindGroups() {
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._batchBuffer.clear();
        }
        // just works for single bind groups for now
        getUniformBindGroup(group, duplicate) {
          if (!duplicate && this._bindGroupHash[group.uid]) {
            return this._bindGroupHash[group.uid];
          }
          this._renderer.ubo.ensureUniformGroup(group);
          const data = group.buffer.data;
          const offset = this._batchBuffer.addEmptyGroup(data.length);
          this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
          this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
          return this._bindGroupHash[group.uid];
        }
        getUboResource(group) {
          this._renderer.ubo.updateUniformGroup(group);
          const data = group.buffer.data;
          const offset = this._batchBuffer.addGroup(data);
          return this._getBufferResource(offset / minUniformOffsetAlignment);
        }
        getArrayBindGroup(data) {
          const offset = this._batchBuffer.addGroup(data);
          return this._getBindGroup(offset / minUniformOffsetAlignment);
        }
        getArrayBufferResource(data) {
          const offset = this._batchBuffer.addGroup(data);
          const index = offset / minUniformOffsetAlignment;
          return this._getBufferResource(index);
        }
        _getBufferResource(index) {
          if (!this._bufferResources[index]) {
            const buffer = this._buffers[index % 2];
            this._bufferResources[index] = new BufferResource({
              buffer,
              offset: (index / 2 | 0) * 256,
              size: minUniformOffsetAlignment
            });
          }
          return this._bufferResources[index];
        }
        _getBindGroup(index) {
          if (!this._bindGroups[index]) {
            const bindGroup = new BindGroup({
              0: this._getBufferResource(index)
            });
            this._bindGroups[index] = bindGroup;
          }
          return this._bindGroups[index];
        }
        _uploadBindGroups() {
          const bufferSystem = this._renderer.buffer;
          const firstBuffer = this._buffers[0];
          firstBuffer.update(this._batchBuffer.byteIndex);
          bufferSystem.updateBuffer(firstBuffer);
          const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
          for (let i3 = 1; i3 < this._buffers.length; i3++) {
            const buffer = this._buffers[i3];
            commandEncoder.copyBufferToBuffer(
              bufferSystem.getGPUBuffer(firstBuffer),
              minUniformOffsetAlignment,
              bufferSystem.getGPUBuffer(buffer),
              0,
              this._batchBuffer.byteIndex
            );
          }
          this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        }
        destroy() {
          var _a2;
          for (let i3 = 0; i3 < this._bindGroups.length; i3++) {
            (_a2 = this._bindGroups[i3]) == null ? void 0 : _a2.destroy();
          }
          this._bindGroups = null;
          this._bindGroupHash = null;
          for (let i3 = 0; i3 < this._buffers.length; i3++) {
            this._buffers[i3].destroy();
          }
          this._buffers = null;
          for (let i3 = 0; i3 < this._bufferResources.length; i3++) {
            this._bufferResources[i3].destroy();
          }
          this._bufferResources = null;
          this._batchBuffer.destroy();
          this._renderer = null;
        }
      };
      GpuUniformBatchPipe.extension = {
        type: [
          ExtensionType.WebGPUPipes
        ],
        name: "uniformBatch"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs
  function ensureAttributes(geometry, extractedData) {
    var _a2, _b, _c;
    for (const i3 in geometry.attributes) {
      const attribute = geometry.attributes[i3];
      const attributeData = extractedData[i3];
      if (attributeData) {
        (_a2 = attribute.format) != null ? _a2 : attribute.format = attributeData.format;
        (_b = attribute.offset) != null ? _b : attribute.offset = attributeData.offset;
        (_c = attribute.instance) != null ? _c : attribute.instance = attributeData.instance;
      } else {
        warn(`Attribute ${i3} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
      }
    }
    ensureStartAndStride(geometry);
  }
  function ensureStartAndStride(geometry) {
    var _a2, _b;
    const { buffers, attributes } = geometry;
    const tempStride = {};
    const tempStart = {};
    for (const j2 in buffers) {
      const buffer = buffers[j2];
      tempStride[buffer.uid] = 0;
      tempStart[buffer.uid] = 0;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      (_a2 = attribute.stride) != null ? _a2 : attribute.stride = tempStride[attribute.buffer.uid];
      (_b = attribute.start) != null ? _b : attribute.start = tempStart[attribute.buffer.uid];
      tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
  }
  var init_ensureAttributes = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs"() {
      init_warn();
      init_getAttributeInfoFromFormat();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
  var GpuStencilModesToPixi;
  var init_GpuStencilModesToPixi = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
      init_const3();
      GpuStencilModesToPixi = [];
      GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
      GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
        stencilWriteMask: 0,
        stencilReadMask: 0
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
        stencilFront: {
          compare: "equal",
          passOp: "increment-clamp"
        },
        stencilBack: {
          compare: "equal",
          passOp: "increment-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
        stencilFront: {
          compare: "equal",
          passOp: "decrement-clamp"
        },
        stencilBack: {
          compare: "equal",
          passOp: "decrement-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
          compare: "equal",
          passOp: "keep"
        },
        stencilBack: {
          compare: "equal",
          passOp: "keep"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
          compare: "not-equal",
          passOp: "keep"
        },
        stencilBack: {
          compare: "not-equal",
          passOp: "keep"
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
  function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
    return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
  }
  function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget, colorTargetCount) {
    return colorMask << 8 | stencilStateId << 5 | renderTarget << 3 | colorTargetCount << 1 | multiSampleCount;
  }
  var topologyStringToId, PipelineSystem;
  var init_PipelineSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
      init_Extensions();
      init_warn();
      init_ensureAttributes();
      init_const3();
      init_createIdFromString();
      init_GpuStencilModesToPixi();
      topologyStringToId = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 2,
        "triangle-list": 3,
        "triangle-strip": 4
      };
      PipelineSystem = class {
        constructor(renderer) {
          this._moduleCache = /* @__PURE__ */ Object.create(null);
          this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
          this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
          this._pipeCache = /* @__PURE__ */ Object.create(null);
          this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
          this._colorMask = 15;
          this._multisampleCount = 1;
          this._colorTargetCount = 1;
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
          this.setStencilMode(STENCIL_MODES.DISABLED);
          this._updatePipeHash();
        }
        setMultisampleCount(multisampleCount) {
          if (this._multisampleCount === multisampleCount)
            return;
          this._multisampleCount = multisampleCount;
          this._updatePipeHash();
        }
        setRenderTarget(renderTarget) {
          this._multisampleCount = renderTarget.msaaSamples;
          this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
          this._colorTargetCount = renderTarget.colorTargetCount;
          this._updatePipeHash();
        }
        setColorMask(colorMask) {
          if (this._colorMask === colorMask)
            return;
          this._colorMask = colorMask;
          this._updatePipeHash();
        }
        setStencilMode(stencilMode) {
          if (this._stencilMode === stencilMode)
            return;
          this._stencilMode = stencilMode;
          this._stencilState = GpuStencilModesToPixi[stencilMode];
          this._updatePipeHash();
        }
        setPipeline(geometry, program, state, passEncoder) {
          const pipeline = this.getPipeline(geometry, program, state);
          passEncoder.setPipeline(pipeline);
        }
        getPipeline(geometry, program, state, topology) {
          if (!geometry._layoutKey) {
            ensureAttributes(geometry, program.attributeData);
            this._generateBufferKey(geometry);
          }
          topology || (topology = geometry.topology);
          const key = getGraphicsStateKey(
            geometry._layoutKey,
            program._layoutKey,
            state.data,
            state._blendModeId,
            topologyStringToId[topology]
          );
          if (this._pipeCache[key])
            return this._pipeCache[key];
          this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
          return this._pipeCache[key];
        }
        _createPipeline(geometry, program, state, topology) {
          const device = this._gpu.device;
          const buffers = this._createVertexBufferLayouts(geometry, program);
          const blendModes = this._renderer.state.getColorTargets(state, this._colorTargetCount);
          const writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
          for (let i3 = 0; i3 < blendModes.length; i3++) {
            blendModes[i3].writeMask = writeMask;
          }
          const layout = this._renderer.shader.getProgramData(program).pipeline;
          const descriptor = {
            // TODO later check if its helpful to create..
            // layout,
            vertex: {
              module: this._getModule(program.vertex.source),
              entryPoint: program.vertex.entryPoint,
              // geometry..
              buffers
            },
            fragment: {
              module: this._getModule(program.fragment.source),
              entryPoint: program.fragment.entryPoint,
              targets: blendModes
            },
            primitive: {
              topology,
              cullMode: state.cullMode
            },
            layout,
            multisample: {
              count: this._multisampleCount
            },
            // depthStencil,
            label: `PIXI Pipeline`
          };
          if (this._depthStencilAttachment) {
            descriptor.depthStencil = __spreadProps(__spreadValues({}, this._stencilState), {
              format: "depth24plus-stencil8",
              depthWriteEnabled: state.depthTest,
              depthCompare: state.depthTest ? "less" : "always"
            });
          }
          const pipeline = device.createRenderPipeline(descriptor);
          return pipeline;
        }
        _getModule(code) {
          return this._moduleCache[code] || this._createModule(code);
        }
        _createModule(code) {
          const device = this._gpu.device;
          this._moduleCache[code] = device.createShaderModule({
            code
          });
          return this._moduleCache[code];
        }
        _generateBufferKey(geometry) {
          const keyGen = [];
          let index = 0;
          const attributeKeys = Object.keys(geometry.attributes).sort();
          for (let i3 = 0; i3 < attributeKeys.length; i3++) {
            const attribute = geometry.attributes[attributeKeys[i3]];
            keyGen[index++] = attribute.offset;
            keyGen[index++] = attribute.format;
            keyGen[index++] = attribute.stride;
            keyGen[index++] = attribute.instance;
          }
          const stringKey = keyGen.join("|");
          geometry._layoutKey = createIdFromString(stringKey, "geometry");
          return geometry._layoutKey;
        }
        _generateAttributeLocationsKey(program) {
          const keyGen = [];
          let index = 0;
          const attributeKeys = Object.keys(program.attributeData).sort();
          for (let i3 = 0; i3 < attributeKeys.length; i3++) {
            const attribute = program.attributeData[attributeKeys[i3]];
            keyGen[index++] = attribute.location;
          }
          const stringKey = keyGen.join("|");
          program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
          return program._attributeLocationsKey;
        }
        /**
         * Returns a hash of buffer names mapped to bind locations.
         * This is used to bind the correct buffer to the correct location in the shader.
         * @param geometry - The geometry where to get the buffer names
         * @param program - The program where to get the buffer names
         * @returns An object of buffer names mapped to the bind location.
         */
        getBufferNamesToBind(geometry, program) {
          const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
          if (this._bindingNamesCache[key])
            return this._bindingNamesCache[key];
          const data = this._createVertexBufferLayouts(geometry, program);
          const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
          const attributeData = program.attributeData;
          for (let i3 = 0; i3 < data.length; i3++) {
            const attributes = Object.values(data[i3].attributes);
            const shaderLocation = attributes[0].shaderLocation;
            for (const j2 in attributeData) {
              if (attributeData[j2].location === shaderLocation) {
                bufferNamesToBind[i3] = j2;
                break;
              }
            }
          }
          this._bindingNamesCache[key] = bufferNamesToBind;
          return bufferNamesToBind;
        }
        _createVertexBufferLayouts(geometry, program) {
          if (!program._attributeLocationsKey)
            this._generateAttributeLocationsKey(program);
          const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
          if (this._bufferLayoutsCache[key]) {
            return this._bufferLayoutsCache[key];
          }
          const vertexBuffersLayout = [];
          geometry.buffers.forEach((buffer) => {
            var _a2;
            const bufferEntry = {
              arrayStride: 0,
              stepMode: "vertex",
              attributes: []
            };
            const bufferEntryAttributes = bufferEntry.attributes;
            for (const i3 in program.attributeData) {
              const attribute = geometry.attributes[i3];
              if (((_a2 = attribute.divisor) != null ? _a2 : 1) !== 1) {
                warn(`Attribute ${i3} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
              }
              if (attribute.buffer === buffer) {
                bufferEntry.arrayStride = attribute.stride;
                bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
                bufferEntryAttributes.push({
                  shaderLocation: program.attributeData[i3].location,
                  offset: attribute.offset,
                  format: attribute.format
                });
              }
            }
            if (bufferEntryAttributes.length) {
              vertexBuffersLayout.push(bufferEntry);
            }
          });
          this._bufferLayoutsCache[key] = vertexBuffersLayout;
          return vertexBuffersLayout;
        }
        _updatePipeHash() {
          const key = getGlobalStateKey(
            this._stencilMode,
            this._multisampleCount,
            this._colorMask,
            this._depthStencilAttachment,
            this._colorTargetCount
          );
          if (!this._pipeStateCaches[key]) {
            this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
          }
          this._pipeCache = this._pipeStateCaches[key];
        }
        destroy() {
          this._renderer = null;
          this._bufferLayoutsCache = null;
        }
      };
      PipelineSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "pipeline"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
  function calculateProjection(pm, x2, y2, width, height, flipY) {
    const sign2 = flipY ? 1 : -1;
    pm.identity();
    pm.a = 1 / width * 2;
    pm.d = sign2 * (1 / height * 2);
    pm.tx = -1 - x2 * pm.a;
    pm.ty = -sign2 - y2 * pm.d;
    return pm;
  }
  var init_calculateProjection = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
  function isRenderingToScreen(renderTarget) {
    const resource = renderTarget.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
  }
  var init_isRenderingToScreen = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs
  var RenderTargetSystem;
  var init_RenderTargetSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs"() {
      init_Matrix();
      init_Rectangle();
      init_const7();
      init_calculateProjection();
      init_SystemRunner();
      init_CanvasSource();
      init_TextureSource();
      init_Texture();
      init_getCanvasTexture();
      init_isRenderingToScreen();
      init_RenderTarget();
      RenderTargetSystem = class {
        constructor(renderer) {
          this.rootViewPort = new Rectangle();
          this.viewport = new Rectangle();
          this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
          this.projectionMatrix = new Matrix();
          this.defaultClearColor = [0, 0, 0, 0];
          this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
          this._renderTargetStack = [];
          this._renderer = renderer;
          renderer.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
        }
        /** called when dev wants to finish a render pass */
        finishRenderPass() {
          this.adaptor.finishRenderPass(this.renderTarget);
        }
        /**
         * called when the renderer starts to render a scene.
         * @param options
         * @param options.target - the render target to render to
         * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param options.clearColor - the color to clear to
         * @param options.frame - the frame to render to
         */
        renderStart({
          target,
          clear,
          clearColor,
          frame
        }) {
          var _a2, _b;
          this._renderTargetStack.length = 0;
          this.push(
            target,
            clear,
            clearColor,
            frame
          );
          this.rootViewPort.copyFrom(this.viewport);
          this.rootRenderTarget = this.renderTarget;
          this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
          (_b = (_a2 = this.adaptor).prerender) == null ? void 0 : _b.call(_a2, this.rootRenderTarget);
        }
        postrender() {
          var _a2, _b;
          (_b = (_a2 = this.adaptor).postrender) == null ? void 0 : _b.call(_a2, this.rootRenderTarget);
        }
        /**
         * Binding a render surface! This is the main function of the render target system.
         * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
         * Once bound all draw calls will be rendered to the render surface.
         *
         * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
         * @param renderSurface - the render surface to bind
         * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param clearColor - the color to clear to
         * @param frame - the frame to render to
         * @returns the render target that was bound
         */
        bind(renderSurface, clear = true, clearColor, frame) {
          const renderTarget = this.getRenderTarget(renderSurface);
          const didChange = this.renderTarget !== renderTarget;
          this.renderTarget = renderTarget;
          this.renderSurface = renderSurface;
          const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
          if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
            this.adaptor.resizeGpuRenderTarget(renderTarget);
            gpuRenderTarget.width = renderTarget.pixelWidth;
            gpuRenderTarget.height = renderTarget.pixelHeight;
          }
          const source11 = renderTarget.colorTexture;
          const viewport = this.viewport;
          const pixelWidth = source11.pixelWidth;
          const pixelHeight = source11.pixelHeight;
          if (!frame && renderSurface instanceof Texture) {
            frame = renderSurface.frame;
          }
          if (frame) {
            const resolution = source11._resolution;
            viewport.x = frame.x * resolution + 0.5 | 0;
            viewport.y = frame.y * resolution + 0.5 | 0;
            viewport.width = frame.width * resolution + 0.5 | 0;
            viewport.height = frame.height * resolution + 0.5 | 0;
          } else {
            viewport.x = 0;
            viewport.y = 0;
            viewport.width = pixelWidth;
            viewport.height = pixelHeight;
          }
          calculateProjection(
            this.projectionMatrix,
            0,
            0,
            viewport.width / source11.resolution,
            viewport.height / source11.resolution,
            !renderTarget.isRoot
          );
          this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
          if (didChange) {
            this.onRenderTargetChange.emit(renderTarget);
          }
          return renderTarget;
        }
        clear(target, clear = CLEAR.ALL, clearColor) {
          if (!clear)
            return;
          if (target) {
            target = this.getRenderTarget(target);
          }
          this.adaptor.clear(
            target || this.renderTarget,
            clear,
            clearColor,
            this.viewport
          );
        }
        contextChange() {
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Push a render surface to the renderer. This will bind the render surface to the renderer,
         * @param renderSurface - the render surface to push
         * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param clearColor - the color to clear to
         * @param frame - the frame to use when rendering to the render surface
         */
        push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {
          const renderTarget = this.bind(renderSurface, clear, clearColor, frame);
          this._renderTargetStack.push({
            renderTarget,
            frame
          });
          return renderTarget;
        }
        /** Pops the current render target from the renderer and restores the previous render target. */
        pop() {
          this._renderTargetStack.pop();
          const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
          this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
        }
        /**
         * Gets the render target from the provide render surface. Eg if its a texture,
         * it will return the render target for the texture.
         * If its a render target, it will return the same render target.
         * @param renderSurface - the render surface to get the render target for
         * @returns the render target for the render surface
         */
        getRenderTarget(renderSurface) {
          var _a2;
          if (renderSurface.isTexture) {
            renderSurface = renderSurface.source;
          }
          return (_a2 = this._renderSurfaceToRenderTargetHash.get(renderSurface)) != null ? _a2 : this._initRenderTarget(renderSurface);
        }
        /**
         * Copies a render surface to another texture.
         *
         * NOTE:
         * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer
         *
         * The following is not valid:
         * @example
         * const canvas = document.createElement('canvas')
         * canvas.width = 200;
         * canvas.height = 200;
         *
         * const ctx = canvas2.getContext('2d')!
         * ctx.fillStyle = 'red'
         * ctx.fillRect(0, 0, 200, 200);
         *
         * const texture = RenderTexture.create({
         *   width: 200,
         *   height: 200,
         * })
         * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);
         *
         * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});
         *
         * The best way to copy a canvas is to create a texture from it. Then render with that.
         *
         * Parsing in a RenderTarget canvas context (with a 2d context)
         * @param sourceRenderSurfaceTexture - the render surface to copy from
         * @param destinationTexture - the texture to copy to
         * @param originSrc - the origin of the copy
         * @param originSrc.x - the x origin of the copy
         * @param originSrc.y - the y origin of the copy
         * @param size - the size of the copy
         * @param size.width - the width of the copy
         * @param size.height - the height of the copy
         * @param originDest - the destination origin (top left to paste from!)
         * @param originDest.x - the x origin of the paste
         * @param originDest.y - the y origin of the paste
         */
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          if (originSrc.x < 0) {
            size.width += originSrc.x;
            originDest.x -= originSrc.x;
            originSrc.x = 0;
          }
          if (originSrc.y < 0) {
            size.height += originSrc.y;
            originDest.y -= originSrc.y;
            originSrc.y = 0;
          }
          const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
          size.width = Math.min(size.width, pixelWidth - originSrc.x);
          size.height = Math.min(size.height, pixelHeight - originSrc.y);
          return this.adaptor.copyToTexture(
            sourceRenderSurfaceTexture,
            destinationTexture,
            originSrc,
            size,
            originDest
          );
        }
        /**
         * ensures that we have a depth stencil buffer available to render to
         * This is used by the mask system to make sure we have a stencil buffer.
         */
        ensureDepthStencil() {
          if (!this.renderTarget.stencil) {
            this.renderTarget.stencil = true;
            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
          }
        }
        /** nukes the render target system */
        destroy() {
          this._renderer = null;
          this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
            if (renderTarget !== key) {
              renderTarget.destroy();
            }
          });
          this._renderSurfaceToRenderTargetHash.clear();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        }
        _initRenderTarget(renderSurface) {
          let renderTarget = null;
          if (CanvasSource.test(renderSurface)) {
            renderSurface = getCanvasTexture(renderSurface).source;
          }
          if (renderSurface instanceof RenderTarget) {
            renderTarget = renderSurface;
          } else if (renderSurface instanceof TextureSource) {
            renderTarget = new RenderTarget({
              colorTextures: [renderSurface]
            });
            if (renderSurface.source instanceof CanvasSource) {
              renderTarget.isRoot = true;
            }
            renderSurface.once("destroy", () => {
              renderTarget.destroy();
              this._renderSurfaceToRenderTargetHash.delete(renderSurface);
              const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
              if (gpuRenderTarget) {
                this._gpuRenderTargetHash[renderTarget.uid] = null;
                this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
              }
            });
          }
          this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
          return renderTarget;
        }
        getGpuRenderTarget(renderTarget) {
          return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
        }
        resetState() {
          this.renderTarget = null;
          this.renderSurface = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
  var GpuRenderTarget;
  var init_GpuRenderTarget = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
      "use strict";
      GpuRenderTarget = class {
        constructor() {
          this.contexts = [];
          this.msaaTextures = [];
          this.msaaSamples = 1;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs
  var GpuRenderTargetAdaptor;
  var init_GpuRenderTargetAdaptor = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs"() {
      init_const7();
      init_CanvasSource();
      init_TextureSource();
      init_GpuRenderTarget();
      GpuRenderTargetAdaptor = class {
        init(renderer, renderTargetSystem) {
          this._renderer = renderer;
          this._renderTargetSystem = renderTargetSystem;
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          const renderer = this._renderer;
          const baseGpuTexture = this._getGpuColorTexture(
            sourceRenderSurfaceTexture
          );
          const backGpuTexture = renderer.texture.getGpuSource(
            destinationTexture.source
          );
          renderer.encoder.commandEncoder.copyTextureToTexture(
            {
              texture: baseGpuTexture,
              origin: originSrc
            },
            {
              texture: backGpuTexture,
              origin: originDest
            },
            size
          );
          return destinationTexture;
        }
        startRenderPass(renderTarget, clear = true, clearColor, viewport) {
          const renderTargetSystem = this._renderTargetSystem;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
          gpuRenderTarget.descriptor = descriptor;
          this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
          this._renderer.encoder.beginRenderPass(gpuRenderTarget);
          this._renderer.encoder.setViewport(viewport);
        }
        finishRenderPass() {
          this._renderer.encoder.endRenderPass();
        }
        /**
         * returns the gpu texture for the first color texture in the render target
         * mainly used by the filter manager to get copy the texture for blending
         * @param renderTarget
         * @returns a gpu texture
         */
        _getGpuColorTexture(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (gpuRenderTarget.contexts[0]) {
            return gpuRenderTarget.contexts[0].getCurrentTexture();
          }
          return this._renderer.texture.getGpuSource(
            renderTarget.colorTextures[0].source
          );
        }
        getDescriptor(renderTarget, clear, clearValue) {
          if (typeof clear === "boolean") {
            clear = clear ? CLEAR.ALL : CLEAR.NONE;
          }
          const renderTargetSystem = this._renderTargetSystem;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          const colorAttachments = renderTarget.colorTextures.map(
            (texture, i3) => {
              const context4 = gpuRenderTarget.contexts[i3];
              let view;
              let resolveTarget;
              if (context4) {
                const currentTexture = context4.getCurrentTexture();
                const canvasTextureView = currentTexture.createView();
                view = canvasTextureView;
              } else {
                view = this._renderer.texture.getGpuSource(texture).createView({
                  mipLevelCount: 1
                });
              }
              if (gpuRenderTarget.msaaTextures[i3]) {
                resolveTarget = view;
                view = this._renderer.texture.getTextureView(
                  gpuRenderTarget.msaaTextures[i3]
                );
              }
              const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
              clearValue != null ? clearValue : clearValue = renderTargetSystem.defaultClearColor;
              return {
                view,
                resolveTarget,
                clearValue,
                storeOp: "store",
                loadOp
              };
            }
          );
          let depthStencilAttachment;
          if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
            renderTarget.ensureDepthStencilTexture();
            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
          }
          if (renderTarget.depthStencilTexture) {
            const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
            const depthLoadOp = clear & CLEAR.DEPTH ? "clear" : "load";
            depthStencilAttachment = {
              view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
              stencilStoreOp: "store",
              stencilLoadOp,
              depthClearValue: 1,
              depthLoadOp,
              depthStoreOp: "store"
            };
          }
          const descriptor = {
            colorAttachments,
            depthStencilAttachment
          };
          return descriptor;
        }
        clear(renderTarget, clear = true, clearColor, viewport) {
          if (!clear)
            return;
          const { gpu, encoder } = this._renderer;
          const device = gpu.device;
          const standAlone = encoder.commandEncoder === null;
          if (standAlone) {
            const commandEncoder = device.createCommandEncoder();
            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
            passEncoder.end();
            const gpuCommands = commandEncoder.finish();
            device.queue.submit([gpuCommands]);
          } else {
            this.startRenderPass(renderTarget, clear, clearColor, viewport);
          }
        }
        initGpuRenderTarget(renderTarget) {
          renderTarget.isRoot = true;
          const gpuRenderTarget = new GpuRenderTarget();
          gpuRenderTarget.colorTargetCount = renderTarget.colorTextures.length;
          renderTarget.colorTextures.forEach((colorTexture, i3) => {
            if (colorTexture instanceof CanvasSource) {
              const context4 = colorTexture.resource.getContext(
                "webgpu"
              );
              const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
              try {
                context4.configure({
                  device: this._renderer.gpu.device,
                  usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                  format: "bgra8unorm",
                  alphaMode
                });
              } catch (e2) {
                console.error(e2);
              }
              gpuRenderTarget.contexts[i3] = context4;
            }
            gpuRenderTarget.msaa = colorTexture.source.antialias;
            if (colorTexture.source.antialias) {
              const msaaTexture = new TextureSource({
                width: 0,
                height: 0,
                sampleCount: 4
              });
              gpuRenderTarget.msaaTextures[i3] = msaaTexture;
            }
          });
          if (gpuRenderTarget.msaa) {
            gpuRenderTarget.msaaSamples = 4;
            if (renderTarget.depthStencilTexture) {
              renderTarget.depthStencilTexture.source.sampleCount = 4;
            }
          }
          return gpuRenderTarget;
        }
        destroyGpuRenderTarget(gpuRenderTarget) {
          gpuRenderTarget.contexts.forEach((context4) => {
            context4.unconfigure();
          });
          gpuRenderTarget.msaaTextures.forEach((texture) => {
            texture.destroy();
          });
          gpuRenderTarget.msaaTextures.length = 0;
          gpuRenderTarget.contexts.length = 0;
        }
        ensureDepthStencilTexture(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
            renderTarget.depthStencilTexture.source.sampleCount = 4;
          }
        }
        resizeGpuRenderTarget(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          gpuRenderTarget.width = renderTarget.width;
          gpuRenderTarget.height = renderTarget.height;
          if (gpuRenderTarget.msaa) {
            renderTarget.colorTextures.forEach((colorTexture, i3) => {
              const msaaTexture = gpuRenderTarget.msaaTextures[i3];
              msaaTexture == null ? void 0 : msaaTexture.resize(
                colorTexture.source.width,
                colorTexture.source.height,
                colorTexture.source._resolution
              );
            });
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
  var GpuRenderTargetSystem;
  var init_GpuRenderTargetSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
      init_Extensions();
      init_RenderTargetSystem();
      init_GpuRenderTargetAdaptor();
      GpuRenderTargetSystem = class extends RenderTargetSystem {
        constructor(renderer) {
          super(renderer);
          this.adaptor = new GpuRenderTargetAdaptor();
          this.adaptor.init(renderer, this);
        }
      };
      GpuRenderTargetSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "renderTarget"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
  var GpuShaderSystem;
  var init_GpuShaderSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
      init_Extensions();
      GpuShaderSystem = class {
        constructor() {
          this._gpuProgramData = /* @__PURE__ */ Object.create(null);
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getProgramData(program) {
          return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
        }
        _createGPUProgramData(program) {
          const device = this._gpu.device;
          const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
          const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
          this._gpuProgramData[program._layoutKey] = {
            bindGroups,
            pipeline: device.createPipelineLayout(pipelineLayoutDesc)
          };
          return this._gpuProgramData[program._layoutKey];
        }
        destroy() {
          this._gpu = null;
          this._gpuProgramData = null;
        }
      };
      GpuShaderSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "shader"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
  var GpuBlendModesToPixi;
  var init_GpuBlendModesToPixi = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
      "use strict";
      GpuBlendModesToPixi = {};
      GpuBlendModesToPixi.normal = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.add = {
        alpha: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.multiply = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "dst",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.screen = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.overlay = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.none = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "zero",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["normal-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["add-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["screen-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.erase = {
        alpha: {
          srcFactor: "zero",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.min = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "min"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "min"
        }
      };
      GpuBlendModesToPixi.max = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "max"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "max"
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
  var GpuStateSystem;
  var init_GpuStateSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
      init_Extensions();
      init_State();
      init_GpuBlendModesToPixi();
      GpuStateSystem = class {
        constructor() {
          this.defaultState = new State();
          this.defaultState.blend = true;
        }
        contextChange(gpu) {
          this.gpu = gpu;
        }
        /**
         * Gets the blend mode data for the current state
         * @param state - The state to get the blend mode from
         * @param count - The number of color targets to create
         */
        getColorTargets(state, count2) {
          const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
          const targets = [];
          const target = {
            format: "bgra8unorm",
            writeMask: 0,
            blend
          };
          for (let i3 = 0; i3 < count2; i3++) {
            targets[i3] = target;
          }
          return targets;
        }
        destroy() {
          this.gpu = null;
        }
      };
      GpuStateSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "state"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
  var gpuUploadBufferImageResource;
  var init_gpuUploadBufferImageResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
      "use strict";
      gpuUploadBufferImageResource = {
        type: "image",
        upload(source11, gpuTexture, gpu) {
          const resource = source11.resource;
          const total = (source11.pixelWidth | 0) * (source11.pixelHeight | 0);
          const bytesPerPixel = resource.byteLength / total;
          gpu.device.queue.writeTexture(
            { texture: gpuTexture },
            resource,
            {
              offset: 0,
              rowsPerImage: source11.pixelHeight,
              bytesPerRow: source11.pixelWidth * bytesPerPixel
            },
            {
              width: source11.pixelWidth,
              height: source11.pixelHeight,
              depthOrArrayLayers: 1
            }
          );
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs
  var blockDataMap, defaultBlockData, gpuUploadCompressedTextureResource;
  var init_gpuUploadCompressedTextureResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs"() {
      "use strict";
      blockDataMap = {
        "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
      };
      defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
      gpuUploadCompressedTextureResource = {
        type: "compressed",
        upload(source11, gpuTexture, gpu) {
          let mipWidth = source11.pixelWidth;
          let mipHeight = source11.pixelHeight;
          const blockData = blockDataMap[source11.format] || defaultBlockData;
          for (let i3 = 0; i3 < source11.resource.length; i3++) {
            const levelBuffer = source11.resource[i3];
            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
            gpu.device.queue.writeTexture(
              {
                texture: gpuTexture,
                mipLevel: i3
              },
              levelBuffer,
              {
                offset: 0,
                bytesPerRow
              },
              {
                width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
                height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
                depthOrArrayLayers: 1
              }
            );
            mipWidth = Math.max(mipWidth >> 1, 1);
            mipHeight = Math.max(mipHeight >> 1, 1);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
  var gpuUploadImageResource;
  var init_gpuUploadImageSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
      init_adapter();
      init_warn();
      gpuUploadImageResource = {
        type: "image",
        upload(source11, gpuTexture, gpu) {
          const resource = source11.resource;
          if (!resource)
            return;
          if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement) {
            const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);
            const context4 = canvas.getContext("2d");
            context4.drawImage(resource, 0, 0, resource.width, resource.height);
            source11.resource = canvas;
            warn("ImageSource: Image element passed, converting to canvas and replacing resource.");
          }
          const width = Math.min(gpuTexture.width, source11.resourceWidth || source11.pixelWidth);
          const height = Math.min(gpuTexture.height, source11.resourceHeight || source11.pixelHeight);
          const premultipliedAlpha = source11.alphaMode === "premultiply-alpha-on-upload";
          gpu.device.queue.copyExternalImageToTexture(
            { source: resource },
            { texture: gpuTexture, premultipliedAlpha },
            {
              width,
              height
            }
          );
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
  var gpuUploadVideoResource;
  var init_gpuUploadVideoSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
      init_gpuUploadImageSource();
      gpuUploadVideoResource = {
        type: "video",
        upload(source11, gpuTexture, gpu) {
          gpuUploadImageResource.upload(source11, gpuTexture, gpu);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
  var GpuMipmapGenerator;
  var init_GpuMipmapGenerator = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
      "use strict";
      GpuMipmapGenerator = class {
        constructor(device) {
          this.device = device;
          this.sampler = device.createSampler({ minFilter: "linear" });
          this.pipelines = {};
        }
        _getMipmapPipeline(format) {
          let pipeline = this.pipelines[format];
          if (!pipeline) {
            if (!this.mipmapShaderModule) {
              this.mipmapShaderModule = this.device.createShaderModule({
                code: (
                  /* wgsl */
                  `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
                )
              });
            }
            pipeline = this.device.createRenderPipeline({
              layout: "auto",
              vertex: {
                module: this.mipmapShaderModule,
                entryPoint: "vertexMain"
              },
              fragment: {
                module: this.mipmapShaderModule,
                entryPoint: "fragmentMain",
                targets: [{ format }]
              }
            });
            this.pipelines[format] = pipeline;
          }
          return pipeline;
        }
        /**
         * Generates mipmaps for the given GPUTexture from the data in level 0.
         * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
         * @returns {module:External.GPUTexture} - The originally passed texture
         */
        generateMipmap(texture) {
          const pipeline = this._getMipmapPipeline(texture.format);
          if (texture.dimension === "3d" || texture.dimension === "1d") {
            throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
          }
          let mipTexture = texture;
          const arrayLayerCount = texture.depthOrArrayLayers || 1;
          const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
          if (!renderToSource) {
            const mipTextureDescriptor = {
              size: {
                width: Math.ceil(texture.width / 2),
                height: Math.ceil(texture.height / 2),
                depthOrArrayLayers: arrayLayerCount
              },
              format: texture.format,
              usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
              mipLevelCount: texture.mipLevelCount - 1
            };
            mipTexture = this.device.createTexture(mipTextureDescriptor);
          }
          const commandEncoder = this.device.createCommandEncoder({});
          const bindGroupLayout = pipeline.getBindGroupLayout(0);
          for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
            let srcView = texture.createView({
              baseMipLevel: 0,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            let dstMipLevel = renderToSource ? 1 : 0;
            for (let i3 = 1; i3 < texture.mipLevelCount; ++i3) {
              const dstView = mipTexture.createView({
                baseMipLevel: dstMipLevel++,
                mipLevelCount: 1,
                dimension: "2d",
                baseArrayLayer: arrayLayer,
                arrayLayerCount: 1
              });
              const passEncoder = commandEncoder.beginRenderPass({
                colorAttachments: [{
                  view: dstView,
                  storeOp: "store",
                  loadOp: "clear",
                  clearValue: { r: 0, g: 0, b: 0, a: 0 }
                }]
              });
              const bindGroup = this.device.createBindGroup({
                layout: bindGroupLayout,
                entries: [{
                  binding: 0,
                  resource: this.sampler
                }, {
                  binding: 1,
                  resource: srcView
                }]
              });
              passEncoder.setPipeline(pipeline);
              passEncoder.setBindGroup(0, bindGroup);
              passEncoder.draw(3, 1, 0, 0);
              passEncoder.end();
              srcView = dstView;
            }
          }
          if (!renderToSource) {
            const mipLevelSize = {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            };
            for (let i3 = 1; i3 < texture.mipLevelCount; ++i3) {
              commandEncoder.copyTextureToTexture({
                texture: mipTexture,
                mipLevel: i3 - 1
              }, {
                texture,
                mipLevel: i3
              }, mipLevelSize);
              mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
              mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
            }
          }
          this.device.queue.submit([commandEncoder.finish()]);
          if (!renderToSource) {
            mipTexture.destroy();
          }
          return texture;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
  var GPUTextureGpuData, GpuTextureSystem;
  var init_GpuTextureSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_GCManagedHash();
      init_UniformGroup();
      init_CanvasPool();
      init_BindGroup();
      init_gpuUploadBufferImageResource();
      init_gpuUploadCompressedTextureResource();
      init_gpuUploadImageSource();
      init_gpuUploadVideoSource();
      init_GpuMipmapGenerator();
      GPUTextureGpuData = class {
        constructor(gpuTexture) {
          this.textureView = null;
          this.gpuTexture = gpuTexture;
        }
        /** Destroys this GPU data instance. */
        destroy() {
          this.gpuTexture.destroy();
          this.textureView = null;
          this.gpuTexture = null;
        }
      };
      GpuTextureSystem = class {
        constructor(renderer) {
          this._gpuSamplers = /* @__PURE__ */ Object.create(null);
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: gpuUploadImageResource,
            buffer: gpuUploadBufferImageResource,
            video: gpuUploadVideoResource,
            compressed: gpuUploadCompressedTextureResource
          };
          this._renderer = renderer;
          renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
          this._managedTextures = new GCManagedHash({
            renderer,
            type: "resource",
            onUnload: this.onSourceUnload.bind(this),
            name: "gpuTextureSource"
          });
        }
        /**
         * @deprecated since 8.15.0
         */
        get managedTextures() {
          return Object.values(this._managedTextures.items);
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        /**
         * Initializes a texture source, if it has already been initialized nothing will happen.
         * @param source - The texture source to initialize.
         * @returns The initialized texture source.
         */
        initSource(source11) {
          var _a2;
          return ((_a2 = source11._gpuData[this._renderer.uid]) == null ? void 0 : _a2.gpuTexture) || this._initSource(source11);
        }
        _initSource(source11) {
          if (source11.autoGenerateMipmaps) {
            const biggestDimension = Math.max(source11.pixelWidth, source11.pixelHeight);
            source11.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
          if (source11.uploadMethodId !== "compressed") {
            usage |= GPUTextureUsage.RENDER_ATTACHMENT;
            usage |= GPUTextureUsage.COPY_SRC;
          }
          const blockData = blockDataMap[source11.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
          const width = Math.ceil(source11.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
          const height = Math.ceil(source11.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
          const textureDescriptor = {
            label: source11.label,
            size: { width, height },
            format: source11.format,
            sampleCount: source11.sampleCount,
            mipLevelCount: source11.mipLevelCount,
            dimension: source11.dimension,
            usage
          };
          const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
          source11._gpuData[this._renderer.uid] = new GPUTextureGpuData(gpuTexture);
          const added = this._managedTextures.add(source11);
          if (added) {
            source11.on("update", this.onSourceUpdate, this);
            source11.on("resize", this.onSourceResize, this);
            source11.on("updateMipmaps", this.onUpdateMipmaps, this);
          }
          this.onSourceUpdate(source11);
          return gpuTexture;
        }
        onSourceUpdate(source11) {
          const gpuTexture = this.getGpuSource(source11);
          if (!gpuTexture)
            return;
          if (this._uploads[source11.uploadMethodId]) {
            this._uploads[source11.uploadMethodId].upload(source11, gpuTexture, this._gpu);
          }
          if (source11.autoGenerateMipmaps && source11.mipLevelCount > 1) {
            this.onUpdateMipmaps(source11);
          }
        }
        onUpdateMipmaps(source11) {
          if (!this._mipmapGenerator) {
            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
          }
          const gpuTexture = this.getGpuSource(source11);
          this._mipmapGenerator.generateMipmap(gpuTexture);
        }
        onSourceUnload(source11) {
          source11.off("update", this.onSourceUpdate, this);
          source11.off("resize", this.onSourceResize, this);
          source11.off("updateMipmaps", this.onUpdateMipmaps, this);
        }
        onSourceResize(source11) {
          source11._gcLastUsed = this._renderer.gc.now;
          const gpuData = source11._gpuData[this._renderer.uid];
          const gpuTexture = gpuData == null ? void 0 : gpuData.gpuTexture;
          if (!gpuTexture) {
            this.initSource(source11);
          } else if (gpuTexture.width !== source11.pixelWidth || gpuTexture.height !== source11.pixelHeight) {
            gpuData.destroy();
            this._bindGroupHash[source11.uid] = null;
            source11._gpuData[this._renderer.uid] = null;
            this.initSource(source11);
          }
        }
        _initSampler(sampler) {
          this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
          return this._gpuSamplers[sampler._resourceId];
        }
        getGpuSampler(sampler) {
          return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
        }
        getGpuSource(source11) {
          var _a2;
          source11._gcLastUsed = this._renderer.gc.now;
          return ((_a2 = source11._gpuData[this._renderer.uid]) == null ? void 0 : _a2.gpuTexture) || this.initSource(source11);
        }
        /**
         * this returns s bind group for a specific texture, the bind group contains
         * - the texture source
         * - the texture style
         * - the texture matrix
         * This is cached so the bind group should only be created once per texture
         * @param texture - the texture you want the bindgroup for
         * @returns the bind group for the texture
         */
        getTextureBindGroup(texture) {
          return this._bindGroupHash[texture.uid] || this._createTextureBindGroup(texture);
        }
        _createTextureBindGroup(texture) {
          const source11 = texture.source;
          this._bindGroupHash[texture.uid] = new BindGroup({
            0: source11,
            1: source11.style,
            2: new UniformGroup({
              uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }
            })
          });
          return this._bindGroupHash[texture.uid];
        }
        getTextureView(texture) {
          const source11 = texture.source;
          source11._gcLastUsed = this._renderer.gc.now;
          let gpuData = source11._gpuData[this._renderer.uid];
          let textureView = null;
          if (!gpuData) {
            this.initSource(source11);
            gpuData = source11._gpuData[this._renderer.uid];
          }
          textureView = gpuData.textureView || gpuData.gpuTexture.createView();
          return textureView;
        }
        generateCanvas(texture) {
          const renderer = this._renderer;
          const commandEncoder = renderer.gpu.device.createCommandEncoder();
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = texture.source.pixelWidth;
          canvas.height = texture.source.pixelHeight;
          const context4 = canvas.getContext("webgpu");
          context4.configure({
            device: renderer.gpu.device,
            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
            alphaMode: "premultiplied"
          });
          commandEncoder.copyTextureToTexture({
            texture: renderer.texture.getGpuSource(texture.source),
            origin: {
              x: 0,
              y: 0
            }
          }, {
            texture: context4.getCurrentTexture()
          }, {
            width: canvas.width,
            height: canvas.height
          });
          renderer.gpu.device.queue.submit([commandEncoder.finish()]);
          return canvas;
        }
        getPixels(texture) {
          const webGPUCanvas = this.generateCanvas(texture);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
          const context4 = canvasAndContext.context;
          context4.drawImage(webGPUCanvas, 0, 0);
          const { width, height } = webGPUCanvas;
          const imageData = context4.getImageData(0, 0, width, height);
          const pixels = new Uint8ClampedArray(imageData.data.buffer);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          return { pixels, width, height };
        }
        destroy() {
          this._managedTextures.destroy();
          for (const k2 of Object.keys(this._bindGroupHash)) {
            const key = Number(k2);
            const bindGroup = this._bindGroupHash[key];
            bindGroup == null ? void 0 : bindGroup.destroy();
          }
          this._renderer = null;
          this._gpu = null;
          this._mipmapGenerator = null;
          this._gpuSamplers = null;
          this._bindGroupHash = null;
        }
      };
      GpuTextureSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "texture"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
  var WebGPURenderer_exports = {};
  __export(WebGPURenderer_exports, {
    WebGPURenderer: () => WebGPURenderer
  });
  var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
  var init_WebGPURenderer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
      init_Extensions();
      init_GpuGraphicsAdaptor();
      init_GpuMeshAdapter();
      init_GpuBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types2();
      init_BindGroupSystem();
      init_GpuBufferSystem();
      init_GpuColorMaskSystem();
      init_GpuDeviceSystem();
      init_GpuEncoderSystem();
      init_GpuLimitsSystem();
      init_GpuStencilSystem();
      init_GpuUboSystem();
      init_GpuUniformBatchPipe();
      init_PipelineSystem();
      init_GpuRenderTargetSystem();
      init_GpuShaderSystem();
      init_GpuStateSystem();
      init_GpuTextureSystem();
      DefaultWebGPUSystems = [
        ...SharedSystems,
        GpuUboSystem,
        GpuEncoderSystem,
        GpuDeviceSystem,
        GpuLimitsSystem,
        GpuBufferSystem,
        GpuTextureSystem,
        GpuRenderTargetSystem,
        GpuShaderSystem,
        GpuStateSystem,
        PipelineSystem,
        GpuColorMaskSystem,
        GpuStencilSystem,
        BindGroupSystem
      ];
      DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
      DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
      systems = [];
      renderPipes = [];
      renderPipeAdaptors = [];
      extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
      extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
      extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
      extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
      WebGPURenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgpu",
            type: RendererType.WEBGPU,
            systems,
            renderPipes,
            renderPipeAdaptors
          };
          super(systemConfig);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
  var GlGraphicsAdaptor;
  var init_GlGraphicsAdaptor = __esm({
    "node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      GlGraphicsAdaptor = class {
        contextChange(renderer) {
          const uniforms = new UniformGroup({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          const maxTextures = renderer.limits.maxBatchableTextures;
          const glProgram3 = compileHighShaderGlProgram({
            name: "graphics",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures),
              localUniformBitGl,
              roundPixelsBitGl
            ]
          });
          this.shader = new Shader({
            glProgram: glProgram3,
            resources: {
              localUniforms: uniforms,
              batchSamplers: getBatchSamplersUniformGroup(maxTextures)
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context4 = renderable.context;
          const shader = context4.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            batcher,
            instructions
          } = contextSystem.getContextRenderData(context4);
          shader.groups[0] = renderer.globalUniforms.bindGroup;
          renderer.state.set(graphicsPipe.state);
          renderer.shader.bind(shader);
          renderer.geometry.bind(batcher.geometry, shader.glProgram);
          const batches = instructions.instructions;
          for (let i3 = 0; i3 < instructions.instructionSize; i3++) {
            const batch = batches[i3];
            if (batch.size) {
              for (let j2 = 0; j2 < batch.textures.count; j2++) {
                renderer.texture.bind(batch.textures.textures[j2], j2);
              }
              renderer.geometry.draw(batch.topology, batch.size, batch.start);
            }
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GlGraphicsAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
  var GlMeshAdaptor;
  var init_GlMeshAdaptor = __esm({
    "node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader();
      init_Texture();
      init_warn();
      GlMeshAdaptor = class {
        init() {
          const glProgram3 = compileHighShaderGlProgram({
            name: "mesh",
            bits: [
              localUniformBitGl,
              textureBitGl,
              roundPixelsBitGl
            ]
          });
          this._shader = new Shader({
            glProgram: glProgram3,
            resources: {
              uTexture: Texture.EMPTY.source,
              textureUniforms: {
                uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
              }
            }
          });
        }
        execute(meshPipe, mesh) {
          const renderer = meshPipe.renderer;
          let shader = mesh._shader;
          if (!shader) {
            shader = this._shader;
            const texture = mesh.texture;
            const source11 = texture.source;
            shader.resources.uTexture = source11;
            shader.resources.uSampler = source11.style;
            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
          } else if (!shader.glProgram) {
            warn("Mesh shader has no glProgram", mesh.shader);
            return;
          }
          shader.groups[100] = renderer.globalUniforms.bindGroup;
          shader.groups[101] = meshPipe.localUniformsBindGroup;
          renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GlMeshAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
  var GlBatchAdaptor;
  var init_GlBatchAdaptor = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
      init_Extensions();
      init_State();
      GlBatchAdaptor = class {
        constructor() {
          this._tempState = State.for2d();
          this._didUploadHash = {};
        }
        init(batcherPipe) {
          batcherPipe.renderer.runners.contextChange.add(this);
        }
        contextChange() {
          this._didUploadHash = {};
        }
        start(batchPipe, geometry, shader) {
          const renderer = batchPipe.renderer;
          const didUpload = this._didUploadHash[shader.uid];
          renderer.shader.bind(shader, didUpload);
          if (!didUpload) {
            this._didUploadHash[shader.uid] = true;
          }
          renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
          renderer.geometry.bind(geometry, shader.glProgram);
        }
        execute(batchPipe, batch) {
          const renderer = batchPipe.renderer;
          this._tempState.blendMode = batch.blendMode;
          renderer.state.set(this._tempState);
          const textures = batch.textures.textures;
          for (let i3 = 0; i3 < batch.textures.count; i3++) {
            renderer.texture.bind(textures[i3], i3);
          }
          renderer.geometry.draw(batch.topology, batch.size, batch.start);
        }
      };
      GlBatchAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
  var BUFFER_TYPE;
  var init_const9 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs"() {
      "use strict";
      BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
        BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
        BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
        BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
        return BUFFER_TYPE2;
      })(BUFFER_TYPE || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
  var GlBuffer;
  var init_GlBuffer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
      "use strict";
      GlBuffer = class {
        constructor(buffer, type) {
          this._lastBindBaseLocation = -1;
          this._lastBindCallId = -1;
          this.buffer = buffer || null;
          this.updateID = -1;
          this.byteLength = -1;
          this.type = type;
        }
        destroy() {
          this.buffer = null;
          this.updateID = -1;
          this.byteLength = -1;
          this.type = -1;
          this._lastBindBaseLocation = -1;
          this._lastBindCallId = -1;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
  var GlBufferSystem;
  var init_GlBufferSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
      init_Extensions();
      init_GCManagedHash();
      init_const4();
      init_const9();
      init_GlBuffer();
      GlBufferSystem = class {
        /**
         * @param {Renderer} renderer - The renderer this System works for.
         */
        constructor(renderer) {
          this._boundBufferBases = /* @__PURE__ */ Object.create(null);
          this._minBaseLocation = 0;
          this._nextBindBaseIndex = this._minBaseLocation;
          this._bindCallId = 0;
          this._renderer = renderer;
          this._managedBuffers = new GCManagedHash({
            renderer,
            type: "resource",
            onUnload: this.onBufferUnload.bind(this),
            name: "glBuffer"
          });
        }
        /** @ignore */
        destroy() {
          this._managedBuffers.destroy();
          this._renderer = null;
          this._gl = null;
          this._boundBufferBases = {};
        }
        /** Sets up the renderer context and necessary buffers. */
        contextChange() {
          this._gl = this._renderer.gl;
          this.destroyAll(true);
          this._maxBindings = this._renderer.limits.maxUniformBindings;
        }
        getGlBuffer(buffer) {
          buffer._gcLastUsed = this._renderer.gc.now;
          return buffer._gpuData[this._renderer.uid] || this.createGLBuffer(buffer);
        }
        /**
         * This binds specified buffer. On first run, it will create the webGL buffers for the context too
         * @param buffer - the buffer to bind to the renderer
         */
        bind(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        }
        /**
         * Binds an uniform buffer to at the given index.
         *
         * A cache is used so a buffer will not be bound again if already bound.
         * @param glBuffer - the buffer to bind
         * @param index - the base index to bind it to.
         */
        bindBufferBase(glBuffer, index) {
          const { _gl: gl } = this;
          if (this._boundBufferBases[index] !== glBuffer) {
            this._boundBufferBases[index] = glBuffer;
            glBuffer._lastBindBaseLocation = index;
            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
          }
        }
        nextBindBase(hasTransformFeedback) {
          this._bindCallId++;
          this._minBaseLocation = 0;
          if (hasTransformFeedback) {
            this._boundBufferBases[0] = null;
            this._minBaseLocation = 1;
            if (this._nextBindBaseIndex < 1) {
              this._nextBindBaseIndex = 1;
            }
          }
        }
        freeLocationForBufferBase(glBuffer) {
          let freeIndex = this.getLastBindBaseLocation(glBuffer);
          if (freeIndex >= this._minBaseLocation) {
            glBuffer._lastBindCallId = this._bindCallId;
            return freeIndex;
          }
          let loop = 0;
          let nextIndex = this._nextBindBaseIndex;
          while (loop < 2) {
            if (nextIndex >= this._maxBindings) {
              nextIndex = this._minBaseLocation;
              loop++;
            }
            const curBuf = this._boundBufferBases[nextIndex];
            if (curBuf && curBuf._lastBindCallId === this._bindCallId) {
              nextIndex++;
              continue;
            }
            break;
          }
          freeIndex = nextIndex;
          this._nextBindBaseIndex = nextIndex + 1;
          if (loop >= 2) {
            return -1;
          }
          glBuffer._lastBindCallId = this._bindCallId;
          this._boundBufferBases[freeIndex] = null;
          return freeIndex;
        }
        getLastBindBaseLocation(glBuffer) {
          const index = glBuffer._lastBindBaseLocation;
          if (this._boundBufferBases[index] === glBuffer) {
            return index;
          }
          return -1;
        }
        /**
         * Binds a buffer whilst also binding its range.
         * This will make the buffer start from the offset supplied rather than 0 when it is read.
         * @param glBuffer - the buffer to bind
         * @param index - the base index to bind at, defaults to 0
         * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
         * @param size - the size to bind at (this is blocks of 256).
         */
        bindBufferRange(glBuffer, index, offset, size) {
          const { _gl: gl } = this;
          offset || (offset = 0);
          index || (index = 0);
          this._boundBufferBases[index] = null;
          gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);
        }
        /**
         * Will ensure the data in the buffer is uploaded to the GPU.
         * @param {Buffer} buffer - the buffer to update
         */
        updateBuffer(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          if (buffer._updateID === glBuffer.updateID) {
            return glBuffer;
          }
          glBuffer.updateID = buffer._updateID;
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
          const data = buffer.data;
          const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
          if (data) {
            if (glBuffer.byteLength >= data.byteLength) {
              gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
            } else {
              glBuffer.byteLength = data.byteLength;
              gl.bufferData(glBuffer.type, data, drawType);
            }
          } else {
            glBuffer.byteLength = buffer.descriptor.size;
            gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);
          }
          return glBuffer;
        }
        /**
         * dispose all WebGL resources of all managed buffers
         * @param contextLost
         */
        destroyAll(contextLost = false) {
          this._managedBuffers.removeAll(contextLost);
        }
        onBufferUnload(buffer, contextLost = false) {
          const glBuffer = buffer._gpuData[this._renderer.uid];
          if (!glBuffer)
            return;
          if (!contextLost)
            this._gl.deleteBuffer(glBuffer.buffer);
        }
        /**
         * creates and attaches a GLBuffer object tied to the current context.
         * @param buffer
         * @protected
         */
        createGLBuffer(buffer) {
          const { _gl: gl } = this;
          let type = BUFFER_TYPE.ARRAY_BUFFER;
          if (buffer.descriptor.usage & BufferUsage.INDEX) {
            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
          } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
            type = BUFFER_TYPE.UNIFORM_BUFFER;
          }
          const glBuffer = new GlBuffer(gl.createBuffer(), type);
          buffer._gpuData[this._renderer.uid] = glBuffer;
          this._managedBuffers.add(buffer);
          return glBuffer;
        }
        resetState() {
          this._boundBufferBases = /* @__PURE__ */ Object.create(null);
        }
      };
      GlBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "buffer"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
  var _GlContextSystem, GlContextSystem;
  var init_GlContextSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_warn();
      _GlContextSystem = class _GlContextSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this.supports = {
            /** Support for 32-bit indices buffer. */
            uint32Indices: true,
            /** Support for UniformBufferObjects */
            uniformBufferObject: true,
            /** Support for VertexArrayObjects */
            vertexArrayObject: true,
            /** Support for SRGB texture format */
            srgbTextures: true,
            /** Support for wrapping modes if a texture is non-power of two */
            nonPowOf2wrapping: true,
            /** Support for MSAA (antialiasing of dynamic textures) */
            msaa: true,
            /** Support for mipmaps if a texture is non-power of two */
            nonPowOf2mipmaps: true
          };
          this._renderer = renderer;
          this.extensions = /* @__PURE__ */ Object.create(null);
          this.handleContextLost = this.handleContextLost.bind(this);
          this.handleContextRestored = this.handleContextRestored.bind(this);
        }
        /**
         * `true` if the context is lost
         * @readonly
         */
        get isLost() {
          return !this.gl || this.gl.isContextLost();
        }
        /**
         * Handles the context change event.
         * @param {WebGLRenderingContext} gl - New WebGL context.
         */
        contextChange(gl) {
          this.gl = gl;
          this._renderer.gl = gl;
        }
        init(options) {
          var _a2, _b;
          options = __spreadValues(__spreadValues({}, _GlContextSystem2.defaultOptions), options);
          let multiView = this.multiView = options.multiView;
          if (options.context && multiView) {
            warn("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");
            multiView = false;
          }
          if (multiView) {
            this.canvas = DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);
          } else {
            this.canvas = this._renderer.view.canvas;
          }
          if (options.context) {
            this.initFromContext(options.context);
          } else {
            const alpha = this._renderer.background.alpha < 1;
            const premultipliedAlpha = (_a2 = options.premultipliedAlpha) != null ? _a2 : true;
            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
            this.createContext(options.preferWebGLVersion, {
              alpha,
              premultipliedAlpha,
              antialias,
              stencil: true,
              preserveDrawingBuffer: options.preserveDrawingBuffer,
              powerPreference: (_b = options.powerPreference) != null ? _b : "default"
            });
          }
        }
        ensureCanvasSize(targetCanvas) {
          if (!this.multiView) {
            if (targetCanvas !== this.canvas) {
              warn("multiView is disabled, but targetCanvas is not the main canvas");
            }
            return;
          }
          const { canvas } = this;
          if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
            canvas.width = Math.max(targetCanvas.width, targetCanvas.width);
            canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
          }
        }
        /**
         * Initializes the context.
         * @protected
         * @param {WebGLRenderingContext} gl - WebGL context
         */
        initFromContext(gl) {
          this.gl = gl;
          this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
          this.getExtensions();
          this.validateContext(gl);
          this._renderer.runners.contextChange.emit(gl);
          const element = this._renderer.view.canvas;
          element.addEventListener("webglcontextlost", this.handleContextLost, false);
          element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
        }
        /**
         * Initialize from context options
         * @protected
         * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
         * @param preferWebGLVersion
         * @param {object} options - context attributes
         */
        createContext(preferWebGLVersion, options) {
          let gl;
          const canvas = this.canvas;
          if (preferWebGLVersion === 2) {
            gl = canvas.getContext("webgl2", options);
          }
          if (!gl) {
            gl = canvas.getContext("webgl", options);
            if (!gl) {
              throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            }
          }
          this.gl = gl;
          this.initFromContext(this.gl);
        }
        /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
        getExtensions() {
          const { gl } = this;
          const common = {
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            // eslint-disable-line camelcase
            etc: gl.getExtension("WEBGL_compressed_texture_etc"),
            etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: gl.getExtension("WEBGL_compressed_texture_atc"),
            astc: gl.getExtension("WEBGL_compressed_texture_astc"),
            bptc: gl.getExtension("EXT_texture_compression_bptc"),
            rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
            loseContext: gl.getExtension("WEBGL_lose_context")
          };
          if (this.webGLVersion === 1) {
            this.extensions = __spreadProps(__spreadValues({}, common), {
              drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
              depthTexture: gl.getExtension("WEBGL_depth_texture"),
              vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
              uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
              // Floats and half-floats
              floatTexture: gl.getExtension("OES_texture_float"),
              floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
              textureHalfFloat: gl.getExtension("OES_texture_half_float"),
              textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
              vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
              srgb: gl.getExtension("EXT_sRGB")
            });
          } else {
            this.extensions = __spreadProps(__spreadValues({}, common), {
              colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
            });
            const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
            if (provokeExt) {
              provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
            }
          }
        }
        /**
         * Handles a lost webgl context
         * @param {WebGLContextEvent} event - The context lost event.
         */
        handleContextLost(event) {
          event.preventDefault();
          if (this._contextLossForced) {
            this._contextLossForced = false;
            setTimeout(() => {
              var _a2;
              if (this.gl.isContextLost()) {
                (_a2 = this.extensions.loseContext) == null ? void 0 : _a2.restoreContext();
              }
            }, 0);
          }
        }
        /** Handles a restored webgl context. */
        handleContextRestored() {
          this.getExtensions();
          this._renderer.runners.contextChange.emit(this.gl);
        }
        destroy() {
          var _a2;
          const element = this._renderer.view.canvas;
          this._renderer = null;
          element.removeEventListener("webglcontextlost", this.handleContextLost);
          element.removeEventListener("webglcontextrestored", this.handleContextRestored);
          this.gl.useProgram(null);
          (_a2 = this.extensions.loseContext) == null ? void 0 : _a2.loseContext();
        }
        /**
         * this function can be called to force a webGL context loss
         * this will release all resources on the GPU.
         * Useful if you need to put Pixi to sleep, and save some GPU memory
         *
         * As soon as render is called - all resources will be created again.
         */
        forceContextLoss() {
          var _a2;
          (_a2 = this.extensions.loseContext) == null ? void 0 : _a2.loseContext();
          this._contextLossForced = true;
        }
        /**
         * Validate context.
         * @param {WebGLRenderingContext} gl - Render context.
         */
        validateContext(gl) {
          const attributes = gl.getContextAttributes();
          if (attributes && !attributes.stencil) {
            warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
          }
          const supports = this.supports;
          const isWebGl2 = this.webGLVersion === 2;
          const extensions2 = this.extensions;
          supports.uint32Indices = isWebGl2 || !!extensions2.uint32ElementIndex;
          supports.uniformBufferObject = isWebGl2;
          supports.vertexArrayObject = isWebGl2 || !!extensions2.vertexArrayObject;
          supports.srgbTextures = isWebGl2 || !!extensions2.srgb;
          supports.nonPowOf2wrapping = isWebGl2;
          supports.nonPowOf2mipmaps = isWebGl2;
          supports.msaa = isWebGl2;
          if (!supports.uint32Indices) {
            warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
          }
        }
      };
      _GlContextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "context"
      };
      _GlContextSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.context}
         * @default null
         */
        context: null,
        /**
         * {@link WebGLOptions.premultipliedAlpha}
         * @default true
         */
        premultipliedAlpha: true,
        /**
         * {@link WebGLOptions.preserveDrawingBuffer}
         * @default false
         */
        preserveDrawingBuffer: false,
        /**
         * {@link WebGLOptions.powerPreference}
         * @default default
         */
        powerPreference: void 0,
        /**
         * {@link WebGLOptions.webGLVersion}
         * @default 2
         */
        preferWebGLVersion: 2,
        /**
         * {@link WebGLOptions.multiView}
         * @default false
         */
        multiView: false
      };
      GlContextSystem = _GlContextSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
  var GL_FORMATS, GL_TARGETS, GL_WRAP_MODES, GL_TYPES;
  var init_const10 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs"() {
      "use strict";
      GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
        GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
        GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
        GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
        GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
        GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
        GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
        GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
        GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
        return GL_FORMATS2;
      })(GL_FORMATS || {});
      GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
        return GL_TARGETS2;
      })(GL_TARGETS || {});
      GL_WRAP_MODES = /* @__PURE__ */ ((GL_WRAP_MODES2) => {
        GL_WRAP_MODES2[GL_WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
        GL_WRAP_MODES2[GL_WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
        GL_WRAP_MODES2[GL_WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
        return GL_WRAP_MODES2;
      })(GL_WRAP_MODES || {});
      GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
        GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
        GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
        GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
        GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
        GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
        GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
        GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
        return GL_TYPES2;
      })(GL_TYPES || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs
  function getGlTypeFromFormat(format) {
    var _a2;
    return (_a2 = infoMap[format]) != null ? _a2 : infoMap.float32;
  }
  var infoMap;
  var init_getGlTypeFromFormat = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs"() {
      init_const10();
      infoMap = {
        uint8x2: GL_TYPES.UNSIGNED_BYTE,
        uint8x4: GL_TYPES.UNSIGNED_BYTE,
        sint8x2: GL_TYPES.BYTE,
        sint8x4: GL_TYPES.BYTE,
        unorm8x2: GL_TYPES.UNSIGNED_BYTE,
        unorm8x4: GL_TYPES.UNSIGNED_BYTE,
        snorm8x2: GL_TYPES.BYTE,
        snorm8x4: GL_TYPES.BYTE,
        uint16x2: GL_TYPES.UNSIGNED_SHORT,
        uint16x4: GL_TYPES.UNSIGNED_SHORT,
        sint16x2: GL_TYPES.SHORT,
        sint16x4: GL_TYPES.SHORT,
        unorm16x2: GL_TYPES.UNSIGNED_SHORT,
        unorm16x4: GL_TYPES.UNSIGNED_SHORT,
        snorm16x2: GL_TYPES.SHORT,
        snorm16x4: GL_TYPES.SHORT,
        float16x2: GL_TYPES.HALF_FLOAT,
        float16x4: GL_TYPES.HALF_FLOAT,
        float32: GL_TYPES.FLOAT,
        float32x2: GL_TYPES.FLOAT,
        float32x3: GL_TYPES.FLOAT,
        float32x4: GL_TYPES.FLOAT,
        uint32: GL_TYPES.UNSIGNED_INT,
        uint32x2: GL_TYPES.UNSIGNED_INT,
        uint32x3: GL_TYPES.UNSIGNED_INT,
        uint32x4: GL_TYPES.UNSIGNED_INT,
        sint32: GL_TYPES.INT,
        sint32x2: GL_TYPES.INT,
        sint32x3: GL_TYPES.INT,
        sint32x4: GL_TYPES.INT
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
  var topologyToGlMap, GlGeometryGpuData, GlGeometrySystem;
  var init_GlGeometrySystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
      init_Extensions();
      init_GCManagedHash();
      init_getAttributeInfoFromFormat();
      init_ensureAttributes();
      init_getGlTypeFromFormat();
      topologyToGlMap = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
      };
      GlGeometryGpuData = class {
        constructor() {
          this.vaoCache = /* @__PURE__ */ Object.create(null);
        }
        destroy() {
          this.vaoCache = /* @__PURE__ */ Object.create(null);
        }
      };
      GlGeometrySystem = class {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._renderer = renderer;
          this._activeGeometry = null;
          this._activeVao = null;
          this.hasVao = true;
          this.hasInstance = true;
          this._managedGeometries = new GCManagedHash({
            renderer,
            type: "resource",
            onUnload: this.onGeometryUnload.bind(this),
            name: "glGeometry"
          });
        }
        /** Sets up the renderer context and necessary buffers. */
        contextChange() {
          const gl = this.gl = this._renderer.gl;
          if (!this._renderer.context.supports.vertexArrayObject) {
            throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
          }
          this.destroyAll(true);
          const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
          if (nativeVaoExtension) {
            gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
            gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
            gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
          }
          const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
          if (nativeInstancedExtension) {
            gl.drawArraysInstanced = (a2, b2, c2, d2) => {
              nativeInstancedExtension.drawArraysInstancedANGLE(a2, b2, c2, d2);
            };
            gl.drawElementsInstanced = (a2, b2, c2, d2, e2) => {
              nativeInstancedExtension.drawElementsInstancedANGLE(a2, b2, c2, d2, e2);
            };
            gl.vertexAttribDivisor = (a2, b2) => nativeInstancedExtension.vertexAttribDivisorANGLE(a2, b2);
          }
          this._activeGeometry = null;
          this._activeVao = null;
        }
        /**
         * Binds geometry so that is can be drawn. Creating a Vao if required
         * @param geometry - Instance of geometry to bind.
         * @param program - Instance of program to use vao for.
         */
        bind(geometry, program) {
          const gl = this.gl;
          this._activeGeometry = geometry;
          const vao = this.getVao(geometry, program);
          if (this._activeVao !== vao) {
            this._activeVao = vao;
            gl.bindVertexArray(vao);
          }
          this.updateBuffers();
        }
        /** Reset and unbind any active VAO and geometry. */
        resetState() {
          this.unbind();
        }
        /** Update buffers of the currently bound geometry. */
        updateBuffers() {
          const geometry = this._activeGeometry;
          const bufferSystem = this._renderer.buffer;
          for (let i3 = 0; i3 < geometry.buffers.length; i3++) {
            const buffer = geometry.buffers[i3];
            bufferSystem.updateBuffer(buffer);
          }
          geometry._gcLastUsed = this._renderer.gc.now;
        }
        /**
         * Check compatibility between a geometry and a program
         * @param geometry - Geometry instance.
         * @param program - Program instance.
         */
        checkCompatibility(geometry, program) {
          const geometryAttributes = geometry.attributes;
          const shaderAttributes = program._attributeData;
          for (const j2 in shaderAttributes) {
            if (!geometryAttributes[j2]) {
              throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
            }
          }
        }
        /**
         * Takes a geometry and program and generates a unique signature for them.
         * @param geometry - To get signature from.
         * @param program - To test geometry against.
         * @returns - Unique signature of the geometry and program
         */
        getSignature(geometry, program) {
          const attribs = geometry.attributes;
          const shaderAttributes = program._attributeData;
          const strings = ["g", geometry.uid];
          for (const i3 in attribs) {
            if (shaderAttributes[i3]) {
              strings.push(i3, shaderAttributes[i3].location);
            }
          }
          return strings.join("-");
        }
        getVao(geometry, program) {
          var _a2;
          return ((_a2 = geometry._gpuData[this._renderer.uid]) == null ? void 0 : _a2.vaoCache[program._key]) || this.initGeometryVao(geometry, program);
        }
        /**
         * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
         * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
         * attribute locations.
         * @param geometry - Instance of geometry to to generate Vao for.
         * @param program
         * @param _incRefCount - Increment refCount of all geometry buffers.
         */
        initGeometryVao(geometry, program, _incRefCount = true) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          this._renderer.shader._getProgramData(program);
          this.checkCompatibility(geometry, program);
          const signature = this.getSignature(geometry, program);
          const gpuData = new GlGeometryGpuData();
          geometry._gpuData[this._renderer.uid] = gpuData;
          this._managedGeometries.add(geometry);
          const vaoObjectHash = gpuData.vaoCache;
          let vao = vaoObjectHash[signature];
          if (vao) {
            vaoObjectHash[program._key] = vao;
            return vao;
          }
          ensureAttributes(geometry, program._attributeData);
          const buffers = geometry.buffers;
          vao = gl.createVertexArray();
          gl.bindVertexArray(vao);
          for (let i3 = 0; i3 < buffers.length; i3++) {
            const buffer = buffers[i3];
            bufferSystem.bind(buffer);
          }
          this.activateVao(geometry, program);
          vaoObjectHash[program._key] = vao;
          vaoObjectHash[signature] = vao;
          gl.bindVertexArray(null);
          return vao;
        }
        onGeometryUnload(geometry, contextLost = false) {
          const gpuData = geometry._gpuData[this._renderer.uid];
          if (!gpuData)
            return;
          const vaoCache = gpuData.vaoCache;
          if (!contextLost) {
            for (const i3 in vaoCache) {
              if (this._activeVao !== vaoCache[i3]) {
                this.resetState();
              }
              this.gl.deleteVertexArray(vaoCache[i3]);
            }
          }
        }
        /**
         * Dispose all WebGL resources of all managed geometries.
         * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
         */
        destroyAll(contextLost = false) {
          this._managedGeometries.removeAll(contextLost);
        }
        /**
         * Activate vertex array object.
         * @param geometry - Geometry instance.
         * @param program - Shader program instance.
         */
        activateVao(geometry, program) {
          var _a2, _b;
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          const attributes = geometry.attributes;
          if (geometry.indexBuffer) {
            bufferSystem.bind(geometry.indexBuffer);
          }
          let lastBuffer = null;
          for (const j2 in attributes) {
            const attribute = attributes[j2];
            const buffer = attribute.buffer;
            const glBuffer = bufferSystem.getGlBuffer(buffer);
            const programAttrib = program._attributeData[j2];
            if (programAttrib) {
              if (lastBuffer !== glBuffer) {
                bufferSystem.bind(buffer);
                lastBuffer = glBuffer;
              }
              const location = programAttrib.location;
              gl.enableVertexAttribArray(location);
              const attributeInfo = getAttributeInfoFromFormat(attribute.format);
              const type = getGlTypeFromFormat(attribute.format);
              if (((_a2 = programAttrib.format) == null ? void 0 : _a2.substring(1, 4)) === "int") {
                gl.vertexAttribIPointer(
                  location,
                  attributeInfo.size,
                  type,
                  attribute.stride,
                  attribute.offset
                );
              } else {
                gl.vertexAttribPointer(
                  location,
                  attributeInfo.size,
                  type,
                  attributeInfo.normalised,
                  attribute.stride,
                  attribute.offset
                );
              }
              if (attribute.instance) {
                if (this.hasInstance) {
                  const divisor = (_b = attribute.divisor) != null ? _b : 1;
                  gl.vertexAttribDivisor(location, divisor);
                } else {
                  throw new Error("geometry error, GPU Instancing is not supported on this device");
                }
              }
            }
          }
        }
        /**
         * Draws the currently bound geometry.
         * @param topology - The type primitive to render.
         * @param size - The number of elements to be rendered. If not specified, all vertices after the
         *  starting vertex will be drawn.
         * @param start - The starting vertex in the geometry to start drawing from. If not specified,
         *  drawing will start from the first vertex.
         * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
         *  all instances will be drawn.
         * @returns This instance of the geometry system.
         */
        draw(topology, size, start, instanceCount) {
          const { gl } = this._renderer;
          const geometry = this._activeGeometry;
          const glTopology = topologyToGlMap[topology || geometry.topology];
          instanceCount != null ? instanceCount : instanceCount = geometry.instanceCount;
          if (geometry.indexBuffer) {
            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
            if (instanceCount !== 1) {
              gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
            } else {
              gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
            }
          } else if (instanceCount !== 1) {
            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
          } else {
            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
          }
          return this;
        }
        /** Unbind/reset everything. */
        unbind() {
          this.gl.bindVertexArray(null);
          this._activeVao = null;
          this._activeGeometry = null;
        }
        destroy() {
          this._managedGeometries.destroy();
          this._renderer = null;
          this.gl = null;
          this._activeVao = null;
          this._activeGeometry = null;
        }
      };
      GlGeometrySystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "geometry"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
  var bigTriangleGeometry, _GlBackBufferSystem, GlBackBufferSystem;
  var init_GlBackBufferSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
      init_Extensions();
      init_warn();
      init_Geometry();
      init_Shader();
      init_State();
      init_TextureSource();
      init_Texture();
      init_GlProgram();
      bigTriangleGeometry = new Geometry({
        attributes: {
          aPosition: [
            -1,
            -1,
            // Bottom left corner
            3,
            -1,
            // Bottom right corner, extending beyond right edge
            -1,
            3
            // Top left corner, extending beyond top edge
          ]
        }
      });
      _GlBackBufferSystem = class _GlBackBufferSystem2 {
        constructor(renderer) {
          this.useBackBuffer = false;
          this._useBackBufferThisRender = false;
          this._renderer = renderer;
        }
        init(options = {}) {
          const { useBackBuffer, antialias } = __spreadValues(__spreadValues({}, _GlBackBufferSystem2.defaultOptions), options);
          this.useBackBuffer = useBackBuffer;
          this._antialias = antialias;
          if (!this._renderer.context.supports.msaa) {
            warn("antialiasing, is not supported on when using the back buffer");
            this._antialias = false;
          }
          this._state = State.for2d();
          const bigTriangleProgram = new GlProgram({
            vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
            fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
            name: "big-triangle"
          });
          this._bigTriangleShader = new Shader({
            glProgram: bigTriangleProgram,
            resources: {
              uTexture: Texture.WHITE.source
            }
          });
        }
        /**
         * This is called before the RenderTargetSystem is started. This is where
         * we replace the target with the back buffer if required.
         * @param options - The options for this render.
         */
        renderStart(options) {
          const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
          this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
          if (this._useBackBufferThisRender) {
            const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
            this._targetTexture = renderTarget2.colorTexture;
            options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
          }
        }
        renderEnd() {
          this._presentBackBuffer();
        }
        _presentBackBuffer() {
          const renderer = this._renderer;
          renderer.renderTarget.finishRenderPass();
          if (!this._useBackBufferThisRender)
            return;
          renderer.renderTarget.bind(this._targetTexture, false);
          this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
          renderer.encoder.draw({
            geometry: bigTriangleGeometry,
            shader: this._bigTriangleShader,
            state: this._state
          });
        }
        _getBackBufferTexture(targetSourceTexture) {
          this._backBufferTexture = this._backBufferTexture || new Texture({
            source: new TextureSource({
              width: targetSourceTexture.width,
              height: targetSourceTexture.height,
              resolution: targetSourceTexture._resolution,
              antialias: this._antialias
            })
          });
          this._backBufferTexture.source.resize(
            targetSourceTexture.width,
            targetSourceTexture.height,
            targetSourceTexture._resolution
          );
          return this._backBufferTexture;
        }
        /** destroys the back buffer */
        destroy() {
          if (this._backBufferTexture) {
            this._backBufferTexture.destroy();
            this._backBufferTexture = null;
          }
        }
      };
      _GlBackBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "backBuffer",
        priority: 1
      };
      _GlBackBufferSystem.defaultOptions = {
        /** if true will use the back buffer where required */
        useBackBuffer: false
      };
      GlBackBufferSystem = _GlBackBufferSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
  var GlColorMaskSystem;
  var init_GlColorMaskSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
      init_Extensions();
      GlColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.gl.colorMask(
            !!(colorMask & 8),
            !!(colorMask & 4),
            !!(colorMask & 2),
            !!(colorMask & 1)
          );
        }
      };
      GlColorMaskSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
  var GlEncoderSystem;
  var init_GlEncoderSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
      init_Extensions();
      GlEncoderSystem = class {
        constructor(renderer) {
          this.commandFinished = Promise.resolve();
          this._renderer = renderer;
        }
        setGeometry(geometry, shader) {
          this._renderer.geometry.bind(geometry, shader.glProgram);
        }
        finishRenderPass() {
        }
        draw(options) {
          const renderer = this._renderer;
          const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;
          renderer.shader.bind(shader, skipSync);
          renderer.geometry.bind(geometry, renderer.shader._activeProgram);
          if (state) {
            renderer.state.set(state);
          }
          renderer.geometry.draw(type, size, start, instanceCount != null ? instanceCount : geometry.instanceCount);
        }
        destroy() {
          this._renderer = null;
        }
      };
      GlEncoderSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "encoder"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.mjs
  var GlLimitsSystem;
  var init_GlLimitsSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.mjs"() {
      init_Extensions();
      init_checkMaxIfStatementsInShader();
      GlLimitsSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        contextChange() {
          const gl = this._renderer.gl;
          this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          this.maxBatchableTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);
          const isWebGl2 = this._renderer.context.webGLVersion === 2;
          this.maxUniformBindings = isWebGl2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
        }
        destroy() {
        }
      };
      GlLimitsSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "limits"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
  var GlStencilSystem;
  var init_GlStencilSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
      init_Extensions();
      init_GpuStencilModesToPixi();
      init_const3();
      GlStencilSystem = class {
        constructor(renderer) {
          this._stencilCache = {
            enabled: false,
            stencilReference: 0,
            stencilMode: STENCIL_MODES.NONE
          };
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        contextChange(gl) {
          this._gl = gl;
          this._comparisonFuncMapping = {
            always: gl.ALWAYS,
            never: gl.NEVER,
            equal: gl.EQUAL,
            "not-equal": gl.NOTEQUAL,
            less: gl.LESS,
            "less-equal": gl.LEQUAL,
            greater: gl.GREATER,
            "greater-equal": gl.GEQUAL
          };
          this._stencilOpsMapping = {
            keep: gl.KEEP,
            zero: gl.ZERO,
            replace: gl.REPLACE,
            invert: gl.INVERT,
            "increment-clamp": gl.INCR,
            "decrement-clamp": gl.DECR,
            "increment-wrap": gl.INCR_WRAP,
            "decrement-wrap": gl.DECR_WRAP
          };
          this.resetState();
        }
        onRenderTargetChange(renderTarget) {
          if (this._activeRenderTarget === renderTarget)
            return;
          this._activeRenderTarget = renderTarget;
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        resetState() {
          this._stencilCache.enabled = false;
          this._stencilCache.stencilMode = STENCIL_MODES.NONE;
          this._stencilCache.stencilReference = 0;
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          const gl = this._gl;
          const mode = GpuStencilModesToPixi[stencilMode];
          const _stencilCache = this._stencilCache;
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          if (stencilMode === STENCIL_MODES.DISABLED) {
            if (this._stencilCache.enabled) {
              this._stencilCache.enabled = false;
              gl.disable(gl.STENCIL_TEST);
            }
            return;
          }
          if (!this._stencilCache.enabled) {
            this._stencilCache.enabled = true;
            gl.enable(gl.STENCIL_TEST);
          }
          if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
            _stencilCache.stencilMode = stencilMode;
            _stencilCache.stencilReference = stencilReference;
            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
          }
        }
      };
      GlStencilSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "stencil"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs
  function createUboElementsSTD40(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    const chunkSize = 16;
    let size = 0;
    let offset = 0;
    for (let i3 = 0; i3 < uboElements.length; i3++) {
      const uboElement = uboElements[i3];
      size = WGSL_TO_STD40_SIZE[uboElement.data.type];
      if (!size) {
        throw new Error(`Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size = Math.max(size, chunkSize) * uboElement.data.size;
      }
      const boundary = size === 12 ? 16 : size;
      uboElement.size = size;
      const curOffset = offset % chunkSize;
      if (curOffset > 0 && chunkSize - curOffset < boundary) {
        offset += (chunkSize - curOffset) % 16;
      } else {
        offset += (size - curOffset % size) % size;
      }
      uboElement.offset = offset;
      offset += size;
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_TO_STD40_SIZE;
  var init_createUboElementsSTD40 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs"() {
      "use strict";
      WGSL_TO_STD40_SIZE = {
        f32: 4,
        i32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "vec2<i32>": 8,
        "vec3<i32>": 12,
        "vec4<i32>": 16,
        "mat2x2<f32>": 16 * 2,
        "mat3x3<f32>": 16 * 3,
        "mat4x4<f32>": 16 * 4
        // TODO - not essential for now but support these in the future
        // int:      4,
        // ivec2:    8,
        // ivec3:    12,
        // ivec4:    16,
        // uint:     4,
        // uvec2:    8,
        // uvec3:    12,
        // uvec4:    16,
        // bool:     4,
        // bvec2:    8,
        // bvec3:    12,
        // bvec4:    16,
        // mat2:     16 * 2,
        // mat3:     16 * 3,
        // mat4:     16 * 4,
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs
  function generateArraySyncSTD40(uboElement, offsetToAdd) {
    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
    const elementSize = uboElement.data.value.length / uboElement.data.size;
    const remainder = (4 - elementSize % 4) % 4;
    const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                ${data}[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
  }
  var init_generateArraySyncSTD40 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs"() {
      init_createUboElementsSTD40();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs
  function createUboSyncFunctionSTD40(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboStd40",
      generateArraySyncSTD40,
      uboSyncFunctionsSTD40
    );
  }
  var init_createUboSyncSTD40 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs"() {
      init_createUboSyncFunction();
      init_uboSyncFunctions();
      init_generateArraySyncSTD40();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs
  var GlUboSystem;
  var init_GlUboSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs"() {
      init_Extensions();
      init_UboSystem();
      init_createUboElementsSTD40();
      init_createUboSyncSTD40();
      GlUboSystem = class extends UboSystem {
        constructor() {
          super({
            createUboElements: createUboElementsSTD40,
            generateUboSync: createUboSyncFunctionSTD40
          });
        }
      };
      GlUboSystem.extension = {
        type: [ExtensionType.WebGLSystem],
        name: "ubo"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
  var GlRenderTarget;
  var init_GlRenderTarget = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
      "use strict";
      GlRenderTarget = class {
        constructor() {
          this.width = -1;
          this.height = -1;
          this.msaa = false;
          this.msaaRenderBuffer = [];
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs
  var GlRenderTargetAdaptor;
  var init_GlRenderTargetAdaptor = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs"() {
      init_Rectangle();
      init_warn();
      init_CanvasSource();
      init_const7();
      init_GlRenderTarget();
      GlRenderTargetAdaptor = class {
        constructor() {
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = new Rectangle();
        }
        init(renderer, renderTargetSystem) {
          this._renderer = renderer;
          this._renderTargetSystem = renderTargetSystem;
          renderer.runners.contextChange.add(this);
        }
        contextChange() {
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = new Rectangle();
          const gl = this._renderer.gl;
          this._drawBuffersCache = [];
          for (let i3 = 1; i3 <= 16; i3++) {
            this._drawBuffersCache[i3] = Array.from({ length: i3 }, (_, j2) => gl.COLOR_ATTACHMENT0 + j2);
          }
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          const renderTargetSystem = this._renderTargetSystem;
          const renderer = this._renderer;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
          const gl = renderer.gl;
          this.finishRenderPass(sourceRenderSurfaceTexture);
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          renderer.texture.bind(destinationTexture, 0);
          gl.copyTexSubImage2D(
            gl.TEXTURE_2D,
            0,
            originDest.x,
            originDest.y,
            originSrc.x,
            originSrc.y,
            size.width,
            size.height
          );
          return destinationTexture;
        }
        startRenderPass(renderTarget, clear = true, clearColor, viewport) {
          const renderTargetSystem = this._renderTargetSystem;
          const source11 = renderTarget.colorTexture;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          let viewPortY = viewport.y;
          if (renderTarget.isRoot) {
            viewPortY = source11.pixelHeight - viewport.height - viewport.y;
          }
          renderTarget.colorTextures.forEach((texture) => {
            this._renderer.texture.unbind(texture);
          });
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
          if (renderTarget.colorTextures.length > 1) {
            this._setDrawBuffers(renderTarget, gl);
          }
          const viewPortCache = this._viewPortCache;
          if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
            viewPortCache.x = viewport.x;
            viewPortCache.y = viewPortY;
            viewPortCache.width = viewport.width;
            viewPortCache.height = viewport.height;
            gl.viewport(
              viewport.x,
              viewPortY,
              viewport.width,
              viewport.height
            );
          }
          if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
            this._initStencil(gpuRenderTarget);
          }
          this.clear(renderTarget, clear, clearColor);
        }
        finishRenderPass(renderTarget) {
          const renderTargetSystem = this._renderTargetSystem;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (!glRenderTarget.msaa)
            return;
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
          gl.blitFramebuffer(
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            gl.COLOR_BUFFER_BIT,
            gl.NEAREST
          );
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
        }
        initGpuRenderTarget(renderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const glRenderTarget = new GlRenderTarget();
          const colorTexture = renderTarget.colorTexture;
          if (colorTexture instanceof CanvasSource) {
            this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
            glRenderTarget.framebuffer = null;
            return glRenderTarget;
          }
          this._initColor(renderTarget, glRenderTarget);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          return glRenderTarget;
        }
        destroyGpuRenderTarget(gpuRenderTarget) {
          const gl = this._renderer.gl;
          if (gpuRenderTarget.framebuffer) {
            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
            gpuRenderTarget.framebuffer = null;
          }
          if (gpuRenderTarget.resolveTargetFramebuffer) {
            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
            gpuRenderTarget.resolveTargetFramebuffer = null;
          }
          if (gpuRenderTarget.depthStencilRenderBuffer) {
            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
            gpuRenderTarget.depthStencilRenderBuffer = null;
          }
          gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
            gl.deleteRenderbuffer(renderBuffer);
          });
          gpuRenderTarget.msaaRenderBuffer = null;
        }
        clear(_renderTarget, clear, clearColor) {
          if (!clear)
            return;
          const renderTargetSystem = this._renderTargetSystem;
          if (typeof clear === "boolean") {
            clear = clear ? CLEAR.ALL : CLEAR.NONE;
          }
          const gl = this._renderer.gl;
          if (clear & CLEAR.COLOR) {
            clearColor != null ? clearColor : clearColor = renderTargetSystem.defaultClearColor;
            const clearColorCache = this._clearColorCache;
            const clearColorArray = clearColor;
            if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
              clearColorCache[0] = clearColorArray[0];
              clearColorCache[1] = clearColorArray[1];
              clearColorCache[2] = clearColorArray[2];
              clearColorCache[3] = clearColorArray[3];
              gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
            }
          }
          gl.clear(clear);
        }
        resizeGpuRenderTarget(renderTarget) {
          if (renderTarget.isRoot)
            return;
          const renderTargetSystem = this._renderTargetSystem;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          this._resizeColor(renderTarget, glRenderTarget);
          if (renderTarget.stencil || renderTarget.depth) {
            this._resizeStencil(glRenderTarget);
          }
        }
        _initColor(renderTarget, glRenderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const resolveTargetFramebuffer = gl.createFramebuffer();
          glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
          glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
          glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
          const colorTextures = renderTarget.colorTextures;
          colorTextures.forEach((colorTexture, i3) => {
            const source11 = colorTexture.source;
            if (source11.antialias) {
              if (renderer.context.supports.msaa) {
                glRenderTarget.msaa = true;
              } else {
                warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
              }
            }
            renderer.texture.bindSource(source11, 0);
            const glSource = renderer.texture.getGlSource(source11);
            const glTexture = glSource.texture;
            gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i3,
              3553,
              // texture.target,
              glTexture,
              0
            );
          });
          if (glRenderTarget.msaa) {
            const viewFramebuffer = gl.createFramebuffer();
            glRenderTarget.framebuffer = viewFramebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((_, i3) => {
              const msaaRenderBuffer = gl.createRenderbuffer();
              glRenderTarget.msaaRenderBuffer[i3] = msaaRenderBuffer;
            });
          } else {
            glRenderTarget.framebuffer = resolveTargetFramebuffer;
          }
          this._resizeColor(renderTarget, glRenderTarget);
        }
        _resizeColor(renderTarget, glRenderTarget) {
          const source11 = renderTarget.colorTexture.source;
          glRenderTarget.width = source11.pixelWidth;
          glRenderTarget.height = source11.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i3) => {
            if (i3 === 0)
              return;
            colorTexture.source.resize(source11.width, source11.height, source11._resolution);
          });
          if (glRenderTarget.msaa) {
            const renderer = this._renderer;
            const gl = renderer.gl;
            const viewFramebuffer = glRenderTarget.framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((colorTexture, i3) => {
              const source22 = colorTexture.source;
              renderer.texture.bindSource(source22, 0);
              const glSource = renderer.texture.getGlSource(source22);
              const glInternalFormat = glSource.internalFormat;
              const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i3];
              gl.bindRenderbuffer(
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
              gl.renderbufferStorageMultisample(
                gl.RENDERBUFFER,
                4,
                glInternalFormat,
                source22.pixelWidth,
                source22.pixelHeight
              );
              gl.framebufferRenderbuffer(
                gl.FRAMEBUFFER,
                gl.COLOR_ATTACHMENT0 + i3,
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
            });
          }
        }
        _initStencil(glRenderTarget) {
          if (glRenderTarget.framebuffer === null)
            return;
          const gl = this._renderer.gl;
          const depthStencilRenderBuffer = gl.createRenderbuffer();
          glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          gl.framebufferRenderbuffer(
            gl.FRAMEBUFFER,
            gl.DEPTH_STENCIL_ATTACHMENT,
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          this._resizeStencil(glRenderTarget);
        }
        _resizeStencil(glRenderTarget) {
          const gl = this._renderer.gl;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            glRenderTarget.depthStencilRenderBuffer
          );
          if (glRenderTarget.msaa) {
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              gl.DEPTH24_STENCIL8,
              glRenderTarget.width,
              glRenderTarget.height
            );
          } else {
            gl.renderbufferStorage(
              gl.RENDERBUFFER,
              this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
              glRenderTarget.width,
              glRenderTarget.height
            );
          }
        }
        prerender(renderTarget) {
          const resource = renderTarget.colorTexture.resource;
          if (this._renderer.context.multiView && CanvasSource.test(resource)) {
            this._renderer.context.ensureCanvasSize(resource);
          }
        }
        postrender(renderTarget) {
          if (!this._renderer.context.multiView)
            return;
          if (CanvasSource.test(renderTarget.colorTexture.resource)) {
            const contextCanvas = this._renderer.context.canvas;
            const canvasSource = renderTarget.colorTexture;
            canvasSource.context2D.drawImage(
              contextCanvas,
              0,
              canvasSource.pixelHeight - contextCanvas.height
            );
          }
        }
        _setDrawBuffers(renderTarget, gl) {
          const count2 = renderTarget.colorTextures.length;
          const bufferArray = this._drawBuffersCache[count2];
          if (this._renderer.context.webGLVersion === 1) {
            const ext = this._renderer.context.extensions.drawBuffers;
            if (!ext) {
              warn("[RenderTexture] This WebGL1 context does not support rendering to multiple targets");
            } else {
              ext.drawBuffersWEBGL(bufferArray);
            }
          } else {
            gl.drawBuffers(bufferArray);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs
  var GlRenderTargetSystem;
  var init_GlRenderTargetSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs"() {
      init_Extensions();
      init_RenderTargetSystem();
      init_GlRenderTargetAdaptor();
      GlRenderTargetSystem = class extends RenderTargetSystem {
        constructor(renderer) {
          super(renderer);
          this.adaptor = new GlRenderTargetAdaptor();
          this.adaptor.init(renderer, this);
        }
      };
      GlRenderTargetSystem.extension = {
        type: [ExtensionType.WebGLSystem],
        name: "renderTarget"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs
  function generateShaderSyncCode(shader, shaderSystem) {
    const funcFragments = [];
    const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
    let addedTextreSystem = false;
    let textureCount = 0;
    const programData = shaderSystem._getProgramData(shader.glProgram);
    for (const i3 in shader.groups) {
      const group = shader.groups[i3];
      funcFragments.push(`
            resources = g[${i3}].resources;
        `);
      for (const j2 in group.resources) {
        const resource = group.resources[j2];
        if (resource instanceof UniformGroup) {
          if (resource.ubo) {
            const resName = shader._uniformBindMap[i3][Number(j2)];
            funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j2}],
                            '${resName}',
                            ${shader.glProgram._uniformBlockData[resName].index}
                        );
                    `);
          } else {
            funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j2}], p, sD);
                    `);
          }
        } else if (resource instanceof BufferResource) {
          const resName = shader._uniformBindMap[i3][Number(j2)];
          funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j2}],
                        '${resName}',
                        ${shader.glProgram._uniformBlockData[resName].index}
                    );
                `);
        } else if (resource instanceof TextureSource) {
          const uniformName = shader._uniformBindMap[i3][j2];
          const uniformData = programData.uniformData[uniformName];
          if (uniformData) {
            if (!addedTextreSystem) {
              addedTextreSystem = true;
              headerFragments.push(`
                        var tS = r.texture;
                        `);
            }
            shaderSystem._gl.uniform1i(uniformData.location, textureCount);
            funcFragments.push(`
                        tS.bind(resources[${j2}], ${textureCount});
                    `);
            textureCount++;
          }
        }
      }
    }
    const functionSource = [...headerFragments, ...funcFragments].join("\n");
    return new Function("r", "s", "sD", functionSource);
  }
  var init_GenerateShaderSyncCode = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs"() {
      init_BufferResource();
      init_UniformGroup();
      init_TextureSource();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
  var IGLUniformData, GlProgramData;
  var init_GlProgramData = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
      "use strict";
      IGLUniformData = class {
      };
      GlProgramData = class {
        /**
         * Makes a new Pixi program.
         * @param program - webgl program
         * @param uniformData - uniforms
         */
        constructor(program, uniformData) {
          this.program = program;
          this.uniformData = uniformData;
          this.uniformGroups = {};
          this.uniformDirtyGroups = {};
          this.uniformBlockBindings = {};
        }
        /** Destroys this program. */
        destroy() {
          this.uniformData = null;
          this.uniformGroups = null;
          this.uniformDirtyGroups = null;
          this.uniformBlockBindings = null;
          this.program = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
  function compileShader(gl, type, src) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }
  var init_compileShader = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
  function booleanArray(size) {
    const array = new Array(size);
    for (let i3 = 0; i3 < array.length; i3++) {
      array[i3] = false;
    }
    return array;
  }
  function defaultValue(type, size) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size);
      case "bvec3":
        return booleanArray(3 * size);
      case "bvec4":
        return booleanArray(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_defaultValue = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
  function mapType(gl, type) {
    if (!GL_TABLE) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (let i3 = 0; i3 < typeNames.length; ++i3) {
        const tn = typeNames[i3];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type];
  }
  function mapGlToVertexFormat(gl, type) {
    const typeValue = mapType(gl, type);
    return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
  }
  var GL_TABLE, GL_TO_GLSL_TYPES, GLSL_TO_VERTEX_TYPES;
  var init_mapType = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
      "use strict";
      GL_TABLE = null;
      GL_TO_GLSL_TYPES = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
      };
      GLSL_TO_VERTEX_TYPES = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs
  function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
    const attributes = {};
    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i3 = 0; i3 < totalAttributes; i3++) {
      const attribData = gl.getActiveAttrib(program, i3);
      if (attribData.name.startsWith("gl_")) {
        continue;
      }
      const format = mapGlToVertexFormat(gl, attribData.type);
      attributes[attribData.name] = {
        location: 0,
        // set further down..
        format,
        stride: getAttributeInfoFromFormat(format).stride,
        offset: 0,
        instance: false,
        start: 0
      };
    }
    const keys = Object.keys(attributes);
    if (sortAttributes) {
      keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
      for (let i3 = 0; i3 < keys.length; i3++) {
        attributes[keys[i3]].location = i3;
        gl.bindAttribLocation(program, i3, keys[i3]);
      }
      gl.linkProgram(program);
    } else {
      for (let i3 = 0; i3 < keys.length; i3++) {
        attributes[keys[i3]].location = gl.getAttribLocation(program, keys[i3]);
      }
    }
    return attributes;
  }
  var init_extractAttributesFromGlProgram = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs"() {
      init_getAttributeInfoFromFormat();
      init_mapType();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs
  function getUboData(program, gl) {
    if (!gl.ACTIVE_UNIFORM_BLOCKS)
      return {};
    const uniformBlocks = {};
    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    for (let i3 = 0; i3 < totalUniformsBlocks; i3++) {
      const name = gl.getActiveUniformBlockName(program, i3);
      const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
      const size = gl.getActiveUniformBlockParameter(program, i3, gl.UNIFORM_BLOCK_DATA_SIZE);
      uniformBlocks[name] = {
        name,
        index: uniformBlockIndex,
        size
      };
    }
    return uniformBlocks;
  }
  var init_getUboData = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
  function getUniformData(program, gl) {
    const uniforms = {};
    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i3 = 0; i3 < totalUniforms; i3++) {
      const uniformData = gl.getActiveUniform(program, i3);
      const name = uniformData.name.replace(/\[.*?\]$/, "");
      const isArray = !!uniformData.name.match(/\[.*?\]$/);
      const type = mapType(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i3,
        type,
        size: uniformData.size,
        isArray,
        value: defaultValue(type, uniformData.size)
      };
    }
    return uniforms;
  }
  var init_getUniformData = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
      init_defaultValue();
      init_mapType();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
  function logPrettyShaderError(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
    const shaderLog = gl.getShaderInfoLog(shader);
    const splitShader = shaderLog.split("\n");
    const dedupe = {};
    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
      if (n2 && !dedupe[n2]) {
        dedupe[n2] = true;
        return true;
      }
      return false;
    });
    const logArgs = [""];
    lineNumbers.forEach((number) => {
      shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn(...logArgs);
    console.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }
  var init_logProgramError = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
  function generateProgram(gl, program) {
    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.transformFeedbackVaryings;
    if (transformFeedbackVaryings) {
      if (typeof gl.transformFeedbackVaryings !== "function") {
        warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
      } else {
        gl.transformFeedbackVaryings(
          webGLProgram,
          transformFeedbackVaryings.names,
          transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
        );
      }
    }
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    }
    program._attributeData = extractAttributesFromGlProgram(
      webGLProgram,
      gl,
      !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex)
    );
    program._uniformData = getUniformData(webGLProgram, gl);
    program._uniformBlockData = getUboData(webGLProgram, gl);
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i3 in program._uniformData) {
      const data = program._uniformData[i3];
      uniformData[i3] = {
        location: gl.getUniformLocation(webGLProgram, i3),
        value: defaultValue(data.type, data.size)
      };
    }
    const glProgram3 = new GlProgramData(webGLProgram, uniformData);
    return glProgram3;
  }
  var init_generateProgram = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
      init_warn();
      init_GlProgramData();
      init_compileShader();
      init_defaultValue();
      init_extractAttributesFromGlProgram();
      init_getUboData();
      init_getUniformData();
      init_logProgramError();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
  var defaultSyncData, GlShaderSystem;
  var init_GlShaderSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
      init_Extensions();
      init_GenerateShaderSyncCode();
      init_generateProgram();
      defaultSyncData = {
        textureCount: 0,
        blockIndex: 0
      };
      GlShaderSystem = class {
        constructor(renderer) {
          this._activeProgram = null;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        contextChange(gl) {
          this._gl = gl;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
          this._activeProgram = null;
        }
        /**
         * Changes the current shader to the one given in parameter.
         * @param shader - the new shader
         * @param skipSync - false if the shader should automatically sync its uniforms.
         * @returns the glProgram that belongs to the shader.
         */
        bind(shader, skipSync) {
          this._setProgram(shader.glProgram);
          if (skipSync)
            return;
          defaultSyncData.textureCount = 0;
          defaultSyncData.blockIndex = 0;
          let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
          if (!syncFunction) {
            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
          }
          this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);
          syncFunction(this._renderer, shader, defaultSyncData);
        }
        /**
         * Updates the uniform group.
         * @param uniformGroup - the uniform group to update
         */
        updateUniformGroup(uniformGroup) {
          this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
        }
        /**
         * Binds a uniform block to the shader.
         * @param uniformGroup - the uniform group to bind
         * @param name - the name of the uniform block
         * @param index - the index of the uniform block
         */
        bindUniformBlock(uniformGroup, name, index = 0) {
          const bufferSystem = this._renderer.buffer;
          const programData = this._getProgramData(this._activeProgram);
          const isBufferResource = uniformGroup._bufferResource;
          if (!isBufferResource) {
            this._renderer.ubo.updateUniformGroup(uniformGroup);
          }
          const buffer = uniformGroup.buffer;
          const glBuffer = bufferSystem.updateBuffer(buffer);
          const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);
          if (isBufferResource) {
            const { offset, size } = uniformGroup;
            if (offset === 0 && size === buffer.data.byteLength) {
              bufferSystem.bindBufferBase(glBuffer, boundLocation);
            } else {
              bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);
            }
          } else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation) {
            bufferSystem.bindBufferBase(glBuffer, boundLocation);
          }
          const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
          if (programData.uniformBlockBindings[index] === boundLocation)
            return;
          programData.uniformBlockBindings[index] = boundLocation;
          this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);
        }
        _setProgram(program) {
          if (this._activeProgram === program)
            return;
          this._activeProgram = program;
          const programData = this._getProgramData(program);
          this._gl.useProgram(programData.program);
        }
        /**
         * @param program - the program to get the data for
         * @internal
         */
        _getProgramData(program) {
          return this._programDataHash[program._key] || this._createProgramData(program);
        }
        _createProgramData(program) {
          const key = program._key;
          this._programDataHash[key] = generateProgram(this._gl, program);
          return this._programDataHash[key];
        }
        destroy() {
          for (const key of Object.keys(this._programDataHash)) {
            this._programDataHash[key].destroy();
          }
          this._programDataHash = null;
          this._shaderSyncFunctions = null;
          this._activeProgram = null;
          this._renderer = null;
          this._gl = null;
        }
        /**
         * Creates a function that can be executed that will sync the shader as efficiently as possible.
         * Overridden by the unsafe eval package if you don't want eval used in your project.
         * @param shader - the shader to generate the sync function for
         * @param shaderSystem - the shader system to use
         * @returns - the generated sync function
         * @ignore
         */
        _generateShaderSync(shader, shaderSystem) {
          return generateShaderSyncCode(shader, shaderSystem);
        }
        resetState() {
          this._activeProgram = null;
        }
      };
      GlShaderSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "shader"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs
  var UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS;
  var init_generateUniformsSyncTypes = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs"() {
      "use strict";
      UNIFORM_TO_SINGLE_SETTERS = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
        "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
        "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
      };
      UNIFORM_TO_ARRAY_SETTERS = {
        f32: `gl.uniform1fv(location, v);`,
        "vec2<f32>": `gl.uniform2fv(location, v);`,
        "vec3<f32>": `gl.uniform3fv(location, v);`,
        "vec4<f32>": `gl.uniform4fv(location, v);`,
        "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
        "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
        "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
        i32: `gl.uniform1iv(location, v);`,
        "vec2<i32>": `gl.uniform2iv(location, v);`,
        "vec3<i32>": `gl.uniform3iv(location, v);`,
        "vec4<i32>": `gl.uniform4iv(location, v);`,
        u32: `gl.uniform1iv(location, v);`,
        "vec2<u32>": `gl.uniform2iv(location, v);`,
        "vec3<u32>": `gl.uniform3iv(location, v);`,
        "vec4<u32>": `gl.uniform4iv(location, v);`,
        bool: `gl.uniform1iv(location, v);`,
        "vec2<bool>": `gl.uniform2iv(location, v);`,
        "vec3<bool>": `gl.uniform3iv(location, v);`,
        "vec4<bool>": `gl.uniform4iv(location, v);`
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs
  function generateUniformsSync(group, uniformData) {
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
    for (const i3 in group.uniforms) {
      if (!uniformData[i3]) {
        if (group.uniforms[i3] instanceof UniformGroup) {
          if (group.uniforms[i3].ubo) {
            funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i3}, "${i3}");
                    `);
          } else {
            funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i3});
                    `);
          }
        } else if (group.uniforms[i3] instanceof BufferResource) {
          funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i3}, "${i3}");
                    `);
        }
        continue;
      }
      const uniform = group.uniformStructures[i3];
      let parsed = false;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const parser = uniformParsers[j2];
        if (uniform.type === parser.type && parser.test(uniform)) {
          funcFragments.push(`name = "${i3}";`, uniformParsers[j2].uniform);
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
        const template = templateType[uniform.type].replace("location", `ud["${i3}"].location`);
        funcFragments.push(`
            cu = ud["${i3}"];
            cv = cu.value;
            v = uv["${i3}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }
  var init_generateUniformsSync = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs"() {
      init_BufferResource();
      init_UniformGroup();
      init_uniformParsers();
      init_generateUniformsSyncTypes();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
  var GlUniformGroupSystem;
  var init_GlUniformGroupSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
      init_Extensions();
      init_generateUniformsSync();
      GlUniformGroupSystem = class {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._cache = {};
          this._uniformGroupSyncHash = {};
          this._renderer = renderer;
          this.gl = null;
          this._cache = {};
        }
        contextChange(gl) {
          this.gl = gl;
        }
        /**
         * Uploads the uniforms values to the currently bound shader.
         * @param group - the uniforms values that be applied to the current shader
         * @param program
         * @param syncData
         * @param syncData.textureCount
         */
        updateUniformGroup(group, program, syncData) {
          const programData = this._renderer.shader._getProgramData(program);
          if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
            programData.uniformDirtyGroups[group.uid] = group._dirtyId;
            const syncFunc = this._getUniformSyncFunction(group, program);
            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
          }
        }
        /**
         * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
         * @param group
         * @param program
         */
        _getUniformSyncFunction(group, program) {
          var _a2;
          return ((_a2 = this._uniformGroupSyncHash[group._signature]) == null ? void 0 : _a2[program._key]) || this._createUniformSyncFunction(group, program);
        }
        _createUniformSyncFunction(group, program) {
          const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
          const id = this._getSignature(group, program._uniformData, "u");
          if (!this._cache[id]) {
            this._cache[id] = this._generateUniformsSync(group, program._uniformData);
          }
          uniformGroupSyncHash[program._key] = this._cache[id];
          return uniformGroupSyncHash[program._key];
        }
        _generateUniformsSync(group, uniformData) {
          return generateUniformsSync(group, uniformData);
        }
        /**
         * Takes a uniform group and data and generates a unique signature for them.
         * @param group - The uniform group to get signature of
         * @param group.uniforms
         * @param uniformData - Uniform information generated by the shader
         * @param preFix
         * @returns Unique signature of the uniform group
         */
        _getSignature(group, uniformData, preFix) {
          const uniforms = group.uniforms;
          const strings = [`${preFix}-`];
          for (const i3 in uniforms) {
            strings.push(i3);
            if (uniformData[i3]) {
              strings.push(uniformData[i3].type);
            }
          }
          return strings.join("-");
        }
        /** Destroys this System and removes all its textures. */
        destroy() {
          this._renderer = null;
          this._cache = null;
        }
      };
      GlUniformGroupSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "uniformGroup"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
  function mapWebGLBlendModesToPixi(gl) {
    const blendMap = {};
    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.add = [gl.ONE, gl.ONE];
    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.none = [0, 0];
    blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
    if (isWebGl2) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
    } else {
      const ext = gl.getExtension("EXT_blend_minmax");
      if (ext) {
        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
      }
    }
    return blendMap;
  }
  var init_mapWebGLBlendModesToPixi = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
  var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
  var init_GlStateSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
      init_Extensions();
      init_State();
      init_mapWebGLBlendModesToPixi();
      BLEND2 = 0;
      OFFSET2 = 1;
      CULLING2 = 2;
      DEPTH_TEST2 = 3;
      WINDING2 = 4;
      DEPTH_MASK2 = 5;
      _GlStateSystem = class _GlStateSystem2 {
        constructor(renderer) {
          this._invertFrontFace = false;
          this.gl = null;
          this.stateId = 0;
          this.polygonOffset = 0;
          this.blendMode = "none";
          this._blendEq = false;
          this.map = [];
          this.map[BLEND2] = this.setBlend;
          this.map[OFFSET2] = this.setOffset;
          this.map[CULLING2] = this.setCullFace;
          this.map[DEPTH_TEST2] = this.setDepthTest;
          this.map[WINDING2] = this.setFrontFace;
          this.map[DEPTH_MASK2] = this.setDepthMask;
          this.checks = [];
          this.defaultState = State.for2d();
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(renderTarget) {
          this._invertFrontFace = !renderTarget.isRoot;
          if (this._cullFace) {
            this.setFrontFace(this._frontFace);
          } else {
            this._frontFaceDirty = true;
          }
        }
        contextChange(gl) {
          this.gl = gl;
          this.blendModesMap = mapWebGLBlendModesToPixi(gl);
          this.resetState();
        }
        /**
         * Sets the current state
         * @param {*} state - The state to set.
         */
        set(state) {
          state || (state = this.defaultState);
          if (this.stateId !== state.data) {
            let diff = this.stateId ^ state.data;
            let i3 = 0;
            while (diff) {
              if (diff & 1) {
                this.map[i3].call(this, !!(state.data & 1 << i3));
              }
              diff >>= 1;
              i3++;
            }
            this.stateId = state.data;
          }
          for (let i3 = 0; i3 < this.checks.length; i3++) {
            this.checks[i3](this, state);
          }
        }
        /**
         * Sets the state, when previous state is unknown.
         * @param {*} state - The state to set
         */
        forceState(state) {
          state || (state = this.defaultState);
          for (let i3 = 0; i3 < this.map.length; i3++) {
            this.map[i3].call(this, !!(state.data & 1 << i3));
          }
          for (let i3 = 0; i3 < this.checks.length; i3++) {
            this.checks[i3](this, state);
          }
          this.stateId = state.data;
        }
        /**
         * Sets whether to enable or disable blending.
         * @param value - Turn on or off WebGl blending.
         */
        setBlend(value) {
          this._updateCheck(_GlStateSystem2._checkBlendMode, value);
          this.gl[value ? "enable" : "disable"](this.gl.BLEND);
        }
        /**
         * Sets whether to enable or disable polygon offset fill.
         * @param value - Turn on or off webgl polygon offset testing.
         */
        setOffset(value) {
          this._updateCheck(_GlStateSystem2._checkPolygonOffset, value);
          this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }
        /**
         * Sets whether to enable or disable depth test.
         * @param value - Turn on or off webgl depth testing.
         */
        setDepthTest(value) {
          this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }
        /**
         * Sets whether to enable or disable depth mask.
         * @param value - Turn on or off webgl depth mask.
         */
        setDepthMask(value) {
          this.gl.depthMask(value);
        }
        /**
         * Sets whether to enable or disable cull face.
         * @param {boolean} value - Turn on or off webgl cull face.
         */
        setCullFace(value) {
          this._cullFace = value;
          this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
          if (this._cullFace && this._frontFaceDirty) {
            this.setFrontFace(this._frontFace);
          }
        }
        /**
         * Sets the gl front face.
         * @param {boolean} value - true is clockwise and false is counter-clockwise
         */
        setFrontFace(value) {
          this._frontFace = value;
          this._frontFaceDirty = false;
          const faceMode = this._invertFrontFace ? !value : value;
          if (this._glFrontFace !== faceMode) {
            this._glFrontFace = faceMode;
            this.gl.frontFace(this.gl[faceMode ? "CW" : "CCW"]);
          }
        }
        /**
         * Sets the blend mode.
         * @param {number} value - The blend mode to set to.
         */
        setBlendMode(value) {
          if (!this.blendModesMap[value]) {
            value = "normal";
          }
          if (value === this.blendMode) {
            return;
          }
          this.blendMode = value;
          const mode = this.blendModesMap[value];
          const gl = this.gl;
          if (mode.length === 2) {
            gl.blendFunc(mode[0], mode[1]);
          } else {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
          }
          if (mode.length === 6) {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
          } else if (this._blendEq) {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          }
        }
        /**
         * Sets the polygon offset.
         * @param {number} value - the polygon offset
         * @param {number} scale - the polygon offset scale
         */
        setPolygonOffset(value, scale) {
          this.gl.polygonOffset(value, scale);
        }
        /** Resets all the logic and disables the VAOs. */
        resetState() {
          this._glFrontFace = false;
          this._frontFace = false;
          this._cullFace = false;
          this._frontFaceDirty = false;
          this._invertFrontFace = false;
          this.gl.frontFace(this.gl.CCW);
          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
          this.forceState(this.defaultState);
          this._blendEq = true;
          this.blendMode = "";
          this.setBlendMode("normal");
        }
        /**
         * Checks to see which updates should be checked based on which settings have been activated.
         *
         * For example, if blend is enabled then we should check the blend modes each time the state is changed
         * or if polygon fill is activated then we need to check if the polygon offset changes.
         * The idea is that we only check what we have too.
         * @param func - the checking function to add or remove
         * @param value - should the check function be added or removed.
         */
        _updateCheck(func, value) {
          const index = this.checks.indexOf(func);
          if (value && index === -1) {
            this.checks.push(func);
          } else if (!value && index !== -1) {
            this.checks.splice(index, 1);
          }
        }
        /**
         * A private little wrapper function that we call to check the blend mode.
         * @param system - the System to perform the state check on
         * @param state - the state that the blendMode will pulled from
         */
        static _checkBlendMode(system, state) {
          system.setBlendMode(state.blendMode);
        }
        /**
         * A private little wrapper function that we call to check the polygon offset.
         * @param system - the System to perform the state check on
         * @param state - the state that the blendMode will pulled from
         */
        static _checkPolygonOffset(system, state) {
          system.setPolygonOffset(1, state.polygonOffset);
        }
        /** @ignore */
        destroy() {
          this.gl = null;
          this.checks.length = 0;
        }
      };
      _GlStateSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "state"
      };
      GlStateSystem = _GlStateSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
  var GlTexture;
  var init_GlTexture = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
      init_const10();
      GlTexture = class {
        constructor(texture) {
          this.target = GL_TARGETS.TEXTURE_2D;
          this.texture = texture;
          this.width = -1;
          this.height = -1;
          this.type = GL_TYPES.UNSIGNED_BYTE;
          this.internalFormat = GL_FORMATS.RGBA;
          this.format = GL_FORMATS.RGBA;
          this.samplerType = 0;
        }
        destroy() {
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
  var glUploadBufferImageResource;
  var init_glUploadBufferImageResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
      "use strict";
      glUploadBufferImageResource = {
        id: "buffer",
        upload(source11, glTexture, gl) {
          if (glTexture.width === source11.width || glTexture.height === source11.height) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              source11.width,
              source11.height,
              glTexture.format,
              glTexture.type,
              source11.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              source11.width,
              source11.height,
              0,
              glTexture.format,
              glTexture.type,
              source11.resource
            );
          }
          glTexture.width = source11.width;
          glTexture.height = source11.height;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs
  var compressedFormatMap, glUploadCompressedTextureResource;
  var init_glUploadCompressedTextureResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs"() {
      "use strict";
      compressedFormatMap = {
        "bc1-rgba-unorm": true,
        "bc1-rgba-unorm-srgb": true,
        "bc2-rgba-unorm": true,
        "bc2-rgba-unorm-srgb": true,
        "bc3-rgba-unorm": true,
        "bc3-rgba-unorm-srgb": true,
        "bc4-r-unorm": true,
        "bc4-r-snorm": true,
        "bc5-rg-unorm": true,
        "bc5-rg-snorm": true,
        "bc6h-rgb-ufloat": true,
        "bc6h-rgb-float": true,
        "bc7-rgba-unorm": true,
        "bc7-rgba-unorm-srgb": true,
        // ETC2 compressed formats usable if "texture-compression-etc2" is both
        // supported by the device/user agent and enabled in requestDevice.
        "etc2-rgb8unorm": true,
        "etc2-rgb8unorm-srgb": true,
        "etc2-rgb8a1unorm": true,
        "etc2-rgb8a1unorm-srgb": true,
        "etc2-rgba8unorm": true,
        "etc2-rgba8unorm-srgb": true,
        "eac-r11unorm": true,
        "eac-r11snorm": true,
        "eac-rg11unorm": true,
        "eac-rg11snorm": true,
        // ASTC compressed formats usable if "texture-compression-astc" is both
        // supported by the device/user agent and enabled in requestDevice.
        "astc-4x4-unorm": true,
        "astc-4x4-unorm-srgb": true,
        "astc-5x4-unorm": true,
        "astc-5x4-unorm-srgb": true,
        "astc-5x5-unorm": true,
        "astc-5x5-unorm-srgb": true,
        "astc-6x5-unorm": true,
        "astc-6x5-unorm-srgb": true,
        "astc-6x6-unorm": true,
        "astc-6x6-unorm-srgb": true,
        "astc-8x5-unorm": true,
        "astc-8x5-unorm-srgb": true,
        "astc-8x6-unorm": true,
        "astc-8x6-unorm-srgb": true,
        "astc-8x8-unorm": true,
        "astc-8x8-unorm-srgb": true,
        "astc-10x5-unorm": true,
        "astc-10x5-unorm-srgb": true,
        "astc-10x6-unorm": true,
        "astc-10x6-unorm-srgb": true,
        "astc-10x8-unorm": true,
        "astc-10x8-unorm-srgb": true,
        "astc-10x10-unorm": true,
        "astc-10x10-unorm-srgb": true,
        "astc-12x10-unorm": true,
        "astc-12x10-unorm-srgb": true,
        "astc-12x12-unorm": true,
        "astc-12x12-unorm-srgb": true
      };
      glUploadCompressedTextureResource = {
        id: "compressed",
        upload(source11, glTexture, gl) {
          gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
          let mipWidth = source11.pixelWidth;
          let mipHeight = source11.pixelHeight;
          const compressed = !!compressedFormatMap[source11.format];
          for (let i3 = 0; i3 < source11.resource.length; i3++) {
            const levelBuffer = source11.resource[i3];
            if (compressed) {
              gl.compressedTexImage2D(
                gl.TEXTURE_2D,
                i3,
                glTexture.internalFormat,
                mipWidth,
                mipHeight,
                0,
                levelBuffer
              );
            } else {
              gl.texImage2D(
                gl.TEXTURE_2D,
                i3,
                glTexture.internalFormat,
                mipWidth,
                mipHeight,
                0,
                glTexture.format,
                glTexture.type,
                levelBuffer
              );
            }
            mipWidth = Math.max(mipWidth >> 1, 1);
            mipHeight = Math.max(mipHeight >> 1, 1);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
  var glUploadImageResource;
  var init_glUploadImageResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
      "use strict";
      glUploadImageResource = {
        id: "image",
        upload(source11, glTexture, gl, webGLVersion) {
          const glWidth = glTexture.width;
          const glHeight = glTexture.height;
          const textureWidth = source11.pixelWidth;
          const textureHeight = source11.pixelHeight;
          const resourceWidth = source11.resourceWidth;
          const resourceHeight = source11.resourceHeight;
          if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
            if (glWidth !== textureWidth || glHeight !== textureHeight) {
              gl.texImage2D(
                glTexture.target,
                0,
                glTexture.internalFormat,
                textureWidth,
                textureHeight,
                0,
                glTexture.format,
                glTexture.type,
                null
              );
            }
            if (webGLVersion === 2) {
              gl.texSubImage2D(
                gl.TEXTURE_2D,
                0,
                0,
                0,
                resourceWidth,
                resourceHeight,
                glTexture.format,
                glTexture.type,
                source11.resource
              );
            } else {
              gl.texSubImage2D(
                gl.TEXTURE_2D,
                0,
                0,
                0,
                glTexture.format,
                glTexture.type,
                source11.resource
              );
            }
          } else if (glWidth === textureWidth && glHeight === textureHeight) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source11.resource
            );
          } else if (webGLVersion === 2) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              source11.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              glTexture.format,
              glTexture.type,
              source11.resource
            );
          }
          glTexture.width = textureWidth;
          glTexture.height = textureHeight;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
  var glUploadVideoResource;
  var init_glUploadVideoResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
      init_glUploadImageResource();
      glUploadVideoResource = {
        id: "video",
        upload(source11, glTexture, gl, webGLVersion) {
          if (!source11.isValid) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              1,
              1,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
            return;
          }
          glUploadImageResource.upload(source11, glTexture, gl, webGLVersion);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
  var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
  var init_pixiToGlMaps = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
      "use strict";
      scaleModeToGlFilter = {
        linear: 9729,
        nearest: 9728
      };
      mipmapScaleModeToGlFilter = {
        linear: {
          linear: 9987,
          nearest: 9985
        },
        nearest: {
          linear: 9986,
          nearest: 9984
        }
      };
      wrapModeToGlAddress = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
      };
      compareModeToGlCompare = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
  function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
    const castParam = firstParam;
    if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
      const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
      const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
      const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
      if (gl.TEXTURE_WRAP_R)
        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
    }
    if (!firstCreation || style.magFilter !== "linear") {
      gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
    }
    if (mipmaps) {
      if (!firstCreation || style.mipmapFilter !== "linear") {
        const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
      }
    } else {
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
    }
    if (anisotropicExt && style.maxAnisotropy > 1) {
      const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
    }
    if (style.compare) {
      gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
    }
  }
  var init_applyStyleParams = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
      init_pixiToGlMaps();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
  function mapFormatToGlFormat(gl) {
    return {
      // 8-bit formats
      r8unorm: gl.RED,
      r8snorm: gl.RED,
      r8uint: gl.RED,
      r8sint: gl.RED,
      // 16-bit formats
      r16uint: gl.RED,
      r16sint: gl.RED,
      r16float: gl.RED,
      rg8unorm: gl.RG,
      rg8snorm: gl.RG,
      rg8uint: gl.RG,
      rg8sint: gl.RG,
      // 32-bit formats
      r32uint: gl.RED,
      r32sint: gl.RED,
      r32float: gl.RED,
      rg16uint: gl.RG,
      rg16sint: gl.RG,
      rg16float: gl.RG,
      rgba8unorm: gl.RGBA,
      "rgba8unorm-srgb": gl.RGBA,
      // Packed 32-bit formats
      rgba8snorm: gl.RGBA,
      rgba8uint: gl.RGBA,
      rgba8sint: gl.RGBA,
      bgra8unorm: gl.RGBA,
      "bgra8unorm-srgb": gl.RGBA,
      rgb9e5ufloat: gl.RGB,
      rgb10a2unorm: gl.RGBA,
      rg11b10ufloat: gl.RGB,
      // 64-bit formats
      rg32uint: gl.RG,
      rg32sint: gl.RG,
      rg32float: gl.RG,
      rgba16uint: gl.RGBA,
      rgba16sint: gl.RGBA,
      rgba16float: gl.RGBA,
      // 128-bit formats
      rgba32uint: gl.RGBA,
      rgba32sint: gl.RGBA,
      rgba32float: gl.RGBA,
      // Depth/stencil formats
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT,
      depth24plus: gl.DEPTH_COMPONENT,
      "depth24plus-stencil8": gl.DEPTH_STENCIL,
      depth32float: gl.DEPTH_COMPONENT,
      "depth32float-stencil8": gl.DEPTH_STENCIL
    };
  }
  var init_mapFormatToGlFormat = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
  function mapFormatToGlInternalFormat(gl, extensions2) {
    let srgb = {};
    let bgra8unorm = gl.RGBA;
    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
      srgb = {
        "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
        "bgra8unorm-srgb": gl.SRGB8_ALPHA8
      };
      bgra8unorm = gl.RGBA8;
    } else if (extensions2.srgb) {
      srgb = {
        "rgba8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT,
        "bgra8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT
      };
    }
    return __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues({
      // 8-bit formats
      r8unorm: gl.R8,
      r8snorm: gl.R8_SNORM,
      r8uint: gl.R8UI,
      r8sint: gl.R8I,
      // 16-bit formats
      r16uint: gl.R16UI,
      r16sint: gl.R16I,
      r16float: gl.R16F,
      rg8unorm: gl.RG8,
      rg8snorm: gl.RG8_SNORM,
      rg8uint: gl.RG8UI,
      rg8sint: gl.RG8I,
      // 32-bit formats
      r32uint: gl.R32UI,
      r32sint: gl.R32I,
      r32float: gl.R32F,
      rg16uint: gl.RG16UI,
      rg16sint: gl.RG16I,
      rg16float: gl.RG16F,
      rgba8unorm: gl.RGBA
    }, srgb), {
      // Packed 32-bit formats
      rgba8snorm: gl.RGBA8_SNORM,
      rgba8uint: gl.RGBA8UI,
      rgba8sint: gl.RGBA8I,
      bgra8unorm,
      rgb9e5ufloat: gl.RGB9_E5,
      rgb10a2unorm: gl.RGB10_A2,
      rg11b10ufloat: gl.R11F_G11F_B10F,
      // 64-bit formats
      rg32uint: gl.RG32UI,
      rg32sint: gl.RG32I,
      rg32float: gl.RG32F,
      rgba16uint: gl.RGBA16UI,
      rgba16sint: gl.RGBA16I,
      rgba16float: gl.RGBA16F,
      // 128-bit formats
      rgba32uint: gl.RGBA32UI,
      rgba32sint: gl.RGBA32I,
      rgba32float: gl.RGBA32F,
      // Depth/stencil formats
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT16,
      depth24plus: gl.DEPTH_COMPONENT24,
      "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
      depth32float: gl.DEPTH_COMPONENT32F,
      "depth32float-stencil8": gl.DEPTH32F_STENCIL8
    }), extensions2.s3tc ? {
      "bc1-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
    } : {}), extensions2.s3tc_sRGB ? {
      "bc1-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    } : {}), extensions2.rgtc ? {
      "bc4-r-unorm": extensions2.rgtc.COMPRESSED_RED_RGTC1_EXT,
      "bc4-r-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
      "bc5-rg-unorm": extensions2.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
      "bc5-rg-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
    } : {}), extensions2.bptc ? {
      "bc6h-rgb-float": extensions2.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
      "bc6h-rgb-ufloat": extensions2.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
      "bc7-rgba-unorm": extensions2.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
      "bc7-rgba-unorm-srgb": extensions2.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
    } : {}), extensions2.etc ? {
      "etc2-rgb8unorm": extensions2.etc.COMPRESSED_RGB8_ETC2,
      "etc2-rgb8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ETC2,
      "etc2-rgb8a1unorm": extensions2.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgb8a1unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgba8unorm": extensions2.etc.COMPRESSED_RGBA8_ETC2_EAC,
      "etc2-rgba8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
      "eac-r11unorm": extensions2.etc.COMPRESSED_R11_EAC,
      // 'eac-r11snorm'
      "eac-rg11unorm": extensions2.etc.COMPRESSED_SIGNED_RG11_EAC
      // 'eac-rg11snorm'
    } : {}), extensions2.astc ? {
      "astc-4x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
      "astc-4x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
      "astc-5x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
      "astc-5x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
      "astc-5x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
      "astc-5x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
      "astc-6x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
      "astc-6x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
      "astc-6x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
      "astc-6x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
      "astc-8x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
      "astc-8x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
      "astc-8x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
      "astc-8x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
      "astc-8x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
      "astc-8x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
      "astc-10x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
      "astc-10x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
      "astc-10x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
      "astc-10x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
      "astc-10x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
      "astc-10x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
      "astc-10x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
      "astc-10x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
      "astc-12x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
      "astc-12x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
      "astc-12x12-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
      "astc-12x12-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
    } : {});
  }
  var init_mapFormatToGlInternalFormat = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
  function mapFormatToGlType(gl) {
    return {
      // 8-bit formats
      r8unorm: gl.UNSIGNED_BYTE,
      r8snorm: gl.BYTE,
      r8uint: gl.UNSIGNED_BYTE,
      r8sint: gl.BYTE,
      // 16-bit formats
      r16uint: gl.UNSIGNED_SHORT,
      r16sint: gl.SHORT,
      r16float: gl.HALF_FLOAT,
      rg8unorm: gl.UNSIGNED_BYTE,
      rg8snorm: gl.BYTE,
      rg8uint: gl.UNSIGNED_BYTE,
      rg8sint: gl.BYTE,
      // 32-bit formats
      r32uint: gl.UNSIGNED_INT,
      r32sint: gl.INT,
      r32float: gl.FLOAT,
      rg16uint: gl.UNSIGNED_SHORT,
      rg16sint: gl.SHORT,
      rg16float: gl.HALF_FLOAT,
      rgba8unorm: gl.UNSIGNED_BYTE,
      "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
      // Packed 32-bit formats
      rgba8snorm: gl.BYTE,
      rgba8uint: gl.UNSIGNED_BYTE,
      rgba8sint: gl.BYTE,
      bgra8unorm: gl.UNSIGNED_BYTE,
      "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
      rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
      // 64-bit formats
      rg32uint: gl.UNSIGNED_INT,
      rg32sint: gl.INT,
      rg32float: gl.FLOAT,
      rgba16uint: gl.UNSIGNED_SHORT,
      rgba16sint: gl.SHORT,
      rgba16float: gl.HALF_FLOAT,
      // 128-bit formats
      rgba32uint: gl.UNSIGNED_INT,
      rgba32sint: gl.INT,
      rgba32float: gl.FLOAT,
      // Depth/stencil formats
      stencil8: gl.UNSIGNED_BYTE,
      depth16unorm: gl.UNSIGNED_SHORT,
      depth24plus: gl.UNSIGNED_INT,
      "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
      depth32float: gl.FLOAT,
      "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
    };
  }
  var init_mapFormatToGlType = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs
  function unpremultiplyAlpha2(pixels) {
    if (pixels instanceof Uint8ClampedArray) {
      pixels = new Uint8Array(pixels.buffer);
    }
    const n2 = pixels.length;
    for (let i3 = 0; i3 < n2; i3 += 4) {
      const alpha = pixels[i3 + 3];
      if (alpha !== 0) {
        const a2 = 255.001 / alpha;
        pixels[i3] = pixels[i3] * a2 + 0.5;
        pixels[i3 + 1] = pixels[i3 + 1] * a2 + 0.5;
        pixels[i3 + 2] = pixels[i3 + 2] * a2 + 0.5;
      }
    }
  }
  var init_unpremultiplyAlpha = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
  var BYTES_PER_PIXEL, GlTextureSystem;
  var init_GlTextureSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_GCManagedHash();
      init_Texture();
      init_GlTexture();
      init_glUploadBufferImageResource();
      init_glUploadCompressedTextureResource();
      init_glUploadImageResource();
      init_glUploadVideoResource();
      init_applyStyleParams();
      init_mapFormatToGlFormat();
      init_mapFormatToGlInternalFormat();
      init_mapFormatToGlType();
      BYTES_PER_PIXEL = 4;
      GlTextureSystem = class {
        constructor(renderer) {
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundTextures = [];
          this._activeTextureLocation = -1;
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: glUploadImageResource,
            buffer: glUploadBufferImageResource,
            video: glUploadVideoResource,
            compressed: glUploadCompressedTextureResource
          };
          this._premultiplyAlpha = false;
          this._useSeparateSamplers = false;
          this._renderer = renderer;
          this._managedTextures = new GCManagedHash({
            renderer,
            type: "resource",
            onUnload: this.onSourceUnload.bind(this),
            name: "glTexture"
          });
        }
        /**
         * @deprecated since 8.15.0
         */
        get managedTextures() {
          return Object.values(this._managedTextures.items);
        }
        contextChange(gl) {
          this._gl = gl;
          if (!this._mapFormatToInternalFormat) {
            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
            this._mapFormatToType = mapFormatToGlType(gl);
            this._mapFormatToFormat = mapFormatToGlFormat(gl);
          }
          this._managedTextures.removeAll(true);
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          this._premultiplyAlpha = false;
          for (let i3 = 0; i3 < 16; i3++) {
            this.bind(Texture.EMPTY, i3);
          }
        }
        /**
         * Initializes a texture source, if it has already been initialized nothing will happen.
         * @param source - The texture source to initialize.
         * @returns The initialized texture source.
         */
        initSource(source11) {
          this.bind(source11);
        }
        bind(texture, location = 0) {
          const source11 = texture.source;
          if (texture) {
            this.bindSource(source11, location);
            if (this._useSeparateSamplers) {
              this._bindSampler(source11.style, location);
            }
          } else {
            this.bindSource(null, location);
            if (this._useSeparateSamplers) {
              this._bindSampler(null, location);
            }
          }
        }
        bindSource(source11, location = 0) {
          const gl = this._gl;
          source11._gcLastUsed = this._renderer.gc.now;
          if (this._boundTextures[location] !== source11) {
            this._boundTextures[location] = source11;
            this._activateLocation(location);
            source11 || (source11 = Texture.EMPTY.source);
            const glTexture = this.getGlSource(source11);
            gl.bindTexture(glTexture.target, glTexture.texture);
          }
        }
        _bindSampler(style, location = 0) {
          const gl = this._gl;
          if (!style) {
            this._boundSamplers[location] = null;
            gl.bindSampler(location, null);
            return;
          }
          const sampler = this._getGlSampler(style);
          if (this._boundSamplers[location] !== sampler) {
            this._boundSamplers[location] = sampler;
            gl.bindSampler(location, sampler);
          }
        }
        unbind(texture) {
          const source11 = texture.source;
          const boundTextures = this._boundTextures;
          const gl = this._gl;
          for (let i3 = 0; i3 < boundTextures.length; i3++) {
            if (boundTextures[i3] === source11) {
              this._activateLocation(i3);
              const glTexture = this.getGlSource(source11);
              gl.bindTexture(glTexture.target, null);
              boundTextures[i3] = null;
            }
          }
        }
        _activateLocation(location) {
          if (this._activeTextureLocation !== location) {
            this._activeTextureLocation = location;
            this._gl.activeTexture(this._gl.TEXTURE0 + location);
          }
        }
        _initSource(source11) {
          const gl = this._gl;
          const glTexture = new GlTexture(gl.createTexture());
          glTexture.type = this._mapFormatToType[source11.format];
          glTexture.internalFormat = this._mapFormatToInternalFormat[source11.format];
          glTexture.format = this._mapFormatToFormat[source11.format];
          if (source11.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source11.isPowerOfTwo)) {
            const biggestDimension = Math.max(source11.width, source11.height);
            source11.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          source11._gpuData[this._renderer.uid] = glTexture;
          const added = this._managedTextures.add(source11);
          if (added) {
            source11.on("update", this.onSourceUpdate, this);
            source11.on("resize", this.onSourceUpdate, this);
            source11.on("styleChange", this.onStyleChange, this);
            source11.on("updateMipmaps", this.onUpdateMipmaps, this);
          }
          this.onSourceUpdate(source11);
          this.updateStyle(source11, false);
          return glTexture;
        }
        onStyleChange(source11) {
          this.updateStyle(source11, false);
        }
        updateStyle(source11, firstCreation) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source11);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source11;
          applyStyleParams(
            source11.style,
            gl,
            source11.mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "texParameteri",
            gl.TEXTURE_2D,
            // will force a clamp to edge if the texture is not a power of two
            !this._renderer.context.supports.nonPowOf2wrapping && !source11.isPowerOfTwo,
            firstCreation
          );
        }
        onSourceUnload(source11, contextLost = false) {
          const glTexture = source11._gpuData[this._renderer.uid];
          if (!glTexture)
            return;
          if (!contextLost) {
            this.unbind(source11);
            this._gl.deleteTexture(glTexture.texture);
          }
          source11.off("update", this.onSourceUpdate, this);
          source11.off("resize", this.onSourceUpdate, this);
          source11.off("styleChange", this.onStyleChange, this);
          source11.off("updateMipmaps", this.onUpdateMipmaps, this);
        }
        onSourceUpdate(source11) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source11);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source11;
          const premultipliedAlpha = source11.alphaMode === "premultiply-alpha-on-upload";
          if (this._premultiplyAlpha !== premultipliedAlpha) {
            this._premultiplyAlpha = premultipliedAlpha;
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
          }
          if (this._uploads[source11.uploadMethodId]) {
            this._uploads[source11.uploadMethodId].upload(source11, glTexture, gl, this._renderer.context.webGLVersion);
          } else {
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              glTexture.internalFormat,
              source11.pixelWidth,
              source11.pixelHeight,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
          }
          if (source11.autoGenerateMipmaps && source11.mipLevelCount > 1) {
            this.onUpdateMipmaps(source11, false);
          }
        }
        onUpdateMipmaps(source11, bind = true) {
          if (bind)
            this.bindSource(source11, 0);
          const glTexture = this.getGlSource(source11);
          this._gl.generateMipmap(glTexture.target);
        }
        _initSampler(style) {
          const gl = this._gl;
          const glSampler = this._gl.createSampler();
          this._glSamplers[style._resourceId] = glSampler;
          applyStyleParams(
            style,
            gl,
            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "samplerParameteri",
            glSampler,
            false,
            true
          );
          return this._glSamplers[style._resourceId];
        }
        _getGlSampler(sampler) {
          return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
        }
        getGlSource(source11) {
          source11._gcLastUsed = this._renderer.gc.now;
          return source11._gpuData[this._renderer.uid] || this._initSource(source11);
        }
        generateCanvas(texture) {
          const { pixels, width, height } = this.getPixels(texture);
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          if (ctx) {
            const imageData = ctx.createImageData(width, height);
            imageData.data.set(pixels);
            ctx.putImageData(imageData, 0, 0);
          }
          return canvas;
        }
        getPixels(texture) {
          const resolution = texture.source.resolution;
          const frame = texture.frame;
          const width = Math.max(Math.round(frame.width * resolution), 1);
          const height = Math.max(Math.round(frame.height * resolution), 1);
          const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
          const renderer = this._renderer;
          const renderTarget = renderer.renderTarget.getRenderTarget(texture);
          const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
          const gl = renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
          gl.readPixels(
            Math.round(frame.x * resolution),
            Math.round(frame.y * resolution),
            width,
            height,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            pixels
          );
          if (false) {
            unpremultiplyAlpha(pixels);
          }
          return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
        }
        destroy() {
          this._managedTextures.destroy();
          this._glSamplers = null;
          this._boundTextures = null;
          this._boundSamplers = null;
          this._mapFormatToInternalFormat = null;
          this._mapFormatToType = null;
          this._mapFormatToFormat = null;
          this._uploads = null;
          this._renderer = null;
        }
        resetState() {
          this._activeTextureLocation = -1;
          this._boundTextures.fill(Texture.EMPTY.source);
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          const gl = this._gl;
          this._premultiplyAlpha = false;
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
        }
      };
      GlTextureSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "texture"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
  var WebGLRenderer_exports = {};
  __export(WebGLRenderer_exports, {
    WebGLRenderer: () => WebGLRenderer
  });
  var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
  var init_WebGLRenderer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
      init_Extensions();
      init_GlGraphicsAdaptor();
      init_GlMeshAdaptor();
      init_GlBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types2();
      init_GlBufferSystem();
      init_GlContextSystem();
      init_GlGeometrySystem();
      init_GlBackBufferSystem();
      init_GlColorMaskSystem();
      init_GlEncoderSystem();
      init_GlLimitsSystem();
      init_GlStencilSystem();
      init_GlUboSystem();
      init_GlRenderTargetSystem();
      init_GlShaderSystem();
      init_GlUniformGroupSystem();
      init_GlStateSystem();
      init_GlTextureSystem();
      DefaultWebGLSystems = [
        ...SharedSystems,
        GlUboSystem,
        GlBackBufferSystem,
        GlContextSystem,
        GlLimitsSystem,
        GlBufferSystem,
        GlTextureSystem,
        GlRenderTargetSystem,
        GlGeometrySystem,
        GlUniformGroupSystem,
        GlShaderSystem,
        GlEncoderSystem,
        GlStateSystem,
        GlStencilSystem,
        GlColorMaskSystem
      ];
      DefaultWebGLPipes = [...SharedRenderPipes];
      DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
      systems2 = [];
      renderPipes2 = [];
      renderPipeAdaptors2 = [];
      extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
      extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
      extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
      extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
      WebGLRenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgl",
            type: RendererType.WEBGL,
            systems: systems2,
            renderPipes: renderPipes2,
            renderPipeAdaptors: renderPipeAdaptors2
          };
          super(systemConfig);
        }
      };
    }
  });

  // node_modules/@xmldom/xmldom/lib/conventions.js
  var require_conventions = __commonJS({
    "node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
      "use strict";
      function find(list, predicate, ac) {
        if (ac === void 0) {
          ac = Array.prototype;
        }
        if (list && typeof ac.find === "function") {
          return ac.find.call(list, predicate);
        }
        for (var i3 = 0; i3 < list.length; i3++) {
          if (Object.prototype.hasOwnProperty.call(list, i3)) {
            var item = list[i3];
            if (predicate.call(void 0, item, i3, list)) {
              return item;
            }
          }
        }
      }
      function freeze(object, oc) {
        if (oc === void 0) {
          oc = Object;
        }
        return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
      }
      function assign(target, source11) {
        if (target === null || typeof target !== "object") {
          throw new TypeError("target is not an object");
        }
        for (var key in source11) {
          if (Object.prototype.hasOwnProperty.call(source11, key)) {
            target[key] = source11[key];
          }
        }
        return target;
      }
      var MIME_TYPE = freeze({
        /**
         * `text/html`, the only mime type that triggers treating an XML document as HTML.
         *
         * @see DOMParser.SupportedType.isHTML
         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/HTML Wikipedia
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
         */
        HTML: "text/html",
        /**
         * Helper method to check a mime type if it indicates an HTML document
         *
         * @param {string} [value]
         * @returns {boolean}
         *
         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/HTML Wikipedia
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
        isHTML: function(value) {
          return value === MIME_TYPE.HTML;
        },
        /**
         * `application/xml`, the standard mime type for XML documents.
         *
         * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
         * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
         */
        XML_APPLICATION: "application/xml",
        /**
         * `text/html`, an alias for `application/xml`.
         *
         * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
         * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
         */
        XML_TEXT: "text/xml",
        /**
         * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
         * but is parsed as an XML document.
         *
         * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
         * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
         */
        XML_XHTML_APPLICATION: "application/xhtml+xml",
        /**
         * `image/svg+xml`,
         *
         * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
         * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
         * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
         */
        XML_SVG_IMAGE: "image/svg+xml"
      });
      var NAMESPACE = freeze({
        /**
         * The XHTML namespace.
         *
         * @see http://www.w3.org/1999/xhtml
         */
        HTML: "http://www.w3.org/1999/xhtml",
        /**
         * Checks if `uri` equals `NAMESPACE.HTML`.
         *
         * @param {string} [uri]
         *
         * @see NAMESPACE.HTML
         */
        isHTML: function(uri) {
          return uri === NAMESPACE.HTML;
        },
        /**
         * The SVG namespace.
         *
         * @see http://www.w3.org/2000/svg
         */
        SVG: "http://www.w3.org/2000/svg",
        /**
         * The `xml:` namespace.
         *
         * @see http://www.w3.org/XML/1998/namespace
         */
        XML: "http://www.w3.org/XML/1998/namespace",
        /**
         * The `xmlns:` namespace
         *
         * @see https://www.w3.org/2000/xmlns/
         */
        XMLNS: "http://www.w3.org/2000/xmlns/"
      });
      exports.assign = assign;
      exports.find = find;
      exports.freeze = freeze;
      exports.MIME_TYPE = MIME_TYPE;
      exports.NAMESPACE = NAMESPACE;
    }
  });

  // node_modules/@xmldom/xmldom/lib/dom.js
  var require_dom = __commonJS({
    "node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
      var conventions = require_conventions();
      var find = conventions.find;
      var NAMESPACE = conventions.NAMESPACE;
      function notEmptyString(input) {
        return input !== "";
      }
      function splitOnASCIIWhitespace(input) {
        return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
      }
      function orderedSetReducer(current, element) {
        if (!current.hasOwnProperty(element)) {
          current[element] = true;
        }
        return current;
      }
      function toOrderedSet(input) {
        if (!input) return [];
        var list = splitOnASCIIWhitespace(input);
        return Object.keys(list.reduce(orderedSetReducer, {}));
      }
      function arrayIncludes(list) {
        return function(element) {
          return list && list.indexOf(element) !== -1;
        };
      }
      function copy(src, dest) {
        for (var p3 in src) {
          if (Object.prototype.hasOwnProperty.call(src, p3)) {
            dest[p3] = src[p3];
          }
        }
      }
      function _extends(Class, Super) {
        var pt = Class.prototype;
        if (!(pt instanceof Super)) {
          let t3 = function() {
          };
          var t2 = t3;
          ;
          t3.prototype = Super.prototype;
          t3 = new t3();
          copy(pt, t3);
          Class.prototype = pt = t3;
        }
        if (pt.constructor != Class) {
          if (typeof Class != "function") {
            console.error("unknown Class:" + Class);
          }
          pt.constructor = Class;
        }
      }
      var NodeType = {};
      var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
      var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
      var TEXT_NODE = NodeType.TEXT_NODE = 3;
      var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
      var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
      var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
      var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
      var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
      var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
      var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
      var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
      var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
      var ExceptionCode = {};
      var ExceptionMessage = {};
      var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
      var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
      var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
      var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
      var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
      var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
      var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
      var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
      var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
      var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
      var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
      var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
      var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
      var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
      var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
      function DOMException(code, message) {
        if (message instanceof Error) {
          var error = message;
        } else {
          error = this;
          Error.call(this, ExceptionMessage[code]);
          this.message = ExceptionMessage[code];
          if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
        }
        error.code = code;
        if (message) this.message = this.message + ": " + message;
        return error;
      }
      DOMException.prototype = Error.prototype;
      copy(ExceptionCode, DOMException);
      function NodeList() {
      }
      NodeList.prototype = {
        /**
         * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
         * @standard level1
         */
        length: 0,
        /**
         * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
         * @standard level1
         * @param index  unsigned long
         *   Index into the collection.
         * @return Node
         * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
         */
        item: function(index) {
          return index >= 0 && index < this.length ? this[index] : null;
        },
        toString: function(isHTML, nodeFilter) {
          for (var buf = [], i3 = 0; i3 < this.length; i3++) {
            serializeToString(this[i3], buf, isHTML, nodeFilter);
          }
          return buf.join("");
        },
        /**
         * @private
         * @param {function (Node):boolean} predicate
         * @returns {Node[]}
         */
        filter: function(predicate) {
          return Array.prototype.filter.call(this, predicate);
        },
        /**
         * @private
         * @param {Node} item
         * @returns {number}
         */
        indexOf: function(item) {
          return Array.prototype.indexOf.call(this, item);
        }
      };
      function LiveNodeList(node, refresh) {
        this._node = node;
        this._refresh = refresh;
        _updateLiveList(this);
      }
      function _updateLiveList(list) {
        var inc = list._node._inc || list._node.ownerDocument._inc;
        if (list._inc !== inc) {
          var ls = list._refresh(list._node);
          __set__(list, "length", ls.length);
          if (!list.$length || ls.length < list.$length) {
            for (var i3 = ls.length; i3 in list; i3++) {
              if (Object.prototype.hasOwnProperty.call(list, i3)) {
                delete list[i3];
              }
            }
          }
          copy(ls, list);
          list._inc = inc;
        }
      }
      LiveNodeList.prototype.item = function(i3) {
        _updateLiveList(this);
        return this[i3] || null;
      };
      _extends(LiveNodeList, NodeList);
      function NamedNodeMap() {
      }
      function _findNodeIndex(list, node) {
        var i3 = list.length;
        while (i3--) {
          if (list[i3] === node) {
            return i3;
          }
        }
      }
      function _addNamedNode(el, list, newAttr, oldAttr) {
        if (oldAttr) {
          list[_findNodeIndex(list, oldAttr)] = newAttr;
        } else {
          list[list.length++] = newAttr;
        }
        if (el) {
          newAttr.ownerElement = el;
          var doc = el.ownerDocument;
          if (doc) {
            oldAttr && _onRemoveAttribute(doc, el, oldAttr);
            _onAddAttribute(doc, el, newAttr);
          }
        }
      }
      function _removeNamedNode(el, list, attr) {
        var i3 = _findNodeIndex(list, attr);
        if (i3 >= 0) {
          var lastIndex = list.length - 1;
          while (i3 < lastIndex) {
            list[i3] = list[++i3];
          }
          list.length = lastIndex;
          if (el) {
            var doc = el.ownerDocument;
            if (doc) {
              _onRemoveAttribute(doc, el, attr);
              attr.ownerElement = null;
            }
          }
        } else {
          throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
        }
      }
      NamedNodeMap.prototype = {
        length: 0,
        item: NodeList.prototype.item,
        getNamedItem: function(key) {
          var i3 = this.length;
          while (i3--) {
            var attr = this[i3];
            if (attr.nodeName == key) {
              return attr;
            }
          }
        },
        setNamedItem: function(attr) {
          var el = attr.ownerElement;
          if (el && el != this._ownerElement) {
            throw new DOMException(INUSE_ATTRIBUTE_ERR);
          }
          var oldAttr = this.getNamedItem(attr.nodeName);
          _addNamedNode(this._ownerElement, this, attr, oldAttr);
          return oldAttr;
        },
        /* returns Node */
        setNamedItemNS: function(attr) {
          var el = attr.ownerElement, oldAttr;
          if (el && el != this._ownerElement) {
            throw new DOMException(INUSE_ATTRIBUTE_ERR);
          }
          oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
          _addNamedNode(this._ownerElement, this, attr, oldAttr);
          return oldAttr;
        },
        /* returns Node */
        removeNamedItem: function(key) {
          var attr = this.getNamedItem(key);
          _removeNamedNode(this._ownerElement, this, attr);
          return attr;
        },
        // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
        //for level2
        removeNamedItemNS: function(namespaceURI, localName) {
          var attr = this.getNamedItemNS(namespaceURI, localName);
          _removeNamedNode(this._ownerElement, this, attr);
          return attr;
        },
        getNamedItemNS: function(namespaceURI, localName) {
          var i3 = this.length;
          while (i3--) {
            var node = this[i3];
            if (node.localName == localName && node.namespaceURI == namespaceURI) {
              return node;
            }
          }
          return null;
        }
      };
      function DOMImplementation() {
      }
      DOMImplementation.prototype = {
        /**
         * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
         * The different implementations fairly diverged in what kind of features were reported.
         * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
         *
         * @deprecated It is deprecated and modern browsers return true in all cases.
         *
         * @param {string} feature
         * @param {string} [version]
         * @returns {boolean} always true
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
         * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
         */
        hasFeature: function(feature, version) {
          return true;
        },
        /**
         * Creates an XML Document object of the specified type with its document element.
         *
         * __It behaves slightly different from the description in the living standard__:
         * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
         * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
         * - this implementation is not validating names or qualified names
         *   (when parsing XML strings, the SAX parser takes care of that)
         *
         * @param {string|null} namespaceURI
         * @param {string} qualifiedName
         * @param {DocumentType=null} doctype
         * @returns {Document}
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
         *
         * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
         * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
         * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
         */
        createDocument: function(namespaceURI, qualifiedName, doctype) {
          var doc = new Document();
          doc.implementation = this;
          doc.childNodes = new NodeList();
          doc.doctype = doctype || null;
          if (doctype) {
            doc.appendChild(doctype);
          }
          if (qualifiedName) {
            var root = doc.createElementNS(namespaceURI, qualifiedName);
            doc.appendChild(root);
          }
          return doc;
        },
        /**
         * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
         *
         * __This behavior is slightly different from the in the specs__:
         * - this implementation is not validating names or qualified names
         *   (when parsing XML strings, the SAX parser takes care of that)
         *
         * @param {string} qualifiedName
         * @param {string} [publicId]
         * @param {string} [systemId]
         * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
         * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
         *
         * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
         * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
         * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
         */
        createDocumentType: function(qualifiedName, publicId, systemId) {
          var node = new DocumentType();
          node.name = qualifiedName;
          node.nodeName = qualifiedName;
          node.publicId = publicId || "";
          node.systemId = systemId || "";
          return node;
        }
      };
      function Node() {
      }
      Node.prototype = {
        firstChild: null,
        lastChild: null,
        previousSibling: null,
        nextSibling: null,
        attributes: null,
        parentNode: null,
        childNodes: null,
        ownerDocument: null,
        nodeValue: null,
        namespaceURI: null,
        prefix: null,
        localName: null,
        // Modified in DOM Level 2:
        insertBefore: function(newChild, refChild) {
          return _insertBefore(this, newChild, refChild);
        },
        replaceChild: function(newChild, oldChild) {
          _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
          if (oldChild) {
            this.removeChild(oldChild);
          }
        },
        removeChild: function(oldChild) {
          return _removeChild(this, oldChild);
        },
        appendChild: function(newChild) {
          return this.insertBefore(newChild, null);
        },
        hasChildNodes: function() {
          return this.firstChild != null;
        },
        cloneNode: function(deep) {
          return cloneNode(this.ownerDocument || this, this, deep);
        },
        // Modified in DOM Level 2:
        normalize: function() {
          var child = this.firstChild;
          while (child) {
            var next = child.nextSibling;
            if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
              this.removeChild(next);
              child.appendData(next.data);
            } else {
              child.normalize();
              child = next;
            }
          }
        },
        // Introduced in DOM Level 2:
        isSupported: function(feature, version) {
          return this.ownerDocument.implementation.hasFeature(feature, version);
        },
        // Introduced in DOM Level 2:
        hasAttributes: function() {
          return this.attributes.length > 0;
        },
        /**
         * Look up the prefix associated to the given namespace URI, starting from this node.
         * **The default namespace declarations are ignored by this method.**
         * See Namespace Prefix Lookup for details on the algorithm used by this method.
         *
         * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
         *
         * @param {string | null} namespaceURI
         * @returns {string | null}
         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
         * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
         * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
         * @see https://github.com/xmldom/xmldom/issues/322
         */
        lookupPrefix: function(namespaceURI) {
          var el = this;
          while (el) {
            var map = el._nsMap;
            if (map) {
              for (var n2 in map) {
                if (Object.prototype.hasOwnProperty.call(map, n2) && map[n2] === namespaceURI) {
                  return n2;
                }
              }
            }
            el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
          }
          return null;
        },
        // Introduced in DOM Level 3:
        lookupNamespaceURI: function(prefix) {
          var el = this;
          while (el) {
            var map = el._nsMap;
            if (map) {
              if (Object.prototype.hasOwnProperty.call(map, prefix)) {
                return map[prefix];
              }
            }
            el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
          }
          return null;
        },
        // Introduced in DOM Level 3:
        isDefaultNamespace: function(namespaceURI) {
          var prefix = this.lookupPrefix(namespaceURI);
          return prefix == null;
        }
      };
      function _xmlEncoder(c2) {
        return c2 == "<" && "&lt;" || c2 == ">" && "&gt;" || c2 == "&" && "&amp;" || c2 == '"' && "&quot;" || "&#" + c2.charCodeAt() + ";";
      }
      copy(NodeType, Node);
      copy(NodeType, Node.prototype);
      function _visitNode(node, callback) {
        if (callback(node)) {
          return true;
        }
        if (node = node.firstChild) {
          do {
            if (_visitNode(node, callback)) {
              return true;
            }
          } while (node = node.nextSibling);
        }
      }
      function Document() {
        this.ownerDocument = this;
      }
      function _onAddAttribute(doc, el, newAttr) {
        doc && doc._inc++;
        var ns = newAttr.namespaceURI;
        if (ns === NAMESPACE.XMLNS) {
          el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
        }
      }
      function _onRemoveAttribute(doc, el, newAttr, remove) {
        doc && doc._inc++;
        var ns = newAttr.namespaceURI;
        if (ns === NAMESPACE.XMLNS) {
          delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
        }
      }
      function _onUpdateChild(doc, el, newChild) {
        if (doc && doc._inc) {
          doc._inc++;
          var cs = el.childNodes;
          if (newChild) {
            cs[cs.length++] = newChild;
          } else {
            var child = el.firstChild;
            var i3 = 0;
            while (child) {
              cs[i3++] = child;
              child = child.nextSibling;
            }
            cs.length = i3;
            delete cs[cs.length];
          }
        }
      }
      function _removeChild(parentNode, child) {
        var previous = child.previousSibling;
        var next = child.nextSibling;
        if (previous) {
          previous.nextSibling = next;
        } else {
          parentNode.firstChild = next;
        }
        if (next) {
          next.previousSibling = previous;
        } else {
          parentNode.lastChild = previous;
        }
        child.parentNode = null;
        child.previousSibling = null;
        child.nextSibling = null;
        _onUpdateChild(parentNode.ownerDocument, parentNode);
        return child;
      }
      function hasValidParentNodeType(node) {
        return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
      }
      function hasInsertableNodeType(node) {
        return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
      }
      function isDocTypeNode(node) {
        return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
      }
      function isElementNode(node) {
        return node && node.nodeType === Node.ELEMENT_NODE;
      }
      function isTextNode(node) {
        return node && node.nodeType === Node.TEXT_NODE;
      }
      function isElementInsertionPossible(doc, child) {
        var parentChildNodes = doc.childNodes || [];
        if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
          return false;
        }
        var docTypeNode = find(parentChildNodes, isDocTypeNode);
        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
      }
      function isElementReplacementPossible(doc, child) {
        var parentChildNodes = doc.childNodes || [];
        function hasElementChildThatIsNotChild(node) {
          return isElementNode(node) && node !== child;
        }
        if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
          return false;
        }
        var docTypeNode = find(parentChildNodes, isDocTypeNode);
        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
      }
      function assertPreInsertionValidity1to5(parent, node, child) {
        if (!hasValidParentNodeType(parent)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
        }
        if (child && child.parentNode !== parent) {
          throw new DOMException(NOT_FOUND_ERR, "child not in parent");
        }
        if (
          // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
          !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
          // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
          // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
          // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
          isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
        ) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
          );
        }
      }
      function assertPreInsertionValidityInDocument(parent, node, child) {
        var parentChildNodes = parent.childNodes || [];
        var nodeChildNodes = node.childNodes || [];
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var nodeChildElements = nodeChildNodes.filter(isElementNode);
          if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
          }
          if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
          }
        }
        if (isElementNode(node)) {
          if (!isElementInsertionPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
          }
        }
        if (isDocTypeNode(node)) {
          if (find(parentChildNodes, isDocTypeNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
          }
          var parentElementChild = find(parentChildNodes, isElementNode);
          if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
          }
          if (!child && parentElementChild) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
          }
        }
      }
      function assertPreReplacementValidityInDocument(parent, node, child) {
        var parentChildNodes = parent.childNodes || [];
        var nodeChildNodes = node.childNodes || [];
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var nodeChildElements = nodeChildNodes.filter(isElementNode);
          if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
          }
          if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
          }
        }
        if (isElementNode(node)) {
          if (!isElementReplacementPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
          }
        }
        if (isDocTypeNode(node)) {
          let hasDoctypeChildThatIsNotChild2 = function(node2) {
            return isDocTypeNode(node2) && node2 !== child;
          };
          var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
          if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
          }
          var parentElementChild = find(parentChildNodes, isElementNode);
          if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
          }
        }
      }
      function _insertBefore(parent, node, child, _inDocumentAssertion) {
        assertPreInsertionValidity1to5(parent, node, child);
        if (parent.nodeType === Node.DOCUMENT_NODE) {
          (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
        }
        var cp = node.parentNode;
        if (cp) {
          cp.removeChild(node);
        }
        if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
          var newFirst = node.firstChild;
          if (newFirst == null) {
            return node;
          }
          var newLast = node.lastChild;
        } else {
          newFirst = newLast = node;
        }
        var pre = child ? child.previousSibling : parent.lastChild;
        newFirst.previousSibling = pre;
        newLast.nextSibling = child;
        if (pre) {
          pre.nextSibling = newFirst;
        } else {
          parent.firstChild = newFirst;
        }
        if (child == null) {
          parent.lastChild = newLast;
        } else {
          child.previousSibling = newLast;
        }
        do {
          newFirst.parentNode = parent;
          var targetDoc = parent.ownerDocument || parent;
          _updateOwnerDocument(newFirst, targetDoc);
        } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
        _onUpdateChild(parent.ownerDocument || parent, parent);
        if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
          node.firstChild = node.lastChild = null;
        }
        return node;
      }
      function _updateOwnerDocument(node, newOwnerDocument) {
        if (node.ownerDocument === newOwnerDocument) {
          return;
        }
        node.ownerDocument = newOwnerDocument;
        if (node.nodeType === ELEMENT_NODE && node.attributes) {
          for (var i3 = 0; i3 < node.attributes.length; i3++) {
            var attr = node.attributes.item(i3);
            if (attr) {
              attr.ownerDocument = newOwnerDocument;
            }
          }
        }
        var child = node.firstChild;
        while (child) {
          _updateOwnerDocument(child, newOwnerDocument);
          child = child.nextSibling;
        }
      }
      function _appendSingleChild(parentNode, newChild) {
        if (newChild.parentNode) {
          newChild.parentNode.removeChild(newChild);
        }
        newChild.parentNode = parentNode;
        newChild.previousSibling = parentNode.lastChild;
        newChild.nextSibling = null;
        if (newChild.previousSibling) {
          newChild.previousSibling.nextSibling = newChild;
        } else {
          parentNode.firstChild = newChild;
        }
        parentNode.lastChild = newChild;
        _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
        var targetDoc = parentNode.ownerDocument || parentNode;
        _updateOwnerDocument(newChild, targetDoc);
        return newChild;
      }
      Document.prototype = {
        //implementation : null,
        nodeName: "#document",
        nodeType: DOCUMENT_NODE,
        /**
         * The DocumentType node of the document.
         *
         * @readonly
         * @type DocumentType
         */
        doctype: null,
        documentElement: null,
        _inc: 1,
        insertBefore: function(newChild, refChild) {
          if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
            var child = newChild.firstChild;
            while (child) {
              var next = child.nextSibling;
              this.insertBefore(child, refChild);
              child = next;
            }
            return newChild;
          }
          _insertBefore(this, newChild, refChild);
          _updateOwnerDocument(newChild, this);
          if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
            this.documentElement = newChild;
          }
          return newChild;
        },
        removeChild: function(oldChild) {
          if (this.documentElement == oldChild) {
            this.documentElement = null;
          }
          return _removeChild(this, oldChild);
        },
        replaceChild: function(newChild, oldChild) {
          _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
          _updateOwnerDocument(newChild, this);
          if (oldChild) {
            this.removeChild(oldChild);
          }
          if (isElementNode(newChild)) {
            this.documentElement = newChild;
          }
        },
        // Introduced in DOM Level 2:
        importNode: function(importedNode, deep) {
          return importNode(this, importedNode, deep);
        },
        // Introduced in DOM Level 2:
        getElementById: function(id) {
          var rtv = null;
          _visitNode(this.documentElement, function(node) {
            if (node.nodeType == ELEMENT_NODE) {
              if (node.getAttribute("id") == id) {
                rtv = node;
                return true;
              }
            }
          });
          return rtv;
        },
        /**
         * The `getElementsByClassName` method of `Document` interface returns an array-like object
         * of all child elements which have **all** of the given class name(s).
         *
         * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
         *
         *
         * Warning: This is a live LiveNodeList.
         * Changes in the DOM will reflect in the array as the changes occur.
         * If an element selected by this array no longer qualifies for the selector,
         * it will automatically be removed. Be aware of this for iteration purposes.
         *
         * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
         * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
         */
        getElementsByClassName: function(classNames) {
          var classNamesSet = toOrderedSet(classNames);
          return new LiveNodeList(this, function(base) {
            var ls = [];
            if (classNamesSet.length > 0) {
              _visitNode(base.documentElement, function(node) {
                if (node !== base && node.nodeType === ELEMENT_NODE) {
                  var nodeClassNames = node.getAttribute("class");
                  if (nodeClassNames) {
                    var matches = classNames === nodeClassNames;
                    if (!matches) {
                      var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                      matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                    }
                    if (matches) {
                      ls.push(node);
                    }
                  }
                }
              });
            }
            return ls;
          });
        },
        //document factory method:
        createElement: function(tagName) {
          var node = new Element();
          node.ownerDocument = this;
          node.nodeName = tagName;
          node.tagName = tagName;
          node.localName = tagName;
          node.childNodes = new NodeList();
          var attrs = node.attributes = new NamedNodeMap();
          attrs._ownerElement = node;
          return node;
        },
        createDocumentFragment: function() {
          var node = new DocumentFragment();
          node.ownerDocument = this;
          node.childNodes = new NodeList();
          return node;
        },
        createTextNode: function(data) {
          var node = new Text2();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createComment: function(data) {
          var node = new Comment();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createCDATASection: function(data) {
          var node = new CDATASection();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createProcessingInstruction: function(target, data) {
          var node = new ProcessingInstruction();
          node.ownerDocument = this;
          node.tagName = node.nodeName = node.target = target;
          node.nodeValue = node.data = data;
          return node;
        },
        createAttribute: function(name) {
          var node = new Attr();
          node.ownerDocument = this;
          node.name = name;
          node.nodeName = name;
          node.localName = name;
          node.specified = true;
          return node;
        },
        createEntityReference: function(name) {
          var node = new EntityReference();
          node.ownerDocument = this;
          node.nodeName = name;
          return node;
        },
        // Introduced in DOM Level 2:
        createElementNS: function(namespaceURI, qualifiedName) {
          var node = new Element();
          var pl = qualifiedName.split(":");
          var attrs = node.attributes = new NamedNodeMap();
          node.childNodes = new NodeList();
          node.ownerDocument = this;
          node.nodeName = qualifiedName;
          node.tagName = qualifiedName;
          node.namespaceURI = namespaceURI;
          if (pl.length == 2) {
            node.prefix = pl[0];
            node.localName = pl[1];
          } else {
            node.localName = qualifiedName;
          }
          attrs._ownerElement = node;
          return node;
        },
        // Introduced in DOM Level 2:
        createAttributeNS: function(namespaceURI, qualifiedName) {
          var node = new Attr();
          var pl = qualifiedName.split(":");
          node.ownerDocument = this;
          node.nodeName = qualifiedName;
          node.name = qualifiedName;
          node.namespaceURI = namespaceURI;
          node.specified = true;
          if (pl.length == 2) {
            node.prefix = pl[0];
            node.localName = pl[1];
          } else {
            node.localName = qualifiedName;
          }
          return node;
        }
      };
      _extends(Document, Node);
      function Element() {
        this._nsMap = {};
      }
      Element.prototype = {
        nodeType: ELEMENT_NODE,
        hasAttribute: function(name) {
          return this.getAttributeNode(name) != null;
        },
        getAttribute: function(name) {
          var attr = this.getAttributeNode(name);
          return attr && attr.value || "";
        },
        getAttributeNode: function(name) {
          return this.attributes.getNamedItem(name);
        },
        setAttribute: function(name, value) {
          var attr = this.ownerDocument.createAttribute(name);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr);
        },
        removeAttribute: function(name) {
          var attr = this.getAttributeNode(name);
          attr && this.removeAttributeNode(attr);
        },
        //four real opeartion method
        appendChild: function(newChild) {
          if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
            return this.insertBefore(newChild, null);
          } else {
            return _appendSingleChild(this, newChild);
          }
        },
        setAttributeNode: function(newAttr) {
          return this.attributes.setNamedItem(newAttr);
        },
        setAttributeNodeNS: function(newAttr) {
          return this.attributes.setNamedItemNS(newAttr);
        },
        removeAttributeNode: function(oldAttr) {
          return this.attributes.removeNamedItem(oldAttr.nodeName);
        },
        //get real attribute name,and remove it by removeAttributeNode
        removeAttributeNS: function(namespaceURI, localName) {
          var old = this.getAttributeNodeNS(namespaceURI, localName);
          old && this.removeAttributeNode(old);
        },
        hasAttributeNS: function(namespaceURI, localName) {
          return this.getAttributeNodeNS(namespaceURI, localName) != null;
        },
        getAttributeNS: function(namespaceURI, localName) {
          var attr = this.getAttributeNodeNS(namespaceURI, localName);
          return attr && attr.value || "";
        },
        setAttributeNS: function(namespaceURI, qualifiedName, value) {
          var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr);
        },
        getAttributeNodeNS: function(namespaceURI, localName) {
          return this.attributes.getNamedItemNS(namespaceURI, localName);
        },
        getElementsByTagName: function(tagName) {
          return new LiveNodeList(this, function(base) {
            var ls = [];
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
                ls.push(node);
              }
            });
            return ls;
          });
        },
        getElementsByTagNameNS: function(namespaceURI, localName) {
          return new LiveNodeList(this, function(base) {
            var ls = [];
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
                ls.push(node);
              }
            });
            return ls;
          });
        }
      };
      Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
      Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
      _extends(Element, Node);
      function Attr() {
      }
      Attr.prototype.nodeType = ATTRIBUTE_NODE;
      _extends(Attr, Node);
      function CharacterData() {
      }
      CharacterData.prototype = {
        data: "",
        substringData: function(offset, count2) {
          return this.data.substring(offset, offset + count2);
        },
        appendData: function(text) {
          text = this.data + text;
          this.nodeValue = this.data = text;
          this.length = text.length;
        },
        insertData: function(offset, text) {
          this.replaceData(offset, 0, text);
        },
        appendChild: function(newChild) {
          throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
        },
        deleteData: function(offset, count2) {
          this.replaceData(offset, count2, "");
        },
        replaceData: function(offset, count2, text) {
          var start = this.data.substring(0, offset);
          var end = this.data.substring(offset + count2);
          text = start + text + end;
          this.nodeValue = this.data = text;
          this.length = text.length;
        }
      };
      _extends(CharacterData, Node);
      function Text2() {
      }
      Text2.prototype = {
        nodeName: "#text",
        nodeType: TEXT_NODE,
        splitText: function(offset) {
          var text = this.data;
          var newText = text.substring(offset);
          text = text.substring(0, offset);
          this.data = this.nodeValue = text;
          this.length = text.length;
          var newNode = this.ownerDocument.createTextNode(newText);
          if (this.parentNode) {
            this.parentNode.insertBefore(newNode, this.nextSibling);
          }
          return newNode;
        }
      };
      _extends(Text2, CharacterData);
      function Comment() {
      }
      Comment.prototype = {
        nodeName: "#comment",
        nodeType: COMMENT_NODE
      };
      _extends(Comment, CharacterData);
      function CDATASection() {
      }
      CDATASection.prototype = {
        nodeName: "#cdata-section",
        nodeType: CDATA_SECTION_NODE
      };
      _extends(CDATASection, CharacterData);
      function DocumentType() {
      }
      DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
      _extends(DocumentType, Node);
      function Notation() {
      }
      Notation.prototype.nodeType = NOTATION_NODE;
      _extends(Notation, Node);
      function Entity() {
      }
      Entity.prototype.nodeType = ENTITY_NODE;
      _extends(Entity, Node);
      function EntityReference() {
      }
      EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
      _extends(EntityReference, Node);
      function DocumentFragment() {
      }
      DocumentFragment.prototype.nodeName = "#document-fragment";
      DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
      _extends(DocumentFragment, Node);
      function ProcessingInstruction() {
      }
      ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
      _extends(ProcessingInstruction, Node);
      function XMLSerializer2() {
      }
      XMLSerializer2.prototype.serializeToString = function(node, isHtml, nodeFilter) {
        return nodeSerializeToString.call(node, isHtml, nodeFilter);
      };
      Node.prototype.toString = nodeSerializeToString;
      function nodeSerializeToString(isHtml, nodeFilter) {
        var buf = [];
        var refNode = this.nodeType == 9 && this.documentElement || this;
        var prefix = refNode.prefix;
        var uri = refNode.namespaceURI;
        if (uri && prefix == null) {
          var prefix = refNode.lookupPrefix(uri);
          if (prefix == null) {
            var visibleNamespaces = [
              { namespace: uri, prefix: null }
              //{namespace:uri,prefix:''}
            ];
          }
        }
        serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
        return buf.join("");
      }
      function needNamespaceDefine(node, isHTML, visibleNamespaces) {
        var prefix = node.prefix || "";
        var uri = node.namespaceURI;
        if (!uri) {
          return false;
        }
        if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
          return false;
        }
        var i3 = visibleNamespaces.length;
        while (i3--) {
          var ns = visibleNamespaces[i3];
          if (ns.prefix === prefix) {
            return ns.namespace !== uri;
          }
        }
        return true;
      }
      function addSerializedAttribute(buf, qualifiedName, value) {
        buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
      }
      function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
        if (!visibleNamespaces) {
          visibleNamespaces = [];
        }
        if (nodeFilter) {
          node = nodeFilter(node);
          if (node) {
            if (typeof node == "string") {
              buf.push(node);
              return;
            }
          } else {
            return;
          }
        }
        switch (node.nodeType) {
          case ELEMENT_NODE:
            var attrs = node.attributes;
            var len = attrs.length;
            var child = node.firstChild;
            var nodeName = node.tagName;
            isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
            var prefixedNodeName = nodeName;
            if (!isHTML && !node.prefix && node.namespaceURI) {
              var defaultNS;
              for (var ai = 0; ai < attrs.length; ai++) {
                if (attrs.item(ai).name === "xmlns") {
                  defaultNS = attrs.item(ai).value;
                  break;
                }
              }
              if (!defaultNS) {
                for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                  var namespace = visibleNamespaces[nsi];
                  if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                    defaultNS = namespace.namespace;
                    break;
                  }
                }
              }
              if (defaultNS !== node.namespaceURI) {
                for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                  var namespace = visibleNamespaces[nsi];
                  if (namespace.namespace === node.namespaceURI) {
                    if (namespace.prefix) {
                      prefixedNodeName = namespace.prefix + ":" + nodeName;
                    }
                    break;
                  }
                }
              }
            }
            buf.push("<", prefixedNodeName);
            for (var i3 = 0; i3 < len; i3++) {
              var attr = attrs.item(i3);
              if (attr.prefix == "xmlns") {
                visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
              } else if (attr.nodeName == "xmlns") {
                visibleNamespaces.push({ prefix: "", namespace: attr.value });
              }
            }
            for (var i3 = 0; i3 < len; i3++) {
              var attr = attrs.item(i3);
              if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
                var prefix = attr.prefix || "";
                var uri = attr.namespaceURI;
                addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                visibleNamespaces.push({ prefix, namespace: uri });
              }
              serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
            }
            if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
              var prefix = node.prefix || "";
              var uri = node.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
              buf.push(">");
              if (isHTML && /^script$/i.test(nodeName)) {
                while (child) {
                  if (child.data) {
                    buf.push(child.data);
                  } else {
                    serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                  }
                  child = child.nextSibling;
                }
              } else {
                while (child) {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                  child = child.nextSibling;
                }
              }
              buf.push("</", prefixedNodeName, ">");
            } else {
              buf.push("/>");
            }
            return;
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var child = node.firstChild;
            while (child) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              child = child.nextSibling;
            }
            return;
          case ATTRIBUTE_NODE:
            return addSerializedAttribute(buf, node.name, node.value);
          case TEXT_NODE:
            return buf.push(
              node.data.replace(/[<&>]/g, _xmlEncoder)
            );
          case CDATA_SECTION_NODE:
            return buf.push("<![CDATA[", node.data, "]]>");
          case COMMENT_NODE:
            return buf.push("<!--", node.data, "-->");
          case DOCUMENT_TYPE_NODE:
            var pubid = node.publicId;
            var sysid = node.systemId;
            buf.push("<!DOCTYPE ", node.name);
            if (pubid) {
              buf.push(" PUBLIC ", pubid);
              if (sysid && sysid != ".") {
                buf.push(" ", sysid);
              }
              buf.push(">");
            } else if (sysid && sysid != ".") {
              buf.push(" SYSTEM ", sysid, ">");
            } else {
              var sub = node.internalSubset;
              if (sub) {
                buf.push(" [", sub, "]");
              }
              buf.push(">");
            }
            return;
          case PROCESSING_INSTRUCTION_NODE:
            return buf.push("<?", node.target, " ", node.data, "?>");
          case ENTITY_REFERENCE_NODE:
            return buf.push("&", node.nodeName, ";");
          //case ENTITY_NODE:
          //case NOTATION_NODE:
          default:
            buf.push("??", node.nodeName);
        }
      }
      function importNode(doc, node, deep) {
        var node2;
        switch (node.nodeType) {
          case ELEMENT_NODE:
            node2 = node.cloneNode(false);
            node2.ownerDocument = doc;
          //var attrs = node2.attributes;
          //var len = attrs.length;
          //for(var i=0;i<len;i++){
          //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
          //}
          case DOCUMENT_FRAGMENT_NODE:
            break;
          case ATTRIBUTE_NODE:
            deep = true;
            break;
        }
        if (!node2) {
          node2 = node.cloneNode(false);
        }
        node2.ownerDocument = doc;
        node2.parentNode = null;
        if (deep) {
          var child = node.firstChild;
          while (child) {
            node2.appendChild(importNode(doc, child, deep));
            child = child.nextSibling;
          }
        }
        return node2;
      }
      function cloneNode(doc, node, deep) {
        var node2 = new node.constructor();
        for (var n2 in node) {
          if (Object.prototype.hasOwnProperty.call(node, n2)) {
            var v2 = node[n2];
            if (typeof v2 != "object") {
              if (v2 != node2[n2]) {
                node2[n2] = v2;
              }
            }
          }
        }
        if (node.childNodes) {
          node2.childNodes = new NodeList();
        }
        node2.ownerDocument = doc;
        switch (node2.nodeType) {
          case ELEMENT_NODE:
            var attrs = node.attributes;
            var attrs2 = node2.attributes = new NamedNodeMap();
            var len = attrs.length;
            attrs2._ownerElement = node2;
            for (var i3 = 0; i3 < len; i3++) {
              node2.setAttributeNode(cloneNode(doc, attrs.item(i3), true));
            }
            break;
            ;
          case ATTRIBUTE_NODE:
            deep = true;
        }
        if (deep) {
          var child = node.firstChild;
          while (child) {
            node2.appendChild(cloneNode(doc, child, deep));
            child = child.nextSibling;
          }
        }
        return node2;
      }
      function __set__(object, key, value) {
        object[key] = value;
      }
      try {
        if (Object.defineProperty) {
          let getTextContent2 = function(node) {
            switch (node.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                var buf = [];
                node = node.firstChild;
                while (node) {
                  if (node.nodeType !== 7 && node.nodeType !== 8) {
                    buf.push(getTextContent2(node));
                  }
                  node = node.nextSibling;
                }
                return buf.join("");
              default:
                return node.nodeValue;
            }
          };
          getTextContent = getTextContent2;
          Object.defineProperty(LiveNodeList.prototype, "length", {
            get: function() {
              _updateLiveList(this);
              return this.$length;
            }
          });
          Object.defineProperty(Node.prototype, "textContent", {
            get: function() {
              return getTextContent2(this);
            },
            set: function(data) {
              switch (this.nodeType) {
                case ELEMENT_NODE:
                case DOCUMENT_FRAGMENT_NODE:
                  while (this.firstChild) {
                    this.removeChild(this.firstChild);
                  }
                  if (data || String(data)) {
                    this.appendChild(this.ownerDocument.createTextNode(data));
                  }
                  break;
                default:
                  this.data = data;
                  this.value = data;
                  this.nodeValue = data;
              }
            }
          });
          __set__ = function(object, key, value) {
            object["$" + key] = value;
          };
        }
      } catch (e2) {
      }
      var getTextContent;
      exports.DocumentType = DocumentType;
      exports.DOMException = DOMException;
      exports.DOMImplementation = DOMImplementation;
      exports.Element = Element;
      exports.Node = Node;
      exports.NodeList = NodeList;
      exports.XMLSerializer = XMLSerializer2;
    }
  });

  // node_modules/@xmldom/xmldom/lib/entities.js
  var require_entities = __commonJS({
    "node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
      "use strict";
      var freeze = require_conventions().freeze;
      exports.XML_ENTITIES = freeze({
        amp: "&",
        apos: "'",
        gt: ">",
        lt: "<",
        quot: '"'
      });
      exports.HTML_ENTITIES = freeze({
        Aacute: "\xC1",
        aacute: "\xE1",
        Abreve: "\u0102",
        abreve: "\u0103",
        ac: "\u223E",
        acd: "\u223F",
        acE: "\u223E\u0333",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        Acy: "\u0410",
        acy: "\u0430",
        AElig: "\xC6",
        aelig: "\xE6",
        af: "\u2061",
        Afr: "\u{1D504}",
        afr: "\u{1D51E}",
        Agrave: "\xC0",
        agrave: "\xE0",
        alefsym: "\u2135",
        aleph: "\u2135",
        Alpha: "\u0391",
        alpha: "\u03B1",
        Amacr: "\u0100",
        amacr: "\u0101",
        amalg: "\u2A3F",
        AMP: "&",
        amp: "&",
        And: "\u2A53",
        and: "\u2227",
        andand: "\u2A55",
        andd: "\u2A5C",
        andslope: "\u2A58",
        andv: "\u2A5A",
        ang: "\u2220",
        ange: "\u29A4",
        angle: "\u2220",
        angmsd: "\u2221",
        angmsdaa: "\u29A8",
        angmsdab: "\u29A9",
        angmsdac: "\u29AA",
        angmsdad: "\u29AB",
        angmsdae: "\u29AC",
        angmsdaf: "\u29AD",
        angmsdag: "\u29AE",
        angmsdah: "\u29AF",
        angrt: "\u221F",
        angrtvb: "\u22BE",
        angrtvbd: "\u299D",
        angsph: "\u2222",
        angst: "\xC5",
        angzarr: "\u237C",
        Aogon: "\u0104",
        aogon: "\u0105",
        Aopf: "\u{1D538}",
        aopf: "\u{1D552}",
        ap: "\u2248",
        apacir: "\u2A6F",
        apE: "\u2A70",
        ape: "\u224A",
        apid: "\u224B",
        apos: "'",
        ApplyFunction: "\u2061",
        approx: "\u2248",
        approxeq: "\u224A",
        Aring: "\xC5",
        aring: "\xE5",
        Ascr: "\u{1D49C}",
        ascr: "\u{1D4B6}",
        Assign: "\u2254",
        ast: "*",
        asymp: "\u2248",
        asympeq: "\u224D",
        Atilde: "\xC3",
        atilde: "\xE3",
        Auml: "\xC4",
        auml: "\xE4",
        awconint: "\u2233",
        awint: "\u2A11",
        backcong: "\u224C",
        backepsilon: "\u03F6",
        backprime: "\u2035",
        backsim: "\u223D",
        backsimeq: "\u22CD",
        Backslash: "\u2216",
        Barv: "\u2AE7",
        barvee: "\u22BD",
        Barwed: "\u2306",
        barwed: "\u2305",
        barwedge: "\u2305",
        bbrk: "\u23B5",
        bbrktbrk: "\u23B6",
        bcong: "\u224C",
        Bcy: "\u0411",
        bcy: "\u0431",
        bdquo: "\u201E",
        becaus: "\u2235",
        Because: "\u2235",
        because: "\u2235",
        bemptyv: "\u29B0",
        bepsi: "\u03F6",
        bernou: "\u212C",
        Bernoullis: "\u212C",
        Beta: "\u0392",
        beta: "\u03B2",
        beth: "\u2136",
        between: "\u226C",
        Bfr: "\u{1D505}",
        bfr: "\u{1D51F}",
        bigcap: "\u22C2",
        bigcirc: "\u25EF",
        bigcup: "\u22C3",
        bigodot: "\u2A00",
        bigoplus: "\u2A01",
        bigotimes: "\u2A02",
        bigsqcup: "\u2A06",
        bigstar: "\u2605",
        bigtriangledown: "\u25BD",
        bigtriangleup: "\u25B3",
        biguplus: "\u2A04",
        bigvee: "\u22C1",
        bigwedge: "\u22C0",
        bkarow: "\u290D",
        blacklozenge: "\u29EB",
        blacksquare: "\u25AA",
        blacktriangle: "\u25B4",
        blacktriangledown: "\u25BE",
        blacktriangleleft: "\u25C2",
        blacktriangleright: "\u25B8",
        blank: "\u2423",
        blk12: "\u2592",
        blk14: "\u2591",
        blk34: "\u2593",
        block: "\u2588",
        bne: "=\u20E5",
        bnequiv: "\u2261\u20E5",
        bNot: "\u2AED",
        bnot: "\u2310",
        Bopf: "\u{1D539}",
        bopf: "\u{1D553}",
        bot: "\u22A5",
        bottom: "\u22A5",
        bowtie: "\u22C8",
        boxbox: "\u29C9",
        boxDL: "\u2557",
        boxDl: "\u2556",
        boxdL: "\u2555",
        boxdl: "\u2510",
        boxDR: "\u2554",
        boxDr: "\u2553",
        boxdR: "\u2552",
        boxdr: "\u250C",
        boxH: "\u2550",
        boxh: "\u2500",
        boxHD: "\u2566",
        boxHd: "\u2564",
        boxhD: "\u2565",
        boxhd: "\u252C",
        boxHU: "\u2569",
        boxHu: "\u2567",
        boxhU: "\u2568",
        boxhu: "\u2534",
        boxminus: "\u229F",
        boxplus: "\u229E",
        boxtimes: "\u22A0",
        boxUL: "\u255D",
        boxUl: "\u255C",
        boxuL: "\u255B",
        boxul: "\u2518",
        boxUR: "\u255A",
        boxUr: "\u2559",
        boxuR: "\u2558",
        boxur: "\u2514",
        boxV: "\u2551",
        boxv: "\u2502",
        boxVH: "\u256C",
        boxVh: "\u256B",
        boxvH: "\u256A",
        boxvh: "\u253C",
        boxVL: "\u2563",
        boxVl: "\u2562",
        boxvL: "\u2561",
        boxvl: "\u2524",
        boxVR: "\u2560",
        boxVr: "\u255F",
        boxvR: "\u255E",
        boxvr: "\u251C",
        bprime: "\u2035",
        Breve: "\u02D8",
        breve: "\u02D8",
        brvbar: "\xA6",
        Bscr: "\u212C",
        bscr: "\u{1D4B7}",
        bsemi: "\u204F",
        bsim: "\u223D",
        bsime: "\u22CD",
        bsol: "\\",
        bsolb: "\u29C5",
        bsolhsub: "\u27C8",
        bull: "\u2022",
        bullet: "\u2022",
        bump: "\u224E",
        bumpE: "\u2AAE",
        bumpe: "\u224F",
        Bumpeq: "\u224E",
        bumpeq: "\u224F",
        Cacute: "\u0106",
        cacute: "\u0107",
        Cap: "\u22D2",
        cap: "\u2229",
        capand: "\u2A44",
        capbrcup: "\u2A49",
        capcap: "\u2A4B",
        capcup: "\u2A47",
        capdot: "\u2A40",
        CapitalDifferentialD: "\u2145",
        caps: "\u2229\uFE00",
        caret: "\u2041",
        caron: "\u02C7",
        Cayleys: "\u212D",
        ccaps: "\u2A4D",
        Ccaron: "\u010C",
        ccaron: "\u010D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        Ccirc: "\u0108",
        ccirc: "\u0109",
        Cconint: "\u2230",
        ccups: "\u2A4C",
        ccupssm: "\u2A50",
        Cdot: "\u010A",
        cdot: "\u010B",
        cedil: "\xB8",
        Cedilla: "\xB8",
        cemptyv: "\u29B2",
        cent: "\xA2",
        CenterDot: "\xB7",
        centerdot: "\xB7",
        Cfr: "\u212D",
        cfr: "\u{1D520}",
        CHcy: "\u0427",
        chcy: "\u0447",
        check: "\u2713",
        checkmark: "\u2713",
        Chi: "\u03A7",
        chi: "\u03C7",
        cir: "\u25CB",
        circ: "\u02C6",
        circeq: "\u2257",
        circlearrowleft: "\u21BA",
        circlearrowright: "\u21BB",
        circledast: "\u229B",
        circledcirc: "\u229A",
        circleddash: "\u229D",
        CircleDot: "\u2299",
        circledR: "\xAE",
        circledS: "\u24C8",
        CircleMinus: "\u2296",
        CirclePlus: "\u2295",
        CircleTimes: "\u2297",
        cirE: "\u29C3",
        cire: "\u2257",
        cirfnint: "\u2A10",
        cirmid: "\u2AEF",
        cirscir: "\u29C2",
        ClockwiseContourIntegral: "\u2232",
        CloseCurlyDoubleQuote: "\u201D",
        CloseCurlyQuote: "\u2019",
        clubs: "\u2663",
        clubsuit: "\u2663",
        Colon: "\u2237",
        colon: ":",
        Colone: "\u2A74",
        colone: "\u2254",
        coloneq: "\u2254",
        comma: ",",
        commat: "@",
        comp: "\u2201",
        compfn: "\u2218",
        complement: "\u2201",
        complexes: "\u2102",
        cong: "\u2245",
        congdot: "\u2A6D",
        Congruent: "\u2261",
        Conint: "\u222F",
        conint: "\u222E",
        ContourIntegral: "\u222E",
        Copf: "\u2102",
        copf: "\u{1D554}",
        coprod: "\u2210",
        Coproduct: "\u2210",
        COPY: "\xA9",
        copy: "\xA9",
        copysr: "\u2117",
        CounterClockwiseContourIntegral: "\u2233",
        crarr: "\u21B5",
        Cross: "\u2A2F",
        cross: "\u2717",
        Cscr: "\u{1D49E}",
        cscr: "\u{1D4B8}",
        csub: "\u2ACF",
        csube: "\u2AD1",
        csup: "\u2AD0",
        csupe: "\u2AD2",
        ctdot: "\u22EF",
        cudarrl: "\u2938",
        cudarrr: "\u2935",
        cuepr: "\u22DE",
        cuesc: "\u22DF",
        cularr: "\u21B6",
        cularrp: "\u293D",
        Cup: "\u22D3",
        cup: "\u222A",
        cupbrcap: "\u2A48",
        CupCap: "\u224D",
        cupcap: "\u2A46",
        cupcup: "\u2A4A",
        cupdot: "\u228D",
        cupor: "\u2A45",
        cups: "\u222A\uFE00",
        curarr: "\u21B7",
        curarrm: "\u293C",
        curlyeqprec: "\u22DE",
        curlyeqsucc: "\u22DF",
        curlyvee: "\u22CE",
        curlywedge: "\u22CF",
        curren: "\xA4",
        curvearrowleft: "\u21B6",
        curvearrowright: "\u21B7",
        cuvee: "\u22CE",
        cuwed: "\u22CF",
        cwconint: "\u2232",
        cwint: "\u2231",
        cylcty: "\u232D",
        Dagger: "\u2021",
        dagger: "\u2020",
        daleth: "\u2138",
        Darr: "\u21A1",
        dArr: "\u21D3",
        darr: "\u2193",
        dash: "\u2010",
        Dashv: "\u2AE4",
        dashv: "\u22A3",
        dbkarow: "\u290F",
        dblac: "\u02DD",
        Dcaron: "\u010E",
        dcaron: "\u010F",
        Dcy: "\u0414",
        dcy: "\u0434",
        DD: "\u2145",
        dd: "\u2146",
        ddagger: "\u2021",
        ddarr: "\u21CA",
        DDotrahd: "\u2911",
        ddotseq: "\u2A77",
        deg: "\xB0",
        Del: "\u2207",
        Delta: "\u0394",
        delta: "\u03B4",
        demptyv: "\u29B1",
        dfisht: "\u297F",
        Dfr: "\u{1D507}",
        dfr: "\u{1D521}",
        dHar: "\u2965",
        dharl: "\u21C3",
        dharr: "\u21C2",
        DiacriticalAcute: "\xB4",
        DiacriticalDot: "\u02D9",
        DiacriticalDoubleAcute: "\u02DD",
        DiacriticalGrave: "`",
        DiacriticalTilde: "\u02DC",
        diam: "\u22C4",
        Diamond: "\u22C4",
        diamond: "\u22C4",
        diamondsuit: "\u2666",
        diams: "\u2666",
        die: "\xA8",
        DifferentialD: "\u2146",
        digamma: "\u03DD",
        disin: "\u22F2",
        div: "\xF7",
        divide: "\xF7",
        divideontimes: "\u22C7",
        divonx: "\u22C7",
        DJcy: "\u0402",
        djcy: "\u0452",
        dlcorn: "\u231E",
        dlcrop: "\u230D",
        dollar: "$",
        Dopf: "\u{1D53B}",
        dopf: "\u{1D555}",
        Dot: "\xA8",
        dot: "\u02D9",
        DotDot: "\u20DC",
        doteq: "\u2250",
        doteqdot: "\u2251",
        DotEqual: "\u2250",
        dotminus: "\u2238",
        dotplus: "\u2214",
        dotsquare: "\u22A1",
        doublebarwedge: "\u2306",
        DoubleContourIntegral: "\u222F",
        DoubleDot: "\xA8",
        DoubleDownArrow: "\u21D3",
        DoubleLeftArrow: "\u21D0",
        DoubleLeftRightArrow: "\u21D4",
        DoubleLeftTee: "\u2AE4",
        DoubleLongLeftArrow: "\u27F8",
        DoubleLongLeftRightArrow: "\u27FA",
        DoubleLongRightArrow: "\u27F9",
        DoubleRightArrow: "\u21D2",
        DoubleRightTee: "\u22A8",
        DoubleUpArrow: "\u21D1",
        DoubleUpDownArrow: "\u21D5",
        DoubleVerticalBar: "\u2225",
        DownArrow: "\u2193",
        Downarrow: "\u21D3",
        downarrow: "\u2193",
        DownArrowBar: "\u2913",
        DownArrowUpArrow: "\u21F5",
        DownBreve: "\u0311",
        downdownarrows: "\u21CA",
        downharpoonleft: "\u21C3",
        downharpoonright: "\u21C2",
        DownLeftRightVector: "\u2950",
        DownLeftTeeVector: "\u295E",
        DownLeftVector: "\u21BD",
        DownLeftVectorBar: "\u2956",
        DownRightTeeVector: "\u295F",
        DownRightVector: "\u21C1",
        DownRightVectorBar: "\u2957",
        DownTee: "\u22A4",
        DownTeeArrow: "\u21A7",
        drbkarow: "\u2910",
        drcorn: "\u231F",
        drcrop: "\u230C",
        Dscr: "\u{1D49F}",
        dscr: "\u{1D4B9}",
        DScy: "\u0405",
        dscy: "\u0455",
        dsol: "\u29F6",
        Dstrok: "\u0110",
        dstrok: "\u0111",
        dtdot: "\u22F1",
        dtri: "\u25BF",
        dtrif: "\u25BE",
        duarr: "\u21F5",
        duhar: "\u296F",
        dwangle: "\u29A6",
        DZcy: "\u040F",
        dzcy: "\u045F",
        dzigrarr: "\u27FF",
        Eacute: "\xC9",
        eacute: "\xE9",
        easter: "\u2A6E",
        Ecaron: "\u011A",
        ecaron: "\u011B",
        ecir: "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        ecolon: "\u2255",
        Ecy: "\u042D",
        ecy: "\u044D",
        eDDot: "\u2A77",
        Edot: "\u0116",
        eDot: "\u2251",
        edot: "\u0117",
        ee: "\u2147",
        efDot: "\u2252",
        Efr: "\u{1D508}",
        efr: "\u{1D522}",
        eg: "\u2A9A",
        Egrave: "\xC8",
        egrave: "\xE8",
        egs: "\u2A96",
        egsdot: "\u2A98",
        el: "\u2A99",
        Element: "\u2208",
        elinters: "\u23E7",
        ell: "\u2113",
        els: "\u2A95",
        elsdot: "\u2A97",
        Emacr: "\u0112",
        emacr: "\u0113",
        empty: "\u2205",
        emptyset: "\u2205",
        EmptySmallSquare: "\u25FB",
        emptyv: "\u2205",
        EmptyVerySmallSquare: "\u25AB",
        emsp: "\u2003",
        emsp13: "\u2004",
        emsp14: "\u2005",
        ENG: "\u014A",
        eng: "\u014B",
        ensp: "\u2002",
        Eogon: "\u0118",
        eogon: "\u0119",
        Eopf: "\u{1D53C}",
        eopf: "\u{1D556}",
        epar: "\u22D5",
        eparsl: "\u29E3",
        eplus: "\u2A71",
        epsi: "\u03B5",
        Epsilon: "\u0395",
        epsilon: "\u03B5",
        epsiv: "\u03F5",
        eqcirc: "\u2256",
        eqcolon: "\u2255",
        eqsim: "\u2242",
        eqslantgtr: "\u2A96",
        eqslantless: "\u2A95",
        Equal: "\u2A75",
        equals: "=",
        EqualTilde: "\u2242",
        equest: "\u225F",
        Equilibrium: "\u21CC",
        equiv: "\u2261",
        equivDD: "\u2A78",
        eqvparsl: "\u29E5",
        erarr: "\u2971",
        erDot: "\u2253",
        Escr: "\u2130",
        escr: "\u212F",
        esdot: "\u2250",
        Esim: "\u2A73",
        esim: "\u2242",
        Eta: "\u0397",
        eta: "\u03B7",
        ETH: "\xD0",
        eth: "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        euro: "\u20AC",
        excl: "!",
        exist: "\u2203",
        Exists: "\u2203",
        expectation: "\u2130",
        ExponentialE: "\u2147",
        exponentiale: "\u2147",
        fallingdotseq: "\u2252",
        Fcy: "\u0424",
        fcy: "\u0444",
        female: "\u2640",
        ffilig: "\uFB03",
        fflig: "\uFB00",
        ffllig: "\uFB04",
        Ffr: "\u{1D509}",
        ffr: "\u{1D523}",
        filig: "\uFB01",
        FilledSmallSquare: "\u25FC",
        FilledVerySmallSquare: "\u25AA",
        fjlig: "fj",
        flat: "\u266D",
        fllig: "\uFB02",
        fltns: "\u25B1",
        fnof: "\u0192",
        Fopf: "\u{1D53D}",
        fopf: "\u{1D557}",
        ForAll: "\u2200",
        forall: "\u2200",
        fork: "\u22D4",
        forkv: "\u2AD9",
        Fouriertrf: "\u2131",
        fpartint: "\u2A0D",
        frac12: "\xBD",
        frac13: "\u2153",
        frac14: "\xBC",
        frac15: "\u2155",
        frac16: "\u2159",
        frac18: "\u215B",
        frac23: "\u2154",
        frac25: "\u2156",
        frac34: "\xBE",
        frac35: "\u2157",
        frac38: "\u215C",
        frac45: "\u2158",
        frac56: "\u215A",
        frac58: "\u215D",
        frac78: "\u215E",
        frasl: "\u2044",
        frown: "\u2322",
        Fscr: "\u2131",
        fscr: "\u{1D4BB}",
        gacute: "\u01F5",
        Gamma: "\u0393",
        gamma: "\u03B3",
        Gammad: "\u03DC",
        gammad: "\u03DD",
        gap: "\u2A86",
        Gbreve: "\u011E",
        gbreve: "\u011F",
        Gcedil: "\u0122",
        Gcirc: "\u011C",
        gcirc: "\u011D",
        Gcy: "\u0413",
        gcy: "\u0433",
        Gdot: "\u0120",
        gdot: "\u0121",
        gE: "\u2267",
        ge: "\u2265",
        gEl: "\u2A8C",
        gel: "\u22DB",
        geq: "\u2265",
        geqq: "\u2267",
        geqslant: "\u2A7E",
        ges: "\u2A7E",
        gescc: "\u2AA9",
        gesdot: "\u2A80",
        gesdoto: "\u2A82",
        gesdotol: "\u2A84",
        gesl: "\u22DB\uFE00",
        gesles: "\u2A94",
        Gfr: "\u{1D50A}",
        gfr: "\u{1D524}",
        Gg: "\u22D9",
        gg: "\u226B",
        ggg: "\u22D9",
        gimel: "\u2137",
        GJcy: "\u0403",
        gjcy: "\u0453",
        gl: "\u2277",
        gla: "\u2AA5",
        glE: "\u2A92",
        glj: "\u2AA4",
        gnap: "\u2A8A",
        gnapprox: "\u2A8A",
        gnE: "\u2269",
        gne: "\u2A88",
        gneq: "\u2A88",
        gneqq: "\u2269",
        gnsim: "\u22E7",
        Gopf: "\u{1D53E}",
        gopf: "\u{1D558}",
        grave: "`",
        GreaterEqual: "\u2265",
        GreaterEqualLess: "\u22DB",
        GreaterFullEqual: "\u2267",
        GreaterGreater: "\u2AA2",
        GreaterLess: "\u2277",
        GreaterSlantEqual: "\u2A7E",
        GreaterTilde: "\u2273",
        Gscr: "\u{1D4A2}",
        gscr: "\u210A",
        gsim: "\u2273",
        gsime: "\u2A8E",
        gsiml: "\u2A90",
        Gt: "\u226B",
        GT: ">",
        gt: ">",
        gtcc: "\u2AA7",
        gtcir: "\u2A7A",
        gtdot: "\u22D7",
        gtlPar: "\u2995",
        gtquest: "\u2A7C",
        gtrapprox: "\u2A86",
        gtrarr: "\u2978",
        gtrdot: "\u22D7",
        gtreqless: "\u22DB",
        gtreqqless: "\u2A8C",
        gtrless: "\u2277",
        gtrsim: "\u2273",
        gvertneqq: "\u2269\uFE00",
        gvnE: "\u2269\uFE00",
        Hacek: "\u02C7",
        hairsp: "\u200A",
        half: "\xBD",
        hamilt: "\u210B",
        HARDcy: "\u042A",
        hardcy: "\u044A",
        hArr: "\u21D4",
        harr: "\u2194",
        harrcir: "\u2948",
        harrw: "\u21AD",
        Hat: "^",
        hbar: "\u210F",
        Hcirc: "\u0124",
        hcirc: "\u0125",
        hearts: "\u2665",
        heartsuit: "\u2665",
        hellip: "\u2026",
        hercon: "\u22B9",
        Hfr: "\u210C",
        hfr: "\u{1D525}",
        HilbertSpace: "\u210B",
        hksearow: "\u2925",
        hkswarow: "\u2926",
        hoarr: "\u21FF",
        homtht: "\u223B",
        hookleftarrow: "\u21A9",
        hookrightarrow: "\u21AA",
        Hopf: "\u210D",
        hopf: "\u{1D559}",
        horbar: "\u2015",
        HorizontalLine: "\u2500",
        Hscr: "\u210B",
        hscr: "\u{1D4BD}",
        hslash: "\u210F",
        Hstrok: "\u0126",
        hstrok: "\u0127",
        HumpDownHump: "\u224E",
        HumpEqual: "\u224F",
        hybull: "\u2043",
        hyphen: "\u2010",
        Iacute: "\xCD",
        iacute: "\xED",
        ic: "\u2063",
        Icirc: "\xCE",
        icirc: "\xEE",
        Icy: "\u0418",
        icy: "\u0438",
        Idot: "\u0130",
        IEcy: "\u0415",
        iecy: "\u0435",
        iexcl: "\xA1",
        iff: "\u21D4",
        Ifr: "\u2111",
        ifr: "\u{1D526}",
        Igrave: "\xCC",
        igrave: "\xEC",
        ii: "\u2148",
        iiiint: "\u2A0C",
        iiint: "\u222D",
        iinfin: "\u29DC",
        iiota: "\u2129",
        IJlig: "\u0132",
        ijlig: "\u0133",
        Im: "\u2111",
        Imacr: "\u012A",
        imacr: "\u012B",
        image: "\u2111",
        ImaginaryI: "\u2148",
        imagline: "\u2110",
        imagpart: "\u2111",
        imath: "\u0131",
        imof: "\u22B7",
        imped: "\u01B5",
        Implies: "\u21D2",
        in: "\u2208",
        incare: "\u2105",
        infin: "\u221E",
        infintie: "\u29DD",
        inodot: "\u0131",
        Int: "\u222C",
        int: "\u222B",
        intcal: "\u22BA",
        integers: "\u2124",
        Integral: "\u222B",
        intercal: "\u22BA",
        Intersection: "\u22C2",
        intlarhk: "\u2A17",
        intprod: "\u2A3C",
        InvisibleComma: "\u2063",
        InvisibleTimes: "\u2062",
        IOcy: "\u0401",
        iocy: "\u0451",
        Iogon: "\u012E",
        iogon: "\u012F",
        Iopf: "\u{1D540}",
        iopf: "\u{1D55A}",
        Iota: "\u0399",
        iota: "\u03B9",
        iprod: "\u2A3C",
        iquest: "\xBF",
        Iscr: "\u2110",
        iscr: "\u{1D4BE}",
        isin: "\u2208",
        isindot: "\u22F5",
        isinE: "\u22F9",
        isins: "\u22F4",
        isinsv: "\u22F3",
        isinv: "\u2208",
        it: "\u2062",
        Itilde: "\u0128",
        itilde: "\u0129",
        Iukcy: "\u0406",
        iukcy: "\u0456",
        Iuml: "\xCF",
        iuml: "\xEF",
        Jcirc: "\u0134",
        jcirc: "\u0135",
        Jcy: "\u0419",
        jcy: "\u0439",
        Jfr: "\u{1D50D}",
        jfr: "\u{1D527}",
        jmath: "\u0237",
        Jopf: "\u{1D541}",
        jopf: "\u{1D55B}",
        Jscr: "\u{1D4A5}",
        jscr: "\u{1D4BF}",
        Jsercy: "\u0408",
        jsercy: "\u0458",
        Jukcy: "\u0404",
        jukcy: "\u0454",
        Kappa: "\u039A",
        kappa: "\u03BA",
        kappav: "\u03F0",
        Kcedil: "\u0136",
        kcedil: "\u0137",
        Kcy: "\u041A",
        kcy: "\u043A",
        Kfr: "\u{1D50E}",
        kfr: "\u{1D528}",
        kgreen: "\u0138",
        KHcy: "\u0425",
        khcy: "\u0445",
        KJcy: "\u040C",
        kjcy: "\u045C",
        Kopf: "\u{1D542}",
        kopf: "\u{1D55C}",
        Kscr: "\u{1D4A6}",
        kscr: "\u{1D4C0}",
        lAarr: "\u21DA",
        Lacute: "\u0139",
        lacute: "\u013A",
        laemptyv: "\u29B4",
        lagran: "\u2112",
        Lambda: "\u039B",
        lambda: "\u03BB",
        Lang: "\u27EA",
        lang: "\u27E8",
        langd: "\u2991",
        langle: "\u27E8",
        lap: "\u2A85",
        Laplacetrf: "\u2112",
        laquo: "\xAB",
        Larr: "\u219E",
        lArr: "\u21D0",
        larr: "\u2190",
        larrb: "\u21E4",
        larrbfs: "\u291F",
        larrfs: "\u291D",
        larrhk: "\u21A9",
        larrlp: "\u21AB",
        larrpl: "\u2939",
        larrsim: "\u2973",
        larrtl: "\u21A2",
        lat: "\u2AAB",
        lAtail: "\u291B",
        latail: "\u2919",
        late: "\u2AAD",
        lates: "\u2AAD\uFE00",
        lBarr: "\u290E",
        lbarr: "\u290C",
        lbbrk: "\u2772",
        lbrace: "{",
        lbrack: "[",
        lbrke: "\u298B",
        lbrksld: "\u298F",
        lbrkslu: "\u298D",
        Lcaron: "\u013D",
        lcaron: "\u013E",
        Lcedil: "\u013B",
        lcedil: "\u013C",
        lceil: "\u2308",
        lcub: "{",
        Lcy: "\u041B",
        lcy: "\u043B",
        ldca: "\u2936",
        ldquo: "\u201C",
        ldquor: "\u201E",
        ldrdhar: "\u2967",
        ldrushar: "\u294B",
        ldsh: "\u21B2",
        lE: "\u2266",
        le: "\u2264",
        LeftAngleBracket: "\u27E8",
        LeftArrow: "\u2190",
        Leftarrow: "\u21D0",
        leftarrow: "\u2190",
        LeftArrowBar: "\u21E4",
        LeftArrowRightArrow: "\u21C6",
        leftarrowtail: "\u21A2",
        LeftCeiling: "\u2308",
        LeftDoubleBracket: "\u27E6",
        LeftDownTeeVector: "\u2961",
        LeftDownVector: "\u21C3",
        LeftDownVectorBar: "\u2959",
        LeftFloor: "\u230A",
        leftharpoondown: "\u21BD",
        leftharpoonup: "\u21BC",
        leftleftarrows: "\u21C7",
        LeftRightArrow: "\u2194",
        Leftrightarrow: "\u21D4",
        leftrightarrow: "\u2194",
        leftrightarrows: "\u21C6",
        leftrightharpoons: "\u21CB",
        leftrightsquigarrow: "\u21AD",
        LeftRightVector: "\u294E",
        LeftTee: "\u22A3",
        LeftTeeArrow: "\u21A4",
        LeftTeeVector: "\u295A",
        leftthreetimes: "\u22CB",
        LeftTriangle: "\u22B2",
        LeftTriangleBar: "\u29CF",
        LeftTriangleEqual: "\u22B4",
        LeftUpDownVector: "\u2951",
        LeftUpTeeVector: "\u2960",
        LeftUpVector: "\u21BF",
        LeftUpVectorBar: "\u2958",
        LeftVector: "\u21BC",
        LeftVectorBar: "\u2952",
        lEg: "\u2A8B",
        leg: "\u22DA",
        leq: "\u2264",
        leqq: "\u2266",
        leqslant: "\u2A7D",
        les: "\u2A7D",
        lescc: "\u2AA8",
        lesdot: "\u2A7F",
        lesdoto: "\u2A81",
        lesdotor: "\u2A83",
        lesg: "\u22DA\uFE00",
        lesges: "\u2A93",
        lessapprox: "\u2A85",
        lessdot: "\u22D6",
        lesseqgtr: "\u22DA",
        lesseqqgtr: "\u2A8B",
        LessEqualGreater: "\u22DA",
        LessFullEqual: "\u2266",
        LessGreater: "\u2276",
        lessgtr: "\u2276",
        LessLess: "\u2AA1",
        lesssim: "\u2272",
        LessSlantEqual: "\u2A7D",
        LessTilde: "\u2272",
        lfisht: "\u297C",
        lfloor: "\u230A",
        Lfr: "\u{1D50F}",
        lfr: "\u{1D529}",
        lg: "\u2276",
        lgE: "\u2A91",
        lHar: "\u2962",
        lhard: "\u21BD",
        lharu: "\u21BC",
        lharul: "\u296A",
        lhblk: "\u2584",
        LJcy: "\u0409",
        ljcy: "\u0459",
        Ll: "\u22D8",
        ll: "\u226A",
        llarr: "\u21C7",
        llcorner: "\u231E",
        Lleftarrow: "\u21DA",
        llhard: "\u296B",
        lltri: "\u25FA",
        Lmidot: "\u013F",
        lmidot: "\u0140",
        lmoust: "\u23B0",
        lmoustache: "\u23B0",
        lnap: "\u2A89",
        lnapprox: "\u2A89",
        lnE: "\u2268",
        lne: "\u2A87",
        lneq: "\u2A87",
        lneqq: "\u2268",
        lnsim: "\u22E6",
        loang: "\u27EC",
        loarr: "\u21FD",
        lobrk: "\u27E6",
        LongLeftArrow: "\u27F5",
        Longleftarrow: "\u27F8",
        longleftarrow: "\u27F5",
        LongLeftRightArrow: "\u27F7",
        Longleftrightarrow: "\u27FA",
        longleftrightarrow: "\u27F7",
        longmapsto: "\u27FC",
        LongRightArrow: "\u27F6",
        Longrightarrow: "\u27F9",
        longrightarrow: "\u27F6",
        looparrowleft: "\u21AB",
        looparrowright: "\u21AC",
        lopar: "\u2985",
        Lopf: "\u{1D543}",
        lopf: "\u{1D55D}",
        loplus: "\u2A2D",
        lotimes: "\u2A34",
        lowast: "\u2217",
        lowbar: "_",
        LowerLeftArrow: "\u2199",
        LowerRightArrow: "\u2198",
        loz: "\u25CA",
        lozenge: "\u25CA",
        lozf: "\u29EB",
        lpar: "(",
        lparlt: "\u2993",
        lrarr: "\u21C6",
        lrcorner: "\u231F",
        lrhar: "\u21CB",
        lrhard: "\u296D",
        lrm: "\u200E",
        lrtri: "\u22BF",
        lsaquo: "\u2039",
        Lscr: "\u2112",
        lscr: "\u{1D4C1}",
        Lsh: "\u21B0",
        lsh: "\u21B0",
        lsim: "\u2272",
        lsime: "\u2A8D",
        lsimg: "\u2A8F",
        lsqb: "[",
        lsquo: "\u2018",
        lsquor: "\u201A",
        Lstrok: "\u0141",
        lstrok: "\u0142",
        Lt: "\u226A",
        LT: "<",
        lt: "<",
        ltcc: "\u2AA6",
        ltcir: "\u2A79",
        ltdot: "\u22D6",
        lthree: "\u22CB",
        ltimes: "\u22C9",
        ltlarr: "\u2976",
        ltquest: "\u2A7B",
        ltri: "\u25C3",
        ltrie: "\u22B4",
        ltrif: "\u25C2",
        ltrPar: "\u2996",
        lurdshar: "\u294A",
        luruhar: "\u2966",
        lvertneqq: "\u2268\uFE00",
        lvnE: "\u2268\uFE00",
        macr: "\xAF",
        male: "\u2642",
        malt: "\u2720",
        maltese: "\u2720",
        Map: "\u2905",
        map: "\u21A6",
        mapsto: "\u21A6",
        mapstodown: "\u21A7",
        mapstoleft: "\u21A4",
        mapstoup: "\u21A5",
        marker: "\u25AE",
        mcomma: "\u2A29",
        Mcy: "\u041C",
        mcy: "\u043C",
        mdash: "\u2014",
        mDDot: "\u223A",
        measuredangle: "\u2221",
        MediumSpace: "\u205F",
        Mellintrf: "\u2133",
        Mfr: "\u{1D510}",
        mfr: "\u{1D52A}",
        mho: "\u2127",
        micro: "\xB5",
        mid: "\u2223",
        midast: "*",
        midcir: "\u2AF0",
        middot: "\xB7",
        minus: "\u2212",
        minusb: "\u229F",
        minusd: "\u2238",
        minusdu: "\u2A2A",
        MinusPlus: "\u2213",
        mlcp: "\u2ADB",
        mldr: "\u2026",
        mnplus: "\u2213",
        models: "\u22A7",
        Mopf: "\u{1D544}",
        mopf: "\u{1D55E}",
        mp: "\u2213",
        Mscr: "\u2133",
        mscr: "\u{1D4C2}",
        mstpos: "\u223E",
        Mu: "\u039C",
        mu: "\u03BC",
        multimap: "\u22B8",
        mumap: "\u22B8",
        nabla: "\u2207",
        Nacute: "\u0143",
        nacute: "\u0144",
        nang: "\u2220\u20D2",
        nap: "\u2249",
        napE: "\u2A70\u0338",
        napid: "\u224B\u0338",
        napos: "\u0149",
        napprox: "\u2249",
        natur: "\u266E",
        natural: "\u266E",
        naturals: "\u2115",
        nbsp: "\xA0",
        nbump: "\u224E\u0338",
        nbumpe: "\u224F\u0338",
        ncap: "\u2A43",
        Ncaron: "\u0147",
        ncaron: "\u0148",
        Ncedil: "\u0145",
        ncedil: "\u0146",
        ncong: "\u2247",
        ncongdot: "\u2A6D\u0338",
        ncup: "\u2A42",
        Ncy: "\u041D",
        ncy: "\u043D",
        ndash: "\u2013",
        ne: "\u2260",
        nearhk: "\u2924",
        neArr: "\u21D7",
        nearr: "\u2197",
        nearrow: "\u2197",
        nedot: "\u2250\u0338",
        NegativeMediumSpace: "\u200B",
        NegativeThickSpace: "\u200B",
        NegativeThinSpace: "\u200B",
        NegativeVeryThinSpace: "\u200B",
        nequiv: "\u2262",
        nesear: "\u2928",
        nesim: "\u2242\u0338",
        NestedGreaterGreater: "\u226B",
        NestedLessLess: "\u226A",
        NewLine: "\n",
        nexist: "\u2204",
        nexists: "\u2204",
        Nfr: "\u{1D511}",
        nfr: "\u{1D52B}",
        ngE: "\u2267\u0338",
        nge: "\u2271",
        ngeq: "\u2271",
        ngeqq: "\u2267\u0338",
        ngeqslant: "\u2A7E\u0338",
        nges: "\u2A7E\u0338",
        nGg: "\u22D9\u0338",
        ngsim: "\u2275",
        nGt: "\u226B\u20D2",
        ngt: "\u226F",
        ngtr: "\u226F",
        nGtv: "\u226B\u0338",
        nhArr: "\u21CE",
        nharr: "\u21AE",
        nhpar: "\u2AF2",
        ni: "\u220B",
        nis: "\u22FC",
        nisd: "\u22FA",
        niv: "\u220B",
        NJcy: "\u040A",
        njcy: "\u045A",
        nlArr: "\u21CD",
        nlarr: "\u219A",
        nldr: "\u2025",
        nlE: "\u2266\u0338",
        nle: "\u2270",
        nLeftarrow: "\u21CD",
        nleftarrow: "\u219A",
        nLeftrightarrow: "\u21CE",
        nleftrightarrow: "\u21AE",
        nleq: "\u2270",
        nleqq: "\u2266\u0338",
        nleqslant: "\u2A7D\u0338",
        nles: "\u2A7D\u0338",
        nless: "\u226E",
        nLl: "\u22D8\u0338",
        nlsim: "\u2274",
        nLt: "\u226A\u20D2",
        nlt: "\u226E",
        nltri: "\u22EA",
        nltrie: "\u22EC",
        nLtv: "\u226A\u0338",
        nmid: "\u2224",
        NoBreak: "\u2060",
        NonBreakingSpace: "\xA0",
        Nopf: "\u2115",
        nopf: "\u{1D55F}",
        Not: "\u2AEC",
        not: "\xAC",
        NotCongruent: "\u2262",
        NotCupCap: "\u226D",
        NotDoubleVerticalBar: "\u2226",
        NotElement: "\u2209",
        NotEqual: "\u2260",
        NotEqualTilde: "\u2242\u0338",
        NotExists: "\u2204",
        NotGreater: "\u226F",
        NotGreaterEqual: "\u2271",
        NotGreaterFullEqual: "\u2267\u0338",
        NotGreaterGreater: "\u226B\u0338",
        NotGreaterLess: "\u2279",
        NotGreaterSlantEqual: "\u2A7E\u0338",
        NotGreaterTilde: "\u2275",
        NotHumpDownHump: "\u224E\u0338",
        NotHumpEqual: "\u224F\u0338",
        notin: "\u2209",
        notindot: "\u22F5\u0338",
        notinE: "\u22F9\u0338",
        notinva: "\u2209",
        notinvb: "\u22F7",
        notinvc: "\u22F6",
        NotLeftTriangle: "\u22EA",
        NotLeftTriangleBar: "\u29CF\u0338",
        NotLeftTriangleEqual: "\u22EC",
        NotLess: "\u226E",
        NotLessEqual: "\u2270",
        NotLessGreater: "\u2278",
        NotLessLess: "\u226A\u0338",
        NotLessSlantEqual: "\u2A7D\u0338",
        NotLessTilde: "\u2274",
        NotNestedGreaterGreater: "\u2AA2\u0338",
        NotNestedLessLess: "\u2AA1\u0338",
        notni: "\u220C",
        notniva: "\u220C",
        notnivb: "\u22FE",
        notnivc: "\u22FD",
        NotPrecedes: "\u2280",
        NotPrecedesEqual: "\u2AAF\u0338",
        NotPrecedesSlantEqual: "\u22E0",
        NotReverseElement: "\u220C",
        NotRightTriangle: "\u22EB",
        NotRightTriangleBar: "\u29D0\u0338",
        NotRightTriangleEqual: "\u22ED",
        NotSquareSubset: "\u228F\u0338",
        NotSquareSubsetEqual: "\u22E2",
        NotSquareSuperset: "\u2290\u0338",
        NotSquareSupersetEqual: "\u22E3",
        NotSubset: "\u2282\u20D2",
        NotSubsetEqual: "\u2288",
        NotSucceeds: "\u2281",
        NotSucceedsEqual: "\u2AB0\u0338",
        NotSucceedsSlantEqual: "\u22E1",
        NotSucceedsTilde: "\u227F\u0338",
        NotSuperset: "\u2283\u20D2",
        NotSupersetEqual: "\u2289",
        NotTilde: "\u2241",
        NotTildeEqual: "\u2244",
        NotTildeFullEqual: "\u2247",
        NotTildeTilde: "\u2249",
        NotVerticalBar: "\u2224",
        npar: "\u2226",
        nparallel: "\u2226",
        nparsl: "\u2AFD\u20E5",
        npart: "\u2202\u0338",
        npolint: "\u2A14",
        npr: "\u2280",
        nprcue: "\u22E0",
        npre: "\u2AAF\u0338",
        nprec: "\u2280",
        npreceq: "\u2AAF\u0338",
        nrArr: "\u21CF",
        nrarr: "\u219B",
        nrarrc: "\u2933\u0338",
        nrarrw: "\u219D\u0338",
        nRightarrow: "\u21CF",
        nrightarrow: "\u219B",
        nrtri: "\u22EB",
        nrtrie: "\u22ED",
        nsc: "\u2281",
        nsccue: "\u22E1",
        nsce: "\u2AB0\u0338",
        Nscr: "\u{1D4A9}",
        nscr: "\u{1D4C3}",
        nshortmid: "\u2224",
        nshortparallel: "\u2226",
        nsim: "\u2241",
        nsime: "\u2244",
        nsimeq: "\u2244",
        nsmid: "\u2224",
        nspar: "\u2226",
        nsqsube: "\u22E2",
        nsqsupe: "\u22E3",
        nsub: "\u2284",
        nsubE: "\u2AC5\u0338",
        nsube: "\u2288",
        nsubset: "\u2282\u20D2",
        nsubseteq: "\u2288",
        nsubseteqq: "\u2AC5\u0338",
        nsucc: "\u2281",
        nsucceq: "\u2AB0\u0338",
        nsup: "\u2285",
        nsupE: "\u2AC6\u0338",
        nsupe: "\u2289",
        nsupset: "\u2283\u20D2",
        nsupseteq: "\u2289",
        nsupseteqq: "\u2AC6\u0338",
        ntgl: "\u2279",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        ntlg: "\u2278",
        ntriangleleft: "\u22EA",
        ntrianglelefteq: "\u22EC",
        ntriangleright: "\u22EB",
        ntrianglerighteq: "\u22ED",
        Nu: "\u039D",
        nu: "\u03BD",
        num: "#",
        numero: "\u2116",
        numsp: "\u2007",
        nvap: "\u224D\u20D2",
        nVDash: "\u22AF",
        nVdash: "\u22AE",
        nvDash: "\u22AD",
        nvdash: "\u22AC",
        nvge: "\u2265\u20D2",
        nvgt: ">\u20D2",
        nvHarr: "\u2904",
        nvinfin: "\u29DE",
        nvlArr: "\u2902",
        nvle: "\u2264\u20D2",
        nvlt: "<\u20D2",
        nvltrie: "\u22B4\u20D2",
        nvrArr: "\u2903",
        nvrtrie: "\u22B5\u20D2",
        nvsim: "\u223C\u20D2",
        nwarhk: "\u2923",
        nwArr: "\u21D6",
        nwarr: "\u2196",
        nwarrow: "\u2196",
        nwnear: "\u2927",
        Oacute: "\xD3",
        oacute: "\xF3",
        oast: "\u229B",
        ocir: "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        Ocy: "\u041E",
        ocy: "\u043E",
        odash: "\u229D",
        Odblac: "\u0150",
        odblac: "\u0151",
        odiv: "\u2A38",
        odot: "\u2299",
        odsold: "\u29BC",
        OElig: "\u0152",
        oelig: "\u0153",
        ofcir: "\u29BF",
        Ofr: "\u{1D512}",
        ofr: "\u{1D52C}",
        ogon: "\u02DB",
        Ograve: "\xD2",
        ograve: "\xF2",
        ogt: "\u29C1",
        ohbar: "\u29B5",
        ohm: "\u03A9",
        oint: "\u222E",
        olarr: "\u21BA",
        olcir: "\u29BE",
        olcross: "\u29BB",
        oline: "\u203E",
        olt: "\u29C0",
        Omacr: "\u014C",
        omacr: "\u014D",
        Omega: "\u03A9",
        omega: "\u03C9",
        Omicron: "\u039F",
        omicron: "\u03BF",
        omid: "\u29B6",
        ominus: "\u2296",
        Oopf: "\u{1D546}",
        oopf: "\u{1D560}",
        opar: "\u29B7",
        OpenCurlyDoubleQuote: "\u201C",
        OpenCurlyQuote: "\u2018",
        operp: "\u29B9",
        oplus: "\u2295",
        Or: "\u2A54",
        or: "\u2228",
        orarr: "\u21BB",
        ord: "\u2A5D",
        order: "\u2134",
        orderof: "\u2134",
        ordf: "\xAA",
        ordm: "\xBA",
        origof: "\u22B6",
        oror: "\u2A56",
        orslope: "\u2A57",
        orv: "\u2A5B",
        oS: "\u24C8",
        Oscr: "\u{1D4AA}",
        oscr: "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        osol: "\u2298",
        Otilde: "\xD5",
        otilde: "\xF5",
        Otimes: "\u2A37",
        otimes: "\u2297",
        otimesas: "\u2A36",
        Ouml: "\xD6",
        ouml: "\xF6",
        ovbar: "\u233D",
        OverBar: "\u203E",
        OverBrace: "\u23DE",
        OverBracket: "\u23B4",
        OverParenthesis: "\u23DC",
        par: "\u2225",
        para: "\xB6",
        parallel: "\u2225",
        parsim: "\u2AF3",
        parsl: "\u2AFD",
        part: "\u2202",
        PartialD: "\u2202",
        Pcy: "\u041F",
        pcy: "\u043F",
        percnt: "%",
        period: ".",
        permil: "\u2030",
        perp: "\u22A5",
        pertenk: "\u2031",
        Pfr: "\u{1D513}",
        pfr: "\u{1D52D}",
        Phi: "\u03A6",
        phi: "\u03C6",
        phiv: "\u03D5",
        phmmat: "\u2133",
        phone: "\u260E",
        Pi: "\u03A0",
        pi: "\u03C0",
        pitchfork: "\u22D4",
        piv: "\u03D6",
        planck: "\u210F",
        planckh: "\u210E",
        plankv: "\u210F",
        plus: "+",
        plusacir: "\u2A23",
        plusb: "\u229E",
        pluscir: "\u2A22",
        plusdo: "\u2214",
        plusdu: "\u2A25",
        pluse: "\u2A72",
        PlusMinus: "\xB1",
        plusmn: "\xB1",
        plussim: "\u2A26",
        plustwo: "\u2A27",
        pm: "\xB1",
        Poincareplane: "\u210C",
        pointint: "\u2A15",
        Popf: "\u2119",
        popf: "\u{1D561}",
        pound: "\xA3",
        Pr: "\u2ABB",
        pr: "\u227A",
        prap: "\u2AB7",
        prcue: "\u227C",
        prE: "\u2AB3",
        pre: "\u2AAF",
        prec: "\u227A",
        precapprox: "\u2AB7",
        preccurlyeq: "\u227C",
        Precedes: "\u227A",
        PrecedesEqual: "\u2AAF",
        PrecedesSlantEqual: "\u227C",
        PrecedesTilde: "\u227E",
        preceq: "\u2AAF",
        precnapprox: "\u2AB9",
        precneqq: "\u2AB5",
        precnsim: "\u22E8",
        precsim: "\u227E",
        Prime: "\u2033",
        prime: "\u2032",
        primes: "\u2119",
        prnap: "\u2AB9",
        prnE: "\u2AB5",
        prnsim: "\u22E8",
        prod: "\u220F",
        Product: "\u220F",
        profalar: "\u232E",
        profline: "\u2312",
        profsurf: "\u2313",
        prop: "\u221D",
        Proportion: "\u2237",
        Proportional: "\u221D",
        propto: "\u221D",
        prsim: "\u227E",
        prurel: "\u22B0",
        Pscr: "\u{1D4AB}",
        pscr: "\u{1D4C5}",
        Psi: "\u03A8",
        psi: "\u03C8",
        puncsp: "\u2008",
        Qfr: "\u{1D514}",
        qfr: "\u{1D52E}",
        qint: "\u2A0C",
        Qopf: "\u211A",
        qopf: "\u{1D562}",
        qprime: "\u2057",
        Qscr: "\u{1D4AC}",
        qscr: "\u{1D4C6}",
        quaternions: "\u210D",
        quatint: "\u2A16",
        quest: "?",
        questeq: "\u225F",
        QUOT: '"',
        quot: '"',
        rAarr: "\u21DB",
        race: "\u223D\u0331",
        Racute: "\u0154",
        racute: "\u0155",
        radic: "\u221A",
        raemptyv: "\u29B3",
        Rang: "\u27EB",
        rang: "\u27E9",
        rangd: "\u2992",
        range: "\u29A5",
        rangle: "\u27E9",
        raquo: "\xBB",
        Rarr: "\u21A0",
        rArr: "\u21D2",
        rarr: "\u2192",
        rarrap: "\u2975",
        rarrb: "\u21E5",
        rarrbfs: "\u2920",
        rarrc: "\u2933",
        rarrfs: "\u291E",
        rarrhk: "\u21AA",
        rarrlp: "\u21AC",
        rarrpl: "\u2945",
        rarrsim: "\u2974",
        Rarrtl: "\u2916",
        rarrtl: "\u21A3",
        rarrw: "\u219D",
        rAtail: "\u291C",
        ratail: "\u291A",
        ratio: "\u2236",
        rationals: "\u211A",
        RBarr: "\u2910",
        rBarr: "\u290F",
        rbarr: "\u290D",
        rbbrk: "\u2773",
        rbrace: "}",
        rbrack: "]",
        rbrke: "\u298C",
        rbrksld: "\u298E",
        rbrkslu: "\u2990",
        Rcaron: "\u0158",
        rcaron: "\u0159",
        Rcedil: "\u0156",
        rcedil: "\u0157",
        rceil: "\u2309",
        rcub: "}",
        Rcy: "\u0420",
        rcy: "\u0440",
        rdca: "\u2937",
        rdldhar: "\u2969",
        rdquo: "\u201D",
        rdquor: "\u201D",
        rdsh: "\u21B3",
        Re: "\u211C",
        real: "\u211C",
        realine: "\u211B",
        realpart: "\u211C",
        reals: "\u211D",
        rect: "\u25AD",
        REG: "\xAE",
        reg: "\xAE",
        ReverseElement: "\u220B",
        ReverseEquilibrium: "\u21CB",
        ReverseUpEquilibrium: "\u296F",
        rfisht: "\u297D",
        rfloor: "\u230B",
        Rfr: "\u211C",
        rfr: "\u{1D52F}",
        rHar: "\u2964",
        rhard: "\u21C1",
        rharu: "\u21C0",
        rharul: "\u296C",
        Rho: "\u03A1",
        rho: "\u03C1",
        rhov: "\u03F1",
        RightAngleBracket: "\u27E9",
        RightArrow: "\u2192",
        Rightarrow: "\u21D2",
        rightarrow: "\u2192",
        RightArrowBar: "\u21E5",
        RightArrowLeftArrow: "\u21C4",
        rightarrowtail: "\u21A3",
        RightCeiling: "\u2309",
        RightDoubleBracket: "\u27E7",
        RightDownTeeVector: "\u295D",
        RightDownVector: "\u21C2",
        RightDownVectorBar: "\u2955",
        RightFloor: "\u230B",
        rightharpoondown: "\u21C1",
        rightharpoonup: "\u21C0",
        rightleftarrows: "\u21C4",
        rightleftharpoons: "\u21CC",
        rightrightarrows: "\u21C9",
        rightsquigarrow: "\u219D",
        RightTee: "\u22A2",
        RightTeeArrow: "\u21A6",
        RightTeeVector: "\u295B",
        rightthreetimes: "\u22CC",
        RightTriangle: "\u22B3",
        RightTriangleBar: "\u29D0",
        RightTriangleEqual: "\u22B5",
        RightUpDownVector: "\u294F",
        RightUpTeeVector: "\u295C",
        RightUpVector: "\u21BE",
        RightUpVectorBar: "\u2954",
        RightVector: "\u21C0",
        RightVectorBar: "\u2953",
        ring: "\u02DA",
        risingdotseq: "\u2253",
        rlarr: "\u21C4",
        rlhar: "\u21CC",
        rlm: "\u200F",
        rmoust: "\u23B1",
        rmoustache: "\u23B1",
        rnmid: "\u2AEE",
        roang: "\u27ED",
        roarr: "\u21FE",
        robrk: "\u27E7",
        ropar: "\u2986",
        Ropf: "\u211D",
        ropf: "\u{1D563}",
        roplus: "\u2A2E",
        rotimes: "\u2A35",
        RoundImplies: "\u2970",
        rpar: ")",
        rpargt: "\u2994",
        rppolint: "\u2A12",
        rrarr: "\u21C9",
        Rrightarrow: "\u21DB",
        rsaquo: "\u203A",
        Rscr: "\u211B",
        rscr: "\u{1D4C7}",
        Rsh: "\u21B1",
        rsh: "\u21B1",
        rsqb: "]",
        rsquo: "\u2019",
        rsquor: "\u2019",
        rthree: "\u22CC",
        rtimes: "\u22CA",
        rtri: "\u25B9",
        rtrie: "\u22B5",
        rtrif: "\u25B8",
        rtriltri: "\u29CE",
        RuleDelayed: "\u29F4",
        ruluhar: "\u2968",
        rx: "\u211E",
        Sacute: "\u015A",
        sacute: "\u015B",
        sbquo: "\u201A",
        Sc: "\u2ABC",
        sc: "\u227B",
        scap: "\u2AB8",
        Scaron: "\u0160",
        scaron: "\u0161",
        sccue: "\u227D",
        scE: "\u2AB4",
        sce: "\u2AB0",
        Scedil: "\u015E",
        scedil: "\u015F",
        Scirc: "\u015C",
        scirc: "\u015D",
        scnap: "\u2ABA",
        scnE: "\u2AB6",
        scnsim: "\u22E9",
        scpolint: "\u2A13",
        scsim: "\u227F",
        Scy: "\u0421",
        scy: "\u0441",
        sdot: "\u22C5",
        sdotb: "\u22A1",
        sdote: "\u2A66",
        searhk: "\u2925",
        seArr: "\u21D8",
        searr: "\u2198",
        searrow: "\u2198",
        sect: "\xA7",
        semi: ";",
        seswar: "\u2929",
        setminus: "\u2216",
        setmn: "\u2216",
        sext: "\u2736",
        Sfr: "\u{1D516}",
        sfr: "\u{1D530}",
        sfrown: "\u2322",
        sharp: "\u266F",
        SHCHcy: "\u0429",
        shchcy: "\u0449",
        SHcy: "\u0428",
        shcy: "\u0448",
        ShortDownArrow: "\u2193",
        ShortLeftArrow: "\u2190",
        shortmid: "\u2223",
        shortparallel: "\u2225",
        ShortRightArrow: "\u2192",
        ShortUpArrow: "\u2191",
        shy: "\xAD",
        Sigma: "\u03A3",
        sigma: "\u03C3",
        sigmaf: "\u03C2",
        sigmav: "\u03C2",
        sim: "\u223C",
        simdot: "\u2A6A",
        sime: "\u2243",
        simeq: "\u2243",
        simg: "\u2A9E",
        simgE: "\u2AA0",
        siml: "\u2A9D",
        simlE: "\u2A9F",
        simne: "\u2246",
        simplus: "\u2A24",
        simrarr: "\u2972",
        slarr: "\u2190",
        SmallCircle: "\u2218",
        smallsetminus: "\u2216",
        smashp: "\u2A33",
        smeparsl: "\u29E4",
        smid: "\u2223",
        smile: "\u2323",
        smt: "\u2AAA",
        smte: "\u2AAC",
        smtes: "\u2AAC\uFE00",
        SOFTcy: "\u042C",
        softcy: "\u044C",
        sol: "/",
        solb: "\u29C4",
        solbar: "\u233F",
        Sopf: "\u{1D54A}",
        sopf: "\u{1D564}",
        spades: "\u2660",
        spadesuit: "\u2660",
        spar: "\u2225",
        sqcap: "\u2293",
        sqcaps: "\u2293\uFE00",
        sqcup: "\u2294",
        sqcups: "\u2294\uFE00",
        Sqrt: "\u221A",
        sqsub: "\u228F",
        sqsube: "\u2291",
        sqsubset: "\u228F",
        sqsubseteq: "\u2291",
        sqsup: "\u2290",
        sqsupe: "\u2292",
        sqsupset: "\u2290",
        sqsupseteq: "\u2292",
        squ: "\u25A1",
        Square: "\u25A1",
        square: "\u25A1",
        SquareIntersection: "\u2293",
        SquareSubset: "\u228F",
        SquareSubsetEqual: "\u2291",
        SquareSuperset: "\u2290",
        SquareSupersetEqual: "\u2292",
        SquareUnion: "\u2294",
        squarf: "\u25AA",
        squf: "\u25AA",
        srarr: "\u2192",
        Sscr: "\u{1D4AE}",
        sscr: "\u{1D4C8}",
        ssetmn: "\u2216",
        ssmile: "\u2323",
        sstarf: "\u22C6",
        Star: "\u22C6",
        star: "\u2606",
        starf: "\u2605",
        straightepsilon: "\u03F5",
        straightphi: "\u03D5",
        strns: "\xAF",
        Sub: "\u22D0",
        sub: "\u2282",
        subdot: "\u2ABD",
        subE: "\u2AC5",
        sube: "\u2286",
        subedot: "\u2AC3",
        submult: "\u2AC1",
        subnE: "\u2ACB",
        subne: "\u228A",
        subplus: "\u2ABF",
        subrarr: "\u2979",
        Subset: "\u22D0",
        subset: "\u2282",
        subseteq: "\u2286",
        subseteqq: "\u2AC5",
        SubsetEqual: "\u2286",
        subsetneq: "\u228A",
        subsetneqq: "\u2ACB",
        subsim: "\u2AC7",
        subsub: "\u2AD5",
        subsup: "\u2AD3",
        succ: "\u227B",
        succapprox: "\u2AB8",
        succcurlyeq: "\u227D",
        Succeeds: "\u227B",
        SucceedsEqual: "\u2AB0",
        SucceedsSlantEqual: "\u227D",
        SucceedsTilde: "\u227F",
        succeq: "\u2AB0",
        succnapprox: "\u2ABA",
        succneqq: "\u2AB6",
        succnsim: "\u22E9",
        succsim: "\u227F",
        SuchThat: "\u220B",
        Sum: "\u2211",
        sum: "\u2211",
        sung: "\u266A",
        Sup: "\u22D1",
        sup: "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        supdot: "\u2ABE",
        supdsub: "\u2AD8",
        supE: "\u2AC6",
        supe: "\u2287",
        supedot: "\u2AC4",
        Superset: "\u2283",
        SupersetEqual: "\u2287",
        suphsol: "\u27C9",
        suphsub: "\u2AD7",
        suplarr: "\u297B",
        supmult: "\u2AC2",
        supnE: "\u2ACC",
        supne: "\u228B",
        supplus: "\u2AC0",
        Supset: "\u22D1",
        supset: "\u2283",
        supseteq: "\u2287",
        supseteqq: "\u2AC6",
        supsetneq: "\u228B",
        supsetneqq: "\u2ACC",
        supsim: "\u2AC8",
        supsub: "\u2AD4",
        supsup: "\u2AD6",
        swarhk: "\u2926",
        swArr: "\u21D9",
        swarr: "\u2199",
        swarrow: "\u2199",
        swnwar: "\u292A",
        szlig: "\xDF",
        Tab: "	",
        target: "\u2316",
        Tau: "\u03A4",
        tau: "\u03C4",
        tbrk: "\u23B4",
        Tcaron: "\u0164",
        tcaron: "\u0165",
        Tcedil: "\u0162",
        tcedil: "\u0163",
        Tcy: "\u0422",
        tcy: "\u0442",
        tdot: "\u20DB",
        telrec: "\u2315",
        Tfr: "\u{1D517}",
        tfr: "\u{1D531}",
        there4: "\u2234",
        Therefore: "\u2234",
        therefore: "\u2234",
        Theta: "\u0398",
        theta: "\u03B8",
        thetasym: "\u03D1",
        thetav: "\u03D1",
        thickapprox: "\u2248",
        thicksim: "\u223C",
        ThickSpace: "\u205F\u200A",
        thinsp: "\u2009",
        ThinSpace: "\u2009",
        thkap: "\u2248",
        thksim: "\u223C",
        THORN: "\xDE",
        thorn: "\xFE",
        Tilde: "\u223C",
        tilde: "\u02DC",
        TildeEqual: "\u2243",
        TildeFullEqual: "\u2245",
        TildeTilde: "\u2248",
        times: "\xD7",
        timesb: "\u22A0",
        timesbar: "\u2A31",
        timesd: "\u2A30",
        tint: "\u222D",
        toea: "\u2928",
        top: "\u22A4",
        topbot: "\u2336",
        topcir: "\u2AF1",
        Topf: "\u{1D54B}",
        topf: "\u{1D565}",
        topfork: "\u2ADA",
        tosa: "\u2929",
        tprime: "\u2034",
        TRADE: "\u2122",
        trade: "\u2122",
        triangle: "\u25B5",
        triangledown: "\u25BF",
        triangleleft: "\u25C3",
        trianglelefteq: "\u22B4",
        triangleq: "\u225C",
        triangleright: "\u25B9",
        trianglerighteq: "\u22B5",
        tridot: "\u25EC",
        trie: "\u225C",
        triminus: "\u2A3A",
        TripleDot: "\u20DB",
        triplus: "\u2A39",
        trisb: "\u29CD",
        tritime: "\u2A3B",
        trpezium: "\u23E2",
        Tscr: "\u{1D4AF}",
        tscr: "\u{1D4C9}",
        TScy: "\u0426",
        tscy: "\u0446",
        TSHcy: "\u040B",
        tshcy: "\u045B",
        Tstrok: "\u0166",
        tstrok: "\u0167",
        twixt: "\u226C",
        twoheadleftarrow: "\u219E",
        twoheadrightarrow: "\u21A0",
        Uacute: "\xDA",
        uacute: "\xFA",
        Uarr: "\u219F",
        uArr: "\u21D1",
        uarr: "\u2191",
        Uarrocir: "\u2949",
        Ubrcy: "\u040E",
        ubrcy: "\u045E",
        Ubreve: "\u016C",
        ubreve: "\u016D",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        Ucy: "\u0423",
        ucy: "\u0443",
        udarr: "\u21C5",
        Udblac: "\u0170",
        udblac: "\u0171",
        udhar: "\u296E",
        ufisht: "\u297E",
        Ufr: "\u{1D518}",
        ufr: "\u{1D532}",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        uHar: "\u2963",
        uharl: "\u21BF",
        uharr: "\u21BE",
        uhblk: "\u2580",
        ulcorn: "\u231C",
        ulcorner: "\u231C",
        ulcrop: "\u230F",
        ultri: "\u25F8",
        Umacr: "\u016A",
        umacr: "\u016B",
        uml: "\xA8",
        UnderBar: "_",
        UnderBrace: "\u23DF",
        UnderBracket: "\u23B5",
        UnderParenthesis: "\u23DD",
        Union: "\u22C3",
        UnionPlus: "\u228E",
        Uogon: "\u0172",
        uogon: "\u0173",
        Uopf: "\u{1D54C}",
        uopf: "\u{1D566}",
        UpArrow: "\u2191",
        Uparrow: "\u21D1",
        uparrow: "\u2191",
        UpArrowBar: "\u2912",
        UpArrowDownArrow: "\u21C5",
        UpDownArrow: "\u2195",
        Updownarrow: "\u21D5",
        updownarrow: "\u2195",
        UpEquilibrium: "\u296E",
        upharpoonleft: "\u21BF",
        upharpoonright: "\u21BE",
        uplus: "\u228E",
        UpperLeftArrow: "\u2196",
        UpperRightArrow: "\u2197",
        Upsi: "\u03D2",
        upsi: "\u03C5",
        upsih: "\u03D2",
        Upsilon: "\u03A5",
        upsilon: "\u03C5",
        UpTee: "\u22A5",
        UpTeeArrow: "\u21A5",
        upuparrows: "\u21C8",
        urcorn: "\u231D",
        urcorner: "\u231D",
        urcrop: "\u230E",
        Uring: "\u016E",
        uring: "\u016F",
        urtri: "\u25F9",
        Uscr: "\u{1D4B0}",
        uscr: "\u{1D4CA}",
        utdot: "\u22F0",
        Utilde: "\u0168",
        utilde: "\u0169",
        utri: "\u25B5",
        utrif: "\u25B4",
        uuarr: "\u21C8",
        Uuml: "\xDC",
        uuml: "\xFC",
        uwangle: "\u29A7",
        vangrt: "\u299C",
        varepsilon: "\u03F5",
        varkappa: "\u03F0",
        varnothing: "\u2205",
        varphi: "\u03D5",
        varpi: "\u03D6",
        varpropto: "\u221D",
        vArr: "\u21D5",
        varr: "\u2195",
        varrho: "\u03F1",
        varsigma: "\u03C2",
        varsubsetneq: "\u228A\uFE00",
        varsubsetneqq: "\u2ACB\uFE00",
        varsupsetneq: "\u228B\uFE00",
        varsupsetneqq: "\u2ACC\uFE00",
        vartheta: "\u03D1",
        vartriangleleft: "\u22B2",
        vartriangleright: "\u22B3",
        Vbar: "\u2AEB",
        vBar: "\u2AE8",
        vBarv: "\u2AE9",
        Vcy: "\u0412",
        vcy: "\u0432",
        VDash: "\u22AB",
        Vdash: "\u22A9",
        vDash: "\u22A8",
        vdash: "\u22A2",
        Vdashl: "\u2AE6",
        Vee: "\u22C1",
        vee: "\u2228",
        veebar: "\u22BB",
        veeeq: "\u225A",
        vellip: "\u22EE",
        Verbar: "\u2016",
        verbar: "|",
        Vert: "\u2016",
        vert: "|",
        VerticalBar: "\u2223",
        VerticalLine: "|",
        VerticalSeparator: "\u2758",
        VerticalTilde: "\u2240",
        VeryThinSpace: "\u200A",
        Vfr: "\u{1D519}",
        vfr: "\u{1D533}",
        vltri: "\u22B2",
        vnsub: "\u2282\u20D2",
        vnsup: "\u2283\u20D2",
        Vopf: "\u{1D54D}",
        vopf: "\u{1D567}",
        vprop: "\u221D",
        vrtri: "\u22B3",
        Vscr: "\u{1D4B1}",
        vscr: "\u{1D4CB}",
        vsubnE: "\u2ACB\uFE00",
        vsubne: "\u228A\uFE00",
        vsupnE: "\u2ACC\uFE00",
        vsupne: "\u228B\uFE00",
        Vvdash: "\u22AA",
        vzigzag: "\u299A",
        Wcirc: "\u0174",
        wcirc: "\u0175",
        wedbar: "\u2A5F",
        Wedge: "\u22C0",
        wedge: "\u2227",
        wedgeq: "\u2259",
        weierp: "\u2118",
        Wfr: "\u{1D51A}",
        wfr: "\u{1D534}",
        Wopf: "\u{1D54E}",
        wopf: "\u{1D568}",
        wp: "\u2118",
        wr: "\u2240",
        wreath: "\u2240",
        Wscr: "\u{1D4B2}",
        wscr: "\u{1D4CC}",
        xcap: "\u22C2",
        xcirc: "\u25EF",
        xcup: "\u22C3",
        xdtri: "\u25BD",
        Xfr: "\u{1D51B}",
        xfr: "\u{1D535}",
        xhArr: "\u27FA",
        xharr: "\u27F7",
        Xi: "\u039E",
        xi: "\u03BE",
        xlArr: "\u27F8",
        xlarr: "\u27F5",
        xmap: "\u27FC",
        xnis: "\u22FB",
        xodot: "\u2A00",
        Xopf: "\u{1D54F}",
        xopf: "\u{1D569}",
        xoplus: "\u2A01",
        xotime: "\u2A02",
        xrArr: "\u27F9",
        xrarr: "\u27F6",
        Xscr: "\u{1D4B3}",
        xscr: "\u{1D4CD}",
        xsqcup: "\u2A06",
        xuplus: "\u2A04",
        xutri: "\u25B3",
        xvee: "\u22C1",
        xwedge: "\u22C0",
        Yacute: "\xDD",
        yacute: "\xFD",
        YAcy: "\u042F",
        yacy: "\u044F",
        Ycirc: "\u0176",
        ycirc: "\u0177",
        Ycy: "\u042B",
        ycy: "\u044B",
        yen: "\xA5",
        Yfr: "\u{1D51C}",
        yfr: "\u{1D536}",
        YIcy: "\u0407",
        yicy: "\u0457",
        Yopf: "\u{1D550}",
        yopf: "\u{1D56A}",
        Yscr: "\u{1D4B4}",
        yscr: "\u{1D4CE}",
        YUcy: "\u042E",
        yucy: "\u044E",
        Yuml: "\u0178",
        yuml: "\xFF",
        Zacute: "\u0179",
        zacute: "\u017A",
        Zcaron: "\u017D",
        zcaron: "\u017E",
        Zcy: "\u0417",
        zcy: "\u0437",
        Zdot: "\u017B",
        zdot: "\u017C",
        zeetrf: "\u2128",
        ZeroWidthSpace: "\u200B",
        Zeta: "\u0396",
        zeta: "\u03B6",
        Zfr: "\u2128",
        zfr: "\u{1D537}",
        ZHcy: "\u0416",
        zhcy: "\u0436",
        zigrarr: "\u21DD",
        Zopf: "\u2124",
        zopf: "\u{1D56B}",
        Zscr: "\u{1D4B5}",
        zscr: "\u{1D4CF}",
        zwj: "\u200D",
        zwnj: "\u200C"
      });
      exports.entityMap = exports.HTML_ENTITIES;
    }
  });

  // node_modules/@xmldom/xmldom/lib/sax.js
  var require_sax = __commonJS({
    "node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
      var NAMESPACE = require_conventions().NAMESPACE;
      var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
      var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
      var S_TAG = 0;
      var S_ATTR = 1;
      var S_ATTR_SPACE = 2;
      var S_EQ = 3;
      var S_ATTR_NOQUOT_VALUE = 4;
      var S_ATTR_END = 5;
      var S_TAG_SPACE = 6;
      var S_TAG_CLOSE = 7;
      function ParseError(message, locator) {
        this.message = message;
        this.locator = locator;
        if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
      }
      ParseError.prototype = new Error();
      ParseError.prototype.name = ParseError.name;
      function XMLReader() {
      }
      XMLReader.prototype = {
        parse: function(source11, defaultNSMap, entityMap) {
          var domBuilder = this.domBuilder;
          domBuilder.startDocument();
          _copy3(defaultNSMap, defaultNSMap = {});
          parse2(
            source11,
            defaultNSMap,
            entityMap,
            domBuilder,
            this.errorHandler
          );
          domBuilder.endDocument();
        }
      };
      function parse2(source11, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
        function fixedFromCharCode(code) {
          if (code > 65535) {
            code -= 65536;
            var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
            return String.fromCharCode(surrogate1, surrogate2);
          } else {
            return String.fromCharCode(code);
          }
        }
        function entityReplacer(a3) {
          var k2 = a3.slice(1, -1);
          if (Object.hasOwnProperty.call(entityMap, k2)) {
            return entityMap[k2];
          } else if (k2.charAt(0) === "#") {
            return fixedFromCharCode(parseInt(k2.substr(1).replace("x", "0x")));
          } else {
            errorHandler.error("entity not found:" + a3);
            return a3;
          }
        }
        function appendText(end2) {
          if (end2 > start) {
            var xt = source11.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
            locator && position(start);
            domBuilder.characters(xt, 0, end2 - start);
            start = end2;
          }
        }
        function position(p3, m2) {
          while (p3 >= lineEnd && (m2 = linePattern.exec(source11))) {
            lineStart = m2.index;
            lineEnd = lineStart + m2[0].length;
            locator.lineNumber++;
          }
          locator.columnNumber = p3 - lineStart + 1;
        }
        var lineStart = 0;
        var lineEnd = 0;
        var linePattern = /.*(?:\r\n?|\n)|.*$/g;
        var locator = domBuilder.locator;
        var parseStack = [{ currentNSMap: defaultNSMapCopy }];
        var closeMap = {};
        var start = 0;
        while (true) {
          try {
            var tagStart = source11.indexOf("<", start);
            if (tagStart < 0) {
              if (!source11.substr(start).match(/^\s*$/)) {
                var doc = domBuilder.doc;
                var text = doc.createTextNode(source11.substr(start));
                doc.appendChild(text);
                domBuilder.currentElement = text;
              }
              return;
            }
            if (tagStart > start) {
              appendText(tagStart);
            }
            switch (source11.charAt(tagStart + 1)) {
              case "/":
                var end = source11.indexOf(">", tagStart + 3);
                var tagName = source11.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
                var config3 = parseStack.pop();
                if (end < 0) {
                  tagName = source11.substring(tagStart + 2).replace(/[\s<].*/, "");
                  errorHandler.error("end tag name: " + tagName + " is not complete:" + config3.tagName);
                  end = tagStart + 1 + tagName.length;
                } else if (tagName.match(/\s</)) {
                  tagName = tagName.replace(/[\s<].*/, "");
                  errorHandler.error("end tag name: " + tagName + " maybe not complete");
                  end = tagStart + 1 + tagName.length;
                }
                var localNSMap = config3.localNSMap;
                var endMatch = config3.tagName == tagName;
                var endIgnoreCaseMach = endMatch || config3.tagName && config3.tagName.toLowerCase() == tagName.toLowerCase();
                if (endIgnoreCaseMach) {
                  domBuilder.endElement(config3.uri, config3.localName, tagName);
                  if (localNSMap) {
                    for (var prefix in localNSMap) {
                      if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                        domBuilder.endPrefixMapping(prefix);
                      }
                    }
                  }
                  if (!endMatch) {
                    errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config3.tagName);
                  }
                } else {
                  parseStack.push(config3);
                }
                end++;
                break;
              // end elment
              case "?":
                locator && position(tagStart);
                end = parseInstruction(source11, tagStart, domBuilder);
                break;
              case "!":
                locator && position(tagStart);
                end = parseDCC(source11, tagStart, domBuilder, errorHandler);
                break;
              default:
                locator && position(tagStart);
                var el = new ElementAttributes();
                var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
                var end = parseElementStartPart(source11, tagStart, el, currentNSMap, entityReplacer, errorHandler);
                var len = el.length;
                if (!el.closed && fixSelfClosed(source11, end, el.tagName, closeMap)) {
                  el.closed = true;
                  if (!entityMap.nbsp) {
                    errorHandler.warning("unclosed xml attribute");
                  }
                }
                if (locator && len) {
                  var locator2 = copyLocator(locator, {});
                  for (var i3 = 0; i3 < len; i3++) {
                    var a2 = el[i3];
                    position(a2.offset);
                    a2.locator = copyLocator(locator, {});
                  }
                  domBuilder.locator = locator2;
                  if (appendElement(el, domBuilder, currentNSMap)) {
                    parseStack.push(el);
                  }
                  domBuilder.locator = locator;
                } else {
                  if (appendElement(el, domBuilder, currentNSMap)) {
                    parseStack.push(el);
                  }
                }
                if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                  end = parseHtmlSpecialContent(source11, end, el.tagName, entityReplacer, domBuilder);
                } else {
                  end++;
                }
            }
          } catch (e2) {
            if (e2 instanceof ParseError) {
              throw e2;
            }
            errorHandler.error("element parse error: " + e2);
            end = -1;
          }
          if (end > start) {
            start = end;
          } else {
            appendText(Math.max(tagStart, start) + 1);
          }
        }
      }
      function copyLocator(f2, t2) {
        t2.lineNumber = f2.lineNumber;
        t2.columnNumber = f2.columnNumber;
        return t2;
      }
      function parseElementStartPart(source11, start, el, currentNSMap, entityReplacer, errorHandler) {
        function addAttribute(qname, value2, startIndex) {
          if (el.attributeNames.hasOwnProperty(qname)) {
            errorHandler.fatalError("Attribute " + qname + " redefined");
          }
          el.addValue(
            qname,
            // @see https://www.w3.org/TR/xml/#AVNormalize
            // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
            // - recursive replacement of (DTD) entity references
            // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
            value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
            startIndex
          );
        }
        var attrName;
        var value;
        var p3 = ++start;
        var s2 = S_TAG;
        while (true) {
          var c2 = source11.charAt(p3);
          switch (c2) {
            case "=":
              if (s2 === S_ATTR) {
                attrName = source11.slice(start, p3);
                s2 = S_EQ;
              } else if (s2 === S_ATTR_SPACE) {
                s2 = S_EQ;
              } else {
                throw new Error("attribute equal must after attrName");
              }
              break;
            case "'":
            case '"':
              if (s2 === S_EQ || s2 === S_ATTR) {
                if (s2 === S_ATTR) {
                  errorHandler.warning('attribute value must after "="');
                  attrName = source11.slice(start, p3);
                }
                start = p3 + 1;
                p3 = source11.indexOf(c2, start);
                if (p3 > 0) {
                  value = source11.slice(start, p3);
                  addAttribute(attrName, value, start - 1);
                  s2 = S_ATTR_END;
                } else {
                  throw new Error("attribute value no end '" + c2 + "' match");
                }
              } else if (s2 == S_ATTR_NOQUOT_VALUE) {
                value = source11.slice(start, p3);
                addAttribute(attrName, value, start);
                errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c2 + ")!!");
                start = p3 + 1;
                s2 = S_ATTR_END;
              } else {
                throw new Error('attribute value must after "="');
              }
              break;
            case "/":
              switch (s2) {
                case S_TAG:
                  el.setTagName(source11.slice(start, p3));
                case S_ATTR_END:
                case S_TAG_SPACE:
                case S_TAG_CLOSE:
                  s2 = S_TAG_CLOSE;
                  el.closed = true;
                case S_ATTR_NOQUOT_VALUE:
                case S_ATTR:
                  break;
                case S_ATTR_SPACE:
                  el.closed = true;
                  break;
                //case S_EQ:
                default:
                  throw new Error("attribute invalid close char('/')");
              }
              break;
            case "":
              errorHandler.error("unexpected end of input");
              if (s2 == S_TAG) {
                el.setTagName(source11.slice(start, p3));
              }
              return p3;
            case ">":
              switch (s2) {
                case S_TAG:
                  el.setTagName(source11.slice(start, p3));
                case S_ATTR_END:
                case S_TAG_SPACE:
                case S_TAG_CLOSE:
                  break;
                //normal
                case S_ATTR_NOQUOT_VALUE:
                //Compatible state
                case S_ATTR:
                  value = source11.slice(start, p3);
                  if (value.slice(-1) === "/") {
                    el.closed = true;
                    value = value.slice(0, -1);
                  }
                case S_ATTR_SPACE:
                  if (s2 === S_ATTR_SPACE) {
                    value = attrName;
                  }
                  if (s2 == S_ATTR_NOQUOT_VALUE) {
                    errorHandler.warning('attribute "' + value + '" missed quot(")!');
                    addAttribute(attrName, value, start);
                  } else {
                    if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                      errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                    }
                    addAttribute(value, value, start);
                  }
                  break;
                case S_EQ:
                  throw new Error("attribute value missed!!");
              }
              return p3;
            /*xml space '\x20' | #x9 | #xD | #xA; */
            case "\x80":
              c2 = " ";
            default:
              if (c2 <= " ") {
                switch (s2) {
                  case S_TAG:
                    el.setTagName(source11.slice(start, p3));
                    s2 = S_TAG_SPACE;
                    break;
                  case S_ATTR:
                    attrName = source11.slice(start, p3);
                    s2 = S_ATTR_SPACE;
                    break;
                  case S_ATTR_NOQUOT_VALUE:
                    var value = source11.slice(start, p3);
                    errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                    addAttribute(attrName, value, start);
                  case S_ATTR_END:
                    s2 = S_TAG_SPACE;
                    break;
                }
              } else {
                switch (s2) {
                  //case S_TAG:void();break;
                  //case S_ATTR:void();break;
                  //case S_ATTR_NOQUOT_VALUE:void();break;
                  case S_ATTR_SPACE:
                    var tagName = el.tagName;
                    if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                      errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                    }
                    addAttribute(attrName, attrName, start);
                    start = p3;
                    s2 = S_ATTR;
                    break;
                  case S_ATTR_END:
                    errorHandler.warning('attribute space is required"' + attrName + '"!!');
                  case S_TAG_SPACE:
                    s2 = S_ATTR;
                    start = p3;
                    break;
                  case S_EQ:
                    s2 = S_ATTR_NOQUOT_VALUE;
                    start = p3;
                    break;
                  case S_TAG_CLOSE:
                    throw new Error("elements closed character '/' and '>' must be connected to");
                }
              }
          }
          p3++;
        }
      }
      function appendElement(el, domBuilder, currentNSMap) {
        var tagName = el.tagName;
        var localNSMap = null;
        var i3 = el.length;
        while (i3--) {
          var a2 = el[i3];
          var qName = a2.qName;
          var value = a2.value;
          var nsp = qName.indexOf(":");
          if (nsp > 0) {
            var prefix = a2.prefix = qName.slice(0, nsp);
            var localName = qName.slice(nsp + 1);
            var nsPrefix = prefix === "xmlns" && localName;
          } else {
            localName = qName;
            prefix = null;
            nsPrefix = qName === "xmlns" && "";
          }
          a2.localName = localName;
          if (nsPrefix !== false) {
            if (localNSMap == null) {
              localNSMap = {};
              _copy3(currentNSMap, currentNSMap = {});
            }
            currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
            a2.uri = NAMESPACE.XMLNS;
            domBuilder.startPrefixMapping(nsPrefix, value);
          }
        }
        var i3 = el.length;
        while (i3--) {
          a2 = el[i3];
          var prefix = a2.prefix;
          if (prefix) {
            if (prefix === "xml") {
              a2.uri = NAMESPACE.XML;
            }
            if (prefix !== "xmlns") {
              a2.uri = currentNSMap[prefix || ""];
            }
          }
        }
        var nsp = tagName.indexOf(":");
        if (nsp > 0) {
          prefix = el.prefix = tagName.slice(0, nsp);
          localName = el.localName = tagName.slice(nsp + 1);
        } else {
          prefix = null;
          localName = el.localName = tagName;
        }
        var ns = el.uri = currentNSMap[prefix || ""];
        domBuilder.startElement(ns, localName, tagName, el);
        if (el.closed) {
          domBuilder.endElement(ns, localName, tagName);
          if (localNSMap) {
            for (prefix in localNSMap) {
              if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                domBuilder.endPrefixMapping(prefix);
              }
            }
          }
        } else {
          el.currentNSMap = currentNSMap;
          el.localNSMap = localNSMap;
          return true;
        }
      }
      function parseHtmlSpecialContent(source11, elStartEnd, tagName, entityReplacer, domBuilder) {
        if (/^(?:script|textarea)$/i.test(tagName)) {
          var elEndStart = source11.indexOf("</" + tagName + ">", elStartEnd);
          var text = source11.substring(elStartEnd + 1, elEndStart);
          if (/[&<]/.test(text)) {
            if (/^script$/i.test(tagName)) {
              domBuilder.characters(text, 0, text.length);
              return elEndStart;
            }
            text = text.replace(/&#?\w+;/g, entityReplacer);
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
        }
        return elStartEnd + 1;
      }
      function fixSelfClosed(source11, elStartEnd, tagName, closeMap) {
        var pos = closeMap[tagName];
        if (pos == null) {
          pos = source11.lastIndexOf("</" + tagName + ">");
          if (pos < elStartEnd) {
            pos = source11.lastIndexOf("</" + tagName);
          }
          closeMap[tagName] = pos;
        }
        return pos < elStartEnd;
      }
      function _copy3(source11, target) {
        for (var n2 in source11) {
          if (Object.prototype.hasOwnProperty.call(source11, n2)) {
            target[n2] = source11[n2];
          }
        }
      }
      function parseDCC(source11, start, domBuilder, errorHandler) {
        var next = source11.charAt(start + 2);
        switch (next) {
          case "-":
            if (source11.charAt(start + 3) === "-") {
              var end = source11.indexOf("-->", start + 4);
              if (end > start) {
                domBuilder.comment(source11, start + 4, end - start - 4);
                return end + 3;
              } else {
                errorHandler.error("Unclosed comment");
                return -1;
              }
            } else {
              return -1;
            }
          default:
            if (source11.substr(start + 3, 6) == "CDATA[") {
              var end = source11.indexOf("]]>", start + 9);
              domBuilder.startCDATA();
              domBuilder.characters(source11, start + 9, end - start - 9);
              domBuilder.endCDATA();
              return end + 3;
            }
            var matchs = split(source11, start);
            var len = matchs.length;
            if (len > 1 && /!doctype/i.test(matchs[0][0])) {
              var name = matchs[1][0];
              var pubid = false;
              var sysid = false;
              if (len > 3) {
                if (/^public$/i.test(matchs[2][0])) {
                  pubid = matchs[3][0];
                  sysid = len > 4 && matchs[4][0];
                } else if (/^system$/i.test(matchs[2][0])) {
                  sysid = matchs[3][0];
                }
              }
              var lastMatch = matchs[len - 1];
              domBuilder.startDTD(name, pubid, sysid);
              domBuilder.endDTD();
              return lastMatch.index + lastMatch[0].length;
            }
        }
        return -1;
      }
      function parseInstruction(source11, start, domBuilder) {
        var end = source11.indexOf("?>", start);
        if (end) {
          var match = source11.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
          if (match) {
            var len = match[0].length;
            domBuilder.processingInstruction(match[1], match[2]);
            return end + 2;
          } else {
            return -1;
          }
        }
        return -1;
      }
      function ElementAttributes() {
        this.attributeNames = {};
      }
      ElementAttributes.prototype = {
        setTagName: function(tagName) {
          if (!tagNamePattern.test(tagName)) {
            throw new Error("invalid tagName:" + tagName);
          }
          this.tagName = tagName;
        },
        addValue: function(qName, value, offset) {
          if (!tagNamePattern.test(qName)) {
            throw new Error("invalid attribute:" + qName);
          }
          this.attributeNames[qName] = this.length;
          this[this.length++] = { qName, value, offset };
        },
        length: 0,
        getLocalName: function(i3) {
          return this[i3].localName;
        },
        getLocator: function(i3) {
          return this[i3].locator;
        },
        getQName: function(i3) {
          return this[i3].qName;
        },
        getURI: function(i3) {
          return this[i3].uri;
        },
        getValue: function(i3) {
          return this[i3].value;
        }
        //	,getIndex:function(uri, localName)){
        //		if(localName){
        //
        //		}else{
        //			var qName = uri
        //		}
        //	},
        //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
        //	getType:function(uri,localName){}
        //	getType:function(i){},
      };
      function split(source11, start) {
        var match;
        var buf = [];
        var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
        reg.lastIndex = start;
        reg.exec(source11);
        while (match = reg.exec(source11)) {
          buf.push(match);
          if (match[1]) return buf;
        }
      }
      exports.XMLReader = XMLReader;
      exports.ParseError = ParseError;
    }
  });

  // node_modules/@xmldom/xmldom/lib/dom-parser.js
  var require_dom_parser = __commonJS({
    "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
      var conventions = require_conventions();
      var dom = require_dom();
      var entities = require_entities();
      var sax = require_sax();
      var DOMImplementation = dom.DOMImplementation;
      var NAMESPACE = conventions.NAMESPACE;
      var ParseError = sax.ParseError;
      var XMLReader = sax.XMLReader;
      function normalizeLineEndings(input) {
        return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
      }
      function DOMParser3(options) {
        this.options = options || { locator: {} };
      }
      DOMParser3.prototype.parseFromString = function(source11, mimeType) {
        var options = this.options;
        var sax2 = new XMLReader();
        var domBuilder = options.domBuilder || new DOMHandler();
        var errorHandler = options.errorHandler;
        var locator = options.locator;
        var defaultNSMap = options.xmlns || {};
        var isHTML = /\/x?html?$/.test(mimeType);
        var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
        if (locator) {
          domBuilder.setDocumentLocator(locator);
        }
        sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
        sax2.domBuilder = options.domBuilder || domBuilder;
        if (isHTML) {
          defaultNSMap[""] = NAMESPACE.HTML;
        }
        defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
        var normalize3 = options.normalizeLineEndings || normalizeLineEndings;
        if (source11 && typeof source11 === "string") {
          sax2.parse(
            normalize3(source11),
            defaultNSMap,
            entityMap
          );
        } else {
          sax2.errorHandler.error("invalid doc source");
        }
        return domBuilder.doc;
      };
      function buildErrorHandler(errorImpl, domBuilder, locator) {
        if (!errorImpl) {
          if (domBuilder instanceof DOMHandler) {
            return domBuilder;
          }
          errorImpl = domBuilder;
        }
        var errorHandler = {};
        var isCallback = errorImpl instanceof Function;
        locator = locator || {};
        function build(key) {
          var fn = errorImpl[key];
          if (!fn && isCallback) {
            fn = errorImpl.length == 2 ? function(msg) {
              errorImpl(key, msg);
            } : errorImpl;
          }
          errorHandler[key] = fn && function(msg) {
            fn("[xmldom " + key + "]	" + msg + _locator(locator));
          } || function() {
          };
        }
        build("warning");
        build("error");
        build("fatalError");
        return errorHandler;
      }
      function DOMHandler() {
        this.cdata = false;
      }
      function position(locator, node) {
        node.lineNumber = locator.lineNumber;
        node.columnNumber = locator.columnNumber;
      }
      DOMHandler.prototype = {
        startDocument: function() {
          this.doc = new DOMImplementation().createDocument(null, null, null);
          if (this.locator) {
            this.doc.documentURI = this.locator.systemId;
          }
        },
        startElement: function(namespaceURI, localName, qName, attrs) {
          var doc = this.doc;
          var el = doc.createElementNS(namespaceURI, qName || localName);
          var len = attrs.length;
          appendElement(this, el);
          this.currentElement = el;
          this.locator && position(this.locator, el);
          for (var i3 = 0; i3 < len; i3++) {
            var namespaceURI = attrs.getURI(i3);
            var value = attrs.getValue(i3);
            var qName = attrs.getQName(i3);
            var attr = doc.createAttributeNS(namespaceURI, qName);
            this.locator && position(attrs.getLocator(i3), attr);
            attr.value = attr.nodeValue = value;
            el.setAttributeNode(attr);
          }
        },
        endElement: function(namespaceURI, localName, qName) {
          var current = this.currentElement;
          var tagName = current.tagName;
          this.currentElement = current.parentNode;
        },
        startPrefixMapping: function(prefix, uri) {
        },
        endPrefixMapping: function(prefix) {
        },
        processingInstruction: function(target, data) {
          var ins = this.doc.createProcessingInstruction(target, data);
          this.locator && position(this.locator, ins);
          appendElement(this, ins);
        },
        ignorableWhitespace: function(ch, start, length) {
        },
        characters: function(chars, start, length) {
          chars = _toString.apply(this, arguments);
          if (chars) {
            if (this.cdata) {
              var charNode = this.doc.createCDATASection(chars);
            } else {
              var charNode = this.doc.createTextNode(chars);
            }
            if (this.currentElement) {
              this.currentElement.appendChild(charNode);
            } else if (/^\s*$/.test(chars)) {
              this.doc.appendChild(charNode);
            }
            this.locator && position(this.locator, charNode);
          }
        },
        skippedEntity: function(name) {
        },
        endDocument: function() {
          this.doc.normalize();
        },
        setDocumentLocator: function(locator) {
          if (this.locator = locator) {
            locator.lineNumber = 0;
          }
        },
        //LexicalHandler
        comment: function(chars, start, length) {
          chars = _toString.apply(this, arguments);
          var comm = this.doc.createComment(chars);
          this.locator && position(this.locator, comm);
          appendElement(this, comm);
        },
        startCDATA: function() {
          this.cdata = true;
        },
        endCDATA: function() {
          this.cdata = false;
        },
        startDTD: function(name, publicId, systemId) {
          var impl = this.doc.implementation;
          if (impl && impl.createDocumentType) {
            var dt = impl.createDocumentType(name, publicId, systemId);
            this.locator && position(this.locator, dt);
            appendElement(this, dt);
            this.doc.doctype = dt;
          }
        },
        /**
         * @see org.xml.sax.ErrorHandler
         * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
         */
        warning: function(error) {
          console.warn("[xmldom warning]	" + error, _locator(this.locator));
        },
        error: function(error) {
          console.error("[xmldom error]	" + error, _locator(this.locator));
        },
        fatalError: function(error) {
          throw new ParseError(error, this.locator);
        }
      };
      function _locator(l2) {
        if (l2) {
          return "\n@" + (l2.systemId || "") + "#[line:" + l2.lineNumber + ",col:" + l2.columnNumber + "]";
        }
      }
      function _toString(chars, start, length) {
        if (typeof chars == "string") {
          return chars.substr(start, length);
        } else {
          if (chars.length >= start + length || start) {
            return new java.lang.String(chars, start, length) + "";
          }
          return chars;
        }
      }
      "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
        DOMHandler.prototype[key] = function() {
          return null;
        };
      });
      function appendElement(hander, node) {
        if (!hander.currentElement) {
          hander.doc.appendChild(node);
        } else {
          hander.currentElement.appendChild(node);
        }
      }
      exports.__DOMHandler = DOMHandler;
      exports.normalizeLineEndings = normalizeLineEndings;
      exports.DOMParser = DOMParser3;
    }
  });

  // node_modules/@xmldom/xmldom/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@xmldom/xmldom/lib/index.js"(exports) {
      var dom = require_dom();
      exports.DOMImplementation = dom.DOMImplementation;
      exports.XMLSerializer = dom.XMLSerializer;
      exports.DOMParser = require_dom_parser().DOMParser;
    }
  });

  // src/playable-ad-sdk.ts
  var destinationUrl = "";
  var isSdkInitialized = false;
  var isProtocolInitialized = false;
  var isForcePaused = false;
  var isInstallClicked = false;
  var actualVolume = 1;
  var initCallback = () => {
  };
  function bootAd() {
    if (sdk.isReady) return;
    emitEvent("boot");
    document.body.oncontextmenu = function() {
      return false;
    };
    initCallback(sdk.maxWidth, sdk.maxHeight);
    emitEvent("ready");
    sdk.isReady = true;
  }
  function fireVolumeChange(value) {
    emitEvent("volume", value);
  }
  function changeVolume(value) {
    sdk.volume = value;
    fireVolumeChange(value);
  }
  function handlePause() {
    changeVolume(0);
    sdk.isPaused = true;
    emitEvent("pause");
  }
  function handleResume() {
    if (isForcePaused) return;
    changeVolume(actualVolume);
    sdk.isPaused = false;
    emitEvent("resume");
  }
  function startDefaultProtocol() {
    if (isProtocolInitialized) return;
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        handleResume();
        if (!sdk.isReady && document.readyState === "complete") {
          bootAd();
        }
      } else {
        handlePause();
      }
    });
    function documentIsReady() {
      if (document.visibilityState === "visible") bootAd();
    }
    if (document.readyState === "complete") {
      documentIsReady();
    } else {
      window.addEventListener("load", documentIsReady);
    }
    window.addEventListener("resize", function() {
      handleResize();
    });
    isProtocolInitialized = true;
  }
  function handleResize(width, height) {
    sdk.maxWidth = Math.floor(width || window.innerWidth);
    sdk.maxHeight = Math.floor(height || window.innerHeight);
    sdk.isLandscape = sdk.maxWidth > sdk.maxHeight;
    emitEvent("resize", sdk.maxWidth, sdk.maxHeight);
  }
  var isListeningToTouchEvents = false;
  var isTouchEventRegistered = false;
  function onUserInteraction(event) {
    if (typeof TouchEvent !== "undefined" && event instanceof TouchEvent) {
      isListeningToTouchEvents = true;
    }
    if (isListeningToTouchEvents && event instanceof MouseEvent) return;
    sdk.interactions += 1;
    emitEvent("interaction", sdk.interactions);
  }
  function registerTouchHandlers() {
    if (!isTouchEventRegistered) {
      document.addEventListener("mousedown", onUserInteraction);
      document.addEventListener("touchstart", onUserInteraction);
      isTouchEventRegistered = true;
    }
  }
  function initPlayableAd() {
    destinationUrl = /android/i.test(navigator.userAgent) ? "https://play.google.com/store/apps/details?id=com.prettysimple.elixirapp" : "https://apps.apple.com/us/app/sorcery-school/id1558454859";
    ensureProtocol();
    if (false) {
      if (mraid.getState() === "loading") {
        mraid.addEventListener("ready", startMraidProtocol);
      } else {
        startMraidProtocol();
      }
    } else {
      startDefaultProtocol();
    }
    emitEvent("init");
  }
  var _sdk = class _sdk {
    /**
     * Initializes the SDK and sets up protocol-specific handlers.
     * This must be called as earlier as possible.
     *
     * @param callback Optional function called when ad container is ready
     * @example
     * // Basic initialization
     * sdk.init();
     *
     * // Initialization with callback
     * sdk.init((width, height) => {
     *   new App(width, height)
     * });
     *
     * @fires init When initialization starts
     * @fires boot When the ad begins booting
     * @fires ready When Ad Network is ready and playable ad can be initialized
     */
    static init(callback) {
      if (isSdkInitialized) return;
      if (callback) {
        initCallback = callback;
      }
      if (document.readyState === "loading") {
        window.addEventListener("DOMContentLoaded", initPlayableAd);
      } else {
        initPlayableAd();
      }
      isSdkInitialized = true;
    }
    /**
     * Starts the playable ad experience.
     * Should be called after all resources are loaded and first frame is rendered.
     *
     * @example
     * // Call just after all resources are preloaded and first frame is rendered
     * sdk.start();
     *
     * @fires start When the playable ad starts
     * @fires resize When the ad container is initially sized
     */
    static start() {
      if (_sdk.isStarted) return;
      _sdk.isStarted = true;
      emitEvent("start");
      registerTouchHandlers();
      fireVolumeChange(_sdk.volume);
      _sdk.resize();
    }
    /**
     * Marks the playable ad as finished.
     * This triggers network-specific completion handlers.
     *
     * @example
     * // Call when game/experience is complete
     * sdk.finish();
     *
     * @fires finish When the playable ad is marked as finished
     */
    static finish() {
      _sdk.isFinished = true;
      emitEvent("finish");
    }
    /**
     * Triggers a retry/restart of the playable ad.
     * Behavior varies by ad network.
     *
     * @example
     * // Allow user to try again
     * retryButton.onclick = () => sdk.retry();
     *
     * @fires retry When a retry is triggered
     */
    static retry() {
      emitEvent("retry");
    }
    /**
     * Triggers the install/download action for the advertised app.
     * Handles different store opening methods across ad networks.
     *
     * @example
     * // Call when user wants to install
     * installButton.onclick = () => sdk.install();
     *
     * @fires finish If the ad hasn't been marked as finished
     * @fires install When the install action is triggered
     */
    static install() {
      if (!_sdk.isFinished) {
        _sdk.isFinished = true;
        let timeout = 0;
        emitEvent("finish");
        setTimeout(function() {
          _sdk.install();
        }, timeout);
        return;
      }
      if (isInstallClicked) return;
      isInstallClicked = true;
      setTimeout(function() {
        isInstallClicked = false;
      }, 500);
      emitEvent("install");
      if (false) {
        mraid.open(destinationUrl);
      } else if (false) {
        FbPlayableAd.onCTAClick();
      } else if (false) {
        ExitApi.exit();
      } else {
        window.open(destinationUrl);
      }
    }
    /**
     * Trigger force resize event
     * Useful when container size changes need to be manually propagated.
     *
     * @example
     * sdk.resize();
     *
     * @fires resize With current maxWidth and maxHeight
     */
    static resize() {
      handleResize(_sdk.maxWidth, _sdk.maxHeight);
    }
    /**
     * Forces the playable ad into a paused state.
     *
     * @example
     * // Pause the experience
     * pauseButton.onclick = () => sdk.pause();
     *
     * @fires pause When the ad enters paused state
     */
    static pause() {
      if (!isForcePaused) {
        isForcePaused = true;
        handlePause();
      }
    }
    /**
     * Resumes the playable ad from a forced pause state.
     * Only works if the ad was paused via sdk.pause().
     *
     * @example
     * // Resume from pause
     * resumeButton.onclick = () => sdk.resume();
     *
     * @fires resume When the ad resumes from pause
     */
    static resume() {
      if (isForcePaused) {
        isForcePaused = false;
        handleResume();
      }
    }
    /**
     * Registers an event listener.
     *
     * @param event Name of the event to listen for
     * @param fn Callback function to execute when event occurs
     * @param context Optional 'this' context for the callback
     *
     * @example
     * // Listen for user interactions
     * sdk.on('interaction', (count) => {
     *   console.log(`User interaction #${count}`);
     * });
     *
     * // Listen for resize with context
     * sdk.on('resize', function(width, height) {
     *   this.updateLayout(width, height);
     * }, gameInstance);
     */
    static on(event, fn, context4) {
      onEvent(event, fn, context4);
    }
    /**
     * Registers a one-time event listener that removes itself after execution.
     *
     * @param event Name of the event to listen for
     * @param fn Callback function to execute when event occurs
     * @param context Optional 'this' context for the callback
     *
     * @example
     * // Listen for first interaction only
     * sdk.once('interaction', () => {
     *   console.log('First user interaction occurred!');
     * });
     */
    static once(event, fn, context4) {
      onEvent(event, fn, context4, true);
    }
    /**
     * Removes an event listener.
     *
     * @param event Name of the event to stop listening for
     * @param fn Optional callback function to remove (if not provided, removes all listeners for the event)
     * @param context Optional 'this' context to match when removing
     *
     * @example
     * // Remove specific listener
     * const handler = () => console.log('Interaction');
     * sdk.off('interaction', handler);
     *
     * // Remove all listeners for an event
     * sdk.off('interaction');
     */
    static off(event, fn, context4) {
      offEvent(event, fn, context4);
    }
  };
  /** Current maximum width of the playable ad container in pixels */
  _sdk.maxWidth = Math.floor(window.innerWidth);
  /** Current maximum height of the playable ad container in pixels */
  _sdk.maxHeight = Math.floor(window.innerHeight);
  /** Indicates if the current orientation is landscape (width > height) */
  _sdk.isLandscape = window.innerWidth > window.innerHeight;
  /** Indicates if the Ad Network is ready and playable ad can be initialized */
  _sdk.isReady = false;
  /** Indicates if all playable ad resources are loaded and gameplay has started */
  _sdk.isStarted = false;
  /** Indicates if the playable ad is currently paused */
  _sdk.isPaused = false;
  /** Indicates if the playable ad has finished */
  _sdk.isFinished = false;
  /** Current volume level (0-1) */
  _sdk.volume = actualVolume;
  /** Number of user interactions with the playable ad */
  _sdk.interactions = 0;
  var sdk = _sdk;
  var registeredEvents = {};
  function onEvent(event, fn, context4, once) {
    let listeners = registeredEvents[event];
    if (!listeners) {
      listeners = registeredEvents[event] = [];
    }
    listeners.push(fn, context4 || null, once || false);
  }
  function offEvent(event, fn, context4) {
    const listeners = registeredEvents[event];
    if (!listeners) return;
    if (!fn) {
      delete registeredEvents[event];
    } else {
      const events = [];
      for (let i3 = 0; i3 < listeners.length; i3 += 3) {
        if (listeners[i3] !== fn || context4 !== void 0 && listeners[i3 + 1] !== context4) {
          events.push(listeners[i3], listeners[i3 + 1], listeners[i3 + 2]);
        }
      }
      if (events.length === 0) delete registeredEvents[event];
      else registeredEvents[event] = events;
    }
  }
  function emitEvent(event, a1, a2, a3) {
    const listeners = registeredEvents[event];
    if (!listeners || listeners.length === 0) return;
    const len = arguments.length;
    const listenersLen = listeners.length;
    let fn, ctx;
    for (let i3 = 0; i3 < listenersLen; i3 += 3) {
      fn = listeners[i3];
      ctx = listeners[i3 + 1];
      if (listeners[i3 + 2]) offEvent(event, fn, ctx);
      if (len <= 1) fn.call(ctx);
      else if (len == 2) fn.call(ctx, a1);
      else if (len == 3) fn.call(ctx, a1, a2);
      else fn.call(ctx, a1, a2, a3);
    }
  }
  var uid = 0;
  var NONE = uid++;
  var MRAID = uid++;
  var FACEBOOK = uid++;
  var GOOGLE = uid++;
  function ensureProtocol() {
    if (false) {
      try {
        mraid.getState();
        actualProtocol = MRAID;
      } catch (error) {
      }
    } else if (false) {
      try {
        if (FbPlayableAd) actualProtocol = FACEBOOK;
      } catch (error) {
      }
    } else if (false) {
      try {
        if (ExitApi) actualProtocol = GOOGLE;
      } catch (error) {
      }
    }
  }
  window["console"].log(
    `%c \u2728 Sorcery School Playable Ad \u2728 %c`,
    `background: linear-gradient(135deg, #6a11cb, #2575fc);
    color: #fff;
    font-size: 16px;
    font-weight: bold;
    padding: 6px 12px;
    border-radius: 8px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.4);`,
    `background: linear-gradient(135deg, #6a11cb, #2575fc);
    color: #fff;
    font-size: 16px;
    font-weight: bold;
    padding: 6px 12px;
    border-top-left-radius: 8px;
    border-bottom-left-radius: 8px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.4);`
  );
  window.PlayableAdSdk = sdk;

  // node_modules/gsap/gsap-core.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  };
  var _defaults = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  };
  var _suppressOverwrites;
  var _reverting;
  var _context;
  var _bigNum = 1e8;
  var _tinyNum = 1 / _bigNum;
  var _2PI = Math.PI * 2;
  var _HALF_PI = _2PI / 4;
  var _gsID = 0;
  var _sqrt = Math.sqrt;
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _isString = function _isString2(value) {
    return typeof value === "string";
  };
  var _isFunction = function _isFunction2(value) {
    return typeof value === "function";
  };
  var _isNumber = function _isNumber2(value) {
    return typeof value === "number";
  };
  var _isUndefined = function _isUndefined2(value) {
    return typeof value === "undefined";
  };
  var _isObject = function _isObject2(value) {
    return typeof value === "object";
  };
  var _isNotFalse = function _isNotFalse2(value) {
    return value !== false;
  };
  var _windowExists = function _windowExists2() {
    return typeof window !== "undefined";
  };
  var _isFuncOrString = function _isFuncOrString2(value) {
    return _isFunction(value) || _isString(value);
  };
  var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
  };
  var _isArray = Array.isArray;
  var _randomExp = /random\([^)]+\)/g;
  var _commaDelimExp = /,\s*/g;
  var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
  var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
  var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
  var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
  var _relExp = /[+-]=-?[.\d]+/;
  var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
  var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
  var _globalTimeline;
  var _win;
  var _coreInitted;
  var _doc;
  var _globals = {};
  var _installScope = {};
  var _coreReady;
  var _install = function _install2(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  };
  var _missingPlugin = function _missingPlugin2(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  };
  var _warn = function _warn2(message, suppress) {
    return !suppress && console.warn(message);
  };
  var _addGlobal = function _addGlobal2(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  };
  var _emptyFunc = function _emptyFunc2() {
    return 0;
  };
  var _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  };
  var _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  };
  var _revertConfig = {
    suppressEvents: true
  };
  var _reservedProps = {};
  var _lazyTweens = [];
  var _lazyLookup = {};
  var _lastRenderedFrame;
  var _plugins = {};
  var _effects = {};
  var _nextGCFrame = 30;
  var _harnessPlugins = [];
  var _callbackNames = "";
  var _harness = function _harness2(targets) {
    var target = targets[0], harnessPlugin, i3;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i3 = _harnessPlugins.length;
      while (i3-- && !_harnessPlugins[i3].targetTest(target)) {
      }
      harnessPlugin = _harnessPlugins[i3];
    }
    i3 = targets.length;
    while (i3--) {
      targets[i3] && (targets[i3]._gsap || (targets[i3]._gsap = new GSCache(targets[i3], harnessPlugin))) || targets.splice(i3, 1);
    }
    return targets;
  };
  var _getCache = function _getCache2(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  };
  var _getProperty = function _getProperty2(target, property, v2) {
    return (v2 = target[property]) && _isFunction(v2) ? target[property]() : _isUndefined(v2) && target.getAttribute && target.getAttribute(property) || v2;
  };
  var _forEachName = function _forEachName2(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  };
  var _round = function _round2(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _roundPrecise = function _roundPrecise2(value) {
    return Math.round(value * 1e7) / 1e7 || 0;
  };
  var _parseRelative = function _parseRelative2(start, value) {
    var operator = value.charAt(0), end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  };
  var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
    var l2 = toFind.length, i3 = 0;
    for (; toSearch.indexOf(toFind[i3]) < 0 && ++i3 < l2; ) {
    }
    return i3 < l2;
  };
  var _lazyRender = function _lazyRender2() {
    var l2 = _lazyTweens.length, a2 = _lazyTweens.slice(0), i3, tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i3 = 0; i3 < l2; i3++) {
      tween = a2[i3];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  };
  var _isRevertWorthy = function _isRevertWorthy2(animation) {
    return !!(animation._initted || animation._startAt || animation.add);
  };
  var _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
    _lazyTweens.length && !_reverting && _lazyRender();
    animation.render(time, suppressEvents, force || !!(_reverting && time < 0 && _isRevertWorthy(animation)));
    _lazyTweens.length && !_reverting && _lazyRender();
  };
  var _numericIfPossible = function _numericIfPossible2(value) {
    var n2 = parseFloat(value);
    return (n2 || n2 === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n2 : _isString(value) ? value.trim() : value;
  };
  var _passThrough = function _passThrough2(p3) {
    return p3;
  };
  var _setDefaults = function _setDefaults2(obj, defaults2) {
    for (var p3 in defaults2) {
      p3 in obj || (obj[p3] = defaults2[p3]);
    }
    return obj;
  };
  var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
    return function(obj, defaults2) {
      for (var p3 in defaults2) {
        p3 in obj || p3 === "duration" && excludeDuration || p3 === "ease" || (obj[p3] = defaults2[p3]);
      }
    };
  };
  var _merge = function _merge2(base, toMerge) {
    for (var p3 in toMerge) {
      base[p3] = toMerge[p3];
    }
    return base;
  };
  var _mergeDeep = function _mergeDeep2(base, toMerge) {
    for (var p3 in toMerge) {
      p3 !== "__proto__" && p3 !== "constructor" && p3 !== "prototype" && (base[p3] = _isObject(toMerge[p3]) ? _mergeDeep2(base[p3] || (base[p3] = {}), toMerge[p3]) : toMerge[p3]);
    }
    return base;
  };
  var _copyExcluding = function _copyExcluding2(obj, excluding) {
    var copy = {}, p3;
    for (p3 in obj) {
      p3 in excluding || (copy[p3] = obj[p3]);
    }
    return copy;
  };
  var _inheritDefaults = function _inheritDefaults2(vars) {
    var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent) {
        func(vars, parent.vars.defaults);
        parent = parent.parent || parent._dp;
      }
    }
    return vars;
  };
  var _arraysMatch = function _arraysMatch2(a1, a2) {
    var i3 = a1.length, match = i3 === a2.length;
    while (match && i3-- && a1[i3] === a2[i3]) {
    }
    return i3 < 0;
  };
  var _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = parent[lastProp], t2;
    if (sortBy) {
      t2 = child[sortBy];
      while (prev && prev[sortBy] > t2) {
        prev = prev._prev;
      }
    }
    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent[firstProp];
      parent[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent[lastProp] = child;
    }
    child._prev = prev;
    child.parent = child._dp = parent;
    return child;
  };
  var _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = child._prev, next = child._next;
    if (prev) {
      prev._next = next;
    } else if (parent[firstProp] === child) {
      parent[firstProp] = next;
    }
    if (next) {
      next._prev = prev;
    } else if (parent[lastProp] === child) {
      parent[lastProp] = prev;
    }
    child._next = child._prev = child.parent = null;
  };
  var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  };
  var _uncache = function _uncache2(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      var a2 = animation;
      while (a2) {
        a2._dirty = 1;
        a2 = a2.parent;
      }
    }
    return animation;
  };
  var _recacheAncestors = function _recacheAncestors2(animation) {
    var parent = animation.parent;
    while (parent && parent.parent) {
      parent._dirty = 1;
      parent.totalDuration();
      parent = parent.parent;
    }
    return animation;
  };
  var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  };
  var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  };
  var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  };
  var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
    var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));
    return tTime && whole === tTime ? whole - 1 : whole;
  };
  var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  };
  var _setEnd = function _setEnd2(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  };
  var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
    var parent = animation._dp;
    if (parent && parent.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent._dirty || _uncache(parent, animation);
    }
    return animation;
  };
  var _postAddChecks = function _postAddChecks2(timeline2, child) {
    var t2;
    if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
      t2 = _parentToChildTotalTime(timeline2.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t2) - child._tTime > _tinyNum) {
        child.render(t2, true);
      }
    }
    if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
      if (timeline2._dur < timeline2.duration()) {
        t2 = timeline2;
        while (t2._dp) {
          t2.rawTime() >= 0 && t2.totalTime(t2._tTime);
          t2 = t2._dp;
        }
      }
      timeline2._zTime = -_tinyNum;
    }
  };
  var _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline2._recent = child);
    skipChecks || _postAddChecks(timeline2, child);
    timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
    return timeline2;
  };
  var _scrollTrigger = function _scrollTrigger2(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  };
  var _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  };
  var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
    var parent = _ref.parent;
    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
  };
  var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  };
  var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
    if (repeatDelay && tween._repeat) {
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
      suppressEvents || (suppressEvents = totalTime && !prevIteration);
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  };
  var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
    var child;
    if (time > prevTime) {
      child = animation._first;
      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  };
  var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  };
  var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  };
  var _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  };
  var _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i3, offset, isPercent;
    if (_isString(position) && (isNaN(position) || position in labels)) {
      offset = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i3 = position.indexOf("=");
      if (offset === "<" || offset === ">") {
        i3 >= 0 && (position = position.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i3 < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i3 < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }
      offset = parseFloat(position.charAt(i3 - 1) + position.substr(i3 + 1));
      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i3 > 1 ? _parsePosition2(animation, position.substr(0, i3 - 1), percentAnimation) + offset : clippedDuration + offset;
    }
    return position == null ? clippedDuration : +position;
  };
  var _createTweenType = function _createTweenType2(type, params, timeline2) {
    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline2;
    if (type) {
      irVars = vars;
      parent = timeline2;
      while (parent && !("immediateRender" in irVars)) {
        irVars = parent.vars.defaults || {};
        parent = _isNotFalse(parent.vars.inherit) && parent.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  };
  var _conditionalReturn = function _conditionalReturn2(value, func) {
    return value || value === 0 ? func(value) : func;
  };
  var _clamp = function _clamp2(min, max, value) {
    return value < min ? min : value > max ? max : value;
  };
  var getUnit = function getUnit2(value, v2) {
    return !_isString(value) || !(v2 = _unitExp.exec(value)) ? "" : v2[1];
  };
  var clamp = function clamp2(min, max, value) {
    return _conditionalReturn(value, function(v2) {
      return _clamp(min, max, v2);
    });
  };
  var _slice = [].slice;
  var _isArrayLike = function _isArrayLike2(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  };
  var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function(value) {
      var _accumulator;
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  };
  var toArray = function toArray2(value, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  };
  var selector = function selector2(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function(v2) {
      var el = value.current || value.nativeElement || value;
      return toArray(v2, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
    };
  };
  var shuffle = function shuffle2(a2) {
    return a2.sort(function() {
      return 0.5 - Math.random();
    });
  };
  var distribute = function distribute2(v2) {
    if (_isFunction(v2)) {
      return v2;
    }
    var vars = _isObject(v2) ? v2 : {
      each: v2
    }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
    if (_isString(from)) {
      ratioX = ratioY = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }
    return function(i3, target, a2) {
      var l2 = (a2 || vars).length, distances = cache[l2], originX, originY, x2, y2, d2, j2, max, min, wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max = -_bigNum;
          while (max < (max = a2[wrapAt++].getBoundingClientRect().left) && wrapAt < l2) {
          }
          wrapAt < l2 && wrapAt--;
        }
        distances = cache[l2] = [];
        originX = ratios ? Math.min(wrapAt, l2) * ratioX - 0.5 : from % wrapAt;
        originY = wrapAt === _bigNum ? 0 : ratios ? l2 * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum;
        for (j2 = 0; j2 < l2; j2++) {
          x2 = j2 % wrapAt - originX;
          y2 = originY - (j2 / wrapAt | 0);
          distances[j2] = d2 = !axis ? _sqrt(x2 * x2 + y2 * y2) : Math.abs(axis === "y" ? y2 : x2);
          d2 > max && (max = d2);
          d2 < min && (min = d2);
        }
        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l2 = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l2 ? l2 - 1 : !axis ? Math.max(wrapAt, l2 / wrapAt) : axis === "y" ? l2 / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l2 < 0 ? base - l2 : base;
        distances.u = getUnit(vars.amount || vars.each) || 0;
        ease = ease && l2 < 0 ? _invertEase(ease) : ease;
      }
      l2 = (distances[i3] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l2) : l2) * distances.v) + distances.u;
    };
  };
  var _roundModifier = function _roundModifier2(v2) {
    var p3 = Math.pow(10, ((v2 + "").split(".")[1] || "").length);
    return function(raw) {
      var n2 = _roundPrecise(Math.round(parseFloat(raw) / v2) * v2 * p3);
      return (n2 - n2 % 1) / p3 + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  };
  var snap = function snap2(snapTo, value) {
    var isArray = _isArray(snapTo), radius, is2D;
    if (!isArray && _isObject(snapTo)) {
      radius = isArray = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius;
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function(raw) {
      var x2 = parseFloat(is2D ? raw.x : raw), y2 = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i3 = snapTo.length, dx, dy;
      while (i3--) {
        if (is2D) {
          dx = snapTo[i3].x - x2;
          dy = snapTo[i3].y - y2;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i3] - x2);
        }
        if (dx < min) {
          min = dx;
          closest = i3;
        }
      }
      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  };
  var random = function random2(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  };
  var pipe = function pipe2() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function(value) {
      return functions.reduce(function(v2, f2) {
        return f2(v2);
      }, value);
    };
  };
  var unitize = function unitize2(func, unit) {
    return function(value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  };
  var normalize = function normalize2(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  };
  var _wrapArray = function _wrapArray2(a2, wrapper, value) {
    return _conditionalReturn(value, function(index) {
      return a2[~~wrapper(index)];
    });
  };
  var wrap = function wrap2(min, max, value) {
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
      return (range + (value2 - min) % range) % range + min;
    });
  };
  var wrapYoyo = function wrapYoyo2(min, max, value) {
    var range = max - min, total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
      value2 = (total + (value2 - min) % total) % total || 0;
      return min + (value2 > range ? total - value2 : value2);
    });
  };
  var _replaceRandom = function _replaceRandom2(s2) {
    return s2.replace(_randomExp, function(match) {
      var arIndex = match.indexOf("[") + 1, values = match.substring(arIndex || 7, arIndex ? match.indexOf("]") : match.length - 1).split(_commaDelimExp);
      return random(arIndex ? values : +values[0], arIndex ? 0 : +values[1], +values[2] || 1e-5);
    });
  };
  var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin, outRange = outMax - outMin;
    return _conditionalReturn(value, function(value2) {
      return outMin + ((value2 - inMin) / inRange * outRange || 0);
    });
  };
  var interpolate = function interpolate2(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function(p4) {
      return (1 - p4) * start + p4 * end;
    };
    if (!func) {
      var isString = _isString(start), master = {}, p3, i3, interpolators, l2, il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l2 = start.length;
        il = l2 - 2;
        for (i3 = 1; i3 < l2; i3++) {
          interpolators.push(interpolate2(start[i3 - 1], start[i3]));
        }
        l2--;
        func = function func2(p4) {
          p4 *= l2;
          var i4 = Math.min(il, ~~p4);
          return interpolators[i4](p4 - i4);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p3 in end) {
          _addPropTween.call(master, start, p3, "get", end[p3]);
        }
        func = function func2(p4) {
          return _renderPropTweens(p4, master) || (isString ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  };
  var _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
    var labels = timeline2.labels, min = _bigNum, p3, distance, label;
    for (p3 in labels) {
      distance = labels[p3] - fromTime;
      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p3;
        min = distance;
      }
    }
    return label;
  };
  var _callback = function _callback2(animation, type, executeLazyFirst) {
    var v2 = animation.vars, callback = v2[type], prevContext = _context, context4 = animation._ctx, params, scope, result;
    if (!callback) {
      return;
    }
    params = v2[type + "Params"];
    scope = v2.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender();
    context4 && (_context = context4);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  };
  var _interrupt = function _interrupt2(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  };
  var _quickTween;
  var _registerPluginQueue = [];
  var _createPlugin = function _createPlugin2(config3) {
    if (!config3) return;
    config3 = !config3.name && config3["default"] || config3;
    if (_windowExists() || config3.headless) {
      var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
        this._props = [];
      } : config3, instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      }, statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
      _wake();
      if (config3 !== Plugin) {
        if (_plugins[name]) {
          return;
        }
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
        _plugins[Plugin.prop = name] = Plugin;
        if (config3.targetTest) {
          _harnessPlugins.push(Plugin);
          _reservedProps[name] = 1;
        }
        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
      }
      _addGlobal(name, Plugin);
      config3.register && config3.register(gsap, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config3);
    }
  };
  var _255 = 255;
  var _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  };
  var _hue = function _hue2(h2, m1, m2) {
    h2 += h2 < 0 ? 1 : h2 > 1 ? -1 : 0;
    return (h2 * 6 < 1 ? m1 + (m2 - m1) * h2 * 6 : h2 < 0.5 ? m2 : h2 * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h2) * 6 : m1) * _255 + 0.5 | 0;
  };
  var splitColor = function splitColor2(v2, toHSL, forceAlpha) {
    var a2 = !v2 ? _colorLookup.black : _isNumber(v2) ? [v2 >> 16, v2 >> 8 & _255, v2 & _255] : 0, r2, g2, b2, h2, s2, l2, max, min, d2, wasHSL;
    if (!a2) {
      if (v2.substr(-1) === ",") {
        v2 = v2.substr(0, v2.length - 1);
      }
      if (_colorLookup[v2]) {
        a2 = _colorLookup[v2];
      } else if (v2.charAt(0) === "#") {
        if (v2.length < 6) {
          r2 = v2.charAt(1);
          g2 = v2.charAt(2);
          b2 = v2.charAt(3);
          v2 = "#" + r2 + r2 + g2 + g2 + b2 + b2 + (v2.length === 5 ? v2.charAt(4) + v2.charAt(4) : "");
        }
        if (v2.length === 9) {
          a2 = parseInt(v2.substr(1, 6), 16);
          return [a2 >> 16, a2 >> 8 & _255, a2 & _255, parseInt(v2.substr(7), 16) / 255];
        }
        v2 = parseInt(v2.substr(1), 16);
        a2 = [v2 >> 16, v2 >> 8 & _255, v2 & _255];
      } else if (v2.substr(0, 3) === "hsl") {
        a2 = wasHSL = v2.match(_strictNumExp);
        if (!toHSL) {
          h2 = +a2[0] % 360 / 360;
          s2 = +a2[1] / 100;
          l2 = +a2[2] / 100;
          g2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
          r2 = l2 * 2 - g2;
          a2.length > 3 && (a2[3] *= 1);
          a2[0] = _hue(h2 + 1 / 3, r2, g2);
          a2[1] = _hue(h2, r2, g2);
          a2[2] = _hue(h2 - 1 / 3, r2, g2);
        } else if (~v2.indexOf("=")) {
          a2 = v2.match(_numExp);
          forceAlpha && a2.length < 4 && (a2[3] = 1);
          return a2;
        }
      } else {
        a2 = v2.match(_strictNumExp) || _colorLookup.transparent;
      }
      a2 = a2.map(Number);
    }
    if (toHSL && !wasHSL) {
      r2 = a2[0] / _255;
      g2 = a2[1] / _255;
      b2 = a2[2] / _255;
      max = Math.max(r2, g2, b2);
      min = Math.min(r2, g2, b2);
      l2 = (max + min) / 2;
      if (max === min) {
        h2 = s2 = 0;
      } else {
        d2 = max - min;
        s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        h2 = max === r2 ? (g2 - b2) / d2 + (g2 < b2 ? 6 : 0) : max === g2 ? (b2 - r2) / d2 + 2 : (r2 - g2) / d2 + 4;
        h2 *= 60;
      }
      a2[0] = ~~(h2 + 0.5);
      a2[1] = ~~(s2 * 100 + 0.5);
      a2[2] = ~~(l2 * 100 + 0.5);
    }
    forceAlpha && a2.length < 4 && (a2[3] = 1);
    return a2;
  };
  var _colorOrderData = function _colorOrderData2(v2) {
    var values = [], c2 = [], i3 = -1;
    v2.split(_colorExp).forEach(function(v3) {
      var a2 = v3.match(_numWithUnitExp) || [];
      values.push.apply(values, a2);
      c2.push(i3 += a2.length + 1);
    });
    values.c = c2;
    return values;
  };
  var _formatColors = function _formatColors2(s2, toHSL, orderMatchData) {
    var result = "", colors2 = (s2 + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i3 = 0, c2, shell, d2, l2;
    if (!colors2) {
      return s2;
    }
    colors2 = colors2.map(function(color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d2 = _colorOrderData(s2);
      c2 = orderMatchData.c;
      if (c2.join(result) !== d2.c.join(result)) {
        shell = s2.replace(_colorExp, "1").split(_numWithUnitExp);
        l2 = shell.length - 1;
        for (; i3 < l2; i3++) {
          result += shell[i3] + (~c2.indexOf(i3) ? colors2.shift() || type + "0,0,0,0)" : (d2.length ? d2 : colors2.length ? colors2 : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s2.split(_colorExp);
      l2 = shell.length - 1;
      for (; i3 < l2; i3++) {
        result += shell[i3] + colors2[i3];
      }
    }
    return result + shell[l2];
  };
  var _colorExp = (function() {
    var s2 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p3;
    for (p3 in _colorLookup) {
      s2 += "|" + p3 + "\\b";
    }
    return new RegExp(s2 + ")", "gi");
  })();
  var _hslExp = /hsl[a]?\(/;
  var _colorStringFilter = function _colorStringFilter2(a2) {
    var combined = a2.join(" "), toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a2[1] = _formatColors(a2[1], toHSL);
      a2[0] = _formatColors(a2[0], toHSL, _colorOrderData(a2[1]));
      return true;
    }
  };
  var _tickerActive;
  var _ticker = (function() {
    var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick2(v2) {
      var elapsed = _getTime() - _lastUpdate, manual = v2 === true, overlap, dispatch, time, frame;
      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time = _lastUpdate - _startTime;
      overlap = time - _nextTime;
      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time - _self.time * 1e3;
        _self.time = time = time / 1e3;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }
      manual || (_id = _req(_tick2));
      if (dispatch) {
        for (_i = 0; _i < _listeners2.length; _i++) {
          _listeners2[_i](time, _delta, frame, v2);
        }
      }
    };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1e3 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _registerPluginQueue.forEach(_createPlugin);
          }
          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();
          _req = _raf || function(f2) {
            return setTimeout(f2, _nextTime - _self.time * 1e3 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity;
        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1e3 / (_fps || 240);
        _nextTime = _self.time * 1e3 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function(t2, d2, f2, v2) {
          callback(t2, d2, f2, v2);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners2[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove(callback, i3) {
        ~(i3 = _listeners2.indexOf(callback)) && _listeners2.splice(i3, 1) && _i >= i3 && _i--;
      },
      _listeners: _listeners2
    };
    return _self;
  })();
  var _wake = function _wake2() {
    return !_tickerActive && _ticker.wake();
  };
  var _easeMap = {};
  var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
  var _quotesExp = /["']/g;
  var _parseObjectInString = function _parseObjectInString2(value) {
    var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i3 = 1, l2 = split.length, index, val, parsedVal;
    for (; i3 < l2; i3++) {
      val = split[i3];
      index = i3 !== l2 - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }
    return obj;
  };
  var _valueInParentheses = function _valueInParentheses2(value) {
    var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  };
  var _configEaseFromString = function _configEaseFromString2(name) {
    var split = (name + "").split("("), ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  };
  var _invertEase = function _invertEase2(ease) {
    return function(p3) {
      return 1 - ease(1 - p3);
    };
  };
  var _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
    var child = timeline2._first, ease;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  };
  var _parseEase = function _parseEase2(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  };
  var _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut2(p3) {
        return 1 - easeIn(1 - p3);
      };
    }
    if (easeInOut === void 0) {
      easeInOut = function easeInOut2(p3) {
        return p3 < 0.5 ? easeIn(p3 * 2) / 2 : 1 - easeIn((1 - p3) * 2) / 2;
      };
    }
    var ease = {
      easeIn,
      easeOut,
      easeInOut
    }, lowercaseName;
    _forEachName(names, function(name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
      for (var p3 in ease) {
        _easeMap[lowercaseName + (p3 === "easeIn" ? ".in" : p3 === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p3] = ease[p3];
      }
    });
    return ease;
  };
  var _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
    return function(p3) {
      return p3 < 0.5 ? (1 - easeOut(1 - p3 * 2)) / 2 : 0.5 + easeOut((p3 - 0.5) * 2) / 2;
    };
  };
  var _configElastic = function _configElastic2(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1, p22 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p22 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p4) {
      return p4 === 1 ? 1 : p1 * Math.pow(2, -10 * p4) * _sin((p4 - p3) * p22) + 1;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p4) {
      return 1 - easeOut(1 - p4);
    } : _easeInOutFromOut(easeOut);
    p22 = _2PI / p22;
    ease.config = function(amplitude2, period2) {
      return _configElastic2(type, amplitude2, period2);
    };
    return ease;
  };
  var _configBack = function _configBack2(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut = function easeOut2(p3) {
      return p3 ? --p3 * p3 * ((overshoot + 1) * p3 + overshoot) + 1 : 0;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p3) {
      return 1 - easeOut(1 - p3);
    } : _easeInOutFromOut(easeOut);
    ease.config = function(overshoot2) {
      return _configBack2(type, overshoot2);
    };
    return ease;
  };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i3) {
    var power = i3 < 5 ? i3 + 1 : i3;
    _insertEase(name + ",Power" + (power - 1), i3 ? function(p3) {
      return Math.pow(p3, power);
    } : function(p3) {
      return p3;
    }, function(p3) {
      return 1 - Math.pow(1 - p3, power);
    }, function(p3) {
      return p3 < 0.5 ? Math.pow(p3 * 2, power) / 2 : 1 - Math.pow((1 - p3) * 2, power) / 2;
    });
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n2, c2) {
    var n1 = 1 / c2, n22 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p3) {
      return p3 < n1 ? n2 * p3 * p3 : p3 < n22 ? n2 * Math.pow(p3 - 1.5 / c2, 2) + 0.75 : p3 < n3 ? n2 * (p3 -= 2.25 / c2) * p3 + 0.9375 : n2 * Math.pow(p3 - 2.625 / c2, 2) + 0.984375;
    };
    _insertEase("Bounce", function(p3) {
      return 1 - easeOut(1 - p3);
    }, easeOut);
  })(7.5625, 2.75);
  _insertEase("Expo", function(p3) {
    return Math.pow(2, 10 * (p3 - 1)) * p3 + p3 * p3 * p3 * p3 * p3 * p3 * (1 - p3);
  });
  _insertEase("Circ", function(p3) {
    return -(_sqrt(1 - p3 * p3) - 1);
  });
  _insertEase("Sine", function(p3) {
    return p3 === 1 ? 1 : -_cos(p3 * _HALF_PI) + 1;
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }
      var p1 = 1 / steps, p22 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
      return function(p4) {
        return ((p22 * _clamp(0, max, p4) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  var GSCache = function GSCache2(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  var Animation = /* @__PURE__ */ (function() {
    function Animation3(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;
      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }
      this._ts = 1;
      _setDuration(this, +vars.duration, 1, 1);
      this.data = vars.data;
      if (_context) {
        this._ctx = _context;
        _context.data.push(this);
      }
      _tickerActive || _ticker.wake();
    }
    var _proto = Animation3.prototype;
    _proto.delay = function delay(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }
      return this._delay;
    };
    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };
    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };
    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent = this._dp;
      if (parent && parent.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent._dp || parent.parent || _postAddChecks(parent, this);
        while (parent && parent.parent) {
          if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
            parent.totalTime(parent._tTime, true);
          }
          parent = parent.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !this._initted && this._dur && _totalTime || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        this._ts || (this._pTime = _totalTime);
        _lazySafeRender(this, _totalTime, suppressEvents);
      }
      return this;
    };
    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
    };
    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
    };
    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    };
    _proto.timeScale = function timeScale(value, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts;
      }
      if (this._rts === value) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
      this.totalTime(_clamp(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);
      _setEnd(this);
      return _recacheAncestors(this);
    };
    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value) {
        this._ps = value;
        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
          this._ts = this._act = 0;
        } else {
          _wake();
          this._ts = this._rts;
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
        }
      }
      return this;
    };
    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = _roundPrecise(value);
        var parent = this.parent || this._dp;
        parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, this._start - this._delay);
        return this;
      }
      return this._start;
    };
    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };
    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent = this.parent || this._dp;
      return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
    };
    _proto.revert = function revert(config3) {
      if (config3 === void 0) {
        config3 = _revertConfig;
      }
      var prevIsReverting = _reverting;
      _reverting = config3;
      if (_isRevertWorthy(this)) {
        this.timeline && this.timeline.revert(config3);
        this.totalTime(-0.01, config3.suppressEvents);
      }
      this.data !== "nested" && config3.kill !== false && this.kill();
      _reverting = prevIsReverting;
      return this;
    };
    _proto.globalTime = function globalTime(rawTime) {
      var animation = this, time = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time = animation._start + time / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }
      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;
    };
    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    };
    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time = this._time;
        this._rDelay = value;
        _onUpdateTotalDuration(this);
        return time ? this.time(time) : this;
      }
      return this._rDelay;
    };
    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }
      return this._yoyo;
    };
    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
    };
    _proto.restart = function restart(includeDelay, suppressEvents) {
      this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      this._dur || (this._zTime = -_tinyNum);
      return this;
    };
    _proto.play = function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    };
    _proto.reverse = function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };
    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };
    _proto.resume = function resume() {
      return this.paused(false);
    };
    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
        return this;
      }
      return this._rts < 0;
    };
    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };
    _proto.isActive = function isActive() {
      var parent = this.parent || this._dp, start = this._start, rawTime;
      return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };
    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type];
    };
    _proto.then = function then(onFulfilled) {
      var self2 = this, prevProm = self2._prom;
      return new Promise(function(resolve) {
        var f2 = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
          var _then = self2.then;
          self2.then = null;
          prevProm && prevProm();
          _isFunction(f2) && (f2 = f2(self2)) && (f2.then || f2 === self2) && (self2.then = _then);
          resolve(f2);
          self2.then = _then;
        };
        if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
          _resolve();
        } else {
          self2._prom = _resolve;
        }
      });
    };
    _proto.kill = function kill() {
      _interrupt(this);
    };
    return Animation3;
  })();
  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var Timeline = /* @__PURE__ */ (function(_Animation) {
    _inheritsLoose(Timeline3, _Animation);
    function Timeline3(vars, position) {
      var _this;
      if (vars === void 0) {
        vars = {};
      }
      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }
    var _proto2 = Timeline3.prototype;
    _proto2.to = function to(targets, vars, position) {
      _createTweenType(0, arguments, this);
      return this;
    };
    _proto2.from = function from(targets, vars, position) {
      _createTweenType(1, arguments, this);
      return this;
    };
    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);
      return this;
    };
    _proto2.set = function set(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position), 1);
      return this;
    };
    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    };
    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position));
      return this;
    };
    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.render = function render3(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration);
            iteration = ~~prevIteration;
            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime;
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            if (this.vars.repeatRefresh && !isYoyo) {
              this.invalidate()._lock = 1;
              prevIteration = iteration;
            }
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              return this;
            }
            dur = this._dur;
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -1e-4;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            _propagateYoyoEase(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale;
        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0;
        }
        if (!prevTime && tTime && dur && !suppressEvents && !prevIteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        if (time >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next = child._next;
            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum);
                break;
              }
            }
            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time;
          while (child) {
            next = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && _isRevertWorthy(child));
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                break;
              }
            }
            child = next;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
          if (this._ts) {
            this._start = prevStart;
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
          if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
            if (!this._lock) {
              (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
        }
      }
      return this;
    };
    _proto2.add = function add(child, position) {
      var _this2 = this;
      _isNumber(position) || (position = _parsePosition(this, position, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function(obj) {
            return _this2.add(obj, position);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position) : this;
    };
    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }
      if (tweens === void 0) {
        tweens = true;
      }
      if (timelines === void 0) {
        timelines = true;
      }
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum;
      }
      var a2 = [], child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a2.push(child);
          } else {
            timelines && a2.push(child);
            nested && a2.push.apply(a2, child.getChildren(true, tweens, timelines));
          }
        }
        child = child._next;
      }
      return a2;
    };
    _proto2.getById = function getById2(id) {
      var animations = this.getChildren(1, 1, 1), i3 = animations.length;
      while (i3--) {
        if (animations[i3].vars.id === id) {
          return animations[i3];
        }
      }
    };
    _proto2.remove = function remove(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      child.parent === this && _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    };
    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
      this._forcing = 0;
      return this;
    };
    _proto2.addLabel = function addLabel(label, position) {
      this.labels[label] = _parsePosition(this, position);
      return this;
    };
    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };
    _proto2.addPause = function addPause(position, callback, params) {
      var t2 = Tween.delayedCall(0, callback || _emptyFunc, params);
      t2.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t2, _parsePosition(this, position));
    };
    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition(this, position);
      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    };
    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive), i3 = tweens.length;
      while (i3--) {
        _overwritingTween !== tweens[i3] && tweens[i3].kill(targets, props);
      }
      return this;
    };
    _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
      var a2 = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            a2.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a2.push.apply(a2, children);
        }
        child = child._next;
      }
      return a2;
    };
    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};
      var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []);
        }
      }, vars));
      return immediateRender ? tween.render(0) : tween;
    };
    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };
    _proto2.recent = function recent() {
      return this._recent;
    };
    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };
    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };
    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };
    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }
      var child = this._first, labels = this.labels, p3;
      amount = _roundPrecise(amount);
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p3 in labels) {
          if (labels[p3] >= ignoreBeforeTime) {
            labels[p3] += amount;
          }
        }
      }
      return _uncache(this);
    };
    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate(soft);
        child = child._next;
      }
      return _Animation.prototype.invalidate.call(this, soft);
    };
    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }
      var child = this._first, next;
      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };
    _proto2.totalDuration = function totalDuration(value) {
      var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev, start, parent;
      if (arguments.length) {
        return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
      }
      if (self2._dirty) {
        parent = self2.parent;
        while (child) {
          prev = child._prev;
          child._dirty && child.totalDuration();
          start = child._start;
          if (start > prevStart && self2._sort && child._ts && !self2._lock) {
            self2._lock = 1;
            _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            max -= start;
            if (!parent && !self2._dp || parent && parent.smoothChildTiming) {
              self2._start += _roundPrecise(start / self2._ts);
              self2._time -= start;
              self2._tTime -= start;
            }
            self2.shiftChildren(-start, false, -Infinity);
            prevStart = 0;
          }
          child._end > max && child._ts && (max = child._end);
          child = prev;
        }
        _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
        self2._dirty = 0;
      }
      return self2._tDur;
    };
    Timeline3.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) {
          if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
            child || _ticker.sleep();
          }
        }
      }
    };
    return Timeline3;
  })(Animation);
  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a2;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a2 = [start, end];
      stringFilter(a2, target, prop);
      start = a2[0];
      end = a2[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : "";
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0;
    }
    this._pt = pt;
    return pt;
  };
  var _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  };
  var _processVars = function _processVars2(vars, index, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }
    var copy = {}, p3;
    for (p3 in vars) {
      copy[p3] = _parseFuncOrString(vars[p3], tween, index, target, targets);
    }
    return copy;
  };
  var _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i3;
    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
        i3 = plugin._props.length;
        while (i3--) {
          ptLookup[plugin._props[i3]] = pt;
        }
      }
    }
    return plugin;
  };
  var _overwritingTween;
  var _forceAllPropTweens;
  var _initTween = function _initTween2(tween, time, tTime) {
    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i3, p3, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards;
    if (!tl || keyframes && !vars.stagger) {
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop];
      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1);
        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function() {
            return _callback(tween, "onUpdate");
          },
          stagger: 0
        }, startAt)));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            time && (tween._zTime = time);
            return;
          }
        }
      } else if (runBackwards && dur) {
        if (!prevStartAt) {
          time && (immediateRender = false);
          p3 = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent
            //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
          }, cleanVars);
          harnessVars && (p3[harness.prop] = harnessVars);
          _removeFromParent(tween._startAt = Tween.set(targets, p3));
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum, _tinyNum);
          } else if (!time) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i3 = 0; i3 < targets.length; i3++) {
        target = targets[i3];
        gsData = target._gsap || _harness(targets)[i3]._gsap;
        tween._ptLookup[i3] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
        index = fullTargets === targets ? i3 : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function(name) {
            ptLookup[name] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p3 in cleanVars) {
            if (_plugins[p3] && (plugin = _checkPlugin(p3, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p3] = pt = _addPropTween.call(tween, target, p3, "get", cleanVars[p3], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i3] && tween.kill(target, tween._op[i3]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween);
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten;
    keyframes && time <= 0 && tl.render(_bigNum, true, true);
  };
  var _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i3;
    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup = tween._ptLookup;
      i3 = tween._targets.length;
      while (i3--) {
        pt = lookup[i3][property];
        if (pt && pt.d && pt.d._pt) {
          pt = pt.d._pt;
          while (pt && pt.p !== property && pt.fp !== property) {
            pt = pt._next;
          }
        }
        if (!pt) {
          _forceAllPropTweens = 1;
          tween.vars[property] = "+=0";
          _initTween(tween, time);
          _forceAllPropTweens = 0;
          return skipRecursion ? _warn(property + " not eligible for reset") : 1;
        }
        ptCache.push(pt);
      }
    }
    i3 = ptCache.length;
    while (i3--) {
      rootPT = ptCache[i3];
      pt = rootPT._pt || rootPT;
      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
    }
  };
  var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p3, i3, aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p3 in propertyAliases) {
      if (p3 in copy) {
        aliases = propertyAliases[p3].split(",");
        i3 = aliases.length;
        while (i3--) {
          copy[aliases[i3]] = copy[p3];
        }
      }
    }
    return copy;
  };
  var _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut", p3, a2;
    if (_isArray(obj)) {
      a2 = allProps[prop] || (allProps[prop] = []);
      obj.forEach(function(value, i3) {
        return a2.push({
          t: i3 / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p3 in obj) {
        a2 = allProps[p3] || (allProps[p3] = []);
        p3 === "ease" || a2.push({
          t: parseFloat(prop),
          v: obj[p3],
          e: ease
        });
      }
    }
  };
  var _parseFuncOrString = function _parseFuncOrString2(value, tween, i3, target, targets) {
    return _isFunction(value) ? value.call(tween, i3, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  };
  var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
  var _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
    return _staggerPropsToSkip[name] = 1;
  });
  var Tween = /* @__PURE__ */ (function(_Animation2) {
    _inheritsLoose(Tween2, _Animation2);
    function Tween2(targets, vars, position, skipInherit) {
      var _this3;
      if (typeof vars === "number") {
        position.duration = vars;
        vars = position;
        position = null;
      }
      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i3, copy, l2, p3, curTarget, staggerFunc, staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = [];
      _this3._overwrite = overwrite;
      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults2 || {},
          targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
        });
        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;
        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          l2 = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);
          if (_isObject(stagger)) {
            for (p3 in stagger) {
              if (~_staggerTweenProps.indexOf(p3)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p3] = stagger[p3];
              }
            }
          }
          for (i3 = 0; i3 < l2; i3++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i3];
            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i3, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i3, curTarget, parsedTargets) || 0) - _this3._delay;
            if (!stagger && l2 === 1 && copy.delay) {
              _this3._delay = delay = copy.delay;
              _this3._start += delay;
              copy.delay = 0;
            }
            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i3, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }
          tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
        } else if (keyframes) {
          _inheritDefaults(_setDefaults(tl.vars.defaults, {
            ease: "none"
          }));
          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time = 0, a2, kf, v2;
          if (_isArray(keyframes)) {
            keyframes.forEach(function(frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration();
          } else {
            copy = {};
            for (p3 in keyframes) {
              p3 === "ease" || p3 === "easeEach" || _parseKeyframe(p3, keyframes[p3], copy, keyframes.easeEach);
            }
            for (p3 in copy) {
              a2 = copy[p3].sort(function(a3, b2) {
                return a3.t - b2.t;
              });
              time = 0;
              for (i3 = 0; i3 < a2.length; i3++) {
                kf = a2[i3];
                v2 = {
                  ease: kf.e,
                  duration: (kf.t - (i3 ? a2[i3 - 1].t : 0)) / 100 * duration
                };
                v2[p3] = kf.v;
                tl.to(parsedTargets, v2, time);
                time += v2.duration;
              }
            }
            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            });
          }
        }
        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0;
      }
      if (overwrite === true && !_suppressOverwrites) {
        _overwritingTween = _assertThisInitialized(_this3);
        _globalTimeline.killTweensOf(parsedTargets);
        _overwritingTween = 0;
      }
      _addToTimeline(parent, _assertThisInitialized(_this3), position);
      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);
      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
        _this3._tTime = -_tinyNum;
        _this3.render(Math.max(0, -delay) || 0);
      }
      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }
    var _proto3 = Tween2.prototype;
    _proto3.render = function render3(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {
        time = tTime;
        timeline2 = this.timeline;
        if (this._repeat) {
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration);
            iteration = ~~prevIteration;
            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            } else if (time > dur) {
              time = dur;
            }
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time === prevTime && !force && this._initted && iteration === prevIteration) {
            this._tTime = tTime;
            return this;
          }
          if (iteration !== prevIteration) {
            timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
            if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {
              this._lock = force = 1;
              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
            this._tTime = 0;
            return this;
          }
          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            return this;
          }
          if (dur !== this._dur) {
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time;
        if (!this._act && this._ts) {
          this._act = 1;
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        if (!prevTime && tTime && !suppressEvents && !prevIteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    };
    _proto3.targets = function targets() {
      return this._targets;
    };
    _proto3.invalidate = function invalidate(soft) {
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };
    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
      this._initted || _initTween(this, time);
      ratio = this._ease(time / this._dur);
      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
        return this.resetTo(property, value, start, startIsRelative, 1);
      }
      _alignPlayhead(this, 0);
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };
    _proto3.kill = function kill(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting);
        return this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
        return this;
      }
      var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p3, pt, i3;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        if (_isString(vars)) {
          p3 = {};
          _forEachName(vars, function(name) {
            return p3[name] = 1;
          });
          vars = p3;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i3 = parsedTargets.length;
      while (i3--) {
        if (~killingTargets.indexOf(parsedTargets[i3])) {
          curLookup = propTweenLookup[i3];
          if (vars === "all") {
            overwrittenProps[i3] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i3] = overwrittenProps[i3] || {};
            props = vars;
          }
          for (p3 in props) {
            pt = curLookup && curLookup[p3];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p3) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p3];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p3] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this);
      return this;
    };
    Tween2.to = function to(targets, vars) {
      return new Tween2(targets, vars, arguments[2]);
    };
    Tween2.from = function from(targets, vars) {
      return _createTweenType(1, arguments);
    };
    Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
      return new Tween2(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };
    Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };
    Tween2.set = function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween2(targets, vars);
    };
    Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };
    return Tween2;
  })(Animation);
  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
    Tween[name] = function() {
      var tl = new Timeline(), params = _slice.call(arguments, 0);
      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  var _setterPlain = function _setterPlain2(target, property, value) {
    return target[property] = value;
  };
  var _setterFunc = function _setterFunc2(target, property, value) {
    return target[property](value);
  };
  var _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
    return target[property](data.fp, value);
  };
  var _setterAttribute = function _setterAttribute2(target, property, value) {
    return target.setAttribute(property, value);
  };
  var _getSetter = function _getSetter2(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  };
  var _renderPlain = function _renderPlain2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
  };
  var _renderBoolean = function _renderBoolean2(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  };
  var _renderComplexString = function _renderComplexString2(ratio, data) {
    var pt = data._pt, s2 = "";
    if (!ratio && data.b) {
      s2 = data.b;
    } else if (ratio === 1 && data.e) {
      s2 = data.e;
    } else {
      while (pt) {
        s2 = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s2;
        pt = pt._next;
      }
      s2 += data.c;
    }
    data.set(data.t, data.p, s2, data);
  };
  var _renderPropTweens = function _renderPropTweens2(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  };
  var _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
    var pt = this._pt, next;
    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  };
  var _killPropTweensOf = function _killPropTweensOf2(property) {
    var pt = this._pt, hasNonDependentRemaining, next;
    while (pt) {
      next = pt._next;
      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next;
    }
    return !hasNonDependentRemaining;
  };
  var _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  };
  var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
    var pt = parent._pt, next, pt2, first, last;
    while (pt) {
      next = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }
      pt = next;
    }
    parent._pt = first;
  };
  var PropTween = /* @__PURE__ */ (function() {
    function PropTween3(next, target, prop, start, change, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;
      if (next) {
        next._prev = this;
      }
    }
    var _proto4 = PropTween3.prototype;
    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set;
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target;
      this.tween = tween;
    };
    return PropTween3;
  })();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
    return _reservedProps[name] = 1;
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [];
  var _listeners = {};
  var _emptyArray = [];
  var _lastMediaTime = 0;
  var _contextID = 0;
  var _dispatch = function _dispatch2(type) {
    return (_listeners[type] || _emptyArray).map(function(f2) {
      return f2();
    });
  };
  var _onMediaChange = function _onMediaChange2() {
    var time = Date.now(), matches = [];
    if (time - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function(c2) {
        var queries = c2.queries, conditions = c2.conditions, match, p3, anyMatch, toggled;
        for (p3 in queries) {
          match = _win.matchMedia(queries[p3]).matches;
          match && (anyMatch = 1);
          if (match !== conditions[p3]) {
            conditions[p3] = match;
            toggled = 1;
          }
        }
        if (toggled) {
          c2.revert();
          anyMatch && matches.push(c2);
        }
      });
      _dispatch("matchMediaRevert");
      matches.forEach(function(c2) {
        return c2.onMatch(c2, function(func) {
          return c2.add(null, func);
        });
      });
      _lastMediaTime = time;
      _dispatch("matchMedia");
    }
  };
  var Context = /* @__PURE__ */ (function() {
    function Context2(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = [];
      this.isReverted = false;
      this.id = _contextID++;
      func && this.add(func);
    }
    var _proto5 = Context2.prototype;
    _proto5.add = function add(name, func, scope) {
      if (_isFunction(name)) {
        scope = func;
        func = name;
        name = _isFunction;
      }
      var self2 = this, f2 = function f3() {
        var prev = _context, prevSelector = self2.selector, result;
        prev && prev !== self2 && prev.data.push(self2);
        scope && (self2.selector = selector(scope));
        _context = self2;
        result = func.apply(self2, arguments);
        _isFunction(result) && self2._r.push(result);
        _context = prev;
        self2.selector = prevSelector;
        self2.isReverted = false;
        return result;
      };
      self2.last = f2;
      return name === _isFunction ? f2(self2, function(func2) {
        return self2.add(null, func2);
      }) : name ? self2[name] = f2 : f2;
    };
    _proto5.ignore = function ignore(func) {
      var prev = _context;
      _context = null;
      func(this);
      _context = prev;
    };
    _proto5.getTweens = function getTweens() {
      var a2 = [];
      this.data.forEach(function(e2) {
        return e2 instanceof Context2 ? a2.push.apply(a2, e2.getTweens()) : e2 instanceof Tween && !(e2.parent && e2.parent.data === "nested") && a2.push(e2);
      });
      return a2;
    };
    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };
    _proto5.kill = function kill(revert, matchMedia2) {
      var _this4 = this;
      if (revert) {
        (function() {
          var tweens = _this4.getTweens(), i4 = _this4.data.length, t2;
          while (i4--) {
            t2 = _this4.data[i4];
            if (t2.data === "isFlip") {
              t2.revert();
              t2.getChildren(true, true, false).forEach(function(tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          }
          tweens.map(function(t3) {
            return {
              g: t3._dur || t3._delay || t3._sat && !t3._sat.vars.immediateRender ? t3.globalTime(0) : -Infinity,
              t: t3
            };
          }).sort(function(a2, b2) {
            return b2.g - a2.g || -Infinity;
          }).forEach(function(o2) {
            return o2.t.revert(revert);
          });
          i4 = _this4.data.length;
          while (i4--) {
            t2 = _this4.data[i4];
            if (t2 instanceof Timeline) {
              if (t2.data !== "nested") {
                t2.scrollTrigger && t2.scrollTrigger.revert();
                t2.kill();
              }
            } else {
              !(t2 instanceof Tween) && t2.revert && t2.revert(revert);
            }
          }
          _this4._r.forEach(function(f2) {
            return f2(revert, _this4);
          });
          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function(e2) {
          return e2.kill && e2.kill();
        });
      }
      this.clear();
      if (matchMedia2) {
        var i3 = _media.length;
        while (i3--) {
          _media[i3].id === this.id && _media.splice(i3, 1);
        }
      }
    };
    _proto5.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    return Context2;
  })();
  var MatchMedia = /* @__PURE__ */ (function() {
    function MatchMedia2(scope) {
      this.contexts = [];
      this.scope = scope;
      _context && _context.data.push(this);
    }
    var _proto6 = MatchMedia2.prototype;
    _proto6.add = function add(conditions, func, scope) {
      _isObject(conditions) || (conditions = {
        matches: conditions
      });
      var context4 = new Context(0, scope || this.scope), cond = context4.conditions = {}, mq, p3, active;
      _context && !context4.selector && (context4.selector = _context.selector);
      this.contexts.push(context4);
      func = context4.add("onMatch", func);
      context4.queries = conditions;
      for (p3 in conditions) {
        if (p3 === "all") {
          active = 1;
        } else {
          mq = _win.matchMedia(conditions[p3]);
          if (mq) {
            _media.indexOf(context4) < 0 && _media.push(context4);
            (cond[p3] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }
      active && func(context4, function(f2) {
        return context4.add(null, f2);
      });
      return this;
    };
    _proto6.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    _proto6.kill = function kill(revert) {
      this.contexts.forEach(function(c2) {
        return c2.kill(revert, true);
      });
    };
    return MatchMedia2;
  })();
  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args.forEach(function(config3) {
        return _createPlugin(config3);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      _isString(target) && (target = toArray(target)[0]);
      var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
      unit === "native" && (unit = "");
      return !target ? target : !property ? function(property2, unit2, uncache2) {
        return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);
      if (target.length > 1) {
        var setters = target.map(function(t2) {
          return gsap.quickSetter(t2, property, unit);
        }), l2 = setters.length;
        return function(value) {
          var i3 = l2;
          while (i3--) {
            setters[i3](value);
          }
        };
      }
      target = target[0] || {};
      var Plugin = _plugins[property], cache = _getCache(target), p3 = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
        var p4 = new Plugin();
        _quickTween._pt = 0;
        p4.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p4.render(1, p4);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p3);
      return Plugin ? setter : function(value) {
        return setter(target, p3, unit ? value + unit : value, cache, 1);
      };
    },
    quickTo: function quickTo(target, property, vars) {
      var _setDefaults22;
      var tween = gsap.to(target, _setDefaults((_setDefaults22 = {}, _setDefaults22[property] = "+=0.1", _setDefaults22.paused = true, _setDefaults22.stagger = 0, _setDefaults22), vars || {})), func = function func2(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };
      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
      return _mergeDeep(_defaults, value || {});
    },
    config: function config2(value) {
      return _mergeDeep(_config, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function(pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
      });
      _effects[name] = function(targets, vars, tl) {
        return effect(toArray(targets), _setDefaults(vars || {}, defaults2), tl);
      };
      if (extendTimeline) {
        Timeline.prototype[name] = function(targets, vars, position) {
          return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease) {
      _easeMap[name] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }
      var tl = new Timeline(vars), child, next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
      _globalTimeline.remove(tl);
      tl._dp = 0;
      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;
      while (child) {
        next = child._next;
        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }
        child = next;
      }
      _addToTimeline(_globalTimeline, tl, 0);
      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context;
    },
    matchMedia: function matchMedia(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function(c2) {
        var cond = c2.conditions, found, p3;
        for (p3 in cond) {
          if (cond[p3]) {
            cond[p3] = false;
            found = 1;
          }
        }
        found && c2.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener(type, callback) {
      var a2 = _listeners[type] || (_listeners[type] = []);
      ~a2.indexOf(callback) || a2.push(callback);
    },
    removeEventListener: function removeEventListener(type, callback) {
      var a2 = _listeners[type], i3 = a2 && a2.indexOf(callback);
      i3 >= 0 && a2.splice(i3, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting;
      },
      context: function context2(toAdd) {
        if (toAdd && _context) {
          _context.data.push(toAdd);
          toAdd._ctx = _context;
        }
        return _context;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites = value;
      }
    }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
    return _gsap[name] = Tween[name];
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
    duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  };
  var _addModifiers = function _addModifiers2(tween, modifiers) {
    var targets = tween._targets, p3, i3, pt;
    for (p3 in modifiers) {
      i3 = targets.length;
      while (i3--) {
        pt = tween._ptLookup[i3][p3];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            pt = _getPluginPropTween(pt, p3);
          }
          pt && pt.modifier && pt.modifier(modifiers[p3], tween, targets[i3], p3);
        }
      }
    }
  };
  var _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
    return {
      name,
      headless: 1,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init6(target, vars, tween) {
        tween._onInit = function(tween2) {
          var temp, p3;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function(name2) {
              return temp[name2] = 1;
            });
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p3 in vars) {
              temp[p3] = modifier(vars[p3]);
            }
            vars = temp;
          }
          _addModifiers(tween2, vars);
        };
      }
    };
  };
  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index, targets) {
      var p3, pt, v2;
      this.tween = tween;
      for (p3 in vars) {
        v2 = target.getAttribute(p3) || "";
        pt = this.add(target, "setAttribute", (v2 || 0) + "", vars[p3], index, targets, 0, 0, p3);
        pt.op = p3;
        pt.b = v2;
        this._props.push(p3);
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt;
      while (pt) {
        _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    headless: 1,
    init: function init2(target, value) {
      var i3 = value.length;
      while (i3--) {
        this.add(target, i3, target[i3] || 0, value[i3], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.14.2";
  _coreReady = 1;
  _windowExists() && _wake();
  var Power0 = _easeMap.Power0;
  var Power1 = _easeMap.Power1;
  var Power2 = _easeMap.Power2;
  var Power3 = _easeMap.Power3;
  var Power4 = _easeMap.Power4;
  var Linear = _easeMap.Linear;
  var Quad = _easeMap.Quad;
  var Cubic = _easeMap.Cubic;
  var Quart = _easeMap.Quart;
  var Quint = _easeMap.Quint;
  var Strong = _easeMap.Strong;
  var Elastic = _easeMap.Elastic;
  var Back = _easeMap.Back;
  var SteppedEase = _easeMap.SteppedEase;
  var Bounce = _easeMap.Bounce;
  var Sine = _easeMap.Sine;
  var Expo = _easeMap.Expo;
  var Circ = _easeMap.Circ;

  // node_modules/gsap/CSSPlugin.js
  var _win2;
  var _doc2;
  var _docElement;
  var _pluginInitted;
  var _tempDiv;
  var _tempDivStyler;
  var _recentSetterPlugin;
  var _reverting2;
  var _windowExists3 = function _windowExists4() {
    return typeof window !== "undefined";
  };
  var _transformProps = {};
  var _RAD2DEG = 180 / Math.PI;
  var _DEG2RAD = Math.PI / 180;
  var _atan2 = Math.atan2;
  var _bigNum2 = 1e8;
  var _capsExp = /([A-Z])/g;
  var _horizontalExp = /(left|right|width|margin|padding|x)/i;
  var _complexExp = /[\s,\(]\S/;
  var _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  };
  var _renderCSSProp = function _renderCSSProp2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
  };
  var _renderCSSPropWithBeginningAndEnd = function _renderCSSPropWithBeginningAndEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
  };
  var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
  };
  var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  };
  var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  };
  var _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
    return target.style[property] = value;
  };
  var _setterCSSProp = function _setterCSSProp2(target, property, value) {
    return target.style.setProperty(property, value);
  };
  var _setterTransform = function _setterTransform2(target, property, value) {
    return target._gsap[property] = value;
  };
  var _setterScale = function _setterScale2(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  };
  var _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  };
  var _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  };
  var _transformProp = "transform";
  var _transformOriginProp = _transformProp + "Origin";
  var _saveStyle = function _saveStyle2(property, isNotCSS) {
    var _this = this;
    var target = this.target, style = target.style, cache = target._gsap;
    if (property in _transformProps && style) {
      this.tfm = this.tfm || {};
      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function(a2) {
          return _this.tfm[a2] = _get(target, a2);
        }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
        property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function(p3) {
          return _saveStyle2.call(_this, p3, isNotCSS);
        });
      }
      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (cache.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  };
  var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  };
  var _revertStyle = function _revertStyle2() {
    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i3, p3;
    for (i3 = 0; i3 < props.length; i3 += 3) {
      if (!props[i3 + 1]) {
        props[i3 + 2] ? style[props[i3]] = props[i3 + 2] : style.removeProperty(props[i3].substr(0, 2) === "--" ? props[i3] : props[i3].replace(_capsExp, "-$1").toLowerCase());
      } else if (props[i3 + 1] === 2) {
        target[props[i3]](props[i3 + 2]);
      } else {
        target[props[i3]] = props[i3 + 2];
      }
    }
    if (this.tfm) {
      for (p3 in this.tfm) {
        cache[p3] = this.tfm[p3];
      }
      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i3 = _reverting2();
      if ((!i3 || !i3.isStart) && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        if (cache.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache.zOrigin + "px";
          cache.zOrigin = 0;
          cache.renderTransform();
        }
        cache.uncache = 1;
      }
    }
  };
  var _getStyleSaver = function _getStyleSaver2(target, properties) {
    var saver = {
      target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap.core.getCache(target);
    properties && target.style && target.nodeType && properties.split(",").forEach(function(p3) {
      return saver.save(p3);
    });
    return saver;
  };
  var _supports3D;
  var _createElement = function _createElement2(type, ns) {
    var e2 = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
    return e2 && e2.style ? e2 : _doc2.createElement(type);
  };
  var _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
  };
  var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
  var _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
    var e2 = element || _tempDiv, s2 = e2.style, i3 = 5;
    if (property in s2 && !preferPrefix) {
      return property;
    }
    property = property.charAt(0).toUpperCase() + property.substr(1);
    while (i3-- && !(_prefixes[i3] + property in s2)) {
    }
    return i3 < 0 ? null : (i3 === 3 ? "ms" : i3 >= 0 ? _prefixes[i3] : "") + property;
  };
  var _initCore = function _initCore2() {
    if (_windowExists3() && window.document) {
      _win2 = window;
      _doc2 = _win2.document;
      _docElement = _doc2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
      _supports3D = !!_checkPropPrefix("perspective");
      _reverting2 = gsap.core.reverting;
      _pluginInitted = 1;
    }
  };
  var _getReparentedCloneBBox = function _getReparentedCloneBBox2(target) {
    var owner = target.ownerSVGElement, svg = _createElement("svg", owner && owner.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), clone = target.cloneNode(true), bbox;
    clone.style.display = "block";
    svg.appendChild(clone);
    _docElement.appendChild(svg);
    try {
      bbox = clone.getBBox();
    } catch (e2) {
    }
    svg.removeChild(clone);
    _docElement.removeChild(svg);
    return bbox;
  };
  var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
    var i3 = attributesArray.length;
    while (i3--) {
      if (target.hasAttribute(attributesArray[i3])) {
        return target.getAttribute(attributesArray[i3]);
      }
    }
  };
  var _getBBox = function _getBBox2(target) {
    var bounds, cloned;
    try {
      bounds = target.getBBox();
    } catch (error) {
      bounds = _getReparentedCloneBBox(target);
      cloned = 1;
    }
    bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target));
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  };
  var _isSVG = function _isSVG2(e2) {
    return !!(e2.getCTM && (!e2.parentNode || e2.ownerSVGElement) && _getBBox(e2));
  };
  var _removeProperty = function _removeProperty2(target, property) {
    if (property) {
      var style = target.style, first2Chars;
      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }
      if (style.removeProperty) {
        first2Chars = property.substr(0, 2);
        if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
          property = "-" + property;
        }
        style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        style.removeAttribute(property);
      }
    }
  };
  var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property);
    return pt;
  };
  var _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  };
  var _nonStandardLayouts = {
    grid: 1,
    flex: 1
  };
  var _convertToUnit = function _convertToUnit2(target, property, value, unit) {
    var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent, cache, isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent = unit !== "rem" && ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent || parent === _doc2 || !parent.appendChild) {
      parent = _doc2.body;
    }
    cache = parent._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round(curValue / cache.width * amount);
    } else {
      if (toPercent && (property === "height" || property === "width")) {
        var v2 = target.style[property];
        target.style[property] = amount + unit;
        px = target[measureProperty];
        v2 ? target.style[property] = v2 : _removeProperty(target, property);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent === target && (style.position = "static");
        parent.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent.removeChild(_tempDiv);
        style.position = "absolute";
      }
      if (horizontal && toPercent) {
        cache = _getCache(parent);
        cache.time = _ticker.time;
        cache.width = parent[measureProperty];
      }
    }
    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  };
  var _get = function _get2(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];
      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }
    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
      }
    }
    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  };
  var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
    if (!start || start === "none") {
      var p3 = _checkPropPrefix(prop, target, 1), s2 = p3 && _getComputedProperty(target, p3, 1);
      if (s2 && s2 !== start) {
        prop = p3;
        start = s2;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor");
      }
    }
    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a2, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (end.substring(0, 6) === "var(--") {
      end = _getComputedProperty(target, end.substring(4, end.indexOf(")")));
    }
    if (end === "auto") {
      startValue = target.style[prop];
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
    }
    a2 = [start, end];
    _colorStringFilter(a2);
    start = a2[0];
    end = a2[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            endUnit = endUnit || _config.units[prop] || startUnit;
            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          }
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index < end.length ? end.substring(index, end.length) : "";
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _relExp.test(end) && (pt.e = 0);
    this._pt = pt;
    return pt;
  };
  var _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  };
  var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
    var split = value.split(" "), x2 = split[0], y2 = split[1] || "50%";
    if (x2 === "top" || x2 === "bottom" || y2 === "left" || y2 === "right") {
      value = x2;
      x2 = y2;
      y2 = value;
    }
    split[0] = _keywordToPercent[x2] || x2;
    split[1] = _keywordToPercent[y2] || y2;
    return split.join(" ");
  };
  var _renderClearProps = function _renderClearProps2(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i3;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i3 = props.length;
        while (--i3 > -1) {
          prop = props[i3];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          style.scale = style.rotate = style.translate = "none";
          _parseTransform(target, 1);
          cache.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  };
  var _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  };
  var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
  var _rotationalProperties = {};
  var _isNullTransform = function _isNullTransform2(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  };
  var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  };
  var _getMatrix = function _getMatrix2(target, force2D) {
    var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix;
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      temp = style.display;
      style.display = "block";
      parent = target.parentNode;
      if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {
        addedToDOM = 1;
        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target);
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  };
  var _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a2 = matrix[0], b2 = matrix[1], c2 = matrix[2], d2 = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x2, y2;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a2 * d2 - b2 * c2)) {
      x2 = xOrigin * (d2 / determinant) + yOrigin * (-c2 / determinant) + (c2 * ty - d2 * tx) / determinant;
      y2 = xOrigin * (-b2 / determinant) + yOrigin * (a2 / determinant) - (a2 * ty - b2 * tx) / determinant;
      xOrigin = x2;
      yOrigin = y2;
    }
    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a2 + ty * c2) - tx;
      cache.yOffset = yOffsetOld + (tx * b2 + ty * d2) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px";
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  };
  var _parseTransform = function _parseTransform2(target, uncache) {
    var cache = target._gsap || new GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x2, y2, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a2, b2, c2, d2, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
    x2 = y2 = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      if (cache.uncache) {
        t2 = target.getBBox();
        origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin");
      }
      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a2 = matrix[0];
      b2 = matrix[1];
      c2 = matrix[2];
      d2 = matrix[3];
      x2 = a12 = matrix[4];
      y2 = a22 = matrix[5];
      if (matrix.length === 6) {
        scaleX = Math.sqrt(a2 * a2 + b2 * b2);
        scaleY = Math.sqrt(d2 * d2 + c2 * c2);
        rotation = a2 || b2 ? _atan2(b2, a2) * _RAD2DEG : 0;
        skewX = c2 || d2 ? _atan2(c2, d2) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x2 -= xOrigin - (xOrigin * a2 + yOrigin * c2);
          y2 -= yOrigin - (xOrigin * b2 + yOrigin * d2);
        }
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x2 = matrix[12];
        y2 = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        }
        angle = _atan2(-c2, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a2 * cos - a13 * sin;
          t2 = b2 * cos - a23 * sin;
          t3 = c2 * cos - a33 * sin;
          a43 = d2 * sin + a43 * cos;
          a2 = t1;
          b2 = t2;
          c2 = t3;
        }
        angle = _atan2(b2, a2);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a2 * cos + b2 * sin;
          t2 = a12 * cos + a22 * sin;
          b2 = b2 * cos - a2 * sin;
          a22 = a22 * cos - a12 * sin;
          a2 = t1;
          a12 = t2;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = _round(Math.sqrt(a2 * a2 + b2 * b2 + c2 * c2));
        scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache.uncache;
    cache.x = x2 - ((cache.xPercent = x2 && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x2) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y2 - ((cache.yPercent = y2 && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y2) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z + px;
    cache.scaleX = _round(scaleX);
    cache.scaleY = _round(scaleY);
    cache.rotation = _round(rotation) + deg;
    cache.rotationX = _round(rotationX) + deg;
    cache.rotationY = _round(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  };
  var _firstTwoOnly = function _firstTwoOnly2(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  };
  var _addPxTranslate = function _addPxTranslate2(target, start, value) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  };
  var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  };
  var _zeroDeg = "0deg";
  var _zeroPx = "0px";
  var _endParenthesis = ") ";
  var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x2 = _ref.x, y2 = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x2 = _addPxTranslate(target, x2, a13 * cos * -zOrigin);
      y2 = _addPxTranslate(target, y2, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x2 !== _zeroPx || y2 !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x2 + ", " + y2 + ", " + z + ") " : "translate(" + x2 + ", " + y2 + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  };
  var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x2 = _ref2.x, y2 = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x2), ty = parseFloat(y2), a11, a21, a12, a22, temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x2 + "").indexOf("px") || ty && !~(y2 + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x2, "px");
      ty = _convertToUnit(target, "y", y2, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp);
  };
  var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
    var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
    if (isString) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property);
    return pt;
  };
  var _assign = function _assign2(target, source11) {
    for (var p3 in source11) {
      target[p3] = source11[p3];
    }
    return target;
  };
  var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
    var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p3, startValue, endValue, startNum, endNum, startUnit, endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p3 in _transformProps) {
      startValue = startCache[p3];
      endValue = endCache[p3];
      if (startValue !== endValue && exclude.indexOf(p3) < 0) {
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p3, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p3, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p3);
      }
    }
    _assign(endCache, startCache);
  };
  _forEachName("padding,margin,Width,Radius", function(name, index) {
    var t2 = "Top", r2 = "Right", b2 = "Bottom", l2 = "Left", props = (index < 3 ? [t2, r2, b2, l2] : [t2 + l2, t2 + r2, b2 + r2, b2 + l2]).map(function(side) {
      return index < 2 ? name + side : "border" + side + name;
    });
    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
      var a2, vars;
      if (arguments.length < 4) {
        a2 = props.map(function(prop) {
          return _get(plugin, prop, property);
        });
        vars = a2.join(" ");
        return vars.split(a2[0]).length === 5 ? a2[0] : vars;
      }
      a2 = (endValue + "").split(" ");
      vars = {};
      props.forEach(function(prop, i3) {
        return vars[prop] = a2[i3] = a2[i3] || a2[(i3 - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });
  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init3(target, vars, tween, index, targets) {
      var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p3, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps, finalTransformValue;
      _pluginInitted || _initCore();
      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;
      for (p3 in vars) {
        if (p3 === "autoRound") {
          continue;
        }
        endValue = vars[p3];
        if (_plugins[p3] && _checkPlugin(p3, vars, tween, index, target, targets)) {
          continue;
        }
        type = typeof endValue;
        specialProp = _specialProps[p3];
        if (type === "function") {
          endValue = endValue.call(tween, index, target, targets);
          type = typeof endValue;
        }
        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }
        if (specialProp) {
          specialProp(this, target, p3, endValue, tween) && (hasPriority = 1);
        } else if (p3.substr(0, 2) === "--") {
          startValue = (getComputedStyle(target).getPropertyValue(p3) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;
          if (!_colorExp.test(startValue)) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
            endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p3, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          }
          this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p3);
          props.push(p3);
          inlineProps.push(p3, 0, style[p3]);
        } else if (type !== "undefined") {
          if (startAt && p3 in startAt) {
            startValue = typeof startAt[p3] === "function" ? startAt[p3].call(tween, index, target, targets) : startAt[p3];
            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p3] || getUnit(_get(target, p3)) || "");
            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p3));
          } else {
            startValue = _get(target, p3);
          }
          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);
          if (p3 in _propertyAliases) {
            if (p3 === "autoAlpha") {
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                startNum = 0;
              }
              inlineProps.push("visibility", 0, style.visibility);
              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }
            if (p3 !== "scale" && p3 !== "transform") {
              p3 = _propertyAliases[p3];
              ~p3.indexOf(",") && (p3 = p3.split(",")[0]);
            }
          }
          isTransformRelated = p3 in _transformProps;
          if (isTransformRelated) {
            this.styles.save(p3);
            finalTransformValue = endValue;
            if (type === "string" && endValue.substring(0, 6) === "var(--") {
              endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(")")));
              if (endValue.substring(0, 5) === "calc(") {
                var origPerspective = target.style.perspective;
                target.style.perspective = endValue;
                endValue = _getComputedProperty(target, "perspective");
                origPerspective ? target.style.perspective = origPerspective : _removeProperty(target, "perspective");
              }
              endNum = parseFloat(endValue);
            }
            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
              transformPropTween.dep = 1;
            }
            if (p3 === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p3);
              p3 += "X";
            } else if (p3 === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue);
              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                _addNonTweeningPT(this, style, p3, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }
              continue;
            } else if (p3 === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);
              continue;
            } else if (p3 in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p3, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
              continue;
            } else if (p3 === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
              continue;
            } else if (p3 === "force3D") {
              cache[p3] = endValue;
              continue;
            } else if (p3 === "transform") {
              _addRawTransformPTs(this, endValue, target);
              continue;
            }
          } else if (!(p3 in style)) {
            p3 = _checkPropPrefix(p3) || p3;
          }
          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p3 in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0);
            endUnit = getUnit(endValue) || (p3 in _config.units ? _config.units[p3] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p3, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p3, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p3 === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;
            if (isTransformRelated && finalTransformValue !== endValue) {
              this._pt.b = startValue;
              this._pt.e = finalTransformValue;
              this._pt.r = _renderCSSPropWithBeginningAndEnd;
            } else if (startUnit !== endUnit && endUnit !== "%") {
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p3 in style)) {
            if (p3 in target) {
              this.add(target, p3, startValue || target[p3], relative ? relative + endValue : endValue, index, targets);
            } else if (p3 !== "parseTransform") {
              _missingPlugin(p3, endValue);
              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p3, startValue, relative ? relative + endValue : endValue);
          }
          isTransformRelated || (p3 in style ? inlineProps.push(p3, 0, style[p3]) : typeof target[p3] === "function" ? inlineProps.push(p3, 2, target[p3]()) : inlineProps.push(p3, 1, startValue || target[p3]));
          props.push(p3);
        }
      }
      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render2(ratio, data) {
      if (data.tween._time || !_reverting2()) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      var p3 = _propertyAliases[property];
      p3 && p3.indexOf(",") < 0 && (property = p3);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty,
      _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
      _transformProps[name] = 1;
    });
    _forEachName(rotation, function(name) {
      _config.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });
    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
    _forEachName(aliases, function(name) {
      var split = name.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
    _config.units[name] = "px";
  });
  gsap.registerPlugin(CSSPlugin);

  // node_modules/gsap/index.js
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
  var TweenMaxWithCSS = gsapWithCSS.core.Tween;

  // node_modules/gsap/PixiPlugin.js
  var gsap2;
  var _splitColor;
  var _coreInitted2;
  var _PIXI;
  var PropTween2;
  var _getSetter3;
  var _isV4;
  var _isV8Plus;
  var _windowExists5 = function _windowExists6() {
    return typeof window !== "undefined";
  };
  var _getGSAP = function _getGSAP2() {
    return gsap2 || _windowExists5() && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
  };
  var _isFunction3 = function _isFunction4(value) {
    return typeof value === "function";
  };
  var _warn3 = function _warn4(message) {
    return console.warn(message);
  };
  var _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
  var _lumR = 0.212671;
  var _lumG = 0.71516;
  var _lumB = 0.072169;
  var _filterClass = function _filterClass2(name) {
    return _isFunction3(_PIXI[name]) ? _PIXI[name] : _PIXI.filters[name];
  };
  var _applyMatrix = function _applyMatrix2(m2, m22) {
    var temp = [], i3 = 0, z = 0, y2, x2;
    for (y2 = 0; y2 < 4; y2++) {
      for (x2 = 0; x2 < 5; x2++) {
        z = x2 === 4 ? m2[i3 + 4] : 0;
        temp[i3 + x2] = m2[i3] * m22[x2] + m2[i3 + 1] * m22[x2 + 5] + m2[i3 + 2] * m22[x2 + 10] + m2[i3 + 3] * m22[x2 + 15] + z;
      }
      i3 += 5;
    }
    return temp;
  };
  var _setSaturation = function _setSaturation2(m2, n2) {
    var inv = 1 - n2, r2 = inv * _lumR, g2 = inv * _lumG, b2 = inv * _lumB;
    return _applyMatrix([r2 + n2, g2, b2, 0, 0, r2, g2 + n2, b2, 0, 0, r2, g2, b2 + n2, 0, 0, 0, 0, 0, 1, 0], m2);
  };
  var _colorize = function _colorize2(m2, color, amount) {
    var c2 = _splitColor(color), r2 = c2[0] / 255, g2 = c2[1] / 255, b2 = c2[2] / 255, inv = 1 - amount;
    return _applyMatrix([inv + amount * r2 * _lumR, amount * r2 * _lumG, amount * r2 * _lumB, 0, 0, amount * g2 * _lumR, inv + amount * g2 * _lumG, amount * g2 * _lumB, 0, 0, amount * b2 * _lumR, amount * b2 * _lumG, inv + amount * b2 * _lumB, 0, 0, 0, 0, 0, 1, 0], m2);
  };
  var _setHue = function _setHue2(m2, n2) {
    n2 *= Math.PI / 180;
    var c2 = Math.cos(n2), s2 = Math.sin(n2);
    return _applyMatrix([_lumR + c2 * (1 - _lumR) + s2 * -_lumR, _lumG + c2 * -_lumG + s2 * -_lumG, _lumB + c2 * -_lumB + s2 * (1 - _lumB), 0, 0, _lumR + c2 * -_lumR + s2 * 0.143, _lumG + c2 * (1 - _lumG) + s2 * 0.14, _lumB + c2 * -_lumB + s2 * -0.283, 0, 0, _lumR + c2 * -_lumR + s2 * -(1 - _lumR), _lumG + c2 * -_lumG + s2 * _lumG, _lumB + c2 * (1 - _lumB) + s2 * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m2);
  };
  var _setContrast = function _setContrast2(m2, n2) {
    return _applyMatrix([n2, 0, 0, 0, 0.5 * (1 - n2), 0, n2, 0, 0, 0.5 * (1 - n2), 0, 0, n2, 0, 0.5 * (1 - n2), 0, 0, 0, 1, 0], m2);
  };
  var _getFilter = function _getFilter2(target, type) {
    var filterClass = _filterClass(type), filters = target.filters || [], i3 = filters.length, filter;
    filterClass || _warn3(type + " not found. PixiPlugin.registerPIXI(PIXI)");
    while (--i3 > -1) {
      if (filters[i3] instanceof filterClass) {
        return filters[i3];
      }
    }
    filter = new filterClass();
    if (type === "BlurFilter") {
      if (_isV8Plus) {
        filter.strength = 0;
      } else {
        filter.blur = 0;
      }
    }
    target.filters = [].concat(filters, [filter]);
    return filter;
  };
  var _addColorMatrixFilterCacheTween = function _addColorMatrixFilterCacheTween2(p3, plugin, cache, vars) {
    plugin.add(cache, p3, cache[p3], vars[p3]);
    plugin._props.push(p3);
  };
  var _applyBrightnessToMatrix = function _applyBrightnessToMatrix2(brightness, matrix) {
    var filterClass = _filterClass("ColorMatrixFilter"), temp = new filterClass();
    temp.matrix = matrix;
    temp.brightness(brightness, true);
    return temp.matrix;
  };
  var _copy = function _copy2(obj) {
    var copy = {}, p3;
    for (p3 in obj) {
      copy[p3] = obj[p3];
    }
    return copy;
  };
  var _CMFdefaults = {
    contrast: 1,
    saturation: 1,
    colorizeAmount: 0,
    colorize: "rgb(255,255,255)",
    hue: 0,
    brightness: 1
  };
  var _parseColorMatrixFilter = function _parseColorMatrixFilter2(target, v2, pg) {
    var filter = _getFilter(target, "ColorMatrixFilter"), cache = target._gsColorMatrixFilter = target._gsColorMatrixFilter || _copy(_CMFdefaults), combine = v2.combineCMF && !("colorMatrixFilter" in v2 && !v2.colorMatrixFilter), i3, matrix, startMatrix;
    startMatrix = filter.matrix;
    if (v2.resolution) {
      filter.resolution = v2.resolution;
    }
    if (v2.matrix && v2.matrix.length === startMatrix.length) {
      matrix = v2.matrix;
      if (cache.contrast !== 1) {
        _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
      }
      if (cache.hue) {
        _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
      }
      if (cache.brightness !== 1) {
        _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
      }
      if (cache.colorizeAmount) {
        _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);
        _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
      }
      if (cache.saturation !== 1) {
        _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
      }
    } else {
      matrix = _idMatrix.slice();
      if (v2.contrast != null) {
        matrix = _setContrast(matrix, +v2.contrast);
        _addColorMatrixFilterCacheTween("contrast", pg, cache, v2);
      } else if (cache.contrast !== 1) {
        if (combine) {
          matrix = _setContrast(matrix, cache.contrast);
        } else {
          _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
        }
      }
      if (v2.hue != null) {
        matrix = _setHue(matrix, +v2.hue);
        _addColorMatrixFilterCacheTween("hue", pg, cache, v2);
      } else if (cache.hue) {
        if (combine) {
          matrix = _setHue(matrix, cache.hue);
        } else {
          _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
        }
      }
      if (v2.brightness != null) {
        matrix = _applyBrightnessToMatrix(+v2.brightness, matrix);
        _addColorMatrixFilterCacheTween("brightness", pg, cache, v2);
      } else if (cache.brightness !== 1) {
        if (combine) {
          matrix = _applyBrightnessToMatrix(cache.brightness, matrix);
        } else {
          _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
        }
      }
      if (v2.colorize != null) {
        v2.colorizeAmount = "colorizeAmount" in v2 ? +v2.colorizeAmount : 1;
        matrix = _colorize(matrix, v2.colorize, v2.colorizeAmount);
        _addColorMatrixFilterCacheTween("colorize", pg, cache, v2);
        _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, v2);
      } else if (cache.colorizeAmount) {
        if (combine) {
          matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);
        } else {
          _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);
          _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
        }
      }
      if (v2.saturation != null) {
        matrix = _setSaturation(matrix, +v2.saturation);
        _addColorMatrixFilterCacheTween("saturation", pg, cache, v2);
      } else if (cache.saturation !== 1) {
        if (combine) {
          matrix = _setSaturation(matrix, cache.saturation);
        } else {
          _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
        }
      }
    }
    i3 = matrix.length;
    while (--i3 > -1) {
      if (matrix[i3] !== startMatrix[i3]) {
        pg.add(startMatrix, i3, startMatrix[i3], matrix[i3], "colorMatrixFilter");
      }
    }
    pg._props.push("colorMatrixFilter");
  };
  var _renderColor = function _renderColor2(ratio, _ref) {
    var t2 = _ref.t, p3 = _ref.p, color = _ref.color, set = _ref.set;
    set(t2, p3, color[0] << 16 | color[1] << 8 | color[2]);
  };
  var _renderDirtyCache = function _renderDirtyCache2(ratio, _ref2) {
    var g2 = _ref2.g;
    if (_isV8Plus) {
      g2.fill();
      g2.stroke();
    } else if (g2) {
      g2.dirty++;
      g2.clearDirty++;
    }
  };
  var _renderAutoAlpha = function _renderAutoAlpha2(ratio, data) {
    data.t.visible = !!data.t.alpha;
  };
  var _addColorTween = function _addColorTween2(target, p3, value, plugin) {
    var currentValue = target[p3], startColor = _splitColor(_isFunction3(currentValue) ? target[p3.indexOf("set") || !_isFunction3(target["get" + p3.substr(3)]) ? p3 : "get" + p3.substr(3)]() : currentValue), endColor = _splitColor(value);
    plugin._pt = new PropTween2(plugin._pt, target, p3, 0, 0, _renderColor, {
      t: target,
      p: p3,
      color: startColor,
      set: _getSetter3(target, p3)
    });
    plugin.add(startColor, 0, startColor[0], endColor[0]);
    plugin.add(startColor, 1, startColor[1], endColor[1]);
    plugin.add(startColor, 2, startColor[2], endColor[2]);
  };
  var _colorProps = {
    tint: 1,
    lineColor: 1,
    fillColor: 1,
    strokeColor: 1
  };
  var _xyContexts = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(",");
  var _contexts = {
    x: "position",
    y: "position",
    tileX: "tilePosition",
    tileY: "tilePosition"
  };
  var _colorMatrixFilterProps = {
    colorMatrixFilter: 1,
    saturation: 1,
    contrast: 1,
    hue: 1,
    colorize: 1,
    colorizeAmount: 1,
    brightness: 1,
    combineCMF: 1
  };
  var _DEG2RAD2 = Math.PI / 180;
  var _isString3 = function _isString4(value) {
    return typeof value === "string";
  };
  var _degreesToRadians = function _degreesToRadians2(value) {
    return _isString3(value) && value.charAt(1) === "=" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD2 : value * _DEG2RAD2;
  };
  var _renderPropWithEnd3 = function _renderPropWithEnd4(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e5) / 1e5, data);
  };
  var _addRotationalPropTween3 = function _addRotationalPropTween4(plugin, target, property, startNum, endValue, radians) {
    var cap = 360 * (radians ? _DEG2RAD2 : 1), isString = _isString3(endValue), relative = isString && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0, endNum = parseFloat(relative ? endValue.substr(2) : endValue) * (radians ? _DEG2RAD2 : 1), change = relative ? endNum * relative : endNum - startNum, finalValue = startNum + change, direction, pt;
    if (isString) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * 1e10) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * 1e10) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween2(plugin._pt, target, property, startNum, change, _renderPropWithEnd3);
    pt.e = finalValue;
    return pt;
  };
  var _initCore3 = function _initCore4() {
    if (!_coreInitted2) {
      gsap2 = _getGSAP();
      _PIXI = _coreInitted2 = _PIXI || _windowExists5() && window.PIXI;
      var version = _PIXI && _PIXI.VERSION && parseFloat(_PIXI.VERSION.split(".")[0]) || 0;
      _isV4 = version === 4;
      _isV8Plus = version >= 8;
      _splitColor = function _splitColor2(color) {
        return gsap2.utils.splitColor((color + "").substr(0, 2) === "0x" ? "#" + color.substr(2) : color);
      };
    }
  };
  var i;
  var p;
  for (i = 0; i < _xyContexts.length; i++) {
    p = _xyContexts[i];
    _contexts[p + "X"] = p;
    _contexts[p + "Y"] = p;
  }
  var PixiPlugin = {
    version: "3.14.2",
    name: "pixi",
    register: function register(core, Plugin, propTween) {
      gsap2 = core;
      PropTween2 = propTween;
      _getSetter3 = Plugin.getSetter;
      _initCore3();
    },
    headless: true,
    // doesn't need window
    registerPIXI: function registerPIXI(pixi) {
      _PIXI = pixi;
    },
    init: function init4(target, values, tween, index, targets) {
      _PIXI || _initCore3();
      if (!_PIXI) {
        _warn3("PIXI was not found. PixiPlugin.registerPIXI(PIXI);");
        return false;
      }
      var context4, axis, value, colorMatrix, filter, p3, padding, i3, data, subProp;
      for (p3 in values) {
        context4 = _contexts[p3];
        value = values[p3];
        if (context4) {
          axis = ~p3.charAt(p3.length - 1).toLowerCase().indexOf("x") ? "x" : "y";
          this.add(target[context4], axis, target[context4][axis], context4 === "skew" ? _degreesToRadians(value) : value, 0, 0, 0, 0, 0, 1);
        } else if (p3 === "scale" || p3 === "anchor" || p3 === "pivot" || p3 === "tileScale") {
          this.add(target[p3], "x", target[p3].x, value);
          this.add(target[p3], "y", target[p3].y, value);
        } else if (p3 === "rotation" || p3 === "angle") {
          _addRotationalPropTween3(this, target, p3, target[p3], value, p3 === "rotation");
        } else if (_colorMatrixFilterProps[p3]) {
          if (!colorMatrix) {
            _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);
            colorMatrix = true;
          }
        } else if (p3 === "blur" || p3 === "blurX" || p3 === "blurY" || p3 === "blurPadding") {
          filter = _getFilter(target, "BlurFilter");
          this.add(filter, p3, filter[p3], value);
          if (values.blurPadding !== 0) {
            padding = values.blurPadding || Math.max(filter[p3], value) * 2;
            i3 = target.filters.length;
            while (--i3 > -1) {
              target.filters[i3].padding = Math.max(target.filters[i3].padding, padding);
            }
          }
        } else if (_colorProps[p3]) {
          if ((p3 === "lineColor" || p3 === "fillColor" || p3 === "strokeColor") && target instanceof _PIXI.Graphics) {
            data = "fillStyle" in target ? [target] : (target.geometry || target).graphicsData;
            subProp = p3.substr(0, p3.length - 5);
            _isV8Plus && subProp === "line" && (subProp = "stroke");
            this._pt = new PropTween2(this._pt, target, p3, 0, 0, _renderDirtyCache, {
              g: target.geometry || target
            });
            i3 = data.length;
            while (--i3 > -1) {
              _addColorTween(_isV4 ? data[i3] : data[i3][subProp + "Style"], _isV4 ? p3 : "color", value, this);
            }
          } else {
            _addColorTween(target, p3, value, this);
          }
        } else if (p3 === "autoAlpha") {
          this._pt = new PropTween2(this._pt, target, "visible", 0, 0, _renderAutoAlpha);
          this.add(target, "alpha", target.alpha, value);
          this._props.push("alpha", "visible");
        } else if (p3 !== "resolution") {
          this.add(target, p3, "get", value);
        }
        this._props.push(p3);
      }
    }
  };
  _getGSAP() && gsap2.registerPlugin(PixiPlugin);

  // node_modules/pixi.js/lib/index.mjs
  var lib_exports = {};
  __export(lib_exports, {
    AbstractBitmapFont: () => AbstractBitmapFont,
    AbstractRenderer: () => AbstractRenderer,
    AbstractSplitText: () => AbstractSplitText,
    AbstractText: () => AbstractText,
    AccessibilitySystem: () => AccessibilitySystem,
    AlphaFilter: () => AlphaFilter,
    AlphaMask: () => AlphaMask,
    AlphaMaskPipe: () => AlphaMaskPipe,
    AnimatedSprite: () => AnimatedSprite,
    Application: () => Application,
    ApplicationInitHook: () => ApplicationInitHook,
    Assets: () => Assets,
    AssetsClass: () => AssetsClass,
    BLEND_TO_NPM: () => BLEND_TO_NPM,
    BUFFER_TYPE: () => BUFFER_TYPE,
    BackgroundLoader: () => BackgroundLoader,
    BackgroundSystem: () => BackgroundSystem,
    Batch: () => Batch,
    BatchGeometry: () => BatchGeometry,
    BatchTextureArray: () => BatchTextureArray,
    BatchableGraphics: () => BatchableGraphics,
    BatchableHTMLText: () => BatchableHTMLText,
    BatchableMesh: () => BatchableMesh,
    BatchableSprite: () => BatchableSprite,
    BatchableText: () => BatchableText,
    Batcher: () => Batcher,
    BatcherPipe: () => BatcherPipe,
    BigPool: () => BigPool,
    BindGroup: () => BindGroup,
    BindGroupSystem: () => BindGroupSystem,
    BitmapFont: () => BitmapFont,
    BitmapFontManager: () => BitmapFontManager,
    BitmapText: () => BitmapText,
    BitmapTextGraphics: () => BitmapTextGraphics,
    BitmapTextPipe: () => BitmapTextPipe,
    BlendModeFilter: () => BlendModeFilter,
    BlendModePipe: () => BlendModePipe,
    BlurFilter: () => BlurFilter,
    BlurFilterPass: () => BlurFilterPass,
    Bounds: () => Bounds,
    BrowserAdapter: () => BrowserAdapter,
    Buffer: () => Buffer2,
    BufferImageSource: () => BufferImageSource,
    BufferResource: () => BufferResource,
    BufferUsage: () => BufferUsage,
    CLEAR: () => CLEAR,
    Cache: () => Cache,
    CanvasObserver: () => CanvasObserver,
    CanvasPool: () => CanvasPool,
    CanvasPoolClass: () => CanvasPoolClass,
    CanvasSource: () => CanvasSource,
    CanvasTextGenerator: () => CanvasTextGenerator,
    CanvasTextMetrics: () => CanvasTextMetrics,
    CanvasTextPipe: () => CanvasTextPipe,
    CanvasTextSystem: () => CanvasTextSystem,
    Circle: () => Circle,
    Color: () => Color,
    ColorBlend: () => ColorBlend,
    ColorBurnBlend: () => ColorBurnBlend,
    ColorDodgeBlend: () => ColorDodgeBlend,
    ColorMask: () => ColorMask,
    ColorMaskPipe: () => ColorMaskPipe,
    ColorMatrixFilter: () => ColorMatrixFilter,
    CompressedSource: () => CompressedSource,
    Container: () => Container,
    Culler: () => Culler,
    CullerPlugin: () => CullerPlugin,
    CustomRenderPipe: () => CustomRenderPipe,
    D3D10_RESOURCE_DIMENSION: () => D3D10_RESOURCE_DIMENSION,
    D3DFMT: () => D3DFMT,
    DATA_URI: () => DATA_URI,
    DDS: () => DDS,
    DEG_TO_RAD: () => DEG_TO_RAD,
    DEPRECATED_SCALE_MODES: () => DEPRECATED_SCALE_MODES,
    DEPRECATED_WRAP_MODES: () => DEPRECATED_WRAP_MODES,
    DOMAdapter: () => DOMAdapter,
    DOMContainer: () => DOMContainer,
    DOMPipe: () => DOMPipe,
    DRAW_MODES: () => DRAW_MODES,
    DXGI_FORMAT: () => DXGI_FORMAT,
    DXGI_TO_TEXTURE_FORMAT: () => DXGI_TO_TEXTURE_FORMAT,
    DarkenBlend: () => DarkenBlend,
    DefaultBatcher: () => DefaultBatcher,
    DefaultShader: () => DefaultShader,
    DifferenceBlend: () => DifferenceBlend,
    DisplacementFilter: () => DisplacementFilter,
    DivideBlend: () => DivideBlend,
    DynamicBitmapFont: () => DynamicBitmapFont,
    Ellipse: () => Ellipse,
    EventBoundary: () => EventBoundary,
    EventEmitter: () => eventemitter3_default,
    EventSystem: () => EventSystem,
    EventsTicker: () => EventsTicker,
    ExclusionBlend: () => ExclusionBlend,
    ExtensionType: () => ExtensionType,
    ExtractSystem: () => ExtractSystem,
    FOURCC_TO_TEXTURE_FORMAT: () => FOURCC_TO_TEXTURE_FORMAT,
    FederatedContainer: () => FederatedContainer,
    FederatedEvent: () => FederatedEvent,
    FederatedMouseEvent: () => FederatedMouseEvent,
    FederatedPointerEvent: () => FederatedPointerEvent,
    FederatedWheelEvent: () => FederatedWheelEvent,
    FillGradient: () => FillGradient,
    FillPattern: () => FillPattern,
    Filter: () => Filter,
    FilterEffect: () => FilterEffect,
    FilterPipe: () => FilterPipe,
    FilterSystem: () => FilterSystem,
    FontStylePromiseCache: () => FontStylePromiseCache,
    GAUSSIAN_VALUES: () => GAUSSIAN_VALUES,
    GCManagedHash: () => GCManagedHash,
    GCSystem: () => GCSystem,
    GL_FORMATS: () => GL_FORMATS,
    GL_INTERNAL_FORMAT: () => GL_INTERNAL_FORMAT,
    GL_TARGETS: () => GL_TARGETS,
    GL_TYPES: () => GL_TYPES,
    GL_WRAP_MODES: () => GL_WRAP_MODES,
    GPUTextureGpuData: () => GPUTextureGpuData,
    GenerateTextureSystem: () => GenerateTextureSystem,
    Geometry: () => Geometry,
    GlBackBufferSystem: () => GlBackBufferSystem,
    GlBatchAdaptor: () => GlBatchAdaptor,
    GlBuffer: () => GlBuffer,
    GlBufferSystem: () => GlBufferSystem,
    GlColorMaskSystem: () => GlColorMaskSystem,
    GlContextSystem: () => GlContextSystem,
    GlEncoderSystem: () => GlEncoderSystem,
    GlGeometryGpuData: () => GlGeometryGpuData,
    GlGeometrySystem: () => GlGeometrySystem,
    GlGraphicsAdaptor: () => GlGraphicsAdaptor,
    GlLimitsSystem: () => GlLimitsSystem,
    GlMeshAdaptor: () => GlMeshAdaptor,
    GlParticleContainerAdaptor: () => GlParticleContainerAdaptor,
    GlParticleContainerPipe: () => GlParticleContainerPipe,
    GlProgram: () => GlProgram,
    GlProgramData: () => GlProgramData,
    GlRenderTarget: () => GlRenderTarget,
    GlRenderTargetAdaptor: () => GlRenderTargetAdaptor,
    GlRenderTargetSystem: () => GlRenderTargetSystem,
    GlShaderSystem: () => GlShaderSystem,
    GlStateSystem: () => GlStateSystem,
    GlStencilSystem: () => GlStencilSystem,
    GlTexture: () => GlTexture,
    GlTextureSystem: () => GlTextureSystem,
    GlUboSystem: () => GlUboSystem,
    GlUniformGroupSystem: () => GlUniformGroupSystem,
    GlobalResourceRegistry: () => GlobalResourceRegistry,
    GlobalUniformSystem: () => GlobalUniformSystem,
    GpuBatchAdaptor: () => GpuBatchAdaptor,
    GpuBlendModesToPixi: () => GpuBlendModesToPixi,
    GpuBufferData: () => GpuBufferData,
    GpuBufferSystem: () => GpuBufferSystem,
    GpuColorMaskSystem: () => GpuColorMaskSystem,
    GpuDeviceSystem: () => GpuDeviceSystem,
    GpuEncoderSystem: () => GpuEncoderSystem,
    GpuGraphicsAdaptor: () => GpuGraphicsAdaptor,
    GpuGraphicsContext: () => GpuGraphicsContext,
    GpuLimitsSystem: () => GpuLimitsSystem,
    GpuMeshAdapter: () => GpuMeshAdapter,
    GpuMipmapGenerator: () => GpuMipmapGenerator,
    GpuParticleContainerAdaptor: () => GpuParticleContainerAdaptor,
    GpuParticleContainerPipe: () => GpuParticleContainerPipe,
    GpuProgram: () => GpuProgram,
    GpuRenderTarget: () => GpuRenderTarget,
    GpuRenderTargetAdaptor: () => GpuRenderTargetAdaptor,
    GpuRenderTargetSystem: () => GpuRenderTargetSystem,
    GpuShaderSystem: () => GpuShaderSystem,
    GpuStateSystem: () => GpuStateSystem,
    GpuStencilModesToPixi: () => GpuStencilModesToPixi,
    GpuStencilSystem: () => GpuStencilSystem,
    GpuTextureSystem: () => GpuTextureSystem,
    GpuUboSystem: () => GpuUboSystem,
    GpuUniformBatchPipe: () => GpuUniformBatchPipe,
    Graphics: () => Graphics,
    GraphicsContext: () => GraphicsContext,
    GraphicsContextRenderData: () => GraphicsContextRenderData,
    GraphicsContextSystem: () => GraphicsContextSystem,
    GraphicsGpuData: () => GraphicsGpuData,
    GraphicsPath: () => GraphicsPath,
    GraphicsPipe: () => GraphicsPipe,
    HTMLText: () => HTMLText,
    HTMLTextPipe: () => HTMLTextPipe,
    HTMLTextRenderData: () => HTMLTextRenderData,
    HTMLTextStyle: () => HTMLTextStyle,
    HTMLTextSystem: () => HTMLTextSystem,
    HardLightBlend: () => HardLightBlend,
    HardMixBlend: () => HardMixBlend,
    HelloSystem: () => HelloSystem,
    IGLUniformData: () => IGLUniformData,
    ImageSource: () => ImageSource,
    InstructionSet: () => InstructionSet,
    KTX: () => KTX,
    LightenBlend: () => LightenBlend,
    LinearBurnBlend: () => LinearBurnBlend,
    LinearDodgeBlend: () => LinearDodgeBlend,
    LinearLightBlend: () => LinearLightBlend,
    Loader: () => Loader,
    LoaderParserPriority: () => LoaderParserPriority,
    LuminosityBlend: () => LuminosityBlend,
    MaskEffectManager: () => MaskEffectManager,
    MaskEffectManagerClass: () => MaskEffectManagerClass,
    MaskFilter: () => MaskFilter,
    Matrix: () => Matrix,
    Mesh: () => Mesh,
    MeshGeometry: () => MeshGeometry,
    MeshGpuData: () => MeshGpuData,
    MeshPipe: () => MeshPipe,
    MeshPlane: () => MeshPlane,
    MeshRope: () => MeshRope,
    MeshSimple: () => MeshSimple,
    NOOP: () => NOOP,
    NegationBlend: () => NegationBlend,
    NineSliceGeometry: () => NineSliceGeometry,
    NineSlicePlane: () => NineSlicePlane,
    NineSliceSprite: () => NineSliceSprite,
    NineSliceSpriteGpuData: () => NineSliceSpriteGpuData,
    NineSliceSpritePipe: () => NineSliceSpritePipe,
    NoiseFilter: () => NoiseFilter,
    ObservablePoint: () => ObservablePoint,
    OverlayBlend: () => OverlayBlend,
    PI_2: () => PI_2,
    Particle: () => Particle,
    ParticleBuffer: () => ParticleBuffer,
    ParticleContainer: () => ParticleContainer,
    ParticleContainerPipe: () => ParticleContainerPipe,
    ParticleShader: () => ParticleShader,
    PassthroughFilter: () => PassthroughFilter,
    PerspectiveMesh: () => PerspectiveMesh,
    PerspectivePlaneGeometry: () => PerspectivePlaneGeometry,
    PinLightBlend: () => PinLightBlend,
    PipelineSystem: () => PipelineSystem,
    PlaneGeometry: () => PlaneGeometry,
    Point: () => Point,
    Polygon: () => Polygon,
    Pool: () => Pool,
    PoolGroupClass: () => PoolGroupClass,
    PrepareBase: () => PrepareBase,
    PrepareQueue: () => PrepareQueue,
    PrepareSystem: () => PrepareSystem,
    PrepareUpload: () => PrepareUpload,
    QuadGeometry: () => QuadGeometry,
    RAD_TO_DEG: () => RAD_TO_DEG,
    Rectangle: () => Rectangle,
    RenderContainer: () => RenderContainer,
    RenderGroup: () => RenderGroup,
    RenderGroupPipe: () => RenderGroupPipe,
    RenderGroupSystem: () => RenderGroupSystem,
    RenderLayer: () => RenderLayer,
    RenderTarget: () => RenderTarget,
    RenderTargetSystem: () => RenderTargetSystem,
    RenderTexture: () => RenderTexture,
    RenderableGCSystem: () => RenderableGCSystem,
    RendererInitHook: () => RendererInitHook,
    RendererType: () => RendererType,
    ResizePlugin: () => ResizePlugin,
    Resolver: () => Resolver,
    RopeGeometry: () => RopeGeometry,
    RoundedRectangle: () => RoundedRectangle,
    SCALE_MODES: () => SCALE_MODES,
    STENCIL_MODES: () => STENCIL_MODES,
    SVGParser: () => SVGParser,
    SaturationBlend: () => SaturationBlend,
    SchedulerSystem: () => SchedulerSystem,
    ScissorMask: () => ScissorMask,
    SdfShader: () => SdfShader,
    Shader: () => Shader,
    ShaderStage: () => ShaderStage,
    ShapePath: () => ShapePath,
    SharedRenderPipes: () => SharedRenderPipes,
    SharedSystems: () => SharedSystems,
    SoftLightBlend: () => SoftLightBlend,
    SplitBitmapText: () => SplitBitmapText,
    SplitText: () => SplitText,
    Sprite: () => Sprite,
    SpritePipe: () => SpritePipe,
    Spritesheet: () => Spritesheet,
    State: () => State,
    StencilMask: () => StencilMask,
    StencilMaskPipe: () => StencilMaskPipe,
    SubtractBlend: () => SubtractBlend,
    SystemRunner: () => SystemRunner,
    TEXTURE_FORMAT_BLOCK_SIZE: () => TEXTURE_FORMAT_BLOCK_SIZE,
    Text: () => Text,
    TextStyle: () => TextStyle,
    Texture: () => Texture,
    TextureGCSystem: () => TextureGCSystem,
    TextureMatrix: () => TextureMatrix,
    TexturePool: () => TexturePool,
    TexturePoolClass: () => TexturePoolClass,
    TextureSource: () => TextureSource,
    TextureStyle: () => TextureStyle,
    TextureUvs: () => TextureUvs,
    Ticker: () => Ticker,
    TickerListener: () => TickerListener,
    TickerPlugin: () => TickerPlugin,
    TilingSprite: () => TilingSprite,
    TilingSpriteGpuData: () => TilingSpriteGpuData,
    TilingSpritePipe: () => TilingSpritePipe,
    TilingSpriteShader: () => TilingSpriteShader,
    Transform: () => Transform,
    Triangle: () => Triangle,
    UNIFORM_TO_ARRAY_SETTERS: () => UNIFORM_TO_ARRAY_SETTERS,
    UNIFORM_TO_SINGLE_SETTERS: () => UNIFORM_TO_SINGLE_SETTERS,
    UNIFORM_TYPES_MAP: () => UNIFORM_TYPES_MAP,
    UNIFORM_TYPES_VALUES: () => UNIFORM_TYPES_VALUES,
    UPDATE_BLEND: () => UPDATE_BLEND,
    UPDATE_COLOR: () => UPDATE_COLOR,
    UPDATE_PRIORITY: () => UPDATE_PRIORITY,
    UPDATE_TRANSFORM: () => UPDATE_TRANSFORM,
    UPDATE_VISIBLE: () => UPDATE_VISIBLE,
    UboBatch: () => UboBatch,
    UboSystem: () => UboSystem,
    UniformGroup: () => UniformGroup,
    VERSION: () => VERSION,
    VideoSource: () => VideoSource,
    ViewContainer: () => ViewContainer,
    ViewSystem: () => ViewSystem,
    ViewableBuffer: () => ViewableBuffer,
    VividLightBlend: () => VividLightBlend,
    WGSL_ALIGN_SIZE_DATA: () => WGSL_ALIGN_SIZE_DATA,
    WGSL_TO_STD40_SIZE: () => WGSL_TO_STD40_SIZE,
    WRAP_MODES: () => WRAP_MODES,
    WebGLRenderer: () => WebGLRenderer,
    WebGPURenderer: () => WebGPURenderer,
    WebWorkerAdapter: () => WebWorkerAdapter,
    WorkerManager: () => WorkerManager,
    accessibilityTarget: () => accessibilityTarget,
    addBits: () => addBits,
    addMaskBounds: () => addMaskBounds,
    addMaskLocalBounds: () => addMaskLocalBounds,
    addProgramDefines: () => addProgramDefines,
    alphaFrag: () => fragment4,
    alphaWgsl: () => source3,
    appendSVGPath: () => appendSVGPath,
    applyMatrix: () => applyMatrix,
    applyProjectiveTransformationToPlane: () => applyProjectiveTransformationToPlane,
    applyStyleParams: () => applyStyleParams,
    assignWithIgnore: () => assignWithIgnore,
    autoDetectEnvironment: () => autoDetectEnvironment,
    autoDetectRenderer: () => autoDetectRenderer,
    autoDetectSource: () => autoDetectSource,
    basisTranscoderUrls: () => basisTranscoderUrls,
    bgr2rgb: () => bgr2rgb,
    bitmapFontCachePlugin: () => bitmapFontCachePlugin,
    bitmapFontTextParser: () => bitmapFontTextParser,
    bitmapFontXMLParser: () => bitmapFontXMLParser,
    bitmapFontXMLStringParser: () => bitmapFontXMLStringParser,
    bitmapTextSplit: () => bitmapTextSplit,
    blendTemplateFrag: () => blendTemplateFrag,
    blendTemplateVert: () => blendTemplateVert,
    blendTemplateWgsl: () => blendTemplate,
    blockDataMap: () => blockDataMap,
    blurTemplateWgsl: () => source4,
    boundsPool: () => boundsPool,
    browserExt: () => browserExt,
    buildAdaptiveBezier: () => buildAdaptiveBezier,
    buildAdaptiveQuadratic: () => buildAdaptiveQuadratic,
    buildArc: () => buildArc,
    buildArcTo: () => buildArcTo,
    buildArcToSvg: () => buildArcToSvg,
    buildCircle: () => buildCircle,
    buildContextBatches: () => buildContextBatches,
    buildEllipse: () => buildEllipse,
    buildGeometryFromPath: () => buildGeometryFromPath,
    buildLine: () => buildLine,
    buildPixelLine: () => buildPixelLine,
    buildPolygon: () => buildPolygon,
    buildRectangle: () => buildRectangle,
    buildRoundedRectangle: () => buildRoundedRectangle,
    buildSimpleUvs: () => buildSimpleUvs,
    buildTriangle: () => buildTriangle,
    buildUvs: () => buildUvs,
    cacheAsTextureMixin: () => cacheAsTextureMixin,
    cacheTextureArray: () => cacheTextureArray,
    calculatePathArea: () => calculatePathArea,
    calculateProjection: () => calculateProjection,
    canvasTextSplit: () => canvasTextSplit,
    checkChildrenDidChange: () => checkChildrenDidChange,
    checkDataUrl: () => checkDataUrl,
    checkExtension: () => checkExtension,
    checkForNestedPattern: () => checkForNestedPattern,
    checkMaxIfStatementsInShader: () => checkMaxIfStatementsInShader,
    childrenHelperMixin: () => childrenHelperMixin,
    cleanArray: () => cleanArray,
    cleanHash: () => cleanHash,
    clearList: () => clearList,
    closePointEps: () => closePointEps,
    collectAllRenderables: () => collectAllRenderables,
    collectRenderablesMixin: () => collectRenderablesMixin,
    color32BitToUniform: () => color32BitToUniform,
    colorBit: () => colorBit,
    colorBitGl: () => colorBitGl,
    colorMatrixFilterFrag: () => fragment5,
    colorMatrixFilterWgsl: () => source5,
    colorToUniform: () => colorToUniform,
    compareModeToGlCompare: () => compareModeToGlCompare,
    compileHighShader: () => compileHighShader,
    compileHighShaderGl: () => compileHighShaderGl,
    compileHighShaderGlProgram: () => compileHighShaderGlProgram,
    compileHighShaderGpuProgram: () => compileHighShaderGpuProgram,
    compileHooks: () => compileHooks,
    compileInputs: () => compileInputs,
    compileOutputs: () => compileOutputs,
    compileShader: () => compileShader,
    compute2DProjection: () => compute2DProjection,
    convertFormatIfRequired: () => convertFormatIfRequired,
    convertToList: () => convertToList,
    copySearchParams: () => copySearchParams,
    createIdFromString: () => createIdFromString,
    createIndicesForQuads: () => createIndicesForQuads,
    createLevelBuffers: () => createLevelBuffers,
    createLevelBuffersFromKTX: () => createLevelBuffersFromKTX,
    createStringVariations: () => createStringVariations,
    createTexture: () => createTexture,
    createUboElementsSTD40: () => createUboElementsSTD40,
    createUboElementsWGSL: () => createUboElementsWGSL,
    createUboSyncFunction: () => createUboSyncFunction,
    createUboSyncFunctionSTD40: () => createUboSyncFunctionSTD40,
    createUboSyncFunctionWGSL: () => createUboSyncFunctionWGSL,
    crossOrigin: () => crossOrigin,
    cullingMixin: () => cullingMixin,
    curveEps: () => curveEps,
    defaultFilterVert: () => vertex2,
    defaultValue: () => defaultValue,
    definedProps: () => definedProps,
    deprecation: () => deprecation,
    detectAvif: () => detectAvif,
    detectBasis: () => detectBasis,
    detectCompressed: () => detectCompressed,
    detectDefaults: () => detectDefaults,
    detectMp4: () => detectMp4,
    detectOgv: () => detectOgv,
    detectVideoAlphaMode: () => detectVideoAlphaMode,
    detectWebm: () => detectWebm,
    detectWebp: () => detectWebp,
    determineCrossOrigin: () => determineCrossOrigin,
    displacementFrag: () => fragment6,
    displacementVert: () => vertex4,
    displacementWgsl: () => source6,
    earcut: () => earcut2,
    effectsMixin: () => effectsMixin,
    ensureAttributes: () => ensureAttributes,
    ensureIsBuffer: () => ensureIsBuffer,
    ensurePrecision: () => ensurePrecision,
    ensureTextOptions: () => ensureTextOptions,
    executeInstructions: () => executeInstructions,
    extensions: () => extensions,
    extractAttributesFromGlProgram: () => extractAttributesFromGlProgram,
    extractAttributesFromGpuProgram: () => extractAttributesFromGpuProgram,
    extractFontFamilies: () => extractFontFamilies,
    extractStructAndGroups: () => extractStructAndGroups,
    extractSubpaths: () => extractSubpaths,
    extractSvgUrlId: () => extractSvgUrlId,
    fastCopy: () => fastCopy,
    findMixin: () => findMixin,
    fontStringFromTextStyle: () => fontStringFromTextStyle,
    formatShader: () => formatShader,
    fragmentGPUTemplate: () => fragmentGPUTemplate,
    fragmentGlTemplate: () => fragmentGlTemplate,
    generateArraySyncSTD40: () => generateArraySyncSTD40,
    generateArraySyncWGSL: () => generateArraySyncWGSL,
    generateBlurFragSource: () => generateBlurFragSource,
    generateBlurGlProgram: () => generateBlurGlProgram,
    generateBlurProgram: () => generateBlurProgram,
    generateBlurVertSource: () => generateBlurVertSource,
    generateGPULayout: () => generateGPULayout,
    generateGpuLayoutGroups: () => generateGpuLayoutGroups,
    generateLayout: () => generateLayout,
    generateLayoutHash: () => generateLayoutHash,
    generateParticleUpdateFunction: () => generateParticleUpdateFunction,
    generateProgram: () => generateProgram,
    generateShaderSyncCode: () => generateShaderSyncCode,
    generateTextStyleKey: () => generateTextStyleKey,
    generateTextureBatchBit: () => generateTextureBatchBit,
    generateTextureBatchBitGl: () => generateTextureBatchBitGl,
    generateTextureMatrix: () => generateTextureMatrix,
    generateUniformsSync: () => generateUniformsSync,
    getAdjustedBlendModeBlend: () => getAdjustedBlendModeBlend,
    getAttributeInfoFromFormat: () => getAttributeInfoFromFormat,
    getBatchSamplersUniformGroup: () => getBatchSamplersUniformGroup,
    getBitmapTextLayout: () => getBitmapTextLayout,
    getCanvasBoundingBox: () => getCanvasBoundingBox,
    getCanvasFillStyle: () => getCanvasFillStyle,
    getCanvasTexture: () => getCanvasTexture,
    getDefaultUniformValue: () => getDefaultUniformValue,
    getFastGlobalBounds: () => getFastGlobalBounds,
    getFastGlobalBoundsMixin: () => getFastGlobalBoundsMixin,
    getFillInstructionData: () => getFillInstructionData,
    getFontCss: () => getFontCss,
    getFontFamilyName: () => getFontFamilyName,
    getGeometryBounds: () => getGeometryBounds,
    getGlTypeFromFormat: () => getGlTypeFromFormat,
    getGlobalBounds: () => getGlobalBounds,
    getGlobalMixin: () => getGlobalMixin,
    getGlobalRenderableBounds: () => getGlobalRenderableBounds,
    getLocalBounds: () => getLocalBounds,
    getMaxFragmentPrecision: () => getMaxFragmentPrecision,
    getMaxTexturesPerBatch: () => getMaxTexturesPerBatch,
    getOrientationOfPoints: () => getOrientationOfPoints,
    getPo2TextureFromSource: () => getPo2TextureFromSource,
    getResolutionOfUrl: () => getResolutionOfUrl,
    getSVGUrl: () => getSVGUrl,
    getSupportedCompressedTextureFormats: () => getSupportedCompressedTextureFormats,
    getSupportedGPUCompressedTextureFormats: () => getSupportedGPUCompressedTextureFormats,
    getSupportedGlCompressedTextureFormats: () => getSupportedGlCompressedTextureFormats,
    getSupportedTextureFormats: () => getSupportedTextureFormats,
    getTemporaryCanvasFromImage: () => getTemporaryCanvasFromImage,
    getTestContext: () => getTestContext,
    getTextureBatchBindGroup: () => getTextureBatchBindGroup,
    getTextureDefaultMatrix: () => getTextureDefaultMatrix,
    getTextureFormatFromKTXTexture: () => getTextureFormatFromKTXTexture,
    getUboData: () => getUboData,
    getUniformData: () => getUniformData,
    getUrlExtension: () => getUrlExtension,
    glFormatToGPUFormat: () => glFormatToGPUFormat,
    glUploadBufferImageResource: () => glUploadBufferImageResource,
    glUploadCompressedTextureResource: () => glUploadCompressedTextureResource,
    glUploadImageResource: () => glUploadImageResource,
    glUploadVideoResource: () => glUploadVideoResource,
    globalUniformsBit: () => globalUniformsBit,
    globalUniformsBitGl: () => globalUniformsBitGl,
    globalUniformsUBOBitGl: () => globalUniformsUBOBitGl,
    gpuFormatToBasisTranscoderFormat: () => gpuFormatToBasisTranscoderFormat,
    gpuFormatToKTXBasisTranscoderFormat: () => gpuFormatToKTXBasisTranscoderFormat,
    gpuUploadBufferImageResource: () => gpuUploadBufferImageResource,
    gpuUploadCompressedTextureResource: () => gpuUploadCompressedTextureResource,
    gpuUploadImageResource: () => gpuUploadImageResource,
    gpuUploadVideoResource: () => gpuUploadVideoResource,
    groupD8: () => groupD8,
    hasCachedCanvasTexture: () => hasCachedCanvasTexture,
    hslWgsl: () => hsl,
    hslgl: () => hslgl,
    hslgpu: () => hslgpu,
    injectBits: () => injectBits,
    insertVersion: () => insertVersion,
    isMobile: () => isMobile2,
    isPow2: () => isPow2,
    isRenderingToScreen: () => isRenderingToScreen,
    isSafari: () => isSafari,
    isSingleItem: () => isSingleItem,
    isWebGLSupported: () => isWebGLSupported,
    isWebGPUSupported: () => isWebGPUSupported,
    ktxTranscoderUrls: () => ktxTranscoderUrls,
    loadBasis: () => loadBasis,
    loadBasisOnWorker: () => loadBasisOnWorker,
    loadBitmapFont: () => loadBitmapFont,
    loadDDS: () => loadDDS,
    loadEnvironmentExtensions: () => loadEnvironmentExtensions,
    loadFontAsBase64: () => loadFontAsBase64,
    loadFontCSS: () => loadFontCSS,
    loadImageBitmap: () => loadImageBitmap,
    loadJson: () => loadJson,
    loadKTX: () => loadKTX,
    loadKTX2: () => loadKTX2,
    loadKTX2onWorker: () => loadKTX2onWorker,
    loadSVGImage: () => loadSVGImage,
    loadSvg: () => loadSvg,
    loadTextures: () => loadTextures,
    loadTxt: () => loadTxt,
    loadVideoTextures: () => loadVideoTextures,
    loadWebFont: () => loadWebFont,
    localUniformBit: () => localUniformBit,
    localUniformBitGl: () => localUniformBitGl,
    localUniformBitGroup2: () => localUniformBitGroup2,
    localUniformMSDFBit: () => localUniformMSDFBit,
    localUniformMSDFBitGl: () => localUniformMSDFBitGl,
    log2: () => log2,
    logDebugTexture: () => logDebugTexture,
    logProgramError: () => logProgramError,
    logRenderGroupScene: () => logRenderGroupScene,
    logScene: () => logScene,
    mSDFBit: () => mSDFBit,
    mSDFBitGl: () => mSDFBitGl,
    mapFormatToGlFormat: () => mapFormatToGlFormat,
    mapFormatToGlInternalFormat: () => mapFormatToGlInternalFormat,
    mapFormatToGlType: () => mapFormatToGlType,
    mapGlToVertexFormat: () => mapGlToVertexFormat,
    mapSize: () => mapSize,
    mapType: () => mapType,
    mapWebGLBlendModesToPixi: () => mapWebGLBlendModesToPixi,
    maskFrag: () => fragment3,
    maskVert: () => vertex3,
    maskWgsl: () => source2,
    matrixPool: () => matrixPool,
    measureHtmlText: () => measureHtmlText,
    measureMixin: () => measureMixin,
    migrateFragmentFromV7toV8: () => migrateFragmentFromV7toV8,
    mipmapScaleModeToGlFilter: () => mipmapScaleModeToGlFilter,
    multiplyColors: () => multiplyColors,
    multiplyHexColors: () => multiplyHexColors,
    nextPow2: () => nextPow2,
    noiseFrag: () => fragment7,
    noiseWgsl: () => source7,
    nonCompressedFormats: () => nonCompressedFormats,
    normalizeExtensionPriority: () => normalizeExtensionPriority,
    onRenderMixin: () => onRenderMixin,
    parseDDS: () => parseDDS,
    parseFunctionBody: () => parseFunctionBody,
    parseKTX: () => parseKTX,
    parseSVGDefinitions: () => parseSVGDefinitions,
    parseSVGFloatAttribute: () => parseSVGFloatAttribute,
    parseSVGPath: () => parseSVGPath,
    parseSVGStyle: () => parseSVGStyle,
    particleData: () => particleData,
    particlesFrag: () => fragment,
    particlesVert: () => vertex,
    particlesWgsl: () => wgsl,
    passthroughFrag: () => fragment2,
    passthroughWgsl: () => source,
    path: () => path,
    pointInTriangle: () => pointInTriangle2,
    preloadVideo: () => preloadVideo,
    removeItems: () => removeItems,
    removeStructAndGroupDuplicates: () => removeStructAndGroupDuplicates,
    resetUids: () => resetUids,
    resolveCharacters: () => resolveCharacters,
    resolveCompressedTextureUrl: () => resolveCompressedTextureUrl,
    resolveJsonUrl: () => resolveJsonUrl,
    resolveTextureUrl: () => resolveTextureUrl,
    resourceToTexture: () => resourceToTexture,
    roundPixelsBit: () => roundPixelsBit,
    roundPixelsBitGl: () => roundPixelsBitGl,
    roundedShapeArc: () => roundedShapeArc,
    roundedShapeQuadraticCurve: () => roundedShapeQuadraticCurve,
    sayHello: () => sayHello,
    scaleModeToGlFilter: () => scaleModeToGlFilter,
    setBasisTranscoderPath: () => setBasisTranscoderPath,
    setKTXTranscoderPath: () => setKTXTranscoderPath,
    setPositions: () => setPositions,
    setProgramName: () => setProgramName,
    setUvs: () => setUvs,
    shapeBuilders: () => shapeBuilders,
    sortMixin: () => sortMixin,
    spritesheetAsset: () => spritesheetAsset,
    squaredDistanceToLineSegment: () => squaredDistanceToLineSegment,
    stripVersion: () => stripVersion,
    styleAttributes: () => styleAttributes,
    testImageFormat: () => testImageFormat,
    testVideoFormat: () => testVideoFormat,
    textStyleToCSS: () => textStyleToCSS,
    textureBit: () => textureBit,
    textureBitGl: () => textureBitGl,
    textureFrom: () => textureFrom,
    tilingBit: () => tilingBit,
    tilingBitGl: () => tilingBitGl,
    toFillStyle: () => toFillStyle,
    toLocalGlobalMixin: () => toLocalGlobalMixin,
    toStrokeStyle: () => toStrokeStyle,
    transformVertices: () => transformVertices,
    triangulateWithHoles: () => triangulateWithHoles,
    uboSyncFunctionsSTD40: () => uboSyncFunctionsSTD40,
    uboSyncFunctionsWGSL: () => uboSyncFunctionsWGSL,
    uid: () => uid2,
    uniformParsers: () => uniformParsers,
    unpremultiplyAlpha: () => unpremultiplyAlpha2,
    unsafeEvalSupported: () => unsafeEvalSupported,
    updateLocalTransform: () => updateLocalTransform,
    updateQuadBounds: () => updateQuadBounds,
    updateRenderGroupTransform: () => updateRenderGroupTransform,
    updateRenderGroupTransforms: () => updateRenderGroupTransforms,
    updateTextBounds: () => updateTextBounds,
    updateTransformAndChildren: () => updateTransformAndChildren,
    updateTransformBackwards: () => updateTransformBackwards,
    updateWorldTransform: () => updateWorldTransform,
    v8_0_0: () => v8_0_0,
    v8_3_4: () => v8_3_4,
    validFormats: () => validFormats,
    validateRenderables: () => validateRenderables,
    vertexGPUTemplate: () => vertexGPUTemplate,
    vertexGlTemplate: () => vertexGlTemplate,
    vkFormatToGPUFormat: () => vkFormatToGPUFormat,
    warn: () => warn,
    webworkerExt: () => webworkerExt,
    wrapModeToGlAddress: () => wrapModeToGlAddress
  });

  // node_modules/pixi.js/lib/environment-browser/browserExt.mjs
  init_Extensions();
  var browserExt = {
    extension: {
      type: ExtensionType.Environment,
      name: "browser",
      priority: -1
    },
    test: () => true,
    load: () => __async(null, null, function* () {
      yield Promise.resolve().then(() => (init_browserAll(), browserAll_exports));
    })
  };

  // node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs
  init_Extensions();
  var webworkerExt = {
    extension: {
      type: ExtensionType.Environment,
      name: "webworker",
      priority: 0
    },
    test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
    load: () => __async(null, null, function* () {
      yield Promise.resolve().then(() => (init_webworkerAll(), webworkerAll_exports));
    })
  };

  // node_modules/pixi.js/lib/index.mjs
  init_Extensions();
  init_Extensions();
  init_init6();
  init_init5();

  // node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs
  init_GlProgram();
  init_GpuProgram();
  init_UniformGroup();
  init_Texture();
  init_Filter();

  // node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.mjs
  var blendTemplateFrag = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uBlend;\n\nuniform sampler2D uTexture;\nuniform sampler2D uBackTexture;\n\n{FUNCTIONS}\n\nvoid main()\n{ \n    vec4 back = texture(uBackTexture, vTextureCoord);\n    vec4 front = texture(uTexture, vTextureCoord);\n    float blendedAlpha = front.a + back.a * (1.0 - front.a);\n    \n    {MAIN}\n}\n";

  // node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.mjs
  var blendTemplateVert = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 backgroundUv;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

  // node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs
  var blendTemplate = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlendUniforms {\n  uBlend:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(0) @binding(3) var uBackTexture: texture_2d<f32>;\n\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n{FUNCTIONS}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n\n\n   var back =  textureSample(uBackTexture, uSampler, uv);\n   var front = textureSample(uTexture, uSampler, uv);\n   var blendedAlpha = front.a + back.a * (1.0 - front.a);\n   \n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\n\n   {MAIN}\n\n   return out;\n}";

  // node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs
  var BlendModeFilter = class extends Filter {
    constructor(options) {
      const gpuOptions = options.gpu;
      const gpuSource = compileBlendModeShader(__spreadValues({ source: blendTemplate }, gpuOptions));
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source: gpuSource,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: gpuSource,
          entryPoint: "mainFragment"
        }
      });
      const glOptions = options.gl;
      const glSource = compileBlendModeShader(__spreadValues({ source: blendTemplateFrag }, glOptions));
      const glProgram3 = GlProgram.from({
        vertex: blendTemplateVert,
        fragment: glSource
      });
      const uniformGroup = new UniformGroup({
        uBlend: {
          value: 1,
          type: "f32"
        }
      });
      super({
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        blendRequired: true,
        resources: {
          blendUniforms: uniformGroup,
          uBackTexture: Texture.EMPTY
        }
      });
    }
  };
  function compileBlendModeShader(options) {
    const { source: source11, functions, main } = options;
    return source11.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
  }

  // node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs
  var hslgl = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `;

  // node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs
  var hslgpu = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;

  // node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.mjs
  var ColorBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                ${hslgl}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendColor(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                ${hslgpu}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
        }
      });
    }
  };
  ColorBlend.extension = {
    name: "color",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.mjs
  init_Extensions();
  var ColorBurnBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendColorBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
        },
        gpu: {
          functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  ColorBurnBlend.extension = {
    name: "color-burn",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.mjs
  init_Extensions();
  var ColorDodgeBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendColorDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
        }
      });
    }
  };
  ColorDodgeBlend.extension = {
    name: "color-dodge",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.mjs
  init_Extensions();
  var DarkenBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendDarken(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
        }
      });
    }
  };
  DarkenBlend.extension = {
    name: "darken",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.mjs
  init_Extensions();
  var DifferenceBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendDifference(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
        },
        gpu: {
          functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  DifferenceBlend.extension = {
    name: "difference",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.mjs
  init_Extensions();
  var DivideBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendDivide(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  DivideBlend.extension = {
    name: "divide",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.mjs
  init_Extensions();
  var ExclusionBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendExclusion(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  ExclusionBlend.extension = {
    name: "exclusion",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.mjs
  init_Extensions();
  var HardLightBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendHardLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
        },
        gpu: {
          functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
        }
      });
    }
  };
  HardLightBlend.extension = {
    name: "hard-light",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.mjs
  init_Extensions();
  var HardMixBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendHardMix(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
        },
        gpu: {
          functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  HardMixBlend.extension = {
    name: "hard-mix",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.mjs
  init_Extensions();
  var LightenBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLighten(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  LightenBlend.extension = {
    name: "lighten",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.mjs
  init_Extensions();
  var LinearBurnBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
        }
      });
    }
  };
  LinearBurnBlend.extension = {
    name: "linear-burn",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.mjs
  init_Extensions();
  var LinearDodgeBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  LinearDodgeBlend.extension = {
    name: "linear-dodge",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.mjs
  init_Extensions();
  var LinearLightBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendLinearLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  LinearLightBlend.extension = {
    name: "linear-light",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.mjs
  init_Extensions();
  var LuminosityBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                ${hslgl}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendLuminosity(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                ${hslgpu}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  LuminosityBlend.extension = {
    name: "luminosity",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.mjs
  init_Extensions();
  var NegationBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  NegationBlend.extension = {
    name: "negation",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.mjs
  init_Extensions();
  var OverlayBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float overlay(float base, float blend)
                {
                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendOverlay(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
        }
      });
    }
  };
  OverlayBlend.extension = {
    name: "overlay",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.mjs
  init_Extensions();
  var PinLightBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
        }
      });
    }
  };
  PinLightBlend.extension = {
    name: "pin-light",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.mjs
  init_Extensions();
  var SaturationBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                ${hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
            `
        },
        gpu: {
          functions: `
                ${hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
        }
      });
    }
  };
  SaturationBlend.extension = {
    name: "saturation",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.mjs
  init_Extensions();
  var SoftLightBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
        }
      });
    }
  };
  SoftLightBlend.extension = {
    name: "soft-light",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.mjs
  init_Extensions();
  var SubtractBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
        },
        gpu: {
          functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
        }
      });
    }
  };
  SubtractBlend.extension = {
    name: "subtract",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.mjs
  init_Extensions();
  var VividLightBlend = class extends BlendModeFilter {
    constructor() {
      super({
        gl: {
          functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
          main: `
                finalColor = vec4(blendVividLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
        },
        gpu: {
          functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
          main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
        }
      });
    }
  };
  VividLightBlend.extension = {
    name: "vivid-light",
    type: ExtensionType.BlendMode
  };

  // node_modules/pixi.js/lib/app/Application.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
  init_adapter();
  init_AbstractRenderer();
  var _isWebGLSupported;
  function isWebGLSupported(failIfMajorPerformanceCaveat) {
    if (_isWebGLSupported !== void 0)
      return _isWebGLSupported;
    _isWebGLSupported = (() => {
      var _a2;
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat != null ? failIfMajorPerformanceCaveat : AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!DOMAdapter.get().getWebGLRenderingContext()) {
          return false;
        }
        const canvas = DOMAdapter.get().createCanvas();
        let gl = canvas.getContext("webgl", contextOptions);
        const success = !!((_a2 = gl == null ? void 0 : gl.getContextAttributes()) == null ? void 0 : _a2.stencil);
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (_e) {
        return false;
      }
    })();
    return _isWebGLSupported;
  }

  // node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
  init_adapter();
  var _isWebGPUSupported;
  function isWebGPUSupported() {
    return __async(this, arguments, function* (options = {}) {
      if (_isWebGPUSupported !== void 0)
        return _isWebGPUSupported;
      _isWebGPUSupported = yield (() => __async(null, null, function* () {
        const gpu = DOMAdapter.get().getNavigator().gpu;
        if (!gpu) {
          return false;
        }
        try {
          const adapter = yield gpu.requestAdapter(options);
          yield adapter.requestDevice();
          return true;
        } catch (_e) {
          return false;
        }
      }))();
      return _isWebGPUSupported;
    });
  }

  // node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
  init_AbstractRenderer();
  var renderPriority = ["webgl", "webgpu", "canvas"];
  function autoDetectRenderer(options) {
    return __async(this, null, function* () {
      var _a2;
      let preferredOrder = [];
      if (options.preference) {
        preferredOrder.push(options.preference);
        renderPriority.forEach((item) => {
          if (item !== options.preference) {
            preferredOrder.push(item);
          }
        });
      } else {
        preferredOrder = renderPriority.slice();
      }
      let RendererClass;
      let finalOptions = {};
      for (let i3 = 0; i3 < preferredOrder.length; i3++) {
        const rendererType = preferredOrder[i3];
        if (rendererType === "webgpu" && (yield isWebGPUSupported())) {
          const { WebGPURenderer: WebGPURenderer2 } = yield Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
          RendererClass = WebGPURenderer2;
          finalOptions = __spreadValues(__spreadValues({}, options), options.webgpu);
          break;
        } else if (rendererType === "webgl" && isWebGLSupported(
          (_a2 = options.failIfMajorPerformanceCaveat) != null ? _a2 : AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
        )) {
          const { WebGLRenderer: WebGLRenderer2 } = yield Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
          RendererClass = WebGLRenderer2;
          finalOptions = __spreadValues(__spreadValues({}, options), options.webgl);
          break;
        } else if (rendererType === "canvas") {
          finalOptions = __spreadValues({}, options);
          throw new Error("CanvasRenderer is not yet implemented");
        }
      }
      delete finalOptions.webgpu;
      delete finalOptions.webgl;
      if (!RendererClass) {
        throw new Error("No available renderer for the current environment");
      }
      const renderer = new RendererClass();
      yield renderer.init(finalOptions);
      return renderer;
    });
  }

  // node_modules/pixi.js/lib/app/Application.mjs
  init_Container();
  init_globalHooks();
  init_deprecation();
  var _Application = class _Application2 {
    constructor(...args) {
      this.stage = new Container();
      if (args[0] !== void 0) {
        deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
      }
    }
    /**
     * Initializes the PixiJS application with the specified options.
     *
     * This method must be called after creating a new Application instance.
     * @param options - Configuration options for the application and renderer
     * @returns A promise that resolves when initialization is complete
     * @example
     * ```js
     * const app = new Application();
     *
     * // Initialize with custom options
     * await app.init({
     *     width: 800,
     *     height: 600,
     *     backgroundColor: 0x1099bb,
     *     preference: 'webgl', // or 'webgpu'
     * });
     * ```
     */
    init(options) {
      return __async(this, null, function* () {
        options = __spreadValues({}, options);
        this.stage || (this.stage = new Container());
        this.renderer = yield autoDetectRenderer(options);
        _Application2._plugins.forEach((plugin) => {
          plugin.init.call(this, options);
        });
      });
    }
    /**
     * Renders the current stage to the screen.
     *
     * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call
     * this method directly as rendering is handled automatically.
     *
     * Only use this method if you've disabled the {@link TickerPlugin} or need custom
     * render timing control.
     * @example
     * ```js
     * // Example 1: Default setup (TickerPlugin handles rendering)
     * const app = new Application();
     * await app.init();
     * // No need to call render() - TickerPlugin handles it
     *
     * // Example 2: Custom rendering loop (if TickerPlugin is disabled)
     * const app = new Application();
     * await app.init({ autoStart: false }); // Disable automatic rendering
     *
     * function animate() {
     *     app.render();
     *     requestAnimationFrame(animate);
     * }
     * animate();
     * ```
     */
    render() {
      this.renderer.render({ container: this.stage });
    }
    /**
     * Reference to the renderer's canvas element. This is the HTML element
     * that displays your application's graphics.
     * @readonly
     * @type {HTMLCanvasElement}
     * @example
     * ```js
     * // Create a new application
     * const app = new Application();
     * // Initialize the application
     * await app.init({...});
     * // Add canvas to the page
     * document.body.appendChild(app.canvas);
     *
     * // Access the canvas directly
     * console.log(app.canvas); // HTMLCanvasElement
     * ```
     */
    get canvas() {
      return this.renderer.canvas;
    }
    /**
     * Reference to the renderer's canvas element.
     * @type {HTMLCanvasElement}
     * @deprecated since 8.0.0
     * @see {@link Application#canvas}
     */
    get view() {
      deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
      return this.renderer.canvas;
    }
    /**
     * Reference to the renderer's screen rectangle. This represents the visible area of your application.
     *
     * It's commonly used for:
     * - Setting filter areas for full-screen effects
     * - Defining hit areas for screen-wide interaction
     * - Determining the visible bounds of your application
     * @readonly
     * @example
     * ```js
     * // Use as filter area for a full-screen effect
     * const blurFilter = new BlurFilter();
     * sprite.filterArea = app.screen;
     *
     * // Use as hit area for screen-wide interaction
     * const screenSprite = new Sprite();
     * screenSprite.hitArea = app.screen;
     *
     * // Get screen dimensions
     * console.log(app.screen.width, app.screen.height);
     * ```
     * @see {@link Rectangle} For all available properties and methods
     */
    get screen() {
      return this.renderer.screen;
    }
    /**
     * Destroys the application and all of its resources.
     *
     * This method should be called when you want to completely
     * clean up the application and free all associated memory.
     * @param rendererDestroyOptions - Options for destroying the renderer:
     *  - `false` or `undefined`: Preserves the canvas element (default)
     *  - `true`: Removes the canvas element
     *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal
     * @param options - Options for destroying the application:
     *  - `false` or `undefined`: Basic cleanup (default)
     *  - `true`: Complete cleanup including children
     *  - Detailed options object:
     *    - `children`: Remove children
     *    - `texture`: Destroy textures
     *    - `textureSource`: Destroy texture sources
     *    - `context`: Destroy WebGL context
     * @example
     * ```js
     * // Basic cleanup
     * app.destroy();
     *
     * // Remove canvas and do complete cleanup
     * app.destroy(true, true);
     *
     * // Remove canvas with explicit options
     * app.destroy({ removeView: true }, true);
     *
     * // Detailed cleanup with specific options
     * app.destroy(
     *     { removeView: true },
     *     {
     *         children: true,
     *         texture: true,
     *         textureSource: true,
     *         context: true
     *     }
     * );
     * ```
     * > [!WARNING] After calling destroy, the application instance should no longer be used.
     * > All properties will be null and further operations will throw errors.
     */
    destroy(rendererDestroyOptions = false, options = false) {
      const plugins = _Application2._plugins.slice(0);
      plugins.reverse();
      plugins.forEach((plugin) => {
        plugin.destroy.call(this);
      });
      this.stage.destroy(options);
      this.stage = null;
      this.renderer.destroy(rendererDestroyOptions);
      this.renderer = null;
    }
  };
  _Application._plugins = [];
  var Application = _Application;
  extensions.handleByList(ExtensionType.Application, Application._plugins);
  extensions.add(ApplicationInitHook);

  // node_modules/pixi.js/lib/assets/Assets.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs
  init_LoaderParser();
  init_copySearchParams();
  init_adapter();
  init_Extensions();
  init_path();

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs
  init_groupD8();
  init_Rectangle();
  init_Texture();
  init_AbstractBitmapFont();
  init_BitmapFontManager();
  var BitmapFont = class extends AbstractBitmapFont {
    constructor(options, url) {
      var _a2;
      super();
      const { textures, data } = options;
      Object.keys(data.pages).forEach((key) => {
        const pageData = data.pages[parseInt(key, 10)];
        const texture = textures[pageData.id];
        this.pages.push({ texture });
      });
      Object.keys(data.chars).forEach((key) => {
        var _a3;
        const charData = data.chars[key];
        const {
          frame: textureFrame,
          source: textureSource,
          rotate: textureRotate
        } = textures[charData.page];
        const frame = groupD8.transformRectCoords(
          charData,
          textureFrame,
          textureRotate,
          new Rectangle()
        );
        const texture = new Texture({
          frame,
          orig: new Rectangle(0, 0, charData.width, charData.height),
          source: textureSource,
          rotate: textureRotate
        });
        this.chars[key] = {
          id: key.codePointAt(0),
          xOffset: charData.xOffset,
          yOffset: charData.yOffset,
          xAdvance: charData.xAdvance,
          kerning: (_a3 = charData.kerning) != null ? _a3 : {},
          texture
        };
      });
      this.baseRenderedFontSize = data.fontSize;
      this.baseMeasurementFontSize = data.fontSize;
      this.fontMetrics = {
        ascent: 0,
        descent: 0,
        fontSize: data.fontSize
      };
      this.baseLineOffset = data.baseLineOffset;
      this.lineHeight = data.lineHeight;
      this.fontFamily = data.fontFamily;
      this.distanceField = (_a2 = data.distanceField) != null ? _a2 : {
        type: "none",
        range: 0
      };
      this.url = url;
    }
    /** Destroys the BitmapFont object. */
    destroy() {
      super.destroy();
      for (let i3 = 0; i3 < this.pages.length; i3++) {
        const { texture } = this.pages[i3];
        texture.destroy(true);
      }
      this.pages = null;
    }
    /**
     * Generates and installs a bitmap font with the specified options.
     * The font will be cached and available for use in BitmapText objects.
     * @param options - Setup options for font generation
     * @returns Installed font instance
     * @example
     * ```ts
     * // Install a basic font
     * BitmapFont.install({
     *     name: 'Title',
     *     style: {
     *         fontFamily: 'Arial',
     *         fontSize: 32,
     *         fill: '#ffffff'
     *     }
     * });
     *
     * // Install with advanced options
     * BitmapFont.install({
     *     name: 'Custom',
     *     style: {
     *         fontFamily: 'Arial',
     *         fontSize: 24,
     *         fill: '#00ff00',
     *         stroke: { color: '#000000', width: 2 }
     *     },
     *     chars: [['a', 'z'], ['A', 'Z'], ['0', '9']],
     *     resolution: 2,
     *     padding: 4,
     *     textureStyle: {
     *         scaleMode: 'nearest'
     *     }
     * });
     * ```
     */
    static install(options) {
      BitmapFontManager.install(options);
    }
    /**
     * Uninstalls a bitmap font from the cache.
     * This frees up memory and resources associated with the font.
     * @param name - The name of the bitmap font to uninstall
     * @example
     * ```ts
     * // Remove a font when it's no longer needed
     * BitmapFont.uninstall('MyCustomFont');
     *
     * // Clear multiple fonts
     * ['Title', 'Heading', 'Body'].forEach(BitmapFont.uninstall);
     * ```
     */
    static uninstall(name) {
      BitmapFontManager.uninstall(name);
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs
  var bitmapFontTextParser = {
    test(data) {
      return typeof data === "string" && data.startsWith("info face=");
    },
    parse(txt) {
      var _a2, _b, _c;
      const items = txt.match(/^[a-z]+\s+.+$/gm);
      const rawData = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (const i3 in items) {
        const name = items[i3].match(/^[a-z]+/gm)[0];
        const attributeList = items[i3].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
        const itemData = {};
        for (const i22 in attributeList) {
          const split = attributeList[i22].split("=");
          const key = split[0];
          const strValue = split[1].replace(/"/gm, "");
          const floatValue = parseFloat(strValue);
          const value = isNaN(floatValue) ? strValue : floatValue;
          itemData[key] = value;
        }
        rawData[name].push(itemData);
      }
      const font = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0
      };
      const [info] = rawData.info;
      const [common] = rawData.common;
      const [distanceField] = (_a2 = rawData.distanceField) != null ? _a2 : [];
      if (distanceField) {
        font.distanceField = {
          range: parseInt(distanceField.distanceRange, 10),
          type: distanceField.fieldType
        };
      }
      font.fontSize = parseInt(info.size, 10);
      font.fontFamily = info.face;
      font.lineHeight = parseInt(common.lineHeight, 10);
      const page = rawData.page;
      for (let i3 = 0; i3 < page.length; i3++) {
        font.pages.push({
          id: parseInt(page[i3].id, 10) || 0,
          file: page[i3].file
        });
      }
      const map = {};
      font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
      const char = rawData.char;
      for (let i3 = 0; i3 < char.length; i3++) {
        const charNode = char[i3];
        const id = parseInt(charNode.id, 10);
        let letter = (_c = (_b = charNode.letter) != null ? _b : charNode.char) != null ? _c : String.fromCharCode(id);
        if (letter === "space")
          letter = " ";
        map[id] = letter;
        font.chars[letter] = {
          id,
          // texture deets..
          page: parseInt(charNode.page, 10) || 0,
          x: parseInt(charNode.x, 10),
          y: parseInt(charNode.y, 10),
          width: parseInt(charNode.width, 10),
          height: parseInt(charNode.height, 10),
          xOffset: parseInt(charNode.xoffset, 10),
          yOffset: parseInt(charNode.yoffset, 10),
          xAdvance: parseInt(charNode.xadvance, 10),
          kerning: {}
        };
      }
      const kerning = rawData.kerning || [];
      for (let i3 = 0; i3 < kerning.length; i3++) {
        const first = parseInt(kerning[i3].first, 10);
        const second = parseInt(kerning[i3].second, 10);
        const amount = parseInt(kerning[i3].amount, 10);
        font.chars[map[second]].kerning[map[first]] = amount;
      }
      return font;
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs
  init_adapter();

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs
  var bitmapFontXMLParser = {
    test(data) {
      const xml = data;
      return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
    },
    parse(xml) {
      var _a2, _b;
      const data = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0
      };
      const info = xml.getElementsByTagName("info")[0];
      const common = xml.getElementsByTagName("common")[0];
      const distanceField = xml.getElementsByTagName("distanceField")[0];
      if (distanceField) {
        data.distanceField = {
          type: distanceField.getAttribute("fieldType"),
          range: parseInt(distanceField.getAttribute("distanceRange"), 10)
        };
      }
      const page = xml.getElementsByTagName("page");
      const char = xml.getElementsByTagName("char");
      const kerning = xml.getElementsByTagName("kerning");
      data.fontSize = parseInt(info.getAttribute("size"), 10);
      data.fontFamily = info.getAttribute("face");
      data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
      for (let i3 = 0; i3 < page.length; i3++) {
        data.pages.push({
          id: parseInt(page[i3].getAttribute("id"), 10) || 0,
          file: page[i3].getAttribute("file")
        });
      }
      const map = {};
      data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
      for (let i3 = 0; i3 < char.length; i3++) {
        const charNode = char[i3];
        const id = parseInt(charNode.getAttribute("id"), 10);
        let letter = (_b = (_a2 = charNode.getAttribute("letter")) != null ? _a2 : charNode.getAttribute("char")) != null ? _b : String.fromCharCode(id);
        if (letter === "space")
          letter = " ";
        map[id] = letter;
        data.chars[letter] = {
          id,
          // texture deets..
          page: parseInt(charNode.getAttribute("page"), 10) || 0,
          x: parseInt(charNode.getAttribute("x"), 10),
          y: parseInt(charNode.getAttribute("y"), 10),
          width: parseInt(charNode.getAttribute("width"), 10),
          height: parseInt(charNode.getAttribute("height"), 10),
          // render deets..
          xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
          yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
          // + baseLineOffset,
          xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
          kerning: {}
        };
      }
      for (let i3 = 0; i3 < kerning.length; i3++) {
        const first = parseInt(kerning[i3].getAttribute("first"), 10);
        const second = parseInt(kerning[i3].getAttribute("second"), 10);
        const amount = parseInt(kerning[i3].getAttribute("amount"), 10);
        data.chars[map[second]].kerning[map[first]] = amount;
      }
      return data;
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs
  var bitmapFontXMLStringParser = {
    test(data) {
      if (typeof data === "string" && data.match(/<font(\s|>)/)) {
        return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));
      }
      return false;
    },
    parse(data) {
      return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs
  var validExtensions = [".xml", ".fnt"];
  var bitmapFontCachePlugin = {
    extension: {
      type: ExtensionType.CacheParser,
      name: "cacheBitmapFont"
    },
    test: (asset) => asset instanceof BitmapFont,
    getCacheableAssets(keys, asset) {
      const out2 = {};
      keys.forEach((key) => {
        out2[key] = asset;
        out2[`${key}-bitmap`] = asset;
      });
      out2[`${asset.fontFamily}-bitmap`] = asset;
      return out2;
    }
  };
  var loadBitmapFont = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    /** used for deprecation purposes */
    name: "loadBitmapFont",
    id: "bitmap-font",
    test(url) {
      return validExtensions.includes(path.extname(url).toLowerCase());
    },
    testParse(data) {
      return __async(this, null, function* () {
        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);
      });
    },
    parse(asset, data, loader) {
      return __async(this, null, function* () {
        const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);
        const { src } = data;
        const { pages } = bitmapFontData;
        const textureUrls = [];
        const textureOptions = bitmapFontData.distanceField ? {
          scaleMode: "linear",
          alphaMode: "premultiply-alpha-on-upload",
          autoGenerateMipmaps: false,
          resolution: 1
        } : {};
        for (let i3 = 0; i3 < pages.length; ++i3) {
          const pageFile = pages[i3].file;
          let imagePath = path.join(path.dirname(src), pageFile);
          imagePath = copySearchParams(imagePath, src);
          textureUrls.push({
            src: imagePath,
            data: textureOptions
          });
        }
        const loadedTextures = yield loader.load(textureUrls);
        const textures = textureUrls.map((url) => loadedTextures[url.src]);
        const bitmapFont = new BitmapFont({
          data: bitmapFontData,
          textures
        }, src);
        return bitmapFont;
      });
    },
    load(url, _options) {
      return __async(this, null, function* () {
        const response = yield DOMAdapter.get().fetch(url);
        return yield response.text();
      });
    },
    unload(bitmapFont, _resolvedAsset, loader) {
      return __async(this, null, function* () {
        yield Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));
        bitmapFont.destroy();
      });
    }
  };

  // node_modules/pixi.js/lib/assets/Assets.mjs
  init_warn();

  // node_modules/pixi.js/lib/assets/BackgroundLoader.mjs
  var BackgroundLoader = class {
    /**
     * @param loader
     * @param verbose - should the loader log to the console
     */
    constructor(loader, verbose = false) {
      this._loader = loader;
      this._assetList = [];
      this._isLoading = false;
      this._maxConcurrent = 1;
      this.verbose = verbose;
    }
    /**
     * Adds assets to the background loading queue. Assets are loaded one at a time to minimize
     * performance impact.
     * @param assetUrls - Array of resolved assets to load in the background
     * @example
     * ```ts
     * // Add assets to background load queue
     * backgroundLoader.add([
     *     { src: 'images/level1/bg.png' },
     *     { src: 'images/level1/characters.json' }
     * ]);
     *
     * // Assets will load sequentially in the background
     * // The loader automatically pauses when high-priority loads occur
     * // e.g. Assets.load() is called
     * ```
     * @remarks
     * - Assets are loaded one at a time to minimize performance impact
     * - Loading automatically pauses when Assets.load() is called
     * - No progress tracking is available for background loading
     * - Assets are cached as they complete loading
     * @internal
     */
    add(assetUrls) {
      assetUrls.forEach((a2) => {
        this._assetList.push(a2);
      });
      if (this.verbose) {
        console.log("[BackgroundLoader] assets: ", this._assetList);
      }
      if (this._isActive && !this._isLoading) {
        void this._next();
      }
    }
    /**
     * Loads the next set of assets. Will try to load as many assets as it can at the same time.
     *
     * The max assets it will try to load at one time will be 4.
     */
    _next() {
      return __async(this, null, function* () {
        if (this._assetList.length && this._isActive) {
          this._isLoading = true;
          const toLoad = [];
          const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
          for (let i3 = 0; i3 < toLoadAmount; i3++) {
            toLoad.push(this._assetList.pop());
          }
          yield this._loader.load(toLoad);
          this._isLoading = false;
          void this._next();
        }
      });
    }
    /**
     * Controls the active state of the background loader. When active, the loader will
     * continue processing its queue. When inactive, loading is paused.
     * @returns Whether the background loader is currently active
     * @example
     * ```ts
     * // Pause background loading
     * backgroundLoader.active = false;
     *
     * // Resume background loading
     * backgroundLoader.active = true;
     *
     * // Check current state
     * console.log(backgroundLoader.active); // true/false
     *
     * // Common use case: Pause during intensive operations
     * backgroundLoader.active = false;  // Pause background loading
     * ... // Perform high-priority tasks
     * backgroundLoader.active = true;   // Resume background loading
     * ```
     * @remarks
     * - Setting to true resumes loading immediately
     * - Setting to false pauses after current asset completes
     * - Background loading is automatically paused during `Assets.load()`
     * - Assets already being loaded will complete even when set to false
     */
    get active() {
      return this._isActive;
    }
    set active(value) {
      if (this._isActive === value)
        return;
      this._isActive = value;
      if (value && !this._isLoading) {
        void this._next();
      }
    }
  };

  // node_modules/pixi.js/lib/assets/Assets.mjs
  init_Cache();

  // node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs
  init_Extensions();
  init_Texture();
  var cacheTextureArray = {
    extension: {
      type: ExtensionType.CacheParser,
      name: "cacheTextureArray"
    },
    test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
    getCacheableAssets: (keys, asset) => {
      const out2 = {};
      keys.forEach((key) => {
        asset.forEach((item, i3) => {
          out2[key + (i3 === 0 ? "" : i3 + 1)] = item;
        });
      });
      return out2;
    }
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs
  function testImageFormat(imageData) {
    return __async(this, null, function* () {
      if ("Image" in globalThis) {
        return new Promise((resolve) => {
          const image = new Image();
          image.onload = () => {
            resolve(true);
          };
          image.onerror = () => {
            resolve(false);
          };
          image.src = imageData;
        });
      }
      if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
        try {
          const blob = yield (yield fetch(imageData)).blob();
          yield createImageBitmap(blob);
        } catch (_e) {
          return false;
        }
        return true;
      }
      return false;
    });
  }

  // node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
  var detectAvif = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 1
    },
    test: () => __async(null, null, function* () {
      return testImageFormat(
        // eslint-disable-next-line max-len
        "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
      );
    }),
    add: (formats) => __async(null, null, function* () {
      return [...formats, "avif"];
    }),
    remove: (formats) => __async(null, null, function* () {
      return formats.filter((f2) => f2 !== "avif");
    })
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs
  init_Extensions();
  var imageFormats = ["png", "jpg", "jpeg"];
  var detectDefaults = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: -1
    },
    test: () => Promise.resolve(true),
    add: (formats) => __async(null, null, function* () {
      return [...formats, ...imageFormats];
    }),
    remove: (formats) => __async(null, null, function* () {
      return formats.filter((f2) => !imageFormats.includes(f2));
    })
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs
  var inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  function testVideoFormat(mimeType) {
    if (inWorker) {
      return false;
    }
    const video = document.createElement("video");
    return video.canPlayType(mimeType) !== "";
  }

  // node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
  var detectMp4 = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: () => __async(null, null, function* () {
      return testVideoFormat("video/mp4");
    }),
    add: (formats) => __async(null, null, function* () {
      return [...formats, "mp4", "m4v"];
    }),
    remove: (formats) => __async(null, null, function* () {
      return formats.filter((f2) => f2 !== "mp4" && f2 !== "m4v");
    })
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs
  init_Extensions();
  var detectOgv = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: () => __async(null, null, function* () {
      return testVideoFormat("video/ogg");
    }),
    add: (formats) => __async(null, null, function* () {
      return [...formats, "ogv"];
    }),
    remove: (formats) => __async(null, null, function* () {
      return formats.filter((f2) => f2 !== "ogv");
    })
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs
  init_Extensions();
  var detectWebm = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: () => __async(null, null, function* () {
      return testVideoFormat("video/webm");
    }),
    add: (formats) => __async(null, null, function* () {
      return [...formats, "webm"];
    }),
    remove: (formats) => __async(null, null, function* () {
      return formats.filter((f2) => f2 !== "webm");
    })
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs
  init_Extensions();
  var detectWebp = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: () => __async(null, null, function* () {
      return testImageFormat(
        "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
      );
    }),
    add: (formats) => __async(null, null, function* () {
      return [...formats, "webp"];
    }),
    remove: (formats) => __async(null, null, function* () {
      return formats.filter((f2) => f2 !== "webp");
    })
  };

  // node_modules/pixi.js/lib/assets/loader/Loader.mjs
  init_warn();
  init_path();
  init_convertToList();
  init_isSingleItem();
  var _Loader = class _Loader2 {
    constructor() {
      this.loadOptions = __spreadValues({}, _Loader2.defaultOptions);
      this._parsers = [];
      this._parsersValidated = false;
      this.parsers = new Proxy(this._parsers, {
        set: (target, key, value) => {
          this._parsersValidated = false;
          target[key] = value;
          return true;
        }
      });
      this.promiseCache = {};
    }
    /** function used for testing */
    reset() {
      this._parsersValidated = false;
      this.promiseCache = {};
    }
    /**
     * Used internally to generate a promise for the asset to be loaded.
     * @param url - The URL to be loaded
     * @param data - any custom additional information relevant to the asset being loaded
     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
     */
    _getLoadPromiseAndParser(url, data) {
      const result = {
        promise: null,
        parser: null
      };
      result.promise = (() => __async(this, null, function* () {
        var _a2, _b;
        let asset = null;
        let parser = null;
        if (data.parser || data.loadParser) {
          parser = this._parserHash[data.parser || data.loadParser];
          if (data.loadParser) {
            warn(
              `[Assets] "loadParser" is deprecated, use "parser" instead for ${url}`
            );
          }
          if (!parser) {
            warn(
              `[Assets] specified load parser "${data.parser || data.loadParser}" not found while loading ${url}`
            );
          }
        }
        if (!parser) {
          for (let i3 = 0; i3 < this.parsers.length; i3++) {
            const parserX = this.parsers[i3];
            if (parserX.load && ((_a2 = parserX.test) == null ? void 0 : _a2.call(parserX, url, data, this))) {
              parser = parserX;
              break;
            }
          }
          if (!parser) {
            warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
            return null;
          }
        }
        asset = yield parser.load(url, data, this);
        result.parser = parser;
        for (let i3 = 0; i3 < this.parsers.length; i3++) {
          const parser2 = this.parsers[i3];
          if (parser2.parse) {
            if (parser2.parse && (yield (_b = parser2.testParse) == null ? void 0 : _b.call(parser2, asset, data, this))) {
              asset = (yield parser2.parse(asset, data, this)) || asset;
              result.parser = parser2;
            }
          }
        }
        return asset;
      }))();
      return result;
    }
    load(assetsToLoadIn, onProgressOrOptions) {
      return __async(this, null, function* () {
        if (!this._parsersValidated) {
          this._validateParsers();
        }
        const options = typeof onProgressOrOptions === "function" ? __spreadProps(__spreadValues(__spreadValues({}, _Loader2.defaultOptions), this.loadOptions), { onProgress: onProgressOrOptions }) : __spreadValues(__spreadValues(__spreadValues({}, _Loader2.defaultOptions), this.loadOptions), onProgressOrOptions || {});
        const { onProgress, onError, strategy, retryCount, retryDelay } = options;
        let count2 = 0;
        const assets = {};
        const singleAsset = isSingleItem(assetsToLoadIn);
        const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
          alias: [item],
          src: item,
          data: {}
        }));
        const total = assetsToLoad.reduce((sum, asset) => sum + (asset.progressSize || 1), 0);
        const promises = assetsToLoad.map((asset) => __async(this, null, function* () {
          const url = path.toAbsolute(asset.src);
          if (assets[asset.src])
            return;
          yield this._loadAssetWithRetry(url, asset, { onProgress, onError, strategy, retryCount, retryDelay }, assets);
          count2 += asset.progressSize || 1;
          if (onProgress)
            onProgress(count2 / total);
        }));
        yield Promise.all(promises);
        return singleAsset ? assets[assetsToLoad[0].src] : assets;
      });
    }
    /**
     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
     * The parser that created the asset, will be the one that unloads it.
     * @example
     * // Single asset:
     * const asset = await Loader.load('cool.png');
     *
     * await Loader.unload('cool.png');
     *
     * console.log(asset.destroyed); // true
     * @param assetsToUnloadIn - urls that you want to unload, or a single one!
     */
    unload(assetsToUnloadIn) {
      return __async(this, null, function* () {
        const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
          alias: [item],
          src: item
        }));
        const promises = assetsToUnload.map((asset) => __async(this, null, function* () {
          var _a2, _b;
          const url = path.toAbsolute(asset.src);
          const loadPromise = this.promiseCache[url];
          if (loadPromise) {
            const loadedAsset = yield loadPromise.promise;
            delete this.promiseCache[url];
            yield (_b = (_a2 = loadPromise.parser) == null ? void 0 : _a2.unload) == null ? void 0 : _b.call(_a2, loadedAsset, asset, this);
          }
        }));
        yield Promise.all(promises);
      });
    }
    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
    _validateParsers() {
      this._parsersValidated = true;
      this._parserHash = this._parsers.filter((parser) => parser.name || parser.id).reduce((hash, parser) => {
        if (!parser.name && !parser.id) {
          warn(`[Assets] parser should have an id`);
        } else if (hash[parser.name] || hash[parser.id]) {
          warn(`[Assets] parser id conflict "${parser.id}"`);
        }
        hash[parser.name] = parser;
        if (parser.id)
          hash[parser.id] = parser;
        return hash;
      }, {});
    }
    _loadAssetWithRetry(url, asset, options, assets) {
      return __async(this, null, function* () {
        let attempt = 0;
        const { onError, strategy, retryCount, retryDelay } = options;
        const wait = (ms) => new Promise((r2) => setTimeout(r2, ms));
        while (true) {
          try {
            if (!this.promiseCache[url]) {
              this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
            }
            assets[asset.src] = yield this.promiseCache[url].promise;
            return;
          } catch (e2) {
            delete this.promiseCache[url];
            delete assets[asset.src];
            attempt++;
            const isLast = strategy !== "retry" || attempt > retryCount;
            if (strategy === "retry" && !isLast) {
              if (onError)
                onError(e2, asset);
              yield wait(retryDelay);
              continue;
            }
            if (strategy === "skip") {
              if (onError)
                onError(e2, asset);
              return;
            }
            if (onError)
              onError(e2, asset);
            const error = new Error(`[Loader.load] Failed to load ${url}.
${e2}`);
            if (e2 instanceof Error && e2.stack) {
              error.stack = e2.stack;
            }
            throw error;
          }
        }
      });
    }
  };
  _Loader.defaultOptions = {
    onProgress: void 0,
    onError: void 0,
    strategy: "throw",
    retryCount: 3,
    retryDelay: 250
  };
  var Loader = _Loader;

  // node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
  init_adapter();
  init_Extensions();

  // node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs
  function checkDataUrl(url, mimes) {
    if (Array.isArray(mimes)) {
      for (const mime of mimes) {
        if (url.startsWith(`data:${mime}`))
          return true;
      }
      return false;
    }
    return url.startsWith(`data:${mimes}`);
  }

  // node_modules/pixi.js/lib/assets/utils/checkExtension.mjs
  init_path();
  function checkExtension(url, extension) {
    const tempURL = url.split("?")[0];
    const ext = path.extname(tempURL).toLowerCase();
    if (Array.isArray(extension)) {
      return extension.includes(ext);
    }
    return ext === extension;
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
  init_LoaderParser();
  var validJSONExtension = ".json";
  var validJSONMIME = "application/json";
  var loadJson = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    /** used for deprecation purposes */
    name: "loadJson",
    id: "json",
    test(url) {
      return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);
    },
    load(url) {
      return __async(this, null, function* () {
        const response = yield DOMAdapter.get().fetch(url);
        const json = yield response.json();
        return json;
      });
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs
  init_adapter();
  init_Extensions();
  init_LoaderParser();
  var validTXTExtension = ".txt";
  var validTXTMIME = "text/plain";
  var loadTxt = {
    /** used for deprecation purposes */
    name: "loadTxt",
    id: "text",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low,
      name: "loadTxt"
    },
    test(url) {
      return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);
    },
    load(url) {
      return __async(this, null, function* () {
        const response = yield DOMAdapter.get().fetch(url);
        const txt = yield response.text();
        return txt;
      });
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs
  init_adapter();
  init_Extensions();
  init_warn();
  init_path();
  init_Cache();
  init_LoaderParser();
  var validWeights = [
    "normal",
    "bold",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900"
  ];
  var validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
  var validFontMIMEs = [
    "font/ttf",
    "font/otf",
    "font/woff",
    "font/woff2"
  ];
  var CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
  function getFontFamilyName(url) {
    const ext = path.extname(url);
    const name = path.basename(url, ext);
    const nameWithSpaces = name.replace(/(-|_)/g, " ");
    const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
    let valid = nameTokens.length > 0;
    for (const token of nameTokens) {
      if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
        valid = false;
        break;
      }
    }
    let fontFamilyName = nameTokens.join(" ");
    if (!valid) {
      fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\/* inject:js */")}"`;
    }
    return fontFamilyName;
  }
  var validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\/* inject:js */'()\*\+,;=\-._~]*$/;
  function encodeURIWhenNeeded(uri) {
    if (validURICharactersRegex.test(uri)) {
      return uri;
    }
    return encodeURI(uri);
  }
  var loadWebFont = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    /** used for deprecation purposes */
    name: "loadWebFont",
    id: "web-font",
    test(url) {
      return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);
    },
    load(url, options) {
      return __async(this, null, function* () {
        var _a2, _b, _c, _d, _e, _f;
        const fonts = DOMAdapter.get().getFontFaceSet();
        if (fonts) {
          const fontFaces = [];
          const name = (_b = (_a2 = options.data) == null ? void 0 : _a2.family) != null ? _b : getFontFamilyName(url);
          const weights = (_e = (_d = (_c = options.data) == null ? void 0 : _c.weights) == null ? void 0 : _d.filter((weight) => validWeights.includes(weight))) != null ? _e : ["normal"];
          const data = (_f = options.data) != null ? _f : {};
          for (let i3 = 0; i3 < weights.length; i3++) {
            const weight = weights[i3];
            const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, __spreadProps(__spreadValues({}, data), {
              weight
            }));
            yield font.load();
            fonts.add(font);
            fontFaces.push(font);
          }
          if (Cache.has(`${name}-and-url`)) {
            const cached = Cache.get(`${name}-and-url`);
            cached.entries.push({ url, faces: fontFaces });
          } else {
            Cache.set(`${name}-and-url`, {
              entries: [{ url, faces: fontFaces }]
            });
          }
          return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
        }
        warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
        return null;
      });
    },
    unload(font) {
      const fonts = Array.isArray(font) ? font : [font];
      const fontFamily = fonts[0].family;
      const cached = Cache.get(`${fontFamily}-and-url`);
      const entry = cached.entries.find((f2) => f2.faces.some((t2) => fonts.indexOf(t2) !== -1));
      entry.faces = entry.faces.filter((f2) => fonts.indexOf(f2) === -1);
      if (entry.faces.length === 0) {
        cached.entries = cached.entries.filter((f2) => f2 !== entry);
      }
      fonts.forEach((t2) => {
        DOMAdapter.get().getFontFaceSet().delete(t2);
      });
      if (cached.entries.length === 0) {
        Cache.remove(`${fontFamily}-and-url`);
      }
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
  init_adapter();
  init_Extensions();
  init_ImageSource();
  init_GraphicsContext();

  // node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs
  init_Resolver();
  function getResolutionOfUrl(url, defaultValue2 = 1) {
    var _a2;
    const resolution = (_a2 = Resolver.RETINA_PREFIX) == null ? void 0 : _a2.exec(url);
    if (resolution) {
      return parseFloat(resolution[1]);
    }
    return defaultValue2;
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
  init_LoaderParser();

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs
  init_Texture();
  init_warn();
  init_Cache();
  function createTexture(source11, loader, url) {
    source11.label = url;
    source11._sourceOrigin = url;
    const texture = new Texture({
      source: source11,
      label: url
    });
    const unload = () => {
      delete loader.promiseCache[url];
      if (Cache.has(url)) {
        Cache.remove(url);
      }
    };
    texture.source.once("destroy", () => {
      if (loader.promiseCache[url]) {
        warn("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.");
        unload();
      }
    });
    texture.once("destroy", () => {
      if (!source11.destroyed) {
        warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
        unload();
      }
    });
    return texture;
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
  var validSVGExtension = ".svg";
  var validSVGMIME = "image/svg+xml";
  var loadSvg = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low,
      name: "loadSVG"
    },
    /** used for deprecation purposes */
    name: "loadSVG",
    id: "svg",
    config: {
      crossOrigin: "anonymous",
      parseAsGraphicsContext: false
    },
    test(url) {
      return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);
    },
    load(url, asset, loader) {
      return __async(this, null, function* () {
        var _a2, _b;
        if ((_b = (_a2 = asset.data) == null ? void 0 : _a2.parseAsGraphicsContext) != null ? _b : this.config.parseAsGraphicsContext) {
          return loadAsGraphics(url);
        }
        return loadAsTexture(url, asset, loader, this.config.crossOrigin);
      });
    },
    unload(asset) {
      asset.destroy(true);
    }
  };
  function loadAsTexture(url, asset, loader, crossOrigin2) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f;
      const response = yield DOMAdapter.get().fetch(url);
      const image = DOMAdapter.get().createImage();
      image.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(yield response.text())}`;
      image.crossOrigin = crossOrigin2;
      yield image.decode();
      const width = (_b = (_a2 = asset.data) == null ? void 0 : _a2.width) != null ? _b : image.width;
      const height = (_d = (_c = asset.data) == null ? void 0 : _c.height) != null ? _d : image.height;
      const resolution = ((_e = asset.data) == null ? void 0 : _e.resolution) || getResolutionOfUrl(url);
      const canvasWidth = Math.ceil(width * resolution);
      const canvasHeight = Math.ceil(height * resolution);
      const canvas = DOMAdapter.get().createCanvas(canvasWidth, canvasHeight);
      const context4 = canvas.getContext("2d");
      context4.imageSmoothingEnabled = true;
      context4.imageSmoothingQuality = "high";
      context4.drawImage(image, 0, 0, width * resolution, height * resolution);
      const _g = (_f = asset.data) != null ? _f : {}, { parseAsGraphicsContext: _p } = _g, rest = __objRest(_g, ["parseAsGraphicsContext"]);
      const base = new ImageSource(__spreadValues({
        resource: canvas,
        alphaMode: "premultiply-alpha-on-upload",
        resolution
      }, rest));
      return createTexture(base, loader, url);
    });
  }
  function loadAsGraphics(url) {
    return __async(this, null, function* () {
      const response = yield DOMAdapter.get().fetch(url);
      const svgSource = yield response.text();
      const context4 = new GraphicsContext();
      context4.svg(svgSource);
      return context4;
    });
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
  init_adapter();
  init_Extensions();
  init_ImageSource();

  // node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs
  var WORKER_CODE = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
  var WORKER_URL = null;
  var WorkerInstance = class {
    constructor() {
      if (!WORKER_URL) {
        WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: "application/javascript" }));
      }
      this.worker = new Worker(WORKER_URL);
    }
  };
  WorkerInstance.revokeObjectURL = function revokeObjectURL() {
    if (WORKER_URL) {
      URL.revokeObjectURL(WORKER_URL);
      WORKER_URL = null;
    }
  };

  // node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs
  var WORKER_CODE2 = '(function () {\n    \'use strict\';\n\n    async function loadImageBitmap(url, alphaMode) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n';
  var WORKER_URL2 = null;
  var WorkerInstance2 = class {
    constructor() {
      if (!WORKER_URL2) {
        WORKER_URL2 = URL.createObjectURL(new Blob([WORKER_CODE2], { type: "application/javascript" }));
      }
      this.worker = new Worker(WORKER_URL2);
    }
  };
  WorkerInstance2.revokeObjectURL = function revokeObjectURL2() {
    if (WORKER_URL2) {
      URL.revokeObjectURL(WORKER_URL2);
      WORKER_URL2 = null;
    }
  };

  // node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs
  var UUID = 0;
  var MAX_WORKERS;
  var WorkerManagerClass = class {
    constructor() {
      this._initialized = false;
      this._createdWorkers = 0;
      this._workerPool = [];
      this._queue = [];
      this._resolveHash = {};
    }
    /**
     * Checks if ImageBitmap is supported in the current environment.
     *
     * This method uses a dedicated worker to test ImageBitmap support
     * and caches the result for subsequent calls.
     * @returns Promise that resolves to true if ImageBitmap is supported, false otherwise
     */
    isImageBitmapSupported() {
      if (this._isImageBitmapSupported !== void 0)
        return this._isImageBitmapSupported;
      this._isImageBitmapSupported = new Promise((resolve) => {
        const { worker } = new WorkerInstance();
        worker.addEventListener("message", (event) => {
          worker.terminate();
          WorkerInstance.revokeObjectURL();
          resolve(event.data);
        });
      });
      return this._isImageBitmapSupported;
    }
    /**
     * Loads an image as an ImageBitmap using a web worker.
     * @param src - The source URL or path of the image to load
     * @param asset - Optional resolved asset containing additional texture source options
     * @returns Promise that resolves to the loaded ImageBitmap
     * @example
     * ```typescript
     * const bitmap = await WorkerManager.loadImageBitmap('image.png');
     * const bitmapWithOptions = await WorkerManager.loadImageBitmap('image.png', asset);
     * ```
     */
    loadImageBitmap(src, asset) {
      var _a2;
      return this._run("loadImageBitmap", [src, (_a2 = asset == null ? void 0 : asset.data) == null ? void 0 : _a2.alphaMode]);
    }
    /**
     * Initializes the worker pool if not already initialized.
     * Currently a no-op but reserved for future initialization logic.
     */
    _initWorkers() {
      return __async(this, null, function* () {
        if (this._initialized)
          return;
        this._initialized = true;
      });
    }
    /**
     * Gets an available worker from the pool or creates a new one if needed.
     *
     * Workers are created up to the MAX_WORKERS limit (based on navigator.hardwareConcurrency).
     * Each worker is configured with a message handler for processing results.
     * @returns Available worker or undefined if pool is at capacity and no workers are free
     */
    _getWorker() {
      if (MAX_WORKERS === void 0) {
        MAX_WORKERS = navigator.hardwareConcurrency || 4;
      }
      let worker = this._workerPool.pop();
      if (!worker && this._createdWorkers < MAX_WORKERS) {
        this._createdWorkers++;
        worker = new WorkerInstance2().worker;
        worker.addEventListener("message", (event) => {
          this._complete(event.data);
          this._returnWorker(event.target);
          this._next();
        });
      }
      return worker;
    }
    /**
     * Returns a worker to the pool after completing a task.
     * @param worker - The worker to return to the pool
     */
    _returnWorker(worker) {
      this._workerPool.push(worker);
    }
    /**
     * Handles completion of a worker task by resolving or rejecting the corresponding promise.
     * @param data - Result data from the worker containing uuid, data, and optional error
     */
    _complete(data) {
      if (!this._resolveHash[data.uuid]) {
        return;
      }
      if (data.error !== void 0) {
        this._resolveHash[data.uuid].reject(data.error);
      } else {
        this._resolveHash[data.uuid].resolve(data.data);
      }
      delete this._resolveHash[data.uuid];
    }
    /**
     * Executes a task using the worker pool system.
     *
     * Queues the task and processes it when a worker becomes available.
     * @param id - Identifier for the type of task to run
     * @param args - Arguments to pass to the worker
     * @returns Promise that resolves with the worker's result
     */
    _run(id, args) {
      return __async(this, null, function* () {
        yield this._initWorkers();
        const promise2 = new Promise((resolve, reject) => {
          this._queue.push({ id, arguments: args, resolve, reject });
        });
        this._next();
        return promise2;
      });
    }
    /**
     * Processes the next item in the queue if workers are available.
     *
     * This method is called after worker initialization and when workers
     * complete tasks to continue processing the queue.
     */
    _next() {
      if (!this._queue.length)
        return;
      const worker = this._getWorker();
      if (!worker) {
        return;
      }
      const toDo = this._queue.pop();
      const id = toDo.id;
      this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
      worker.postMessage({
        data: toDo.arguments,
        uuid: UUID++,
        id
      });
    }
    /**
     * Resets the worker manager, terminating all workers and clearing the queue.
     *
     * This method:
     * - Terminates all active workers
     * - Rejects all pending promises with an error
     * - Clears all internal state
     * - Resets initialization flags
     *
     * This should be called when the worker manager is no longer needed
     * to prevent memory leaks and ensure proper cleanup.
     * @example
     * ```typescript
     * // Clean up when shutting down
     * WorkerManager.reset();
     * ```
     */
    reset() {
      this._workerPool.forEach((worker) => worker.terminate());
      this._workerPool.length = 0;
      Object.values(this._resolveHash).forEach(({ reject }) => {
        reject == null ? void 0 : reject(new Error("WorkerManager has been reset before completion"));
      });
      this._resolveHash = {};
      this._queue.length = 0;
      this._initialized = false;
      this._createdWorkers = 0;
    }
  };
  var WorkerManager = new WorkerManagerClass();

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
  init_LoaderParser();
  var validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
  var validImageMIMEs = [
    "image/jpeg",
    "image/png",
    "image/webp",
    "image/avif"
  ];
  function loadImageBitmap(url, asset) {
    return __async(this, null, function* () {
      var _a2;
      const response = yield DOMAdapter.get().fetch(url);
      if (!response.ok) {
        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
      }
      const imageBlob = yield response.blob();
      return ((_a2 = asset == null ? void 0 : asset.data) == null ? void 0 : _a2.alphaMode) === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    });
  }
  var loadTextures = {
    /** used for deprecation purposes */
    name: "loadTextures",
    id: "texture",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High,
      name: "loadTextures"
    },
    config: {
      preferWorkers: true,
      preferCreateImageBitmap: true,
      crossOrigin: "anonymous"
    },
    test(url) {
      return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);
    },
    load(url, asset, loader) {
      return __async(this, null, function* () {
        var _a2;
        let src = null;
        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
          if (this.config.preferWorkers && (yield WorkerManager.isImageBitmapSupported())) {
            src = yield WorkerManager.loadImageBitmap(url, asset);
          } else {
            src = yield loadImageBitmap(url, asset);
          }
        } else {
          src = yield new Promise((resolve, reject) => {
            src = DOMAdapter.get().createImage();
            src.crossOrigin = this.config.crossOrigin;
            src.src = url;
            if (src.complete) {
              resolve(src);
            } else {
              src.onload = () => {
                resolve(src);
              };
              src.onerror = reject;
            }
          });
        }
        const base = new ImageSource(__spreadValues({
          resource: src,
          alphaMode: "premultiply-alpha-on-upload",
          resolution: ((_a2 = asset.data) == null ? void 0 : _a2.resolution) || getResolutionOfUrl(url)
        }, asset.data));
        return createTexture(base, loader, url);
      });
    },
    unload(texture) {
      texture.destroy(true);
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs
  init_Extensions();
  init_VideoSource();
  init_detectVideoAlphaMode();
  var potentialVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
  var validVideoExtensions;
  var validVideoMIMEs;
  function crossOrigin(element, url, crossorigin) {
    if (crossorigin === void 0 && !url.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin(url);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  function preloadVideo(element) {
    return new Promise((resolve, reject) => {
      element.addEventListener("canplaythrough", loaded);
      element.addEventListener("error", error);
      element.load();
      function loaded() {
        cleanup();
        resolve();
      }
      function error(err) {
        cleanup();
        reject(err);
      }
      function cleanup() {
        element.removeEventListener("canplaythrough", loaded);
        element.removeEventListener("error", error);
      }
    });
  }
  function determineCrossOrigin(url, loc = globalThis.location) {
    if (url.startsWith("data:")) {
      return "";
    }
    loc || (loc = globalThis.location);
    const parsedUrl = new URL(url, document.baseURI);
    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }
  function getBrowserSupportedVideoExtensions() {
    const supportedExtensions = [];
    const supportedMimes = [];
    for (const ext of potentialVideoExtensions) {
      const mimeType = VideoSource.MIME_TYPES[ext.substring(1)] || `video/${ext.substring(1)}`;
      if (testVideoFormat(mimeType)) {
        supportedExtensions.push(ext);
        if (!supportedMimes.includes(mimeType)) {
          supportedMimes.push(mimeType);
        }
      }
    }
    return {
      validVideoExtensions: supportedExtensions,
      validVideoMime: supportedMimes
    };
  }
  var loadVideoTextures = {
    /** used for deprecation purposes */
    name: "loadVideo",
    id: "video",
    extension: {
      type: ExtensionType.LoadParser,
      name: "loadVideo"
    },
    test(url) {
      if (!validVideoExtensions || !validVideoMIMEs) {
        const { validVideoExtensions: ve, validVideoMime: vm } = getBrowserSupportedVideoExtensions();
        validVideoExtensions = ve;
        validVideoMIMEs = vm;
      }
      const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);
      const isValidExtension = checkExtension(url, validVideoExtensions);
      return isValidDataUrl || isValidExtension;
    },
    load(url, asset, loader) {
      return __async(this, null, function* () {
        var _a2, _b;
        const options = __spreadValues(__spreadProps(__spreadValues({}, VideoSource.defaultOptions), {
          resolution: ((_a2 = asset.data) == null ? void 0 : _a2.resolution) || getResolutionOfUrl(url),
          alphaMode: ((_b = asset.data) == null ? void 0 : _b.alphaMode) || (yield detectVideoAlphaMode())
        }), asset.data);
        const videoElement = document.createElement("video");
        const attributeMap = {
          preload: options.autoLoad !== false ? "auto" : void 0,
          "webkit-playsinline": options.playsinline !== false ? "" : void 0,
          playsinline: options.playsinline !== false ? "" : void 0,
          muted: options.muted === true ? "" : void 0,
          loop: options.loop === true ? "" : void 0,
          autoplay: options.autoPlay !== false ? "" : void 0
        };
        Object.keys(attributeMap).forEach((key) => {
          const value = attributeMap[key];
          if (value !== void 0)
            videoElement.setAttribute(key, value);
        });
        if (options.muted === true) {
          videoElement.muted = true;
        }
        crossOrigin(videoElement, url, options.crossorigin);
        const sourceElement = document.createElement("source");
        let mime;
        if (options.mime) {
          mime = options.mime;
        } else if (url.startsWith("data:")) {
          mime = url.slice(5, url.indexOf(";"));
        } else if (!url.startsWith("blob:")) {
          const ext = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase();
          mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;
        }
        sourceElement.src = url;
        if (mime) {
          sourceElement.type = mime;
        }
        return new Promise((resolve) => {
          const onCanPlay = () => __async(null, null, function* () {
            const base = new VideoSource(__spreadProps(__spreadValues({}, options), { resource: videoElement }));
            videoElement.removeEventListener("canplay", onCanPlay);
            if (asset.data.preload) {
              yield preloadVideo(videoElement);
            }
            resolve(createTexture(base, loader, url));
          });
          if (options.preload && !options.autoPlay) {
            videoElement.load();
          }
          videoElement.addEventListener("canplay", onCanPlay);
          videoElement.appendChild(sourceElement);
        });
      });
    },
    unload(texture) {
      texture.destroy(true);
    }
  };

  // node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs
  init_Extensions();
  init_Resolver();

  // node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs
  init_Extensions();
  init_Resolver();
  var resolveTextureUrl = {
    extension: {
      type: ExtensionType.ResolveParser,
      name: "resolveTexture"
    },
    test: loadTextures.test,
    parse: (value) => {
      var _a2, _b;
      return {
        resolution: parseFloat((_b = (_a2 = Resolver.RETINA_PREFIX.exec(value)) == null ? void 0 : _a2[1]) != null ? _b : "1"),
        format: value.split(".").pop(),
        src: value
      };
    }
  };

  // node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs
  var resolveJsonUrl = {
    extension: {
      type: ExtensionType.ResolveParser,
      priority: -2,
      name: "resolveJson"
    },
    test: (value) => Resolver.RETINA_PREFIX.test(value) && value.endsWith(".json"),
    parse: resolveTextureUrl.parse
  };

  // node_modules/pixi.js/lib/assets/Assets.mjs
  init_Resolver();
  init_convertToList();
  init_isSingleItem();
  var AssetsClass = class {
    constructor() {
      this._detections = [];
      this._initialized = false;
      this.resolver = new Resolver();
      this.loader = new Loader();
      this.cache = Cache;
      this._backgroundLoader = new BackgroundLoader(this.loader);
      this._backgroundLoader.active = true;
      this.reset();
    }
    /**
     * Initializes the Assets class with configuration options. While not required,
     * calling this before loading assets is recommended to set up default behaviors.
     * @param options - Configuration options for the Assets system
     * @example
     * ```ts
     * // Basic initialization (optional as Assets.load will call this automatically)
     * await Assets.init();
     *
     * // With CDN configuration
     * await Assets.init({
     *     basePath: 'https://my-cdn.com/assets/',
     *     defaultSearchParams: { version: '1.0.0' }
     * });
     *
     * // With manifest and preferences
     * await Assets.init({
     *     manifest: {
     *         bundles: [{
     *             name: 'game-screen',
     *             assets: [
     *                 {
     *                     alias: 'hero',
     *                     src: 'hero.{png,webp}',
     *                     data: { scaleMode: SCALE_MODES.NEAREST }
     *                 },
     *                 {
     *                     alias: 'map',
     *                     src: 'map.json'
     *                 }
     *             ]
     *         }]
     *     },
     *     // Optimize for device capabilities
     *     texturePreference: {
     *         resolution: window.devicePixelRatio,
     *         format: ['webp', 'png']
     *     },
     *     // Set global preferences
     *     preferences: {
     *         crossOrigin: 'anonymous',
     *     }
     * });
     *
     * // Load assets after initialization
     * const heroTexture = await Assets.load('hero');
     * ```
     * @remarks
     * - Can be called only once; subsequent calls will be ignored with a warning
     * - Format detection runs automatically unless `skipDetections` is true
     * - The manifest can be a URL to a JSON file or an inline object
     * @see {@link AssetInitOptions} For all available initialization options
     * @see {@link AssetsManifest} For manifest format details
     */
    init() {
      return __async(this, arguments, function* (options = {}) {
        var _a2, _b, _c;
        if (this._initialized) {
          warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
          return;
        }
        this._initialized = true;
        if (options.defaultSearchParams) {
          this.resolver.setDefaultSearchParams(options.defaultSearchParams);
        }
        if (options.basePath) {
          this.resolver.basePath = options.basePath;
        }
        if (options.bundleIdentifier) {
          this.resolver.setBundleIdentifier(options.bundleIdentifier);
        }
        if (options.manifest) {
          let manifest = options.manifest;
          if (typeof manifest === "string") {
            manifest = yield this.load(manifest);
          }
          this.resolver.addManifest(manifest);
        }
        const resolutionPref = (_b = (_a2 = options.texturePreference) == null ? void 0 : _a2.resolution) != null ? _b : 1;
        const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
        const formats = yield this._detectFormats({
          preferredFormats: (_c = options.texturePreference) == null ? void 0 : _c.format,
          skipDetections: options.skipDetections,
          detections: this._detections
        });
        this.resolver.prefer({
          params: {
            format: formats,
            resolution
          }
        });
        if (options.preferences) {
          this.setPreferences(options.preferences);
        }
        if (options.loadOptions) {
          this.loader.loadOptions = __spreadValues(__spreadValues({}, this.loader.loadOptions), options.loadOptions);
        }
      });
    }
    /**
     * Registers assets with the Assets resolver. This method maps keys (aliases) to asset sources,
     * allowing you to load assets using friendly names instead of direct URLs.
     * @param assets - The unresolved assets to add to the resolver
     * @example
     * ```ts
     * // Basic usage - single asset
     * Assets.add({
     *     alias: 'myTexture',
     *     src: 'assets/texture.png'
     * });
     * const texture = await Assets.load('myTexture');
     *
     * // Multiple aliases for the same asset
     * Assets.add({
     *     alias: ['hero', 'player'],
     *     src: 'hero.png'
     * });
     * const hero1 = await Assets.load('hero');
     * const hero2 = await Assets.load('player'); // Same texture
     *
     * // Multiple format support
     * Assets.add({
     *     alias: 'character',
     *     src: 'character.{webp,png}' // Will choose best format
     * });
     * Assets.add({
     *     alias: 'character',
     *     src: ['character.webp', 'character.png'], // Explicitly specify formats
     * });
     *
     * // With texture options
     * Assets.add({
     *     alias: 'sprite',
     *     src: 'sprite.png',
     *     data: { scaleMode: 'nearest' }
     * });
     *
     * // Multiple assets at once
     * Assets.add([
     *     { alias: 'bg', src: 'background.png' },
     *     { alias: 'music', src: 'music.mp3' },
     *     { alias: 'spritesheet', src: 'sheet.json', data: { ignoreMultiPack: false } }
     * ]);
     * ```
     * @remarks
     * - Assets are resolved when loaded, not when added
     * - Multiple formats use the best available format for the browser
     * - Adding with same alias overwrites previous definition
     * - The `data` property is passed to the asset loader
     * @see {@link Resolver} For details on asset resolution
     * @see {@link LoaderParser} For asset-specific data options
     * @advanced
     */
    add(assets) {
      this.resolver.add(assets);
    }
    load(urls, onProgress) {
      return __async(this, null, function* () {
        if (!this._initialized) {
          yield this.init();
        }
        const singleAsset = isSingleItem(urls);
        const urlArray = convertToList(urls).map((url) => {
          if (typeof url !== "string") {
            const aliases = this.resolver.getAlias(url);
            if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
              this.add(url);
            }
            return Array.isArray(aliases) ? aliases[0] : aliases;
          }
          if (!this.resolver.hasKey(url))
            this.add({ alias: url, src: url });
          return url;
        });
        const resolveResults = this.resolver.resolve(urlArray);
        const out2 = yield this._mapLoadToResolve(resolveResults, onProgress);
        return singleAsset ? out2[urlArray[0]] : out2;
      });
    }
    /**
     * Registers a bundle of assets that can be loaded as a group. Bundles are useful for organizing
     * assets into logical groups, such as game levels or UI screens.
     * @param bundleId - Unique identifier for the bundle
     * @param assets - Assets to include in the bundle
     * @example
     * ```ts
     * // Add a bundle using array format
     * Assets.addBundle('animals', [
     *     { alias: 'bunny', src: 'bunny.png' },
     *     { alias: 'chicken', src: 'chicken.png' },
     *     { alias: 'thumper', src: 'thumper.png' },
     * ]);
     *
     * // Add a bundle using object format
     * Assets.addBundle('animals', {
     *     bunny: 'bunny.png',
     *     chicken: 'chicken.png',
     *     thumper: 'thumper.png',
     * });
     *
     * // Add a bundle with advanced options
     * Assets.addBundle('ui', [
     *     {
     *         alias: 'button',
     *         src: 'button.{webp,png}',
     *         data: { scaleMode: 'nearest' }
     *     },
     *     {
     *         alias: ['logo', 'brand'],  // Multiple aliases
     *         src: 'logo.svg',
     *         data: { resolution: 2 }
     *     }
     * ]);
     *
     * // Load the bundle
     * await Assets.loadBundle('animals');
     *
     * // Use the loaded assets
     * const bunny = Sprite.from('bunny');
     * const chicken = Sprite.from('chicken');
     * ```
     * @remarks
     * - Bundle IDs must be unique
     * - Assets in bundles are not loaded until `loadBundle` is called
     * - Bundles can be background loaded using `backgroundLoadBundle`
     * - Assets in bundles can be loaded individually using their aliases
     * @see {@link Assets.loadBundle} For loading bundles
     * @see {@link Assets.backgroundLoadBundle} For background loading bundles
     * @see {@link Assets.unloadBundle} For unloading bundles
     * @see {@link AssetsManifest} For manifest format details
     */
    addBundle(bundleId, assets) {
      this.resolver.addBundle(bundleId, assets);
    }
    /**
     * Loads a bundle or multiple bundles of assets. Bundles are collections of related assets
     * that can be loaded together.
     * @param bundleIds - Single bundle ID or array of bundle IDs to load
     * @param onProgress - Optional callback for load progress (0.0 to 1.0)
     * @returns Promise that resolves with the loaded bundle assets
     * @example
     * ```ts
     * // Define bundles in your manifest
     * const manifest = {
     *     bundles: [
     *         {
     *             name: 'load-screen',
     *             assets: [
     *                 {
     *                     alias: 'background',
     *                     src: 'sunset.png',
     *                 },
     *                 {
     *                     alias: 'bar',
     *                     src: 'load-bar.{png,webp}', // use an array of individual assets
     *                 },
     *             ],
     *         },
     *         {
     *             name: 'game-screen',
     *             assets: [
     *                 {
     *                     alias: 'character',
     *                     src: 'robot.png',
     *                 },
     *                 {
     *                     alias: 'enemy',
     *                     src: 'bad-guy.png',
     *                 },
     *             ],
     *         },
     *     ]
     * };
     *
     * // Initialize with manifest
     * await Assets.init({ manifest });
     *
     * // Or add bundles programmatically
     * Assets.addBundle('load-screen', [...]);
     * Assets.loadBundle('load-screen');
     *
     * // Load a single bundle
     * await Assets.loadBundle('load-screen');
     * const bg = Sprite.from('background'); // Uses alias from bundle
     *
     * // Load multiple bundles
     * await Assets.loadBundle([
     *     'load-screen',
     *     'game-screen'
     * ]);
     *
     * // Load with progress tracking
     * await Assets.loadBundle('game-screen', (progress) => {
     *     console.log(`Loading: ${Math.round(progress * 100)}%`);
     * });
     * ```
     * @remarks
     * - Bundle assets are cached automatically
     * - Bundles can be pre-loaded using `backgroundLoadBundle`
     * - Assets in bundles can be accessed by their aliases
     * - Progress callback receives values from 0.0 to 1.0
     * @throws {Error} If the bundle ID doesn't exist in the manifest
     * @see {@link Assets.addBundle} For adding bundles programmatically
     * @see {@link Assets.backgroundLoadBundle} For background loading bundles
     * @see {@link Assets.unloadBundle} For unloading bundles
     * @see {@link AssetsManifest} For manifest format details
     */
    loadBundle(bundleIds, onProgress) {
      return __async(this, null, function* () {
        if (!this._initialized) {
          yield this.init();
        }
        let singleAsset = false;
        if (typeof bundleIds === "string") {
          singleAsset = true;
          bundleIds = [bundleIds];
        }
        const resolveResults = this.resolver.resolveBundle(bundleIds);
        const out2 = {};
        const keys = Object.keys(resolveResults);
        let total = 0;
        const counts = [];
        const _onProgress = () => {
          onProgress == null ? void 0 : onProgress(counts.reduce((a2, b2) => a2 + b2, 0) / total);
        };
        const promises = keys.map((bundleId, i3) => {
          const resolveResult = resolveResults[bundleId];
          const values = Object.values(resolveResult);
          const totalAssetsToLoad = [...new Set(values.flat())];
          const progressSize = totalAssetsToLoad.reduce((sum, asset) => sum + (asset.progressSize || 1), 0);
          counts.push(0);
          total += progressSize;
          return this._mapLoadToResolve(resolveResult, (e2) => {
            counts[i3] = e2 * progressSize;
            _onProgress();
          }).then((resolveResult2) => {
            out2[bundleId] = resolveResult2;
          });
        });
        yield Promise.all(promises);
        return singleAsset ? out2[bundleIds[0]] : out2;
      });
    }
    /**
     * Initiates background loading of assets. This allows assets to be loaded passively while other operations
     * continue, making them instantly available when needed later.
     *
     * Background loading is useful for:
     * - Preloading game levels while in a menu
     * - Loading non-critical assets during gameplay
     * - Reducing visible loading screens
     * @param urls - Single URL/alias or array of URLs/aliases to load in the background
     * @example
     * ```ts
     * // Basic background loading
     * Assets.backgroundLoad('images/level2-assets.png');
     *
     * // Background load multiple assets
     * Assets.backgroundLoad([
     *     'images/sprite1.png',
     *     'images/sprite2.png',
     *     'images/background.png'
     * ]);
     *
     * // Later, when you need the assets
     * const textures = await Assets.load([
     *     'images/sprite1.png',
     *     'images/sprite2.png'
     * ]); // Resolves immediately if background loading completed
     * ```
     * @remarks
     * - Background loading happens one asset at a time to avoid blocking the main thread
     * - Loading can be interrupted safely by calling `Assets.load()`
     * - Assets are cached as they complete loading
     * - No progress tracking is available for background loading
     */
    backgroundLoad(urls) {
      return __async(this, null, function* () {
        if (!this._initialized) {
          yield this.init();
        }
        if (typeof urls === "string") {
          urls = [urls];
        }
        const resolveResults = this.resolver.resolve(urls);
        this._backgroundLoader.add(Object.values(resolveResults));
      });
    }
    /**
     * Initiates background loading of asset bundles. Similar to backgroundLoad but works with
     * predefined bundles of assets.
     *
     * Perfect for:
     * - Preloading level bundles during gameplay
     * - Loading UI assets during splash screens
     * - Preparing assets for upcoming game states
     * @param bundleIds - Single bundle ID or array of bundle IDs to load in the background
     * @example
     * ```ts
     * // Define bundles in your manifest
     * await Assets.init({
     *     manifest: {
     *         bundles: [
     *             {
     *               name: 'home',
     *               assets: [
     *                 {
     *                     alias: 'background',
     *                     src: 'images/home-bg.png',
     *                 },
     *                 {
     *                     alias: 'logo',
     *                     src: 'images/logo.png',
     *                 }
     *              ]
     *            },
     *            {
     *             name: 'level-1',
     *             assets: [
     *                 {
     *                     alias: 'background',
     *                     src: 'images/level1/bg.png',
     *                 },
     *                 {
     *                     alias: 'sprites',
     *                     src: 'images/level1/sprites.json'
     *                 }
     *             ]
     *         }]
     *     }
     * });
     *
     * // Load the home screen assets right away
     * await Assets.loadBundle('home');
     * showHomeScreen();
     *
     * // Start background loading while showing home screen
     * Assets.backgroundLoadBundle('level-1');
     *
     * // When player starts level, load completes faster
     * await Assets.loadBundle('level-1');
     * hideHomeScreen();
     * startLevel();
     * ```
     * @remarks
     * - Bundle assets are loaded one at a time
     * - Loading can be interrupted safely by calling `Assets.loadBundle()`
     * - Assets are cached as they complete loading
     * - Requires bundles to be registered via manifest or `addBundle`
     * @see {@link Assets.addBundle} For adding bundles programmatically
     * @see {@link Assets.loadBundle} For immediate bundle loading
     * @see {@link AssetsManifest} For manifest format details
     */
    backgroundLoadBundle(bundleIds) {
      return __async(this, null, function* () {
        if (!this._initialized) {
          yield this.init();
        }
        if (typeof bundleIds === "string") {
          bundleIds = [bundleIds];
        }
        const resolveResults = this.resolver.resolveBundle(bundleIds);
        Object.values(resolveResults).forEach((resolveResult) => {
          this._backgroundLoader.add(Object.values(resolveResult));
        });
      });
    }
    /**
     * Only intended for development purposes.
     * This will wipe the resolver and caches.
     * You will need to reinitialize the Asset
     * @internal
     */
    reset() {
      this.resolver.reset();
      this.loader.reset();
      this.cache.reset();
      this._initialized = false;
    }
    get(keys) {
      if (typeof keys === "string") {
        return Cache.get(keys);
      }
      const assets = {};
      for (let i3 = 0; i3 < keys.length; i3++) {
        assets[i3] = Cache.get(keys[i3]);
      }
      return assets;
    }
    /**
     * helper function to map resolved assets back to loaded assets
     * @param resolveResults - the resolve results from the resolver
     * @param progressOrLoadOptions - the progress callback or load options
     */
    _mapLoadToResolve(resolveResults, progressOrLoadOptions) {
      return __async(this, null, function* () {
        const resolveArray = [...new Set(Object.values(resolveResults))];
        this._backgroundLoader.active = false;
        const loadedAssets = yield this.loader.load(resolveArray, progressOrLoadOptions);
        this._backgroundLoader.active = true;
        const out2 = {};
        resolveArray.forEach((resolveResult) => {
          const asset = loadedAssets[resolveResult.src];
          const keys = [resolveResult.src];
          if (resolveResult.alias) {
            keys.push(...resolveResult.alias);
          }
          keys.forEach((key) => {
            out2[key] = asset;
          });
          Cache.set(keys, asset);
        });
        return out2;
      });
    }
    /**
     * Unloads assets and releases them from memory. This method ensures proper cleanup of
     * loaded assets when they're no longer needed.
     * @param urls - Single URL/alias or array of URLs/aliases to unload
     * @example
     * ```ts
     * // Unload a single asset
     * await Assets.unload('images/sprite.png');
     *
     * // Unload using an alias
     * await Assets.unload('hero'); // Unloads the asset registered with 'hero' alias
     *
     * // Unload multiple assets
     * await Assets.unload([
     *     'images/background.png',
     *     'images/character.png',
     *     'hero'
     * ]);
     *
     * // Unload and handle creation of new instances
     * await Assets.unload('hero');
     * const newHero = await Assets.load('hero'); // Will load fresh from source
     * ```
     * @remarks
     * > [!WARNING]
     * > Make sure assets aren't being used before unloading:
     * > - Remove sprites using the texture
     * > - Clear any references to the asset
     * > - Textures will be destroyed and can't be used after unloading
     * @throws {Error} If the asset is not found in cache
     */
    unload(urls) {
      return __async(this, null, function* () {
        if (!this._initialized) {
          yield this.init();
        }
        const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
        const resolveResults = this.resolver.resolve(urlArray);
        yield this._unloadFromResolved(resolveResults);
      });
    }
    /**
     * Unloads all assets in a bundle. Use this to free memory when a bundle's assets
     * are no longer needed, such as when switching game levels.
     * @param bundleIds - Single bundle ID or array of bundle IDs to unload
     * @example
     * ```ts
     * // Define and load a bundle
     * Assets.addBundle('level-1', {
     *     background: 'level1/bg.png',
     *     sprites: 'level1/sprites.json',
     *     music: 'level1/music.mp3'
     * });
     *
     * // Load the bundle
     * const level1 = await Assets.loadBundle('level-1');
     *
     * // Use the assets
     * const background = Sprite.from(level1.background);
     *
     * // When done with the level, unload everything
     * await Assets.unloadBundle('level-1');
     * // background sprite is now invalid!
     *
     * // Unload multiple bundles
     * await Assets.unloadBundle([
     *     'level-1',
     *     'level-2',
     *     'ui-elements'
     * ]);
     * ```
     * @remarks
     * > [!WARNING]
     * > - All assets in the bundle will be destroyed
     * > - Bundle needs to be reloaded to use assets again
     * > - Make sure no sprites or other objects are using the assets
     * @throws {Error} If the bundle is not found
     * @see {@link Assets.addBundle} For adding bundles
     * @see {@link Assets.loadBundle} For loading bundles
     */
    unloadBundle(bundleIds) {
      return __async(this, null, function* () {
        if (!this._initialized) {
          yield this.init();
        }
        bundleIds = convertToList(bundleIds);
        const resolveResults = this.resolver.resolveBundle(bundleIds);
        const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
        yield Promise.all(promises);
      });
    }
    _unloadFromResolved(resolveResult) {
      return __async(this, null, function* () {
        const resolveArray = Object.values(resolveResult);
        resolveArray.forEach((resolveResult2) => {
          Cache.remove(resolveResult2.src);
        });
        yield this.loader.unload(resolveArray);
      });
    }
    /**
     * Detects the supported formats for the browser, and returns an array of supported formats, respecting
     * the users preferred formats order.
     * @param options - the options to use when detecting formats
     * @param options.preferredFormats - the preferred formats to use
     * @param options.skipDetections - if we should skip the detections altogether
     * @param options.detections - the detections to use
     * @returns - the detected formats
     */
    _detectFormats(options) {
      return __async(this, null, function* () {
        let formats = [];
        if (options.preferredFormats) {
          formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];
        }
        for (const detection of options.detections) {
          if (options.skipDetections || (yield detection.test())) {
            formats = yield detection.add(formats);
          } else if (!options.skipDetections) {
            formats = yield detection.remove(formats);
          }
        }
        formats = formats.filter((format, index) => formats.indexOf(format) === index);
        return formats;
      });
    }
    /**
     * All the detection parsers currently added to the Assets class.
     * @advanced
     */
    get detections() {
      return this._detections;
    }
    /**
     * Sets global preferences for asset loading behavior. This method configures how assets
     * are loaded and processed across all parsers.
     * @param preferences - Asset loading preferences
     * @example
     * ```ts
     * // Basic preferences
     * Assets.setPreferences({
     *     crossOrigin: 'anonymous',
     *     parseAsGraphicsContext: false
     * });
     * ```
     * @remarks
     * Preferences are applied to all compatible parsers and affect future asset loading.
     * Common preferences include:
     * - `crossOrigin`: CORS setting for loaded assets
     * - `preferWorkers`: Whether to use web workers for loading textures
     * - `preferCreateImageBitmap`: Use `createImageBitmap` for texture creation. Turning this off will use the `Image` constructor instead.
     * @see {@link AssetsPreferences} For all available preferences
     */
    setPreferences(preferences) {
      this.loader.parsers.forEach((parser) => {
        if (!parser.config)
          return;
        Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
          parser.config[key] = preferences[key];
        });
      });
    }
  };
  var Assets = new AssetsClass();
  extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
  extensions.add(
    cacheTextureArray,
    detectDefaults,
    detectAvif,
    detectWebp,
    detectMp4,
    detectOgv,
    detectWebm,
    loadJson,
    loadTxt,
    loadWebFont,
    loadSvg,
    loadTextures,
    loadVideoTextures,
    loadBitmapFont,
    bitmapFontCachePlugin,
    resolveTextureUrl,
    resolveJsonUrl
  );
  var assetKeyMap = {
    loader: ExtensionType.LoadParser,
    resolver: ExtensionType.ResolveParser,
    cache: ExtensionType.CacheParser,
    detection: ExtensionType.DetectionParser
  };
  extensions.handle(ExtensionType.Asset, (extension) => {
    const ref = extension.ref;
    Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => {
      var _a2;
      return extensions.add(Object.assign(
        ref[key],
        // Allow the function to optionally define it's own
        // ExtensionMetadata, the use cases here is priority for LoaderParsers
        { extension: (_a2 = ref[key].extension) != null ? _a2 : type }
      ));
    });
  }, (extension) => {
    const ref = extension.ref;
    Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
  });

  // node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.mjs
  init_Extensions();
  var detectBasis = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 3
    },
    test: () => __async(null, null, function* () {
      if (yield isWebGPUSupported())
        return true;
      if (isWebGLSupported())
        return true;
      return false;
    }),
    add: (formats) => __async(null, null, function* () {
      return [...formats, "basis"];
    }),
    remove: (formats) => __async(null, null, function* () {
      return formats.filter((f2) => f2 !== "basis");
    })
  };

  // node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.mjs
  init_LoaderParser();
  init_Extensions();

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs
  init_TextureSource();
  var CompressedSource = class extends TextureSource {
    constructor(options) {
      super(options);
      this.uploadMethodId = "compressed";
      this.resource = options.resource;
      this.mipLevelCount = this.resource.length;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs
  init_adapter();
  var supportedGLCompressedTextureFormats;
  function getSupportedGlCompressedTextureFormats() {
    if (supportedGLCompressedTextureFormats)
      return supportedGLCompressedTextureFormats;
    const canvas = DOMAdapter.get().createCanvas(1, 1);
    const gl = canvas.getContext("webgl");
    if (!gl) {
      return [];
    }
    supportedGLCompressedTextureFormats = [
      // BC compressed formats usable if "texture-compression-bc" is both
      // supported by the device/user agent and enabled in requestDevice.
      // 'bc6h-rgb-ufloat'
      // 'bc6h-rgb-float'
      // 'bc7-rgba-unorm',
      // 'bc7-rgba-unorm-srgb',
      ...gl.getExtension("EXT_texture_compression_bptc") ? [
        "bc6h-rgb-ufloat",
        "bc6h-rgb-float",
        "bc7-rgba-unorm",
        "bc7-rgba-unorm-srgb"
      ] : [],
      // BC compressed formats usable if "texture-compression-bc" is both
      // supported by the device/user agent and enabled in requestDevice.
      // 'bc1-rgba-unorm',
      // 'bc1-rgba-unorm-srgb',
      // 'bc4-r-unorm'
      // 'bc4-r-snorm'
      // 'bc5-rg-unorm'
      // 'bc5-rg-snorm'
      ...gl.getExtension("WEBGL_compressed_texture_s3tc") ? [
        "bc1-rgba-unorm",
        "bc2-rgba-unorm",
        "bc3-rgba-unorm"
      ] : [],
      ...gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") ? [
        "bc1-rgba-unorm-srgb",
        "bc2-rgba-unorm-srgb",
        "bc3-rgba-unorm-srgb"
      ] : [],
      ...gl.getExtension("EXT_texture_compression_rgtc") ? [
        "bc4-r-unorm",
        "bc4-r-snorm",
        "bc5-rg-unorm",
        "bc5-rg-snorm"
      ] : [],
      // ETC2 compressed formats usable if "texture-compression-etc2" is both
      // supported by the device/user agent and enabled in requestDevice.
      ...gl.getExtension("WEBGL_compressed_texture_etc") ? [
        "etc2-rgb8unorm",
        "etc2-rgb8unorm-srgb",
        "etc2-rgba8unorm",
        "etc2-rgba8unorm-srgb",
        "etc2-rgb8a1unorm",
        "etc2-rgb8a1unorm-srgb",
        "eac-r11unorm",
        "eac-rg11unorm"
      ] : [],
      // 'eac-r11snorm',
      // 'eac-rg11snorm',
      // ASTC compressed formats usable if "texture-compression-astc" is both
      // supported by the device/user agent and enabled in requestDevice.
      ...gl.getExtension("WEBGL_compressed_texture_astc") ? [
        "astc-4x4-unorm",
        "astc-4x4-unorm-srgb",
        "astc-5x4-unorm",
        "astc-5x4-unorm-srgb",
        "astc-5x5-unorm",
        "astc-5x5-unorm-srgb",
        "astc-6x5-unorm",
        "astc-6x5-unorm-srgb",
        "astc-6x6-unorm",
        "astc-6x6-unorm-srgb",
        "astc-8x5-unorm",
        "astc-8x5-unorm-srgb",
        "astc-8x6-unorm",
        "astc-8x6-unorm-srgb",
        "astc-8x8-unorm",
        "astc-8x8-unorm-srgb",
        "astc-10x5-unorm",
        "astc-10x5-unorm-srgb",
        "astc-10x6-unorm",
        "astc-10x6-unorm-srgb",
        "astc-10x8-unorm",
        "astc-10x8-unorm-srgb",
        "astc-10x10-unorm",
        "astc-10x10-unorm-srgb",
        "astc-12x10-unorm",
        "astc-12x10-unorm-srgb",
        "astc-12x12-unorm",
        "astc-12x12-unorm-srgb"
      ] : []
    ];
    return supportedGLCompressedTextureFormats;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs
  init_adapter();
  var supportedGPUCompressedTextureFormats;
  function getSupportedGPUCompressedTextureFormats() {
    return __async(this, null, function* () {
      if (supportedGPUCompressedTextureFormats)
        return supportedGPUCompressedTextureFormats;
      const adapter = yield DOMAdapter.get().getNavigator().gpu.requestAdapter();
      supportedGPUCompressedTextureFormats = [
        ...adapter.features.has("texture-compression-bc") ? [
          // BC compressed formats usable if "texture-compression-bc" is both
          // supported by the device/user agent and enabled in requestDevice.
          "bc1-rgba-unorm",
          "bc1-rgba-unorm-srgb",
          "bc2-rgba-unorm",
          "bc2-rgba-unorm-srgb",
          "bc3-rgba-unorm",
          "bc3-rgba-unorm-srgb",
          "bc4-r-unorm",
          "bc4-r-snorm",
          "bc5-rg-unorm",
          "bc5-rg-snorm",
          "bc6h-rgb-ufloat",
          "bc6h-rgb-float",
          "bc7-rgba-unorm",
          "bc7-rgba-unorm-srgb"
        ] : [],
        ...adapter.features.has("texture-compression-etc2") ? [
          // ETC2 compressed formats usable if "texture-compression-etc2" is both
          // supported by the device/user agent and enabled in requestDevice.
          "etc2-rgb8unorm",
          "etc2-rgb8unorm-srgb",
          "etc2-rgb8a1unorm",
          "etc2-rgb8a1unorm-srgb",
          "etc2-rgba8unorm",
          "etc2-rgba8unorm-srgb",
          "eac-r11unorm",
          "eac-r11snorm",
          "eac-rg11unorm",
          "eac-rg11snorm"
        ] : [],
        ...adapter.features.has("texture-compression-astc") ? [
          // ASTC compressed formats usable if "texture-compression-astc" is both
          // supported by the device/user agent and enabled in requestDevice.
          "astc-4x4-unorm",
          "astc-4x4-unorm-srgb",
          "astc-5x4-unorm",
          "astc-5x4-unorm-srgb",
          "astc-5x5-unorm",
          "astc-5x5-unorm-srgb",
          "astc-6x5-unorm",
          "astc-6x5-unorm-srgb",
          "astc-6x6-unorm",
          "astc-6x6-unorm-srgb",
          "astc-8x5-unorm",
          "astc-8x5-unorm-srgb",
          "astc-8x6-unorm",
          "astc-8x6-unorm-srgb",
          "astc-8x8-unorm",
          "astc-8x8-unorm-srgb",
          "astc-10x5-unorm",
          "astc-10x5-unorm-srgb",
          "astc-10x6-unorm",
          "astc-10x6-unorm-srgb",
          "astc-10x8-unorm",
          "astc-10x8-unorm-srgb",
          "astc-10x10-unorm",
          "astc-10x10-unorm-srgb",
          "astc-12x10-unorm",
          "astc-12x10-unorm-srgb",
          "astc-12x12-unorm",
          "astc-12x12-unorm-srgb"
        ] : []
      ];
      return supportedGPUCompressedTextureFormats;
    });
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs
  var supportedCompressedTextureFormats;
  function getSupportedCompressedTextureFormats() {
    return __async(this, null, function* () {
      if (supportedCompressedTextureFormats !== void 0)
        return supportedCompressedTextureFormats;
      supportedCompressedTextureFormats = yield (() => __async(null, null, function* () {
        const _isWebGPUSupported2 = yield isWebGPUSupported();
        const _isWebGLSupported2 = isWebGLSupported();
        if (_isWebGPUSupported2 && _isWebGLSupported2) {
          const gpuTextureFormats = yield getSupportedGPUCompressedTextureFormats();
          const glTextureFormats = getSupportedGlCompressedTextureFormats();
          return gpuTextureFormats.filter((format) => glTextureFormats.includes(format));
        } else if (_isWebGPUSupported2) {
          return yield getSupportedGPUCompressedTextureFormats();
        } else if (_isWebGLSupported2) {
          return getSupportedGlCompressedTextureFormats();
        }
        return [];
      }))();
      return supportedCompressedTextureFormats;
    });
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs
  var nonCompressedFormats = [
    // 8-bit formats
    "r8unorm",
    "r8snorm",
    "r8uint",
    "r8sint",
    // 16-bit formats
    "r16uint",
    "r16sint",
    "r16float",
    "rg8unorm",
    "rg8snorm",
    "rg8uint",
    "rg8sint",
    // 32-bit formats
    "r32uint",
    "r32sint",
    "r32float",
    "rg16uint",
    "rg16sint",
    "rg16float",
    "rgba8unorm",
    "rgba8unorm-srgb",
    "rgba8snorm",
    "rgba8uint",
    "rgba8sint",
    "bgra8unorm",
    "bgra8unorm-srgb",
    // Packed 32-bit formats
    "rgb9e5ufloat",
    "rgb10a2unorm",
    "rg11b10ufloat",
    // 64-bit formats
    "rg32uint",
    "rg32sint",
    "rg32float",
    "rgba16uint",
    "rgba16sint",
    "rgba16float",
    // 128-bit formats
    "rgba32uint",
    "rgba32sint",
    "rgba32float",
    // Depth/stencil formats
    "stencil8",
    "depth16unorm",
    "depth24plus",
    "depth24plus-stencil8",
    "depth32float",
    // "depth32float-stencil8" feature
    "depth32float-stencil8"
  ];
  var supportedTextureFormats;
  function getSupportedTextureFormats() {
    return __async(this, null, function* () {
      if (supportedTextureFormats !== void 0)
        return supportedTextureFormats;
      const compressedTextureFormats = yield getSupportedCompressedTextureFormats();
      supportedTextureFormats = [
        ...nonCompressedFormats,
        ...compressedTextureFormats
      ];
      return supportedTextureFormats;
    });
  }

  // node_modules/pixi.js/lib/_virtual/basis.worker.mjs
  var WORKER_CODE3 = '(function () {\n    \'use strict\';\n\n    function createLevelBuffers(basisTexture, basisTranscoderFormat) {\n      const images = basisTexture.getNumImages();\n      const levels = basisTexture.getNumLevels(0);\n      const success = basisTexture.startTranscoding();\n      if (!success) {\n        throw new Error("startTranscoding failed");\n      }\n      const levelBuffers = [];\n      for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {\n        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {\n          const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);\n          const levelBuffer = new Uint8Array(transcodeSize);\n          const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);\n          if (!success2) {\n            throw new Error("transcodeImage failed");\n          }\n          levelBuffers.push(levelBuffer);\n        }\n      }\n      return levelBuffers;\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap = {\n      "bc3-rgba-unorm": 3,\n      // cTFBC3_RGBA\n      "bc7-rgba-unorm": 6,\n      // cTFBC7_RGBA,\n      "etc2-rgba8unorm": 1,\n      // cTFETC2_RGBA,\n      "astc-4x4-unorm": 10,\n      // cTFASTC_4x4_RGBA,\n      // Uncompressed\n      rgba8unorm: 13,\n      // cTFRGBA32,\n      rgba4unorm: 16\n      // cTFRGBA4444,\n    };\n    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings = {\n      jsUrl: "basis/basis_transcoder.js",\n      wasmUrl: "basis/basis_transcoder.wasm"\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let basisPromise;\n    async function getBasis() {\n      if (!basisPromise) {\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        basisPromise = new Promise((resolve) => {\n          BASIS({\n            locateFile: (_file) => absoluteWasmUrl\n          }).then((module) => {\n            module.initializeBasis();\n            resolve(module.BasisFile);\n          });\n        });\n      }\n      return basisPromise;\n    }\n    async function fetchBasisTexture(url, BasisTexture) {\n      const basisResponse = await fetch(url);\n      if (basisResponse.ok) {\n        const basisArrayBuffer = await basisResponse.arrayBuffer();\n        return new BasisTexture(new Uint8Array(basisArrayBuffer));\n      }\n      throw new Error(`Failed to load Basis texture: ${url}`);\n    }\n    const preferredTranscodedFormat = [\n      "bc7-rgba-unorm",\n      "astc-4x4-unorm",\n      "etc2-rgba8unorm",\n      "bc3-rgba-unorm",\n      "rgba8unorm"\n    ];\n    async function load(url) {\n      const BasisTexture = await getBasis();\n      const basisTexture = await fetchBasisTexture(url, BasisTexture);\n      const levelBuffers = createLevelBuffers(basisTexture, basisTranscoderFormat);\n      return {\n        width: basisTexture.getImageWidth(0, 0),\n        height: basisTexture.getImageHeight(0, 0),\n        format: basisTranscodedTextureFormat,\n        resource: levelBuffers,\n        alphaMode: "no-premultiply-alpha"\n      };\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl = jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl = wasmUrl;\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\n      basisTranscoderFormat = gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getBasis();\n    }\n    const messageHandlers = {\n      init: async (data) => {\n        const { jsUrl, wasmUrl, supportedTextures } = data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) => {\n        try {\n          const textureOptions = await load(data.url);\n          return {\n            type: "load",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage = async (messageEvent) => {\n      const message = messageEvent.data;\n      const response = await messageHandlers[message.type](message);\n      if (response) {\n        self.postMessage(response, response.transferables);\n      }\n    };\n\n})();\n';
  var WORKER_URL3 = null;
  var WorkerInstance3 = class {
    constructor() {
      if (!WORKER_URL3) {
        WORKER_URL3 = URL.createObjectURL(new Blob([WORKER_CODE3], { type: "application/javascript" }));
      }
      this.worker = new Worker(WORKER_URL3);
    }
  };
  WorkerInstance3.revokeObjectURL = function revokeObjectURL3() {
    if (WORKER_URL3) {
      URL.revokeObjectURL(WORKER_URL3);
      WORKER_URL3 = null;
    }
  };

  // node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs
  var basisTranscoderUrls = {
    jsUrl: "https://cdn.jsdelivr.net/npm/pixi.js/transcoders/basis/basis_transcoder.js",
    wasmUrl: "https://cdn.jsdelivr.net/npm/pixi.js/transcoders/basis/basis_transcoder.wasm"
  };
  function setBasisTranscoderPath(config3) {
    Object.assign(basisTranscoderUrls, config3);
  }

  // node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs
  var basisWorker;
  var urlHash = {};
  function getBasisWorker(supportedTextures) {
    if (!basisWorker) {
      basisWorker = new WorkerInstance3().worker;
      basisWorker.onmessage = (messageEvent) => {
        const { success, url, textureOptions } = messageEvent.data;
        if (!success) {
          console.warn("Failed to load Basis texture", url);
        }
        urlHash[url](textureOptions);
      };
      basisWorker.postMessage({
        type: "init",
        jsUrl: basisTranscoderUrls.jsUrl,
        wasmUrl: basisTranscoderUrls.wasmUrl,
        supportedTextures
      });
    }
    return basisWorker;
  }
  function loadBasisOnWorker(url, supportedTextures) {
    const ktxWorker2 = getBasisWorker(supportedTextures);
    return new Promise((resolve) => {
      urlHash[url] = resolve;
      ktxWorker2.postMessage({ type: "load", url });
    });
  }

  // node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.mjs
  var loadBasis = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High,
      name: "loadBasis"
    },
    /** used for deprecation purposes */
    name: "loadBasis",
    id: "basis",
    test(url) {
      return checkExtension(url, [".basis"]);
    },
    load(url, _asset, loader) {
      return __async(this, null, function* () {
        const supportedTextures = yield getSupportedTextureFormats();
        const textureOptions = yield loadBasisOnWorker(url, supportedTextures);
        const compressedTextureSource = new CompressedSource(textureOptions);
        return createTexture(compressedTextureSource, loader, url);
      });
    },
    unload(texture) {
      if (Array.isArray(texture)) {
        texture.forEach((t2) => t2.destroy(true));
      } else {
        texture.destroy(true);
      }
    }
  };

  // node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.mjs
  function createLevelBuffers(basisTexture, basisTranscoderFormat) {
    const images = basisTexture.getNumImages();
    const levels = basisTexture.getNumLevels(0);
    const success = basisTexture.startTranscoding();
    if (!success) {
      throw new Error("startTranscoding failed");
    }
    const levelBuffers = [];
    for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {
      for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {
        const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);
        const levelBuffer = new Uint8Array(transcodeSize);
        const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);
        if (!success2) {
          throw new Error("transcodeImage failed");
        }
        levelBuffers.push(levelBuffer);
      }
    }
    return levelBuffers;
  }

  // node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs
  var gpuFormatToBasisTranscoderFormatMap = {
    "bc3-rgba-unorm": 3,
    // cTFBC3_RGBA
    "bc7-rgba-unorm": 6,
    // cTFBC7_RGBA,
    "etc2-rgba8unorm": 1,
    // cTFETC2_RGBA,
    "astc-4x4-unorm": 10,
    // cTFASTC_4x4_RGBA,
    // Uncompressed
    rgba8unorm: 13,
    // cTFRGBA32,
    rgba4unorm: 16
    // cTFRGBA4444,
  };
  function gpuFormatToBasisTranscoderFormat(transcoderFormat) {
    const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
    if (format) {
      return format;
    }
    throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);
  }

  // node_modules/pixi.js/lib/compressed-textures/dds/const.mjs
  var DDS_HEADER_FIELDS = {
    MAGIC: 0,
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19,
    PF_FLAGS: 20,
    FOURCC: 21,
    RGB_BITCOUNT: 22,
    R_BIT_MASK: 23,
    G_BIT_MASK: 24,
    B_BIT_MASK: 25,
    A_BIT_MASK: 26
  };
  var DDS_DX10_FIELDS = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4
  };
  var DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
    DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
    return DXGI_FORMAT2;
  })(DXGI_FORMAT || {});
  var D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {
    D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
    D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
    D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
    return D3D10_RESOURCE_DIMENSION2;
  })(D3D10_RESOURCE_DIMENSION || {});
  function fourCCToInt32(value) {
    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
  }
  var D3DFMT = ((D3DFMT2) => {
    D3DFMT2[D3DFMT2["UNKNOWN"] = 0] = "UNKNOWN";
    D3DFMT2[D3DFMT2["R8G8B8"] = 20] = "R8G8B8";
    D3DFMT2[D3DFMT2["A8R8G8B8"] = 21] = "A8R8G8B8";
    D3DFMT2[D3DFMT2["X8R8G8B8"] = 22] = "X8R8G8B8";
    D3DFMT2[D3DFMT2["R5G6B5"] = 23] = "R5G6B5";
    D3DFMT2[D3DFMT2["X1R5G5B5"] = 24] = "X1R5G5B5";
    D3DFMT2[D3DFMT2["A1R5G5B5"] = 25] = "A1R5G5B5";
    D3DFMT2[D3DFMT2["A4R4G4B4"] = 26] = "A4R4G4B4";
    D3DFMT2[D3DFMT2["R3G3B2"] = 27] = "R3G3B2";
    D3DFMT2[D3DFMT2["A8"] = 28] = "A8";
    D3DFMT2[D3DFMT2["A8R3G3B2"] = 29] = "A8R3G3B2";
    D3DFMT2[D3DFMT2["X4R4G4B4"] = 30] = "X4R4G4B4";
    D3DFMT2[D3DFMT2["A2B10G10R10"] = 31] = "A2B10G10R10";
    D3DFMT2[D3DFMT2["A8B8G8R8"] = 32] = "A8B8G8R8";
    D3DFMT2[D3DFMT2["X8B8G8R8"] = 33] = "X8B8G8R8";
    D3DFMT2[D3DFMT2["G16R16"] = 34] = "G16R16";
    D3DFMT2[D3DFMT2["A2R10G10B10"] = 35] = "A2R10G10B10";
    D3DFMT2[D3DFMT2["A16B16G16R16"] = 36] = "A16B16G16R16";
    D3DFMT2[D3DFMT2["A8P8"] = 40] = "A8P8";
    D3DFMT2[D3DFMT2["P8"] = 41] = "P8";
    D3DFMT2[D3DFMT2["L8"] = 50] = "L8";
    D3DFMT2[D3DFMT2["A8L8"] = 51] = "A8L8";
    D3DFMT2[D3DFMT2["A4L4"] = 52] = "A4L4";
    D3DFMT2[D3DFMT2["V8U8"] = 60] = "V8U8";
    D3DFMT2[D3DFMT2["L6V5U5"] = 61] = "L6V5U5";
    D3DFMT2[D3DFMT2["X8L8V8U8"] = 62] = "X8L8V8U8";
    D3DFMT2[D3DFMT2["Q8W8V8U8"] = 63] = "Q8W8V8U8";
    D3DFMT2[D3DFMT2["V16U16"] = 64] = "V16U16";
    D3DFMT2[D3DFMT2["A2W10V10U10"] = 67] = "A2W10V10U10";
    D3DFMT2[D3DFMT2["Q16W16V16U16"] = 110] = "Q16W16V16U16";
    D3DFMT2[D3DFMT2["R16F"] = 111] = "R16F";
    D3DFMT2[D3DFMT2["G16R16F"] = 112] = "G16R16F";
    D3DFMT2[D3DFMT2["A16B16G16R16F"] = 113] = "A16B16G16R16F";
    D3DFMT2[D3DFMT2["R32F"] = 114] = "R32F";
    D3DFMT2[D3DFMT2["G32R32F"] = 115] = "G32R32F";
    D3DFMT2[D3DFMT2["A32B32G32R32F"] = 116] = "A32B32G32R32F";
    D3DFMT2[D3DFMT2["UYVY"] = fourCCToInt32("UYVY")] = "UYVY";
    D3DFMT2[D3DFMT2["R8G8_B8G8"] = fourCCToInt32("RGBG")] = "R8G8_B8G8";
    D3DFMT2[D3DFMT2["YUY2"] = fourCCToInt32("YUY2")] = "YUY2";
    D3DFMT2[D3DFMT2["D3DFMT_G8R8_G8B8"] = fourCCToInt32("GRGB")] = "D3DFMT_G8R8_G8B8";
    D3DFMT2[D3DFMT2["DXT1"] = fourCCToInt32("DXT1")] = "DXT1";
    D3DFMT2[D3DFMT2["DXT2"] = fourCCToInt32("DXT2")] = "DXT2";
    D3DFMT2[D3DFMT2["DXT3"] = fourCCToInt32("DXT3")] = "DXT3";
    D3DFMT2[D3DFMT2["DXT4"] = fourCCToInt32("DXT4")] = "DXT4";
    D3DFMT2[D3DFMT2["DXT5"] = fourCCToInt32("DXT5")] = "DXT5";
    D3DFMT2[D3DFMT2["ATI1"] = fourCCToInt32("ATI1")] = "ATI1";
    D3DFMT2[D3DFMT2["AT1N"] = fourCCToInt32("AT1N")] = "AT1N";
    D3DFMT2[D3DFMT2["ATI2"] = fourCCToInt32("ATI2")] = "ATI2";
    D3DFMT2[D3DFMT2["AT2N"] = fourCCToInt32("AT2N")] = "AT2N";
    D3DFMT2[D3DFMT2["BC4U"] = fourCCToInt32("BC4U")] = "BC4U";
    D3DFMT2[D3DFMT2["BC4S"] = fourCCToInt32("BC4S")] = "BC4S";
    D3DFMT2[D3DFMT2["BC5U"] = fourCCToInt32("BC5U")] = "BC5U";
    D3DFMT2[D3DFMT2["BC5S"] = fourCCToInt32("BC5S")] = "BC5S";
    D3DFMT2[D3DFMT2["DX10"] = fourCCToInt32("DX10")] = "DX10";
    return D3DFMT2;
  })(D3DFMT || {});
  var FOURCC_TO_TEXTURE_FORMAT = {
    [D3DFMT.DXT1]: "bc1-rgba-unorm",
    [D3DFMT.DXT2]: "bc2-rgba-unorm",
    [D3DFMT.DXT3]: "bc2-rgba-unorm",
    [D3DFMT.DXT4]: "bc3-rgba-unorm",
    [D3DFMT.DXT5]: "bc3-rgba-unorm",
    [D3DFMT.ATI1]: "bc4-r-unorm",
    [D3DFMT.BC4U]: "bc4-r-unorm",
    [D3DFMT.BC4S]: "bc4-r-snorm",
    [D3DFMT.ATI2]: "bc5-rg-unorm",
    [D3DFMT.BC5U]: "bc5-rg-unorm",
    [D3DFMT.BC5S]: "bc5-rg-snorm",
    [
      36
      /* A16B16G16R16 */
    ]: "rgba16uint",
    [
      110
      /* Q16W16V16U16 */
    ]: "rgba16sint",
    [
      111
      /* R16F */
    ]: "r16float",
    [
      112
      /* G16R16F */
    ]: "rg16float",
    [
      113
      /* A16B16G16R16F */
    ]: "rgba16float",
    [
      114
      /* R32F */
    ]: "r32float",
    [
      115
      /* G32R32F */
    ]: "rg32float",
    [
      116
      /* A32B32G32R32F */
    ]: "rgba32float"
  };
  var DXGI_TO_TEXTURE_FORMAT = {
    [
      70
      /* DXGI_FORMAT_BC1_TYPELESS */
    ]: "bc1-rgba-unorm",
    [
      71
      /* DXGI_FORMAT_BC1_UNORM */
    ]: "bc1-rgba-unorm",
    [
      72
      /* DXGI_FORMAT_BC1_UNORM_SRGB */
    ]: "bc1-rgba-unorm-srgb",
    [
      73
      /* DXGI_FORMAT_BC2_TYPELESS */
    ]: "bc2-rgba-unorm",
    [
      74
      /* DXGI_FORMAT_BC2_UNORM */
    ]: "bc2-rgba-unorm",
    [
      75
      /* DXGI_FORMAT_BC2_UNORM_SRGB */
    ]: "bc2-rgba-unorm-srgb",
    [
      76
      /* DXGI_FORMAT_BC3_TYPELESS */
    ]: "bc3-rgba-unorm",
    [
      77
      /* DXGI_FORMAT_BC3_UNORM */
    ]: "bc3-rgba-unorm",
    [
      78
      /* DXGI_FORMAT_BC3_UNORM_SRGB */
    ]: "bc3-rgba-unorm-srgb",
    [
      79
      /* DXGI_FORMAT_BC4_TYPELESS */
    ]: "bc4-r-unorm",
    [
      80
      /* DXGI_FORMAT_BC4_UNORM */
    ]: "bc4-r-unorm",
    [
      81
      /* DXGI_FORMAT_BC4_SNORM */
    ]: "bc4-r-snorm",
    [
      82
      /* DXGI_FORMAT_BC5_TYPELESS */
    ]: "bc5-rg-unorm",
    [
      83
      /* DXGI_FORMAT_BC5_UNORM */
    ]: "bc5-rg-unorm",
    [
      84
      /* DXGI_FORMAT_BC5_SNORM */
    ]: "bc5-rg-snorm",
    [
      94
      /* DXGI_FORMAT_BC6H_TYPELESS */
    ]: "bc6h-rgb-ufloat",
    [
      95
      /* DXGI_FORMAT_BC6H_UF16 */
    ]: "bc6h-rgb-ufloat",
    [
      96
      /* DXGI_FORMAT_BC6H_SF16 */
    ]: "bc6h-rgb-float",
    [
      97
      /* DXGI_FORMAT_BC7_TYPELESS */
    ]: "bc7-rgba-unorm",
    [
      98
      /* DXGI_FORMAT_BC7_UNORM */
    ]: "bc7-rgba-unorm",
    [
      99
      /* DXGI_FORMAT_BC7_UNORM_SRGB */
    ]: "bc7-rgba-unorm-srgb",
    [
      28
      /* DXGI_FORMAT_R8G8B8A8_UNORM */
    ]: "rgba8unorm",
    [
      29
      /* DXGI_FORMAT_R8G8B8A8_UNORM_SRGB */
    ]: "rgba8unorm-srgb",
    [
      87
      /* DXGI_FORMAT_B8G8R8A8_UNORM */
    ]: "bgra8unorm",
    [
      91
      /* DXGI_FORMAT_B8G8R8A8_UNORM_SRGB */
    ]: "bgra8unorm-srgb",
    [
      41
      /* DXGI_FORMAT_R32_FLOAT */
    ]: "r32float",
    [
      49
      /* DXGI_FORMAT_R8G8_UNORM */
    ]: "rg8unorm",
    [
      56
      /* DXGI_FORMAT_R16_UNORM */
    ]: "r16uint",
    [
      61
      /* DXGI_FORMAT_R8_UNORM */
    ]: "r8unorm",
    [
      24
      /* DXGI_FORMAT_R10G10B10A2_UNORM */
    ]: "rgb10a2unorm",
    [
      11
      /* DXGI_FORMAT_R16G16B16A16_UNORM */
    ]: "rgba16uint",
    [
      13
      /* DXGI_FORMAT_R16G16B16A16_SNORM */
    ]: "rgba16sint",
    [
      10
      /* DXGI_FORMAT_R16G16B16A16_FLOAT */
    ]: "rgba16float",
    [
      54
      /* DXGI_FORMAT_R16_FLOAT */
    ]: "r16float",
    [
      34
      /* DXGI_FORMAT_R16G16_FLOAT */
    ]: "rg16float",
    [
      16
      /* DXGI_FORMAT_R32G32_FLOAT */
    ]: "rg32float",
    [
      2
      /* DXGI_FORMAT_R32G32B32A32_FLOAT */
    ]: "rgba32float"
  };
  var DDS = {
    MAGIC_VALUE: 542327876,
    MAGIC_SIZE: 4,
    HEADER_SIZE: 124,
    HEADER_DX10_SIZE: 20,
    PIXEL_FORMAT_FLAGS: {
      // PIXEL_FORMAT flags
      // https://github.com/Microsoft/DirectXTex/blob/main/DirectXTex/DDS.h
      // https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dds-pixelformat
      ALPHAPIXELS: 1,
      ALPHA: 2,
      FOURCC: 4,
      RGB: 64,
      RGBA: 65,
      YUV: 512,
      LUMINANCE: 131072,
      LUMINANCEA: 131073
    },
    RESOURCE_MISC_TEXTURECUBE: 4,
    HEADER_FIELDS: DDS_HEADER_FIELDS,
    HEADER_DX10_FIELDS: DDS_DX10_FIELDS,
    DXGI_FORMAT,
    D3D10_RESOURCE_DIMENSION,
    D3DFMT
  };
  var TEXTURE_FORMAT_BLOCK_SIZE = {
    "bc1-rgba-unorm": 8,
    "bc1-rgba-unorm-srgb": 8,
    "bc2-rgba-unorm": 16,
    "bc2-rgba-unorm-srgb": 16,
    "bc3-rgba-unorm": 16,
    "bc3-rgba-unorm-srgb": 16,
    "bc4-r-unorm": 8,
    "bc4-r-snorm": 8,
    "bc5-rg-unorm": 16,
    "bc5-rg-snorm": 16,
    "bc6h-rgb-ufloat": 16,
    "bc6h-rgb-float": 16,
    "bc7-rgba-unorm": 16,
    "bc7-rgba-unorm-srgb": 16
  };

  // node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.mjs
  init_LoaderParser();
  init_Extensions();

  // node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs
  function parseDDS(arrayBuffer, supportedFormats) {
    const {
      format,
      fourCC,
      width,
      height,
      dataOffset,
      mipmapCount
    } = parseDDSHeader(arrayBuffer);
    if (!supportedFormats.includes(format)) {
      throw new Error(`Unsupported texture format: ${fourCC} ${format}, supported: ${supportedFormats}`);
    }
    if (mipmapCount <= 1) {
      return {
        format,
        width,
        height,
        resource: [new Uint8Array(arrayBuffer, dataOffset)],
        alphaMode: "no-premultiply-alpha"
      };
    }
    const levelBuffers = getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer);
    const textureOptions = {
      format,
      width,
      height,
      resource: levelBuffers,
      alphaMode: "no-premultiply-alpha"
    };
    return textureOptions;
  }
  function getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer) {
    const levelBuffers = [];
    const blockBytes = TEXTURE_FORMAT_BLOCK_SIZE[format];
    let mipWidth = width;
    let mipHeight = height;
    let offset = dataOffset;
    for (let level = 0; level < mipmapCount; ++level) {
      const alignedWidth = Math.ceil(Math.max(4, mipWidth) / 4) * 4;
      const alignedHeight = Math.ceil(Math.max(4, mipHeight) / 4) * 4;
      const byteLength = blockBytes ? alignedWidth / 4 * alignedHeight / 4 * blockBytes : mipWidth * mipHeight * 4;
      const levelBuffer = new Uint8Array(arrayBuffer, offset, byteLength);
      levelBuffers.push(levelBuffer);
      offset += byteLength;
      mipWidth = Math.max(mipWidth >> 1, 1);
      mipHeight = Math.max(mipHeight >> 1, 1);
    }
    return levelBuffers;
  }
  function parseDDSHeader(buffer) {
    const header = new Uint32Array(buffer, 0, DDS.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    if (header[DDS.HEADER_FIELDS.MAGIC] !== DDS.MAGIC_VALUE) {
      throw new Error("Invalid magic number in DDS header");
    }
    const height = header[DDS.HEADER_FIELDS.HEIGHT];
    const width = header[DDS.HEADER_FIELDS.WIDTH];
    const mipmapCount = Math.max(1, header[DDS.HEADER_FIELDS.MIPMAP_COUNT]);
    const flags = header[DDS.HEADER_FIELDS.PF_FLAGS];
    const fourCC = header[DDS.HEADER_FIELDS.FOURCC];
    const format = getTextureFormat(header, flags, fourCC, buffer);
    const dataOffset = DDS.MAGIC_SIZE + DDS.HEADER_SIZE + (fourCC === DDS.D3DFMT.DX10 ? DDS.HEADER_DX10_SIZE : 0);
    return {
      format,
      fourCC,
      width,
      height,
      dataOffset,
      mipmapCount
    };
  }
  function getTextureFormat(header, flags, fourCC, buffer) {
    if (flags & DDS.PIXEL_FORMAT_FLAGS.FOURCC) {
      if (fourCC === DDS.D3DFMT.DX10) {
        const dx10Header = new Uint32Array(
          buffer,
          DDS.MAGIC_SIZE + DDS.HEADER_SIZE,
          // there is a 20-byte DDS_HEADER_DX10 after DDS_HEADER
          DDS.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT
        );
        const miscFlag = dx10Header[DDS.HEADER_DX10_FIELDS.MISC_FLAG];
        if (miscFlag === DDS.RESOURCE_MISC_TEXTURECUBE) {
          throw new Error("DDSParser does not support cubemap textures");
        }
        const resourceDimension = dx10Header[DDS.HEADER_DX10_FIELDS.RESOURCE_DIMENSION];
        if (resourceDimension === DDS.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
          throw new Error("DDSParser does not supported 3D texture data");
        }
        const dxgiFormat = dx10Header[DDS.HEADER_DX10_FIELDS.DXGI_FORMAT];
        if (dxgiFormat in DXGI_TO_TEXTURE_FORMAT) {
          return DXGI_TO_TEXTURE_FORMAT[dxgiFormat];
        }
        throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
      }
      if (fourCC in FOURCC_TO_TEXTURE_FORMAT) {
        return FOURCC_TO_TEXTURE_FORMAT[fourCC];
      }
      throw new Error(`DDSParser cannot parse texture data with fourCC format ${fourCC}`);
    }
    if (flags & DDS.PIXEL_FORMAT_FLAGS.RGB || flags & DDS.PIXEL_FORMAT_FLAGS.RGBA) {
      return getUncompressedTextureFormat(header);
    }
    if (flags & DDS.PIXEL_FORMAT_FLAGS.YUV) {
      throw new Error("DDSParser does not supported YUV uncompressed texture data.");
    }
    if (flags & DDS.PIXEL_FORMAT_FLAGS.LUMINANCE || flags & DDS.PIXEL_FORMAT_FLAGS.LUMINANCEA) {
      throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
    }
    if (flags & DDS.PIXEL_FORMAT_FLAGS.ALPHA || flags & DDS.PIXEL_FORMAT_FLAGS.ALPHAPIXELS) {
      throw new Error("DDSParser does not support single-channel (alpha) texture data!");
    }
    throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
  }
  function getUncompressedTextureFormat(header) {
    const bitCount = header[DDS.HEADER_FIELDS.RGB_BITCOUNT];
    const rBitMask = header[DDS.HEADER_FIELDS.R_BIT_MASK];
    const gBitMask = header[DDS.HEADER_FIELDS.G_BIT_MASK];
    const bBitMask = header[DDS.HEADER_FIELDS.B_BIT_MASK];
    const aBitMask = header[DDS.HEADER_FIELDS.A_BIT_MASK];
    switch (bitCount) {
      case 32:
        if (rBitMask === 255 && gBitMask === 65280 && bBitMask === 16711680 && aBitMask === 4278190080) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];
        }
        if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 4278190080) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];
        }
        if (rBitMask === 1072693248 && gBitMask === 1047552 && bBitMask === 1023 && aBitMask === 3221225472) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];
        }
        if (rBitMask === 65535 && gBitMask === 4294901760 && bBitMask === 0 && aBitMask === 0) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];
        }
        if (rBitMask === 4294967295 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];
        }
        break;
      case 24:
        if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 32768) {
        }
        break;
      case 16:
        if (rBitMask === 31744 && gBitMask === 992 && bBitMask === 31 && aBitMask === 32768) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];
        }
        if (rBitMask === 63488 && gBitMask === 2016 && bBitMask === 31 && aBitMask === 0) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];
        }
        if (rBitMask === 3840 && gBitMask === 240 && bBitMask === 15 && aBitMask === 61440) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];
        }
        if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 65280) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];
        }
        if (rBitMask === 65535 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];
        }
        break;
      case 8:
        if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];
        }
        break;
    }
    throw new Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${bitCount}, rBitMask = ${rBitMask}, gBitMask = ${gBitMask}, aBitMask = ${aBitMask}`);
  }

  // node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.mjs
  var loadDDS = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High,
      name: "loadDDS"
    },
    /** used for deprecation purposes */
    name: "loadDDS",
    id: "dds",
    test(url) {
      return checkExtension(url, [".dds"]);
    },
    load(url, _asset, loader) {
      return __async(this, null, function* () {
        const supportedTextures = yield getSupportedTextureFormats();
        const ddsResponse = yield fetch(url);
        const ddsArrayBuffer = yield ddsResponse.arrayBuffer();
        const textureOptions = parseDDS(ddsArrayBuffer, supportedTextures);
        const compressedTextureSource = new CompressedSource(textureOptions);
        return createTexture(compressedTextureSource, loader, url);
      });
    },
    unload(texture) {
      if (Array.isArray(texture)) {
        texture.forEach((t2) => t2.destroy(true));
      } else {
        texture.destroy(true);
      }
    }
  };

  // node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.mjs
  init_LoaderParser();
  init_Extensions();

  // node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs
  var GL_INTERNAL_FORMAT = /* @__PURE__ */ ((GL_INTERNAL_FORMAT2) => {
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA"] = 6408] = "RGBA";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8UI"] = 36220] = "RGBA8UI";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8I"] = 36238] = "RGBA8I";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8"] = 32856] = "RGBA8";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
    GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
    return GL_INTERNAL_FORMAT2;
  })(GL_INTERNAL_FORMAT || {});
  var INTERNAL_FORMAT_TO_TEXTURE_FORMATS = {
    [
      33776
      /* COMPRESSED_RGB_S3TC_DXT1_EXT */
    ]: "bc1-rgba-unorm",
    // TODO: ???
    [
      33777
      /* COMPRESSED_RGBA_S3TC_DXT1_EXT */
    ]: "bc1-rgba-unorm",
    [
      33778
      /* COMPRESSED_RGBA_S3TC_DXT3_EXT */
    ]: "bc2-rgba-unorm",
    [
      33779
      /* COMPRESSED_RGBA_S3TC_DXT5_EXT */
    ]: "bc3-rgba-unorm",
    [
      35916
      /* COMPRESSED_SRGB_S3TC_DXT1_EXT */
    ]: "bc1-rgba-unorm-srgb",
    // TODO: ???
    [
      35917
      /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
    ]: "bc1-rgba-unorm-srgb",
    [
      35918
      /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
    ]: "bc2-rgba-unorm-srgb",
    [
      35919
      /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
    ]: "bc3-rgba-unorm-srgb",
    [
      36283
      /* COMPRESSED_RED_RGTC1_EXT */
    ]: "bc4-r-unorm",
    [
      36284
      /* COMPRESSED_SIGNED_RED_RGTC1_EXT */
    ]: "bc4-r-snorm",
    [
      36285
      /* COMPRESSED_RED_GREEN_RGTC2_EXT */
    ]: "bc5-rg-unorm",
    [
      36286
      /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */
    ]: "bc5-rg-snorm",
    [
      37488
      /* COMPRESSED_R11_EAC */
    ]: "eac-r11unorm",
    // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_R11_EAC]: 'eac-r11snorm',
    [
      37490
      /* COMPRESSED_RG11_EAC */
    ]: "eac-rg11snorm",
    // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RG11_EAC]: 'eac-rg11unorm',
    [
      37492
      /* COMPRESSED_RGB8_ETC2 */
    ]: "etc2-rgb8unorm",
    [
      37496
      /* COMPRESSED_RGBA8_ETC2_EAC */
    ]: "etc2-rgba8unorm",
    [
      37493
      /* COMPRESSED_SRGB8_ETC2 */
    ]: "etc2-rgb8unorm-srgb",
    [
      37497
      /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
    ]: "etc2-rgba8unorm-srgb",
    [
      37494
      /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
    ]: "etc2-rgb8a1unorm",
    [
      37495
      /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
    ]: "etc2-rgb8a1unorm-srgb",
    [
      37808
      /* COMPRESSED_RGBA_ASTC_4x4_KHR */
    ]: "astc-4x4-unorm",
    [
      37840
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */
    ]: "astc-4x4-unorm-srgb",
    [
      37809
      /* COMPRESSED_RGBA_ASTC_5x4_KHR */
    ]: "astc-5x4-unorm",
    [
      37841
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */
    ]: "astc-5x4-unorm-srgb",
    [
      37810
      /* COMPRESSED_RGBA_ASTC_5x5_KHR */
    ]: "astc-5x5-unorm",
    [
      37842
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */
    ]: "astc-5x5-unorm-srgb",
    [
      37811
      /* COMPRESSED_RGBA_ASTC_6x5_KHR */
    ]: "astc-6x5-unorm",
    [
      37843
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */
    ]: "astc-6x5-unorm-srgb",
    [
      37812
      /* COMPRESSED_RGBA_ASTC_6x6_KHR */
    ]: "astc-6x6-unorm",
    [
      37844
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */
    ]: "astc-6x6-unorm-srgb",
    [
      37813
      /* COMPRESSED_RGBA_ASTC_8x5_KHR */
    ]: "astc-8x5-unorm",
    [
      37845
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */
    ]: "astc-8x5-unorm-srgb",
    [
      37814
      /* COMPRESSED_RGBA_ASTC_8x6_KHR */
    ]: "astc-8x6-unorm",
    [
      37846
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */
    ]: "astc-8x6-unorm-srgb",
    [
      37815
      /* COMPRESSED_RGBA_ASTC_8x8_KHR */
    ]: "astc-8x8-unorm",
    [
      37847
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */
    ]: "astc-8x8-unorm-srgb",
    [
      37816
      /* COMPRESSED_RGBA_ASTC_10x5_KHR */
    ]: "astc-10x5-unorm",
    [
      37848
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */
    ]: "astc-10x5-unorm-srgb",
    [
      37817
      /* COMPRESSED_RGBA_ASTC_10x6_KHR */
    ]: "astc-10x6-unorm",
    [
      37849
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */
    ]: "astc-10x6-unorm-srgb",
    [
      37818
      /* COMPRESSED_RGBA_ASTC_10x8_KHR */
    ]: "astc-10x8-unorm",
    [
      37850
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */
    ]: "astc-10x8-unorm-srgb",
    [
      37819
      /* COMPRESSED_RGBA_ASTC_10x10_KHR */
    ]: "astc-10x10-unorm",
    [
      37851
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */
    ]: "astc-10x10-unorm-srgb",
    [
      37820
      /* COMPRESSED_RGBA_ASTC_12x10_KHR */
    ]: "astc-12x10-unorm",
    [
      37852
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */
    ]: "astc-12x10-unorm-srgb",
    [
      37821
      /* COMPRESSED_RGBA_ASTC_12x12_KHR */
    ]: "astc-12x12-unorm",
    [
      37853
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */
    ]: "astc-12x12-unorm-srgb",
    [
      36492
      /* COMPRESSED_RGBA_BPTC_UNORM_EXT */
    ]: "bc7-rgba-unorm",
    [
      36493
      /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */
    ]: "bc7-rgba-unorm-srgb",
    [
      36494
      /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */
    ]: "bc6h-rgb-float",
    [
      36495
      /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */
    ]: "bc6h-rgb-ufloat",
    [
      35907
      /* SRGB8_ALPHA8 */
    ]: "rgba8unorm-srgb",
    [
      36759
      /* RGBA8_SNORM */
    ]: "rgba8snorm",
    [
      36220
      /* RGBA8UI */
    ]: "rgba8uint",
    [
      36238
      /* RGBA8I */
    ]: "rgba8sint",
    [
      6408
      /* RGBA */
    ]: "rgba8unorm"
    // [GL_INTERNAL_FORMAT.RGBA8]: 'bgra8unorm'
  };
  var FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
  var FIELDS = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60
  };
  var FILE_HEADER_SIZE = 64;
  var ENDIANNESS = 67305985;
  var TYPES_TO_BYTES_PER_COMPONENT = {
    [
      5121
      /* UNSIGNED_BYTE */
    ]: 1,
    [
      5123
      /* UNSIGNED_SHORT */
    ]: 2,
    [
      5124
      /* INT */
    ]: 4,
    [
      5125
      /* UNSIGNED_INT */
    ]: 4,
    [
      5126
      /* FLOAT */
    ]: 4,
    [
      36193
      /* HALF_FLOAT */
    ]: 8
  };
  var FORMATS_TO_COMPONENTS = {
    [
      6408
      /* RGBA */
    ]: 4,
    [
      6407
      /* RGB */
    ]: 3,
    [
      33319
      /* RG */
    ]: 2,
    [
      6403
      /* RED */
    ]: 1,
    [
      6409
      /* LUMINANCE */
    ]: 1,
    [
      6410
      /* LUMINANCE_ALPHA */
    ]: 2,
    [
      6406
      /* ALPHA */
    ]: 1
  };
  var TYPES_TO_BYTES_PER_PIXEL = {
    [
      32819
      /* UNSIGNED_SHORT_4_4_4_4 */
    ]: 2,
    [
      32820
      /* UNSIGNED_SHORT_5_5_5_1 */
    ]: 2,
    [
      33635
      /* UNSIGNED_SHORT_5_6_5 */
    ]: 2
  };
  var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
    [
      33776
      /* COMPRESSED_RGB_S3TC_DXT1_EXT */
    ]: 0.5,
    [
      33777
      /* COMPRESSED_RGBA_S3TC_DXT1_EXT */
    ]: 0.5,
    [
      33778
      /* COMPRESSED_RGBA_S3TC_DXT3_EXT */
    ]: 1,
    [
      33779
      /* COMPRESSED_RGBA_S3TC_DXT5_EXT */
    ]: 1,
    [
      35916
      /* COMPRESSED_SRGB_S3TC_DXT1_EXT */
    ]: 0.5,
    [
      35917
      /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
    ]: 0.5,
    [
      35918
      /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
    ]: 1,
    [
      35919
      /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
    ]: 1,
    [
      36283
      /* COMPRESSED_RED_RGTC1_EXT */
    ]: 0.5,
    [
      36284
      /* COMPRESSED_SIGNED_RED_RGTC1_EXT */
    ]: 0.5,
    [
      36285
      /* COMPRESSED_RED_GREEN_RGTC2_EXT */
    ]: 1,
    [
      36286
      /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */
    ]: 1,
    [
      37488
      /* COMPRESSED_R11_EAC */
    ]: 0.5,
    [
      37489
      /* COMPRESSED_SIGNED_R11_EAC */
    ]: 0.5,
    [
      37490
      /* COMPRESSED_RG11_EAC */
    ]: 1,
    [
      37491
      /* COMPRESSED_SIGNED_RG11_EAC */
    ]: 1,
    [
      37492
      /* COMPRESSED_RGB8_ETC2 */
    ]: 0.5,
    [
      37496
      /* COMPRESSED_RGBA8_ETC2_EAC */
    ]: 1,
    [
      37493
      /* COMPRESSED_SRGB8_ETC2 */
    ]: 0.5,
    [
      37497
      /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
    ]: 1,
    [
      37494
      /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
    ]: 0.5,
    [
      37495
      /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
    ]: 0.5,
    [
      37808
      /* COMPRESSED_RGBA_ASTC_4x4_KHR */
    ]: 1,
    [
      37840
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */
    ]: 1,
    [
      37809
      /* COMPRESSED_RGBA_ASTC_5x4_KHR */
    ]: 0.8,
    [
      37841
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */
    ]: 0.8,
    [
      37810
      /* COMPRESSED_RGBA_ASTC_5x5_KHR */
    ]: 0.64,
    [
      37842
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */
    ]: 0.64,
    [
      37811
      /* COMPRESSED_RGBA_ASTC_6x5_KHR */
    ]: 0.53375,
    [
      37843
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */
    ]: 0.53375,
    [
      37812
      /* COMPRESSED_RGBA_ASTC_6x6_KHR */
    ]: 0.445,
    [
      37844
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */
    ]: 0.445,
    [
      37813
      /* COMPRESSED_RGBA_ASTC_8x5_KHR */
    ]: 0.4,
    [
      37845
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */
    ]: 0.4,
    [
      37814
      /* COMPRESSED_RGBA_ASTC_8x6_KHR */
    ]: 0.33375,
    [
      37846
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */
    ]: 0.33375,
    [
      37815
      /* COMPRESSED_RGBA_ASTC_8x8_KHR */
    ]: 0.25,
    [
      37847
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */
    ]: 0.25,
    [
      37816
      /* COMPRESSED_RGBA_ASTC_10x5_KHR */
    ]: 0.32,
    [
      37848
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */
    ]: 0.32,
    [
      37817
      /* COMPRESSED_RGBA_ASTC_10x6_KHR */
    ]: 0.26625,
    [
      37849
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */
    ]: 0.26625,
    [
      37818
      /* COMPRESSED_RGBA_ASTC_10x8_KHR */
    ]: 0.2,
    [
      37850
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */
    ]: 0.2,
    [
      37819
      /* COMPRESSED_RGBA_ASTC_10x10_KHR */
    ]: 0.16,
    [
      37851
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */
    ]: 0.16,
    [
      37820
      /* COMPRESSED_RGBA_ASTC_12x10_KHR */
    ]: 0.13375,
    [
      37852
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */
    ]: 0.13375,
    [
      37821
      /* COMPRESSED_RGBA_ASTC_12x12_KHR */
    ]: 0.11125,
    [
      37853
      /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */
    ]: 0.11125,
    [
      36492
      /* COMPRESSED_RGBA_BPTC_UNORM_EXT */
    ]: 1,
    [
      36493
      /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */
    ]: 1,
    [
      36494
      /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */
    ]: 1,
    [
      36495
      /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */
    ]: 1
  };
  var KTX = {
    FILE_HEADER_SIZE,
    FILE_IDENTIFIER,
    FORMATS_TO_COMPONENTS,
    INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
    INTERNAL_FORMAT_TO_TEXTURE_FORMATS,
    FIELDS,
    TYPES_TO_BYTES_PER_COMPONENT,
    TYPES_TO_BYTES_PER_PIXEL,
    ENDIANNESS
  };

  // node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs
  function parseKTX(arrayBuffer, supportedFormats) {
    const dataView = new DataView(arrayBuffer);
    if (!validate(dataView)) {
      throw new Error("Invalid KTX identifier in header");
    }
    const {
      littleEndian,
      glType,
      glFormat,
      glInternalFormat,
      pixelWidth,
      pixelHeight,
      numberOfMipmapLevels,
      offset
    } = parseKTXHeader(dataView);
    const textureFormat = KTX.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat];
    if (!textureFormat) {
      throw new Error(`Unknown texture format ${glInternalFormat}`);
    }
    if (!supportedFormats.includes(textureFormat)) {
      throw new Error(`Unsupported texture format: ${textureFormat}, supportedFormats: ${supportedFormats}`);
    }
    const imagePixelByteSize = getImagePixelByteSize(glType, glFormat, glInternalFormat);
    const imageBuffers = getImageBuffers(
      dataView,
      glType,
      imagePixelByteSize,
      pixelWidth,
      pixelHeight,
      offset,
      numberOfMipmapLevels,
      littleEndian
    );
    return {
      format: textureFormat,
      width: pixelWidth,
      height: pixelHeight,
      resource: imageBuffers,
      alphaMode: "no-premultiply-alpha"
    };
  }
  function getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset, numberOfMipmapLevels, littleEndian) {
    const alignedWidth = pixelWidth + 3 & ~3;
    const alignedHeight = pixelHeight + 3 & ~3;
    let imagePixels = pixelWidth * pixelHeight;
    if (glType === 0) {
      imagePixels = alignedWidth * alignedHeight;
    }
    let mipByteSize = imagePixels * imagePixelByteSize;
    let mipWidth = pixelWidth;
    let mipHeight = pixelHeight;
    let alignedMipWidth = alignedWidth;
    let alignedMipHeight = alignedHeight;
    let imageOffset = offset;
    const imageBuffers = new Array(numberOfMipmapLevels);
    for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
      const imageSize = dataView.getUint32(imageOffset, littleEndian);
      let elementOffset = imageOffset + 4;
      imageBuffers[mipmapLevel] = new Uint8Array(dataView.buffer, elementOffset, mipByteSize);
      elementOffset += mipByteSize;
      imageOffset += imageSize + 4;
      imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
      mipWidth = mipWidth >> 1 || 1;
      mipHeight = mipHeight >> 1 || 1;
      alignedMipWidth = mipWidth + 4 - 1 & ~(4 - 1);
      alignedMipHeight = mipHeight + 4 - 1 & ~(4 - 1);
      mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
    }
    return imageBuffers;
  }
  function getImagePixelByteSize(glType, glFormat, glInternalFormat) {
    let imagePixelByteSize = KTX.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
    if (glType !== 0) {
      if (KTX.TYPES_TO_BYTES_PER_COMPONENT[glType]) {
        imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_COMPONENT[glType] * KTX.FORMATS_TO_COMPONENTS[glFormat];
      } else {
        imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_PIXEL[glType];
      }
    }
    if (imagePixelByteSize === void 0) {
      throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    }
    return imagePixelByteSize;
  }
  function parseKTXHeader(dataView) {
    const littleEndian = dataView.getUint32(KTX.FIELDS.ENDIANNESS, true) === KTX.ENDIANNESS;
    const glType = dataView.getUint32(KTX.FIELDS.GL_TYPE, littleEndian);
    const glFormat = dataView.getUint32(KTX.FIELDS.GL_FORMAT, littleEndian);
    const glInternalFormat = dataView.getUint32(KTX.FIELDS.GL_INTERNAL_FORMAT, littleEndian);
    const pixelWidth = dataView.getUint32(KTX.FIELDS.PIXEL_WIDTH, littleEndian);
    const pixelHeight = dataView.getUint32(KTX.FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
    const pixelDepth = dataView.getUint32(KTX.FIELDS.PIXEL_DEPTH, littleEndian) || 1;
    const numberOfArrayElements = dataView.getUint32(KTX.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
    const numberOfFaces = dataView.getUint32(KTX.FIELDS.NUMBER_OF_FACES, littleEndian);
    const numberOfMipmapLevels = dataView.getUint32(KTX.FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
    const bytesOfKeyValueData = dataView.getUint32(KTX.FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
    if (pixelHeight === 0 || pixelDepth !== 1) {
      throw new Error("Only 2D textures are supported");
    }
    if (numberOfFaces !== 1) {
      throw new Error("CubeTextures are not supported by KTXLoader yet!");
    }
    if (numberOfArrayElements !== 1) {
      throw new Error("WebGL does not support array textures");
    }
    return {
      littleEndian,
      glType,
      glFormat,
      glInternalFormat,
      pixelWidth,
      pixelHeight,
      numberOfMipmapLevels,
      offset: KTX.FILE_HEADER_SIZE + bytesOfKeyValueData
    };
  }
  function validate(dataView) {
    for (let i3 = 0; i3 < KTX.FILE_IDENTIFIER.length; i3++) {
      if (dataView.getUint8(i3) !== KTX.FILE_IDENTIFIER[i3]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.mjs
  var loadKTX = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High,
      name: "loadKTX"
    },
    /** used for deprecation purposes */
    name: "loadKTX",
    id: "ktx",
    test(url) {
      return checkExtension(url, ".ktx");
    },
    load(url, _asset, loader) {
      return __async(this, null, function* () {
        const supportedTextures = yield getSupportedTextureFormats();
        const ktxResponse = yield fetch(url);
        const ktxArrayBuffer = yield ktxResponse.arrayBuffer();
        const textureOptions = parseKTX(ktxArrayBuffer, supportedTextures);
        const compressedTextureSource = new CompressedSource(textureOptions);
        return createTexture(compressedTextureSource, loader, url);
      });
    },
    unload(texture) {
      if (Array.isArray(texture)) {
        texture.forEach((t2) => t2.destroy(true));
      } else {
        texture.destroy(true);
      }
    }
  };

  // node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.mjs
  init_LoaderParser();
  init_Extensions();

  // node_modules/pixi.js/lib/_virtual/ktx.worker.mjs
  var WORKER_CODE4 = '(function () {\n    \'use strict\';\n\n    const converters = {\n      rgb8unorm: {\n        convertedFormat: "rgba8unorm",\n        convertFunction: convertRGBtoRGBA\n      },\n      "rgb8unorm-srgb": {\n        convertedFormat: "rgba8unorm-srgb",\n        convertFunction: convertRGBtoRGBA\n      }\n    };\n    function convertFormatIfRequired(textureOptions) {\n      const format = textureOptions.format;\n      if (converters[format]) {\n        const convertFunction = converters[format].convertFunction;\n        const levelBuffers = textureOptions.resource;\n        for (let i = 0; i < levelBuffers.length; i++) {\n          levelBuffers[i] = convertFunction(levelBuffers[i]);\n        }\n        textureOptions.format = converters[format].convertedFormat;\n      }\n    }\n    function convertRGBtoRGBA(levelBuffer) {\n      const pixelCount = levelBuffer.byteLength / 3;\n      const levelBufferWithAlpha = new Uint32Array(pixelCount);\n      for (let i = 0; i < pixelCount; ++i) {\n        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;\n      }\n      return new Uint8Array(levelBufferWithAlpha.buffer);\n    }\n\n    function createLevelBuffersFromKTX(ktxTexture) {\n      const levelBuffers = [];\n      for (let i = 0; i < ktxTexture.numLevels; i++) {\n        const imageData = ktxTexture.getImageData(i, 0, 0);\n        const levelBuffer = new Uint8Array(imageData.byteLength);\n        levelBuffer.set(imageData);\n        levelBuffers.push(levelBuffer);\n      }\n      return levelBuffers;\n    }\n\n    const glFormatToGPUFormatMap = {\n      6408: "rgba8unorm",\n      32856: "bgra8unorm",\n      //\n      32857: "rgb10a2unorm",\n      33189: "depth16unorm",\n      33190: "depth24plus",\n      33321: "r8unorm",\n      33323: "rg8unorm",\n      33325: "r16float",\n      33326: "r32float",\n      33327: "rg16float",\n      33328: "rg32float",\n      33329: "r8sint",\n      33330: "r8uint",\n      33331: "r16sint",\n      33332: "r16uint",\n      33333: "r32sint",\n      33334: "r32uint",\n      33335: "rg8sint",\n      33336: "rg8uint",\n      33337: "rg16sint",\n      33338: "rg16uint",\n      33339: "rg32sint",\n      33340: "rg32uint",\n      33778: "bc2-rgba-unorm",\n      33779: "bc3-rgba-unorm",\n      34836: "rgba32float",\n      34842: "rgba16float",\n      35056: "depth24plus-stencil8",\n      35898: "rg11b10ufloat",\n      35901: "rgb9e5ufloat",\n      35907: "rgba8unorm-srgb",\n      // bgra8unorm-srgb\n      36012: "depth32float",\n      36013: "depth32float-stencil8",\n      36168: "stencil8",\n      36208: "rgba32uint",\n      36214: "rgba16uint",\n      36220: "rgba8uint",\n      36226: "rgba32sint",\n      36232: "rgba16sint",\n      36238: "rgba8sint",\n      36492: "bc7-rgba-unorm",\n      36756: "r8snorm",\n      36757: "rg8snorm",\n      36759: "rgba8snorm",\n      37496: "etc2-rgba8unorm",\n      37808: "astc-4x4-unorm"\n    };\n    function glFormatToGPUFormat(glInternalFormat) {\n      const format = glFormatToGPUFormatMap[glInternalFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\n    }\n\n    const vkFormatToGPUFormatMap = {\n      23: "rgb8unorm",\n      // VK_FORMAT_R8G8B8_UNORM\n      37: "rgba8unorm",\n      // VK_FORMAT_R8G8B8A8_UNORM\n      43: "rgba8unorm-srgb"\n      // VK_FORMAT_R8G8B8A8_SRGB\n      // TODO add more!\n    };\n    function vkFormatToGPUFormat(vkFormat) {\n      const format = vkFormatToGPUFormatMap[vkFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported VkFormat: ${vkFormat}`);\n    }\n\n    function getTextureFormatFromKTXTexture(ktxTexture) {\n      if (ktxTexture.classId === 2) {\n        return vkFormatToGPUFormat(ktxTexture.vkFormat);\n      }\n      return glFormatToGPUFormat(ktxTexture.glInternalformat);\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap = {\n      "bc3-rgba-unorm": "BC3_RGBA",\n      "bc7-rgba-unorm": "BC7_M5_RGBA",\n      "etc2-rgba8unorm": "ETC2_RGBA",\n      "astc-4x4-unorm": "ASTC_4x4_RGBA",\n      // Uncompressed\n      rgba8unorm: "RGBA32",\n      rg11b10ufloat: "R11F_G11F_B10F"\n    };\n    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings = {\n      jsUrl: "",\n      wasmUrl: ""\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let ktxPromise;\n    async function getKTX() {\n      if (!ktxPromise) {\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        ktxPromise = new Promise((resolve) => {\n          LIBKTX({\n            locateFile: (_file) => absoluteWasmUrl\n          }).then((libktx) => {\n            resolve(libktx);\n          });\n        });\n      }\n      return ktxPromise;\n    }\n    async function fetchKTXTexture(url, ktx) {\n      const ktx2Response = await fetch(url);\n      if (ktx2Response.ok) {\n        const ktx2ArrayBuffer = await ktx2Response.arrayBuffer();\n        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));\n      }\n      throw new Error(`Failed to load KTX(2) texture: ${url}`);\n    }\n    const preferredTranscodedFormat = [\n      "bc7-rgba-unorm",\n      "astc-4x4-unorm",\n      "etc2-rgba8unorm",\n      "bc3-rgba-unorm",\n      "rgba8unorm"\n    ];\n    async function load(url) {\n      const ktx = await getKTX();\n      const ktxTexture = await fetchKTXTexture(url, ktx);\n      let format;\n      if (ktxTexture.needsTranscoding) {\n        format = basisTranscodedTextureFormat;\n        const transcodeFormat = ktx.TranscodeTarget[basisTranscoderFormat];\n        const result = ktxTexture.transcodeBasis(transcodeFormat, 0);\n        if (result !== ktx.ErrorCode.SUCCESS) {\n          throw new Error("Unable to transcode basis texture.");\n        }\n      } else {\n        format = getTextureFormatFromKTXTexture(ktxTexture);\n      }\n      const levelBuffers = createLevelBuffersFromKTX(ktxTexture);\n      const textureOptions = {\n        width: ktxTexture.baseWidth,\n        height: ktxTexture.baseHeight,\n        format,\n        mipLevelCount: ktxTexture.numLevels,\n        resource: levelBuffers,\n        alphaMode: "no-premultiply-alpha"\n      };\n      convertFormatIfRequired(textureOptions);\n      return textureOptions;\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl = jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl = wasmUrl;\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\n      basisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getKTX();\n    }\n    const messageHandlers = {\n      init: async (data) => {\n        const { jsUrl, wasmUrl, supportedTextures } = data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) => {\n        try {\n          const textureOptions = await load(data.url);\n          return {\n            type: "load",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage = async (messageEvent) => {\n      const message = messageEvent.data;\n      try {\n        const response = await messageHandlers[message.type]?.(message);\n        if (response) {\n          self.postMessage(response, response.transferables);\n        }\n      } catch (err) {\n        self.postMessage({\n          type: "error",\n          err,\n          url: message.url\n        });\n      }\n    };\n\n})();\n';
  var WORKER_URL4 = null;
  var WorkerInstance4 = class {
    constructor() {
      if (!WORKER_URL4) {
        WORKER_URL4 = URL.createObjectURL(new Blob([WORKER_CODE4], { type: "application/javascript" }));
      }
      this.worker = new Worker(WORKER_URL4);
    }
  };
  WorkerInstance4.revokeObjectURL = function revokeObjectURL4() {
    if (WORKER_URL4) {
      URL.revokeObjectURL(WORKER_URL4);
      WORKER_URL4 = null;
    }
  };

  // node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs
  var ktxTranscoderUrls = {
    jsUrl: "https://cdn.jsdelivr.net/npm/pixi.js/transcoders/ktx/libktx.js",
    wasmUrl: "https://cdn.jsdelivr.net/npm/pixi.js/transcoders/ktx/libktx.wasm"
  };
  function setKTXTranscoderPath(config3) {
    Object.assign(ktxTranscoderUrls, config3);
  }

  // node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs
  var ktxWorker;
  var urlHash2 = {};
  var errorHash = {};
  function getKTX2Worker(supportedTextures) {
    if (!ktxWorker) {
      ktxWorker = new WorkerInstance4().worker;
      ktxWorker.onmessage = (messageEvent) => {
        const { err, success, url, textureOptions } = messageEvent.data;
        if (err) {
          errorHash[url](err);
          return;
        }
        if (!success) {
          console.warn("Failed to load KTX texture", url);
        }
        urlHash2[url](textureOptions);
      };
      ktxWorker.postMessage({
        type: "init",
        jsUrl: ktxTranscoderUrls.jsUrl,
        wasmUrl: ktxTranscoderUrls.wasmUrl,
        supportedTextures
      });
    }
    return ktxWorker;
  }
  function loadKTX2onWorker(url, supportedTextures) {
    const ktxWorker2 = getKTX2Worker(supportedTextures);
    return new Promise((resolve, reject) => {
      urlHash2[url] = resolve;
      errorHash[url] = reject;
      ktxWorker2.postMessage({ type: "load", url });
    });
  }

  // node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.mjs
  var loadKTX2 = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High,
      name: "loadKTX2"
    },
    /** used for deprecation purposes */
    name: "loadKTX2",
    id: "ktx2",
    test(url) {
      return checkExtension(url, ".ktx2");
    },
    load(url, _asset, loader) {
      return __async(this, null, function* () {
        const supportedTextures = yield getSupportedTextureFormats();
        const textureOptions = yield loadKTX2onWorker(url, supportedTextures);
        const compressedTextureSource = new CompressedSource(textureOptions);
        return createTexture(compressedTextureSource, loader, url);
      });
    },
    unload(texture) {
      return __async(this, null, function* () {
        if (Array.isArray(texture)) {
          texture.forEach((t2) => t2.destroy(true));
        } else {
          texture.destroy(true);
        }
      });
    }
  };

  // node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.mjs
  var converters = {
    rgb8unorm: {
      convertedFormat: "rgba8unorm",
      convertFunction: convertRGBtoRGBA
    },
    "rgb8unorm-srgb": {
      convertedFormat: "rgba8unorm-srgb",
      convertFunction: convertRGBtoRGBA
    }
  };
  function convertFormatIfRequired(textureOptions) {
    const format = textureOptions.format;
    if (converters[format]) {
      const convertFunction = converters[format].convertFunction;
      const levelBuffers = textureOptions.resource;
      for (let i3 = 0; i3 < levelBuffers.length; i3++) {
        levelBuffers[i3] = convertFunction(levelBuffers[i3]);
      }
      textureOptions.format = converters[format].convertedFormat;
    }
  }
  function convertRGBtoRGBA(levelBuffer) {
    const pixelCount = levelBuffer.byteLength / 3;
    const levelBufferWithAlpha = new Uint32Array(pixelCount);
    for (let i3 = 0; i3 < pixelCount; ++i3) {
      levelBufferWithAlpha[i3] = levelBuffer[i3 * 3] + (levelBuffer[i3 * 3 + 1] << 8) + (levelBuffer[i3 * 3 + 2] << 16) + 4278190080;
    }
    return new Uint8Array(levelBufferWithAlpha.buffer);
  }

  // node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs
  function createLevelBuffersFromKTX(ktxTexture) {
    const levelBuffers = [];
    for (let i3 = 0; i3 < ktxTexture.numLevels; i3++) {
      const imageData = ktxTexture.getImageData(i3, 0, 0);
      const levelBuffer = new Uint8Array(imageData.byteLength);
      levelBuffer.set(imageData);
      levelBuffers.push(levelBuffer);
    }
    return levelBuffers;
  }

  // node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs
  var glFormatToGPUFormatMap = {
    6408: "rgba8unorm",
    32856: "bgra8unorm",
    //
    32857: "rgb10a2unorm",
    33189: "depth16unorm",
    33190: "depth24plus",
    33321: "r8unorm",
    33323: "rg8unorm",
    33325: "r16float",
    33326: "r32float",
    33327: "rg16float",
    33328: "rg32float",
    33329: "r8sint",
    33330: "r8uint",
    33331: "r16sint",
    33332: "r16uint",
    33333: "r32sint",
    33334: "r32uint",
    33335: "rg8sint",
    33336: "rg8uint",
    33337: "rg16sint",
    33338: "rg16uint",
    33339: "rg32sint",
    33340: "rg32uint",
    33778: "bc2-rgba-unorm",
    33779: "bc3-rgba-unorm",
    34836: "rgba32float",
    34842: "rgba16float",
    35056: "depth24plus-stencil8",
    35898: "rg11b10ufloat",
    35901: "rgb9e5ufloat",
    35907: "rgba8unorm-srgb",
    // bgra8unorm-srgb
    36012: "depth32float",
    36013: "depth32float-stencil8",
    36168: "stencil8",
    36208: "rgba32uint",
    36214: "rgba16uint",
    36220: "rgba8uint",
    36226: "rgba32sint",
    36232: "rgba16sint",
    36238: "rgba8sint",
    36492: "bc7-rgba-unorm",
    36756: "r8snorm",
    36757: "rg8snorm",
    36759: "rgba8snorm",
    37496: "etc2-rgba8unorm",
    37808: "astc-4x4-unorm"
  };
  function glFormatToGPUFormat(glInternalFormat) {
    const format = glFormatToGPUFormatMap[glInternalFormat];
    if (format) {
      return format;
    }
    throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);
  }

  // node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs
  var vkFormatToGPUFormatMap = {
    23: "rgb8unorm",
    // VK_FORMAT_R8G8B8_UNORM
    37: "rgba8unorm",
    // VK_FORMAT_R8G8B8A8_UNORM
    43: "rgba8unorm-srgb"
    // VK_FORMAT_R8G8B8A8_SRGB
    // TODO add more!
  };
  function vkFormatToGPUFormat(vkFormat) {
    const format = vkFormatToGPUFormatMap[vkFormat];
    if (format) {
      return format;
    }
    throw new Error(`Unsupported VkFormat: ${vkFormat}`);
  }

  // node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs
  function getTextureFormatFromKTXTexture(ktxTexture) {
    if (ktxTexture.classId === 2) {
      return vkFormatToGPUFormat(ktxTexture.vkFormat);
    }
    return glFormatToGPUFormat(ktxTexture.glInternalformat);
  }

  // node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs
  var gpuFormatToBasisTranscoderFormatMap2 = {
    "bc3-rgba-unorm": "BC3_RGBA",
    "bc7-rgba-unorm": "BC7_M5_RGBA",
    "etc2-rgba8unorm": "ETC2_RGBA",
    "astc-4x4-unorm": "ASTC_4x4_RGBA",
    // Uncompressed
    rgba8unorm: "RGBA32",
    rg11b10ufloat: "R11F_G11F_B10F"
  };
  function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {
    const format = gpuFormatToBasisTranscoderFormatMap2[transcoderFormat];
    if (format) {
      return format;
    }
    throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);
  }

  // node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs
  init_Resolver();
  init_Extensions();
  var validFormats = ["basis", "bc7", "bc6h", "astc", "etc2", "bc5", "bc4", "bc3", "bc2", "bc1", "eac"];
  var resolveCompressedTextureUrl = {
    extension: ExtensionType.ResolveParser,
    test: (value) => checkExtension(value, [".ktx", ".ktx2", ".dds"]),
    parse: (value) => {
      var _a2, _b;
      let format;
      const splitValue = value.split(".");
      if (splitValue.length > 2) {
        const newFormat = splitValue[splitValue.length - 2];
        if (validFormats.includes(newFormat)) {
          format = newFormat;
        }
      } else {
        format = splitValue[splitValue.length - 1];
      }
      return {
        resolution: parseFloat((_b = (_a2 = Resolver.RETINA_PREFIX.exec(value)) == null ? void 0 : _a2[1]) != null ? _b : "1"),
        format,
        src: value
      };
    }
  };

  // node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.mjs
  var compressedTextureExtensions;
  var detectCompressed = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 2
    },
    test: () => __async(null, null, function* () {
      if (yield isWebGPUSupported())
        return true;
      if (isWebGLSupported())
        return true;
      return false;
    }),
    add: (formats) => __async(null, null, function* () {
      const supportedCompressedTextureFormats2 = yield getSupportedCompressedTextureFormats();
      compressedTextureExtensions = extractExtensionsForCompressedTextureFormats(supportedCompressedTextureFormats2);
      return [...compressedTextureExtensions, ...formats];
    }),
    remove: (formats) => __async(null, null, function* () {
      if (compressedTextureExtensions) {
        return formats.filter((f2) => !(f2 in compressedTextureExtensions));
      }
      return formats;
    })
  };
  function extractExtensionsForCompressedTextureFormats(formats) {
    const extensions2 = ["basis"];
    const dupeMap = {};
    formats.forEach((format) => {
      const extension = format.split("-")[0];
      if (extension && !dupeMap[extension]) {
        dupeMap[extension] = true;
        extensions2.push(extension);
      }
    });
    extensions2.sort((a2, b2) => {
      const aIndex = validFormats.indexOf(a2);
      const bIndex = validFormats.indexOf(b2);
      if (aIndex === -1) {
        return 1;
      }
      if (bIndex === -1) {
        return -1;
      }
      return aIndex - bIndex;
    });
    return extensions2;
  }

  // node_modules/pixi.js/lib/culling/Culler.mjs
  init_Bounds();
  init_getGlobalBounds();
  var tempBounds5 = new Bounds();
  var _Culler = class _Culler2 {
    /**
     * Culls the children of a specific container based on the given view rectangle.
     * This determines which objects should be rendered and which can be skipped.
     * @param container - The container to cull. Must be a Container instance.
     * @param view - The view rectangle that defines the visible area
     * @param skipUpdateTransform - Whether to skip updating transforms for better performance
     * @example
     * ```ts
     * // Basic culling with view bounds
     * const culler = new Culler();
     * culler.cull(stage, {
     *     x: 0,
     *     y: 0,
     *     width: 800,
     *     height: 600
     * });
     *
     * // Culling to renderer screen
     * culler.cull(stage, renderer.screen, false);
     * ```
     * @remarks
     * - Recursively processes all cullable children
     * - Uses cullArea if defined, otherwise calculates bounds
     * - Performance depends on scene complexity
     * @see {@link CullingMixinConstructor.cullable} For enabling culling on objects
     * @see {@link CullingMixinConstructor.cullArea} For custom culling boundaries
     */
    cull(container, view, skipUpdateTransform = true) {
      this._cullRecursive(container, view, skipUpdateTransform);
    }
    _cullRecursive(container, view, skipUpdateTransform = true) {
      var _a2;
      if (container.cullable && container.measurable && container.includeInBuild) {
        const bounds = (_a2 = container.cullArea) != null ? _a2 : getGlobalBounds(container, skipUpdateTransform, tempBounds5);
        container.culled = bounds.x >= view.x + view.width || bounds.y >= view.y + view.height || bounds.x + bounds.width <= view.x || bounds.y + bounds.height <= view.y;
      } else {
        container.culled = false;
      }
      if (!container.cullableChildren || container.culled || !container.renderable || !container.measurable || !container.includeInBuild)
        return;
      for (let i3 = 0; i3 < container.children.length; i3++) {
        this._cullRecursive(container.children[i3], view, skipUpdateTransform);
      }
    }
  };
  _Culler.shared = new _Culler();
  var Culler = _Culler;

  // node_modules/pixi.js/lib/culling/CullerPlugin.mjs
  init_Extensions();
  var CullerPlugin = class {
    /**
     * Initialize the plugin with scope of application instance
     * @private
     * @param {object} [options] - See application options
     */
    static init(options) {
      this._renderRef = this.render.bind(this);
      this.render = () => {
        var _a2;
        const updateTransform = ((_a2 = options == null ? void 0 : options.culler) == null ? void 0 : _a2.updateTransform) !== true;
        Culler.shared.cull(this.stage, this.renderer.screen, updateTransform);
        this.renderer.render({ container: this.stage });
      };
    }
    /** @internal */
    static destroy() {
      this.render = this._renderRef;
    }
  };
  CullerPlugin.extension = {
    priority: 10,
    type: ExtensionType.Application,
    name: "culler"
  };

  // node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.mjs
  var import_xmldom = __toESM(require_lib(), 1);
  var WebWorkerAdapter = {
    createCanvas: (width, height) => new OffscreenCanvas(width != null ? width : 0, height != null ? height : 0),
    createImage: () => new Image(),
    getCanvasRenderingContext2D: () => OffscreenCanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => globalThis.location.href,
    getFontFaceSet: () => globalThis.fonts,
    fetch: (url, options) => fetch(url, options),
    parseXML: (xml) => {
      const parser = new import_xmldom.DOMParser();
      return parser.parseFromString(xml, "text/xml");
    }
  };

  // node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs
  init_GlProgram();
  init_GpuProgram();
  init_UniformGroup();
  init_Filter();
  init_defaultFilter_vert();

  // node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs
  var fragment4 = "\nin vec2 vTextureCoord;\n\nout vec4 finalColor;\n\nuniform float uAlpha;\nuniform sampler2D uTexture;\n\nvoid main()\n{\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\n}\n";

  // node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs
  var source3 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct AlphaUniforms {\n  uAlpha:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n \n    var sample = textureSample(uTexture, uSampler, uv);\n    \n    return sample * alphaUniforms.uAlpha;\n}";

  // node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs
  var _AlphaFilter = class _AlphaFilter2 extends Filter {
    constructor(options) {
      options = __spreadValues(__spreadValues({}, _AlphaFilter2.defaultOptions), options);
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source: source3,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source3,
          entryPoint: "mainFragment"
        }
      });
      const glProgram3 = GlProgram.from({
        vertex: vertex2,
        fragment: fragment4,
        name: "alpha-filter"
      });
      const _a2 = options, { alpha } = _a2, rest = __objRest(_a2, ["alpha"]);
      const alphaUniforms = new UniformGroup({
        uAlpha: { value: alpha, type: "f32" }
      });
      super(__spreadProps(__spreadValues({}, rest), {
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        resources: {
          alphaUniforms
        }
      }));
    }
    /**
     * The alpha value of the filter.
     * Controls the transparency of the filtered display object.
     * @example
     * ```ts
     * // Create filter with initial alpha
     * const filter = new AlphaFilter({ alpha: 0.5 });
     *
     * // Update alpha value dynamically
     * filter.alpha = 0.8;
     * ```
     * @default 1
     * @remarks
     * - 0 = fully transparent
     * - 1 = fully opaque
     * - Values are clamped between 0 and 1
     */
    get alpha() {
      return this.resources.alphaUniforms.uniforms.uAlpha;
    }
    set alpha(value) {
      this.resources.alphaUniforms.uniforms.uAlpha = value;
    }
  };
  _AlphaFilter.defaultOptions = {
    /**
     * Amount of alpha transparency to apply.
     * - 0 = fully transparent
     * - 1 = fully opaque (default)
     * @default 1
     */
    alpha: 1
  };
  var AlphaFilter = _AlphaFilter;

  // node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs
  init_TexturePool();
  init_types2();
  init_deprecation();
  init_Filter();

  // node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs
  init_TexturePool();
  init_types2();
  init_Filter();

  // node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs
  init_GlProgram();

  // node_modules/pixi.js/lib/filters/defaults/blur/const.mjs
  var GAUSSIAN_VALUES = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
  };

  // node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs
  var fragTemplate2 = [
    "in vec2 vBlurTexCoords[%size%];",
    "uniform sampler2D uTexture;",
    "out vec4 finalColor;",
    "void main(void)",
    "{",
    "    finalColor = vec4(0.0);",
    "    %blur%",
    "}"
  ].join("\n");
  function generateBlurFragSource(kernelSize) {
    const kernel = GAUSSIAN_VALUES[kernelSize];
    const halfLength = kernel.length;
    let fragSource = fragTemplate2;
    let blurLoop = "";
    const template = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
    let value;
    for (let i3 = 0; i3 < kernelSize; i3++) {
      let blur = template.replace("%index%", i3.toString());
      value = i3;
      if (i3 >= halfLength) {
        value = kernelSize - i3 - 1;
      }
      blur = blur.replace("%value%", kernel[value].toString());
      blurLoop += blur;
      blurLoop += "\n";
    }
    fragSource = fragSource.replace("%blur%", blurLoop);
    fragSource = fragSource.replace("%size%", kernelSize.toString());
    return fragSource;
  }

  // node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs
  var vertTemplate = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
  function generateBlurVertSource(kernelSize, x2) {
    const halfLength = Math.ceil(kernelSize / 2);
    let vertSource = vertTemplate;
    let blurLoop = "";
    let template;
    if (x2) {
      template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);";
    } else {
      template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
    }
    for (let i3 = 0; i3 < kernelSize; i3++) {
      let blur = template.replace("%index%", i3.toString());
      blur = blur.replace("%sampleIndex%", `${i3 - (halfLength - 1)}.0`);
      blurLoop += blur;
      blurLoop += "\n";
    }
    vertSource = vertSource.replace("%blur%", blurLoop);
    vertSource = vertSource.replace("%size%", kernelSize.toString());
    vertSource = vertSource.replace("%dimension%", x2 ? "z" : "w");
    return vertSource;
  }

  // node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs
  function generateBlurGlProgram(horizontal, kernelSize) {
    const vertex6 = generateBlurVertSource(kernelSize, horizontal);
    const fragment11 = generateBlurFragSource(kernelSize);
    return GlProgram.from({
      vertex: vertex6,
      fragment: fragment11,
      name: `blur-${horizontal ? "horizontal" : "vertical"}-pass-filter`
    });
  }

  // node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs
  init_GpuProgram();

  // node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs
  var source4 = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlurUniforms {\n  uStrength:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    %blur-struct%\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n\n  let filteredCord = filterTextureCoord(aPosition);\n\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\n\n  return VSOutput(\n   filterVertexPosition(aPosition),\n    %blur-vertex-out%\n  );\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  %blur-fragment-in%\n) -> @location(0) vec4<f32> {\n\n    var   finalColor = vec4(0.0);\n\n    %blur-sampling%\n\n    return finalColor;\n}";

  // node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs
  function generateBlurProgram(horizontal, kernelSize) {
    const kernel = GAUSSIAN_VALUES[kernelSize];
    const halfLength = kernel.length;
    const blurStructSource = [];
    const blurOutSource = [];
    const blurSamplingSource = [];
    for (let i3 = 0; i3 < kernelSize; i3++) {
      blurStructSource[i3] = `@location(${i3}) offset${i3}: vec2<f32>,`;
      if (horizontal) {
        blurOutSource[i3] = `filteredCord + vec2(${i3 - halfLength + 1} * pixelStrength, 0.0),`;
      } else {
        blurOutSource[i3] = `filteredCord + vec2(0.0, ${i3 - halfLength + 1} * pixelStrength),`;
      }
      const kernelIndex = i3 < halfLength ? i3 : kernelSize - i3 - 1;
      const kernelValue = kernel[kernelIndex].toString();
      blurSamplingSource[i3] = `finalColor += textureSample(uTexture, uSampler, offset${i3}) * ${kernelValue};`;
    }
    const blurStruct = blurStructSource.join("\n");
    const blurOut = blurOutSource.join("\n");
    const blurSampling = blurSamplingSource.join("\n");
    const finalSource = source4.replace("%blur-struct%", blurStruct).replace("%blur-vertex-out%", blurOut).replace("%blur-fragment-in%", blurStruct).replace("%blur-sampling%", blurSampling).replace("%dimension%", horizontal ? "z" : "w");
    return GpuProgram.from({
      vertex: {
        source: finalSource,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: finalSource,
        entryPoint: "mainFragment"
      }
    });
  }

  // node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs
  var _BlurFilterPass = class _BlurFilterPass2 extends Filter {
    /**
     * @param options
     * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
     * @param options.strength - The strength of the blur filter.
     * @param options.quality - The quality of the blur filter.
     * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
     */
    constructor(options) {
      options = __spreadValues(__spreadValues({}, _BlurFilterPass2.defaultOptions), options);
      const glProgram3 = generateBlurGlProgram(options.horizontal, options.kernelSize);
      const gpuProgram3 = generateBlurProgram(options.horizontal, options.kernelSize);
      super(__spreadValues({
        glProgram: glProgram3,
        gpuProgram: gpuProgram3,
        resources: {
          blurUniforms: {
            uStrength: { value: 0, type: "f32" }
          }
        }
      }, options));
      this.horizontal = options.horizontal;
      this._quality = 0;
      this.quality = options.quality;
      this.blur = options.strength;
      this._uniforms = this.resources.blurUniforms.uniforms;
    }
    /**
     * Applies the filter.
     * @param filterManager - The manager.
     * @param input - The input target.
     * @param output - The output target.
     * @param clearMode - How to clear
     */
    apply(filterManager, input, output, clearMode) {
      this._uniforms.uStrength = this.strength / this.passes;
      if (this.passes === 1) {
        filterManager.applyFilter(this, input, output, clearMode);
      } else {
        const tempTexture = TexturePool.getSameSizeTexture(input);
        let flip = input;
        let flop = tempTexture;
        this._state.blend = false;
        const shouldClear = filterManager.renderer.type === RendererType.WEBGPU;
        for (let i3 = 0; i3 < this.passes - 1; i3++) {
          filterManager.applyFilter(this, flip, flop, i3 === 0 ? true : shouldClear);
          const temp = flop;
          flop = flip;
          flip = temp;
        }
        this._state.blend = true;
        filterManager.applyFilter(this, flip, output, clearMode);
        TexturePool.returnTexture(tempTexture);
      }
    }
    /**
     * Sets the strength of both the blur.
     * @default 16
     */
    get blur() {
      return this.strength;
    }
    set blur(value) {
      this.padding = 1 + Math.abs(value) * 2;
      this.strength = value;
    }
    /**
     * Sets the quality of the blur by modifying the number of passes. More passes means higher
     * quality blurring but the lower the performance.
     * @default 4
     */
    get quality() {
      return this._quality;
    }
    set quality(value) {
      this._quality = value;
      this.passes = value;
    }
  };
  _BlurFilterPass.defaultOptions = {
    /** The strength of the blur filter. */
    strength: 8,
    /** The quality of the blur filter. */
    quality: 4,
    /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
    kernelSize: 5
  };
  var BlurFilterPass = _BlurFilterPass;

  // node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs
  var BlurFilter = class extends Filter {
    constructor(...args) {
      var _a2;
      let options = (_a2 = args[0]) != null ? _a2 : {};
      if (typeof options === "number") {
        deprecation(v8_0_0, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");
        options = { strength: options };
        if (args[1] !== void 0)
          options.quality = args[1];
        if (args[2] !== void 0)
          options.resolution = args[2] || "inherit";
        if (args[3] !== void 0)
          options.kernelSize = args[3];
      }
      options = __spreadValues(__spreadValues({}, BlurFilterPass.defaultOptions), options);
      const _b = options, { strength, strengthX, strengthY, quality } = _b, rest = __objRest(_b, ["strength", "strengthX", "strengthY", "quality"]);
      super(__spreadProps(__spreadValues({}, rest), {
        compatibleRenderers: RendererType.BOTH,
        resources: {}
      }));
      this._repeatEdgePixels = false;
      this.blurXFilter = new BlurFilterPass(__spreadValues({ horizontal: true }, options));
      this.blurYFilter = new BlurFilterPass(__spreadValues({ horizontal: false }, options));
      this.quality = quality;
      this.strengthX = strengthX != null ? strengthX : strength;
      this.strengthY = strengthY != null ? strengthY : strength;
      this.repeatEdgePixels = false;
    }
    /**
     * Applies the filter.
     * @param filterManager - The manager.
     * @param input - The input target.
     * @param output - The output target.
     * @param clearMode - How to clear
     * @advanced
     */
    apply(filterManager, input, output, clearMode) {
      const xStrength = Math.abs(this.blurXFilter.strength);
      const yStrength = Math.abs(this.blurYFilter.strength);
      if (xStrength && yStrength) {
        const tempTexture = TexturePool.getSameSizeTexture(input);
        this.blurXFilter.blendMode = "normal";
        this.blurXFilter.apply(filterManager, input, tempTexture, true);
        this.blurYFilter.blendMode = this.blendMode;
        this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);
        TexturePool.returnTexture(tempTexture);
      } else if (yStrength) {
        this.blurYFilter.blendMode = this.blendMode;
        this.blurYFilter.apply(filterManager, input, output, clearMode);
      } else {
        this.blurXFilter.blendMode = this.blendMode;
        this.blurXFilter.apply(filterManager, input, output, clearMode);
      }
    }
    updatePadding() {
      if (this._repeatEdgePixels) {
        this.padding = 0;
      } else {
        this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;
      }
    }
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously.
     * Controls the overall intensity of the Gaussian blur effect.
     * @example
     * ```ts
     * // Set equal blur strength for both axes
     * filter.strength = 8;
     *
     * // Will throw error if X and Y are different
     * filter.strengthX = 4;
     * filter.strengthY = 8;
     * filter.strength; // Error: BlurFilter's strengthX and strengthY are different
     * ```
     * @default 8
     * @throws {Error} If strengthX and strengthY are different values
     */
    get strength() {
      if (this.strengthX !== this.strengthY) {
        throw new Error("BlurFilter's strengthX and strengthY are different");
      }
      return this.strengthX;
    }
    set strength(value) {
      this.blurXFilter.blur = this.blurYFilter.blur = value;
      this.updatePadding();
    }
    /**
     * Sets the number of passes for blur. More passes means higher quality blurring.
     * Controls the precision and smoothness of the blur effect at the cost of performance.
     * @example
     * ```ts
     * // High quality blur (slower)
     * filter.quality = 8;
     *
     * // Low quality blur (faster)
     * filter.quality = 2;
     * ```
     * @default 4
     * @remarks Higher values produce better quality but impact performance
     */
    get quality() {
      return this.blurXFilter.quality;
    }
    set quality(value) {
      this.blurXFilter.quality = this.blurYFilter.quality = value;
    }
    /**
     * Sets the strength of horizontal blur.
     * Controls the blur intensity along the x-axis independently.
     * @example
     * ```ts
     * // Apply horizontal-only blur
     * filter.strengthX = 8;
     * filter.strengthY = 0;
     *
     * // Create motion blur effect
     * filter.strengthX = 16;
     * filter.strengthY = 2;
     * ```
     * @default 8
     */
    get strengthX() {
      return this.blurXFilter.blur;
    }
    set strengthX(value) {
      this.blurXFilter.blur = value;
      this.updatePadding();
    }
    /**
     * Sets the strength of the vertical blur.
     * Controls the blur intensity along the y-axis independently.
     * @example
     * ```ts
     * // Apply vertical-only blur
     * filter.strengthX = 0;
     * filter.strengthY = 8;
     *
     * // Create radial blur effect
     * filter.strengthX = 8;
     * filter.strengthY = 8;
     * ```
     * @default 8
     */
    get strengthY() {
      return this.blurYFilter.blur;
    }
    set strengthY(value) {
      this.blurYFilter.blur = value;
      this.updatePadding();
    }
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     * @default 2
     * @deprecated since 8.3.0
     * @see BlurFilter.strength
     */
    get blur() {
      deprecation("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
      return this.strength;
    }
    set blur(value) {
      deprecation("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
      this.strength = value;
    }
    /**
     * Sets the strength of the blurX property
     * @default 2
     * @deprecated since 8.3.0
     * @see BlurFilter.strengthX
     */
    get blurX() {
      deprecation("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
      return this.strengthX;
    }
    set blurX(value) {
      deprecation("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
      this.strengthX = value;
    }
    /**
     * Sets the strength of the blurY property
     * @default 2
     * @deprecated since 8.3.0
     * @see BlurFilter.strengthY
     */
    get blurY() {
      deprecation("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
      return this.strengthY;
    }
    set blurY(value) {
      deprecation("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
      this.strengthY = value;
    }
    /**
     * If set to true the edge of the target will be clamped
     * @default false
     */
    get repeatEdgePixels() {
      return this._repeatEdgePixels;
    }
    set repeatEdgePixels(value) {
      this._repeatEdgePixels = value;
      this.updatePadding();
    }
  };
  BlurFilter.defaultOptions = {
    /** The strength of the blur filter. */
    strength: 8,
    /** The quality of the blur filter. */
    quality: 4,
    /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
    kernelSize: 5
  };

  // node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.mjs
  init_Color();
  init_GlProgram();
  init_GpuProgram();
  init_UniformGroup();
  init_Filter();
  init_defaultFilter_vert();

  // node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs
  var fragment5 = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uColorMatrix[20];\nuniform float uAlpha;\n\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * 0.2);\n    float diff = (randomValue - 0.5) *  0.5;\n\n    if (uAlpha == 0.0) {\n        finalColor = color;\n        return;\n    }\n\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    vec4 result;\n\n    result.r = (uColorMatrix[0] * color.r);\n        result.r += (uColorMatrix[1] * color.g);\n        result.r += (uColorMatrix[2] * color.b);\n        result.r += (uColorMatrix[3] * color.a);\n        result.r += uColorMatrix[4];\n\n    result.g = (uColorMatrix[5] * color.r);\n        result.g += (uColorMatrix[6] * color.g);\n        result.g += (uColorMatrix[7] * color.b);\n        result.g += (uColorMatrix[8] * color.a);\n        result.g += uColorMatrix[9];\n\n    result.b = (uColorMatrix[10] * color.r);\n       result.b += (uColorMatrix[11] * color.g);\n       result.b += (uColorMatrix[12] * color.b);\n       result.b += (uColorMatrix[13] * color.a);\n       result.b += uColorMatrix[14];\n\n    result.a = (uColorMatrix[15] * color.r);\n       result.a += (uColorMatrix[16] * color.g);\n       result.a += (uColorMatrix[17] * color.b);\n       result.a += (uColorMatrix[18] * color.a);\n       result.a += uColorMatrix[19];\n\n    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    finalColor = vec4(rgb, result.a);\n}\n";

  // node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs
  var source5 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct ColorMatrixUniforms {\n  uColorMatrix:array<vec4<f32>, 5>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n  };\n  \nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n\n\n  var c = textureSample(uTexture, uSampler, uv);\n  \n  if (colorMatrixUniforms.uAlpha == 0.0) {\n    return c;\n  }\n\n \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.r /= c.a;\n      c.g /= c.a;\n      c.b /= c.a;\n    }\n\n    var cm = colorMatrixUniforms.uColorMatrix;\n\n\n    var result = vec4<f32>(0.);\n\n    result.r = (cm[0][0] * c.r);\n    result.r += (cm[0][1] * c.g);\n    result.r += (cm[0][2] * c.b);\n    result.r += (cm[0][3] * c.a);\n    result.r += cm[1][0];\n\n    result.g = (cm[1][1] * c.r);\n    result.g += (cm[1][2] * c.g);\n    result.g += (cm[1][3] * c.b);\n    result.g += (cm[2][0] * c.a);\n    result.g += cm[2][1];\n\n    result.b = (cm[2][2] * c.r);\n    result.b += (cm[2][3] * c.g);\n    result.b += (cm[3][0] * c.b);\n    result.b += (cm[3][1] * c.a);\n    result.b += cm[3][2];\n\n    result.a = (cm[3][3] * c.r);\n    result.a += (cm[4][0] * c.g);\n    result.a += (cm[4][1] * c.b);\n    result.a += (cm[4][2] * c.a);\n    result.a += cm[4][3];\n\n    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);\n\n    rgb.r *= result.a;\n    rgb.g *= result.a;\n    rgb.b *= result.a;\n\n    return vec4(rgb, result.a);\n}";

  // node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.mjs
  var ColorMatrixFilter = class extends Filter {
    constructor(options = {}) {
      const colorMatrixUniforms = new UniformGroup({
        uColorMatrix: {
          value: [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ],
          type: "f32",
          size: 20
        },
        uAlpha: {
          value: 1,
          type: "f32"
        }
      });
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source: source5,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source5,
          entryPoint: "mainFragment"
        }
      });
      const glProgram3 = GlProgram.from({
        vertex: vertex2,
        fragment: fragment5,
        name: "color-matrix-filter"
      });
      super(__spreadProps(__spreadValues({}, options), {
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        resources: {
          colorMatrixUniforms
        }
      }));
      this.alpha = 1;
    }
    /**
     * Transforms current matrix and set the new one
     * @param {number[]} matrix - 5x4 matrix
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with matrix
     */
    _loadMatrix(matrix, multiply = false) {
      let newMatrix = matrix;
      if (multiply) {
        this._multiply(newMatrix, this.matrix, matrix);
        newMatrix = this._colorMatrix(newMatrix);
      }
      this.resources.colorMatrixUniforms.uniforms.uColorMatrix = newMatrix;
      this.resources.colorMatrixUniforms.update();
    }
    /**
     * Multiplies two mat5's
     * @private
     * @param out - 5x4 matrix the receiving matrix
     * @param a - 5x4 matrix the first operand
     * @param b - 5x4 matrix the second operand
     * @returns {number[]} 5x4 matrix
     */
    _multiply(out2, a2, b2) {
      out2[0] = a2[0] * b2[0] + a2[1] * b2[5] + a2[2] * b2[10] + a2[3] * b2[15];
      out2[1] = a2[0] * b2[1] + a2[1] * b2[6] + a2[2] * b2[11] + a2[3] * b2[16];
      out2[2] = a2[0] * b2[2] + a2[1] * b2[7] + a2[2] * b2[12] + a2[3] * b2[17];
      out2[3] = a2[0] * b2[3] + a2[1] * b2[8] + a2[2] * b2[13] + a2[3] * b2[18];
      out2[4] = a2[0] * b2[4] + a2[1] * b2[9] + a2[2] * b2[14] + a2[3] * b2[19] + a2[4];
      out2[5] = a2[5] * b2[0] + a2[6] * b2[5] + a2[7] * b2[10] + a2[8] * b2[15];
      out2[6] = a2[5] * b2[1] + a2[6] * b2[6] + a2[7] * b2[11] + a2[8] * b2[16];
      out2[7] = a2[5] * b2[2] + a2[6] * b2[7] + a2[7] * b2[12] + a2[8] * b2[17];
      out2[8] = a2[5] * b2[3] + a2[6] * b2[8] + a2[7] * b2[13] + a2[8] * b2[18];
      out2[9] = a2[5] * b2[4] + a2[6] * b2[9] + a2[7] * b2[14] + a2[8] * b2[19] + a2[9];
      out2[10] = a2[10] * b2[0] + a2[11] * b2[5] + a2[12] * b2[10] + a2[13] * b2[15];
      out2[11] = a2[10] * b2[1] + a2[11] * b2[6] + a2[12] * b2[11] + a2[13] * b2[16];
      out2[12] = a2[10] * b2[2] + a2[11] * b2[7] + a2[12] * b2[12] + a2[13] * b2[17];
      out2[13] = a2[10] * b2[3] + a2[11] * b2[8] + a2[12] * b2[13] + a2[13] * b2[18];
      out2[14] = a2[10] * b2[4] + a2[11] * b2[9] + a2[12] * b2[14] + a2[13] * b2[19] + a2[14];
      out2[15] = a2[15] * b2[0] + a2[16] * b2[5] + a2[17] * b2[10] + a2[18] * b2[15];
      out2[16] = a2[15] * b2[1] + a2[16] * b2[6] + a2[17] * b2[11] + a2[18] * b2[16];
      out2[17] = a2[15] * b2[2] + a2[16] * b2[7] + a2[17] * b2[12] + a2[18] * b2[17];
      out2[18] = a2[15] * b2[3] + a2[16] * b2[8] + a2[17] * b2[13] + a2[18] * b2[18];
      out2[19] = a2[15] * b2[4] + a2[16] * b2[9] + a2[17] * b2[14] + a2[18] * b2[19] + a2[19];
      return out2;
    }
    /**
     * Create a Float32 Array and normalize the offset component to 0-1
     * @param {number[]} matrix - 5x4 matrix
     * @returns {number[]} 5x4 matrix with all values between 0-1
     */
    _colorMatrix(matrix) {
      const m2 = new Float32Array(matrix);
      m2[4] /= 255;
      m2[9] /= 255;
      m2[14] /= 255;
      m2[19] /= 255;
      return m2;
    }
    /**
     * Adjusts the brightness of a display object.
     *
     * The brightness adjustment works by multiplying the RGB channels by a scalar value while keeping
     * the alpha channel unchanged. Values below 1 darken the image, while values above 1 brighten it.
     * @param b - The brightness multiplier to apply. Values between 0-1 darken the image (0 being black),
     *           while values > 1 brighten it (2.0 would make it twice as bright)
     * @param multiply - When true, the new matrix is multiplied with the current one instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * // Create a new color matrix filter
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Darken the image to 50% brightness
     * colorMatrix.brightness(0.5, false);
     *
     * // Chain with other effects by using multiply
     * colorMatrix
     *     .brightness(1.2, true)  // Brighten by 20%
     *     .saturate(1.1, true);   // Increase saturation by 10%
     * ```
     */
    brightness(b2, multiply) {
      const matrix = [
        b2,
        0,
        0,
        0,
        0,
        0,
        b2,
        0,
        0,
        0,
        0,
        0,
        b2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Sets each channel on the diagonal of the color matrix to apply a color tint.
     *
     * This method provides a way to tint display objects using the color matrix filter, similar to
     * the tint property available on Sprites and other display objects. The tint is applied by
     * scaling the RGB channels of each pixel.
     * @param color - The color to use for tinting, this can be any valid color source.
     * @param multiply - When true, the new tint matrix is multiplied with the current matrix instead
     *                  of replacing it. This allows for combining tints with other color effects.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply a red tint
     * colorMatrix.tint(0xff0000);
     *
     * // Layer a green tint on top of existing effects
     * colorMatrix.tint('green', true);
     *
     * // Chain with other color adjustments
     * colorMatrix
     *     .tint('blue')       // Blue tint
     *     .brightness(1.2, true) // Increase brightness
     * ```
     */
    tint(color, multiply) {
      const [r2, g2, b2] = Color.shared.setValue(color).toArray();
      const matrix = [
        r2,
        0,
        0,
        0,
        0,
        0,
        g2,
        0,
        0,
        0,
        0,
        0,
        b2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Converts the display object to greyscale by applying a weighted matrix transformation.
     *
     * The greyscale effect works by setting equal RGB values for each pixel based on the scale parameter,
     * effectively removing color information while preserving luminance.
     * @param scale - The intensity of the greyscale effect. Value between 0-1, where:
     *               - 0 produces black
     *               - 0.5 produces 50% grey
     *               - 1 produces white
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Convert to 50% grey
     * colorMatrix.greyscale(0.5, false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .greyscale(0.6, true)    // Add grey tint
     *     .brightness(1.2, true);   // Brighten the result
     * ```
     */
    greyscale(scale, multiply) {
      const matrix = [
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Converts the display object to grayscale by applying a weighted matrix transformation.
     *
     * The grayscale effect works by setting equal RGB values for each pixel based on the scale parameter,
     * effectively removing color information while preserving luminance.
     * @param scale - The intensity of the grayscale effect. Value between 0-1, where:
     *               - 0 produces black
     *               - 0.5 produces 50% grey
     *               - 1 produces white
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Convert to 50% grey
     * colorMatrix.grayscale(0.5, false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .grayscale(0.6, true)    // Add grey tint
     *     .brightness(1.2, true);   // Brighten the result
     * ```
     */
    grayscale(scale, multiply) {
      this.greyscale(scale, multiply);
    }
    /**
     * Converts the display object to pure black and white using a luminance-based threshold.
     *
     * This method applies a matrix transformation that removes all color information and reduces
     * the image to just black and white values based on the luminance of each pixel. The transformation
     * uses standard luminance weightings: 30% red, 60% green, and 10% blue.
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Convert to black and white
     * colorMatrix.blackAndWhite(false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .blackAndWhite(true)     // Apply B&W effect
     *     .brightness(1.2, true);   // Then increase brightness
     * ```
     */
    blackAndWhite(multiply) {
      const matrix = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Adjusts the hue of the display object by rotating the color values around the color wheel.
     *
     * This method uses an optimized matrix transformation that accurately rotates the RGB color space
     * around its luminance axis. The implementation is based on RGB cube rotation in 3D space, providing
     * better results than traditional matrices with magic luminance constants.
     * @param rotation - The angle of rotation in degrees around the color wheel:
     *                  - 0 = no change
     *                  - 90 = rotate colors 90 clockwise
     *                  - 180 = invert all colors
     *                  - 270 = rotate colors 90 counter-clockwise
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Rotate hue by 90 degrees
     * colorMatrix.hue(90, false);
     *
     * // Chain multiple color adjustments
     * colorMatrix
     *     .hue(45, true)          // Rotate colors by 45
     *     .saturate(1.2, true)    // Increase saturation
     *     .brightness(1.1, true); // Slightly brighten
     * ```
     */
    hue(rotation, multiply) {
      rotation = (rotation || 0) / 180 * Math.PI;
      const cosR = Math.cos(rotation);
      const sinR = Math.sin(rotation);
      const sqrt = Math.sqrt;
      const w2 = 1 / 3;
      const sqrW = sqrt(w2);
      const a00 = cosR + (1 - cosR) * w2;
      const a01 = w2 * (1 - cosR) - sqrW * sinR;
      const a02 = w2 * (1 - cosR) + sqrW * sinR;
      const a10 = w2 * (1 - cosR) + sqrW * sinR;
      const a11 = cosR + w2 * (1 - cosR);
      const a12 = w2 * (1 - cosR) - sqrW * sinR;
      const a20 = w2 * (1 - cosR) - sqrW * sinR;
      const a21 = w2 * (1 - cosR) + sqrW * sinR;
      const a22 = cosR + w2 * (1 - cosR);
      const matrix = [
        a00,
        a01,
        a02,
        0,
        0,
        a10,
        a11,
        a12,
        0,
        0,
        a20,
        a21,
        a22,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Adjusts the contrast of the display object by modifying the separation between dark and bright values.
     *
     * This method applies a matrix transformation that affects the difference between dark and light areas
     * in the image. Increasing contrast makes shadows darker and highlights brighter, while decreasing
     * contrast brings shadows up and highlights down, reducing the overall dynamic range.
     * @param amount - The contrast adjustment value. Range is 0 to 1, where:
     *                - 0 represents minimum contrast (flat gray)
     *                - 0.5 represents normal contrast
     *                - 1 represents maximum contrast
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Increase contrast by 50%
     * colorMatrix.contrast(0.75, false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .contrast(0.6, true)     // Boost contrast
     *     .brightness(1.1, true)   // Slightly brighten
     *     .saturate(1.2, true);    // Increase color intensity
     * ```
     */
    contrast(amount, multiply) {
      const v2 = (amount || 0) + 1;
      const o2 = -0.5 * (v2 - 1);
      const matrix = [
        v2,
        0,
        0,
        0,
        o2,
        0,
        v2,
        0,
        0,
        o2,
        0,
        0,
        v2,
        0,
        o2,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Adjusts the saturation of the display object by modifying color separation.
     *
     * This method applies a matrix transformation that affects the intensity of colors.
     * Increasing saturation makes colors more vivid and intense, while decreasing saturation
     * moves colors toward grayscale.
     * @param amount - The saturation adjustment value. Range is -1 to 1, where:
     *                - -1 produces grayscale
     *                - 0 represents no change
     *                - 1 produces maximum saturation
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Double the saturation
     * colorMatrix.saturate(1, false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .saturate(0.5, true)     // Increase saturation by 50%
     *     .brightness(1.1, true)    // Slightly brighten
     *     .contrast(0.8, true);     // Reduce contrast
     * ```
     */
    saturate(amount = 0, multiply) {
      const x2 = amount * 2 / 3 + 1;
      const y2 = (x2 - 1) * -0.5;
      const matrix = [
        x2,
        y2,
        y2,
        0,
        0,
        y2,
        x2,
        y2,
        0,
        0,
        y2,
        y2,
        x2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Completely removes color information from the display object, creating a grayscale version.
     *
     * This is a convenience method that calls `saturate(-1)` internally. The transformation preserves
     * the luminance of the original image while removing all color information.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Convert image to grayscale
     * colorMatrix.desaturate();
     *
     * // Can be chained with other effects
     * colorMatrix
     *     .desaturate()         // Remove all color
     *     .brightness(1.2);     // Then increase brightness
     * ```
     */
    desaturate() {
      this.saturate(-1);
    }
    /**
     * Creates a negative effect by inverting all colors in the display object.
     *
     * This method applies a matrix transformation that inverts the RGB values of each pixel
     * while preserving the alpha channel. The result is similar to a photographic negative.
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Create negative effect
     * colorMatrix.negative(false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .negative(true)       // Apply negative effect
     *     .brightness(1.2, true) // Increase brightness
     *     .contrast(0.8, true);  // Reduce contrast
     * ```
     */
    negative(multiply) {
      const matrix = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Applies a sepia tone effect to the display object, creating a warm brown tint reminiscent of vintage photographs.
     *
     * This method applies a matrix transformation that converts colors to various shades of brown while
     * preserving the original luminance values.
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply sepia effect
     * colorMatrix.sepia(false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .sepia(true)           // Add sepia tone
     *     .brightness(1.1, true)  // Slightly brighten
     *     .contrast(0.9, true);   // Reduce contrast
     * ```
     */
    sepia(multiply) {
      const matrix = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Applies a Technicolor-style effect that simulates the early color motion picture process.
     *
     * This method applies a matrix transformation that recreates the distinctive look of the
     * Technicolor process. The effect produces highly
     * saturated colors with a particular emphasis on reds, greens, and blues.
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply Technicolor effect
     * colorMatrix.technicolor(false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .technicolor(true)      // Add Technicolor effect
     *     .contrast(1.1, true)    // Boost contrast
     *     .brightness(0.9, true); // Slightly darken
     * ```
     */
    technicolor(multiply) {
      const matrix = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Applies a vintage Polaroid camera effect to the display object.
     *
     * This method applies a matrix transformation that simulates the distinctive look of
     * Polaroid instant photographs, characterized by slightly enhanced contrast, subtle color shifts,
     * and a warm overall tone.
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply Polaroid effect
     * colorMatrix.polaroid(false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .polaroid(true)         // Add Polaroid effect
     *     .brightness(1.1, true)  // Slightly brighten
     *     .contrast(1.1, true);   // Boost contrast
     * ```
     */
    polaroid(multiply) {
      const matrix = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Swaps the red and blue color channels in the display object.
     *
     * This method applies a matrix transformation that exchanges the red and blue color values
     * while keeping the green channel and alpha unchanged.
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Swap red and blue channels
     * colorMatrix.toBGR(false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .toBGR(true)           // Swap R and B channels
     *     .brightness(1.1, true)  // Slightly brighten
     *     .contrast(0.9, true);   // Reduce contrast
     * ```
     */
    toBGR(multiply) {
      const matrix = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Applies a Kodachrome color effect that simulates the iconic film stock.
     *
     * This method applies a matrix transformation that recreates the distinctive look of Kodachrome film,
     * known for its rich, vibrant colors and excellent image preservation qualities. The effect emphasizes
     * reds and blues while producing deep, true blacks.
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply Kodachrome effect
     * colorMatrix.kodachrome(false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .kodachrome(true)       // Add Kodachrome effect
     *     .contrast(1.1, true)    // Boost contrast
     *     .brightness(0.9, true); // Slightly darken
     * ```
     */
    kodachrome(multiply) {
      const matrix = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Applies a stylized brown-tinted effect to the display object.
     *
     * This method applies a matrix transformation that creates a rich, warm brown tone
     * with enhanced contrast and subtle color shifts.
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply browni effect
     * colorMatrix.browni(false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .browni(true)          // Add brown tint
     *     .brightness(1.1, true)  // Slightly brighten
     *     .contrast(1.2, true);   // Boost contrast
     * ```
     */
    browni(multiply) {
      const matrix = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Applies a vintage photo effect that simulates old photography techniques.
     *
     * This method applies a matrix transformation that creates a nostalgic, aged look
     * with muted colors, enhanced warmth, and subtle vignetting.
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply vintage effect
     * colorMatrix.vintage(false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .vintage(true)          // Add vintage look
     *     .brightness(0.9, true)  // Slightly darken
     *     .contrast(1.1, true);   // Boost contrast
     * ```
     */
    vintage(multiply) {
      const matrix = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * We don't know exactly what it does, kind of gradient map, but funny to play with!
     * @param desaturation - Tone values.
     * @param toned - Tone values.
     * @param lightColor - Tone values, example: `0xFFE580`
     * @param darkColor - Tone values, example: `0xFFE580`
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with matrix
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Create sepia-like effect with custom colors
     * colorMatrix.colorTone(
     *     0.3,        // Moderate desaturation
     *     0.2,        // Moderate toning
     *     0xFFE580,   // Warm highlight color
     *     0x338000,   // Dark green shadows
     *     false
     * );
     *
     * // Chain with other effects
     * colorMatrix
     *     .colorTone(0.2, 0.15, 0xFFE580, 0x338000, true)
     *     .brightness(1.1, true);  // Slightly brighten
     * ```
     */
    colorTone(desaturation, toned, lightColor, darkColor, multiply) {
      desaturation || (desaturation = 0.2);
      toned || (toned = 0.15);
      lightColor || (lightColor = 16770432);
      darkColor || (darkColor = 3375104);
      const temp = Color.shared;
      const [lR, lG, lB] = temp.setValue(lightColor).toArray();
      const [dR, dG, dB] = temp.setValue(darkColor).toArray();
      const matrix = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        lR,
        lG,
        lB,
        desaturation,
        0,
        dR,
        dG,
        dB,
        toned,
        0,
        lR - dR,
        lG - dG,
        lB - dB,
        0,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Applies a night vision effect to the display object.
     *
     * This method applies a matrix transformation that simulates night vision by enhancing
     * certain color channels while suppressing others, creating a green-tinted effect
     * similar to night vision goggles.
     * @param intensity - The intensity of the night effect (0-1):
     *                   - 0 produces no effect
     *                   - 0.1 produces a subtle night vision effect (default)
     *                   - 1 produces maximum night vision effect
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply night vision effect
     * colorMatrix.night(0.3, false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .night(0.2, true)        // Add night vision
     *     .brightness(1.1, true)    // Slightly brighten
     *     .contrast(1.2, true);     // Boost contrast
     * ```
     */
    night(intensity, multiply) {
      intensity || (intensity = 0.1);
      const matrix = [
        intensity * -2,
        -intensity,
        0,
        0,
        0,
        -intensity,
        0,
        intensity,
        0,
        0,
        0,
        intensity,
        intensity * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Predator effect
     *
     * Erase the current matrix by setting a new independent one
     * @param amount - how much the predator feels his future victim
     * @param multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with matrix
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply thermal vision effect
     * colorMatrix.predator(0.5, false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .predator(0.3, true)      // Add thermal effect
     *     .contrast(1.2, true)      // Boost contrast
     *     .brightness(1.1, true);   // Slightly brighten
     * ```
     */
    predator(amount, multiply) {
      const matrix = [
        // row 1
        11.224130630493164 * amount,
        -4.794486999511719 * amount,
        -2.8746118545532227 * amount,
        0 * amount,
        0.40342438220977783 * amount,
        // row 2
        -3.6330697536468506 * amount,
        9.193157196044922 * amount,
        -2.951810836791992 * amount,
        0 * amount,
        -1.316135048866272 * amount,
        // row 3
        -3.2184197902679443 * amount,
        -4.2375030517578125 * amount,
        7.476448059082031 * amount,
        0 * amount,
        0.8044459223747253 * amount,
        // row 4
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Applies a psychedelic color effect that creates dramatic color shifts.
     *
     * This method applies a matrix transformation that produces vibrant colors
     * through channel mixing and amplification. Creates an effect reminiscent of
     * color distortions in psychedelic art.
     * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.
     *                  This allows for cumulative effects when calling multiple color adjustments.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply psychedelic effect
     * colorMatrix.lsd(false);
     *
     * // Chain with other effects
     * colorMatrix
     *     .lsd(true)             // Add color distortion
     *     .brightness(0.9, true)  // Slightly darken
     *     .contrast(1.2, true);   // Boost contrast
     * ```
     */
    lsd(multiply) {
      const matrix = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    /**
     * Resets the color matrix filter to its default state.
     *
     * This method resets all color transformations by setting the matrix back to its identity state.
     * The identity matrix leaves colors unchanged, effectively removing all previously applied effects.
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply some effects
     * colorMatrix
     *     .sepia(true)
     *     .brightness(1.2, true);
     *
     * // Reset back to original colors
     * colorMatrix.reset();
     * ```
     */
    reset() {
      const matrix = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, false);
    }
    /**
     * The current color transformation matrix of the filter.
     *
     * This 5x4 matrix transforms RGBA color and alpha values of each pixel. The matrix is stored
     * as a 20-element array in row-major order.
     * @type {ColorMatrix}
     * @default [
     *     1, 0, 0, 0, 0,  // Red channel
     *     0, 1, 0, 0, 0,  // Green channel
     *     0, 0, 1, 0, 0,  // Blue channel
     *     0, 0, 0, 1, 0   // Alpha channel
     * ]
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     * // Get the current color matrix
     * const currentMatrix = colorMatrix.matrix;
     * // Modify the matrix
     * colorMatrix.matrix = [
     *     1, 0, 0, 0, 0,
     *     0, 1, 0, 0, 0,
     *     0, 0, 1, 0, 0,
     *     0, 0, 0, 1, 0
     * ];
     */
    get matrix() {
      return this.resources.colorMatrixUniforms.uniforms.uColorMatrix;
    }
    set matrix(value) {
      this.resources.colorMatrixUniforms.uniforms.uColorMatrix = value;
    }
    /**
     * The opacity value used to blend between the original and transformed colors.
     *
     * This value controls how much of the color transformation is applied:
     * - 0 = Original color only (no effect)
     * - 0.5 = 50% blend of original and transformed colors
     * - 1 = Fully transformed color (default)
     * @default 1
     * @example
     * ```ts
     * const colorMatrix = new ColorMatrixFilter();
     *
     * // Apply sepia at 50% strength
     * colorMatrix.sepia(false);
     * colorMatrix.alpha = 0.5;
     *
     * // Fade between effects
     * colorMatrix
     *     .saturate(1.5)      // Increase saturation
     *     .contrast(1.2);     // Boost contrast
     * colorMatrix.alpha = 0.7; // Apply at 70% strength
     * ```
     */
    get alpha() {
      return this.resources.colorMatrixUniforms.uniforms.uAlpha;
    }
    set alpha(value) {
      this.resources.colorMatrixUniforms.uniforms.uAlpha = value;
    }
  };

  // node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs
  init_Matrix();
  init_Point();
  init_GlProgram();
  init_GpuProgram();
  init_UniformGroup();
  init_Sprite();
  init_deprecation();
  init_Filter();

  // node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs
  var fragment6 = "\nin vec2 vTextureCoord;\nin vec2 vFilterUv;\n\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\n\nuniform vec4 uInputClamp;\nuniform highp vec4 uInputSize;\nuniform mat2 uRotation;\nuniform vec2 uScale;\n\nvoid main()\n{\n    vec4 map = texture(uMapTexture, vFilterUv);\n    \n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \n\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\n}\n";

  // node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs
  var vertex4 = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vFilterUv;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( void )\n{\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\n}\n\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vFilterUv = getFilterCoord();\n}\n";

  // node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs
  var source6 = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct DisplacementUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uScale:vec2<f32>,\n  uRotation:mat2x2<f32>\n};\n\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\n\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \n   \n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n}";

  // node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs
  var DisplacementFilter = class extends Filter {
    constructor(...args) {
      let options = args[0];
      if (options instanceof Sprite) {
        if (args[1]) {
          deprecation(v8_0_0, "DisplacementFilter now uses options object instead of params. {sprite, scale}");
        }
        options = { sprite: options, scale: args[1] };
      }
      const _a2 = options, { sprite, scale: scaleOption } = _a2, rest = __objRest(_a2, ["sprite", "scale"]);
      let scale = scaleOption != null ? scaleOption : 20;
      if (typeof scale === "number") {
        scale = new Point(scale, scale);
      }
      const filterUniforms = new UniformGroup({
        uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
        uScale: { value: scale, type: "vec2<f32>" },
        uRotation: { value: new Float32Array([0, 0, 0, 0]), type: "mat2x2<f32>" }
      });
      const glProgram3 = GlProgram.from({
        vertex: vertex4,
        fragment: fragment6,
        name: "displacement-filter"
      });
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source: source6,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source6,
          entryPoint: "mainFragment"
        }
      });
      const textureSource = sprite.texture.source;
      super(__spreadProps(__spreadValues({}, rest), {
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        resources: {
          filterUniforms,
          uMapTexture: textureSource,
          uMapSampler: textureSource.style
        }
      }));
      this._sprite = options.sprite;
      this._sprite.renderable = false;
    }
    /**
     * Applies the filter.
     * @param filterManager - The manager.
     * @param input - The input target.
     * @param output - The output target.
     * @param clearMode - clearMode.
     * @advanced
     */
    apply(filterManager, input, output, clearMode) {
      const uniforms = this.resources.filterUniforms.uniforms;
      filterManager.calculateSpriteMatrix(
        uniforms.uFilterMatrix,
        this._sprite
      );
      const wt = this._sprite.worldTransform;
      const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
      const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
      if (lenX !== 0 && lenY !== 0) {
        uniforms.uRotation[0] = wt.a / lenX;
        uniforms.uRotation[1] = wt.b / lenX;
        uniforms.uRotation[2] = wt.c / lenY;
        uniforms.uRotation[3] = wt.d / lenY;
      }
      this.resources.uMapTexture = this._sprite.texture.source;
      filterManager.applyFilter(this, input, output, clearMode);
    }
    /**
     * The scale of the displacement effect.
     *
     * Gets the current x and y scaling values used for the displacement mapping.
     * - x: Horizontal displacement scale
     * - y: Vertical displacement scale
     * @returns {Point} The current scale as a Point object
     * @example
     * ```ts
     * const filter = new DisplacementFilter({ sprite });
     *
     * // Get current scale
     * console.log(filter.scale.x, filter.scale.y);
     *
     * // Update scale
     * filter.scale.x = 100;
     * filter.scale.y = 50;
     * ```
     */
    get scale() {
      return this.resources.filterUniforms.uniforms.uScale;
    }
  };

  // node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.mjs
  init_GlProgram();
  init_GpuProgram();
  init_UniformGroup();
  init_Filter();
  init_defaultFilter_vert();

  // node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.mjs
  var fragment7 = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) *  uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    finalColor = color;\n}\n";

  // node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs
  var source7 = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct NoiseUniforms {\n  uNoise:f32,\n  uSeed:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\nfn rand(co:vec2<f32>) -> f32\n{\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);\n  \n    \n    var sample = textureSample(uTexture, uSampler, uv);\n    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);\n    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;\n  \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (sample.a > 0.0) {\n      sample.r /= sample.a;\n      sample.g /= sample.a;\n      sample.b /= sample.a;\n    }\n\n    sample.r += diff;\n    sample.g += diff;\n    sample.b += diff;\n\n    // Premultiply alpha again.\n    sample.r *= sample.a;\n    sample.g *= sample.a;\n    sample.b *= sample.a;\n    \n    return sample;\n}";

  // node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.mjs
  var _NoiseFilter = class _NoiseFilter2 extends Filter {
    /**
     * @param options - The options of the noise filter.
     */
    constructor(options = {}) {
      options = __spreadValues(__spreadValues({}, _NoiseFilter2.defaultOptions), options);
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source: source7,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source7,
          entryPoint: "mainFragment"
        }
      });
      const glProgram3 = GlProgram.from({
        vertex: vertex2,
        fragment: fragment7,
        name: "noise-filter"
      });
      const _a2 = options, { noise, seed } = _a2, rest = __objRest(_a2, ["noise", "seed"]);
      super(__spreadProps(__spreadValues({}, rest), {
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        resources: {
          noiseUniforms: new UniformGroup({
            uNoise: { value: 1, type: "f32" },
            uSeed: { value: 1, type: "f32" }
          })
        }
      }));
      this.noise = noise;
      this.seed = seed != null ? seed : Math.random();
    }
    /**
     * The amount of noise to apply to the filtered content.
     *
     * This value controls the intensity of the random noise effect:
     * - Values close to 0 produce subtle noise
     * - Values around 0.5 produce moderate noise
     * - Values close to 1 produce strong noise
     * @default 0.5
     * @example
     * ```ts
     * const noiseFilter = new NoiseFilter();
     *
     * // Set to subtle noise
     * noiseFilter.noise = 0.2;
     *
     * // Set to maximum noise
     * noiseFilter.noise = 1.0;
     * ```
     */
    get noise() {
      return this.resources.noiseUniforms.uniforms.uNoise;
    }
    set noise(value) {
      this.resources.noiseUniforms.uniforms.uNoise = value;
    }
    /**
     * The seed value used for random noise generation.
     *
     * This value determines the noise pattern:
     * - Using the same seed will generate identical noise patterns
     * - Different seeds produce different but consistent patterns
     * - `Math.random()` can be used for random patterns
     * @default Math.random()
     * @example
     * ```ts
     * const noiseFilter = new NoiseFilter();
     *
     * // Use a fixed seed for consistent noise
     * noiseFilter.seed = 12345;
     *
     * // Generate new random pattern
     * noiseFilter.seed = Math.random();
     * ```
     */
    get seed() {
      return this.resources.noiseUniforms.uniforms.uSeed;
    }
    set seed(value) {
      this.resources.noiseUniforms.uniforms.uSeed = value;
    }
  };
  _NoiseFilter.defaultOptions = {
    noise: 0.5
  };
  var NoiseFilter = _NoiseFilter;

  // node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.mjs
  var hsl = "fn getLuminosity(c: vec3<f32>) -> f32 {\n  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n}\n\nfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {\n  let d: f32 = lum - getLuminosity(c);\n  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);\n\n  // clip back into legal range\n  let newLum: f32 = getLuminosity(newColor);\n  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));\n  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));\n\n  let t1: f32 = newLum / (newLum - cMin);\n  let t2: f32 = (1.0 - newLum) / (cMax - newLum);\n\n  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));\n\n  return finalColor;\n}\n\nfn getSaturation(c: vec3<f32>) -> f32 {\n  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n}\n\n// Set saturation if color components are sorted in ascending order.\nfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {\n  var result: vec3<f32>;\n  if (cSorted.z > cSorted.x) {\n    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));\n    result = vec3<f32>(0.0, newY, s);\n  } else {\n    result = vec3<f32>(0.0, 0.0, 0.0);\n  }\n  return vec3<f32>(result.x, result.y, result.z);\n}\n\nfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {\n    var result: vec3<f32> = c;\n\n    if (c.r <= c.g && c.r <= c.b) {\n        if (c.g <= c.b) {\n            result = setSaturationMinMidMax(result, s);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.r, temp.b, temp.g);\n        }\n    } else if (c.g <= c.r && c.g <= c.b) {\n        if (c.r <= c.b) {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.r, temp.b);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.b, temp.r);\n        }\n    } else {\n        if (c.r <= c.g) {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.r, temp.g);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.g, temp.r);\n        }\n    }\n\n    return result;\n}";

  // node_modules/pixi.js/lib/prepare/PrepareBase.mjs
  init_Container();
  init_const2();
  init_Ticker();
  var _PrepareBase = class _PrepareBase2 {
    /**
     * @param {Renderer} renderer - A reference to the current renderer
     */
    constructor(renderer) {
      this._tick = () => {
        if (this._destroyed)
          return;
        this.timeout = setTimeout(this._processQueue, 0);
      };
      this._processQueue = () => {
        if (this._destroyed)
          return;
        const { queue } = this;
        let itemsProcessed = 0;
        while (queue.length && itemsProcessed < _PrepareBase2.uploadsPerFrame) {
          const queueItem = queue.shift();
          this.uploadQueueItem(queueItem);
          itemsProcessed++;
        }
        if (queue.length) {
          Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);
        } else {
          this._resolve();
        }
      };
      this.renderer = renderer;
      this.queue = [];
      this.resolves = [];
    }
    /**
     * Return a copy of the queue
     * @returns {PrepareQueueItem[]} The queue
     */
    getQueue() {
      return [...this.queue];
    }
    /**
     * Add a textures or graphics resource to the queue
     * @param {PrepareSourceItem | PrepareSourceItem[]} resource
     */
    add(resource) {
      const resourceArray = Array.isArray(resource) ? resource : [resource];
      for (const resourceItem of resourceArray) {
        if (resourceItem instanceof Container) {
          this._addContainer(resourceItem);
        } else {
          this.resolveQueueItem(resourceItem, this.queue);
        }
      }
      return this;
    }
    /**
     * Recursively add a container and its children to the queue
     * @param {Container} container - The container to add to the queue
     */
    _addContainer(container) {
      this.resolveQueueItem(container, this.queue);
      for (const child of container.children) {
        this._addContainer(child);
      }
    }
    /**
     * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)
     * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource
     */
    upload(resource) {
      if (resource) {
        this.add(resource);
      }
      return new Promise((resolve) => {
        if (this.queue.length) {
          this.resolves.push(resolve);
          this.dedupeQueue();
          Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);
        } else {
          resolve();
        }
      });
    }
    /** eliminate duplicates before processing */
    dedupeQueue() {
      const hash = /* @__PURE__ */ Object.create(null);
      let nextUnique = 0;
      for (let i3 = 0; i3 < this.queue.length; i3++) {
        const current = this.queue[i3];
        if (!hash[current.uid]) {
          hash[current.uid] = true;
          this.queue[nextUnique++] = current;
        }
      }
      this.queue.length = nextUnique;
    }
    destroy() {
      this._destroyed = true;
      clearTimeout(this.timeout);
    }
    /** Call all the resolve callbacks */
    _resolve() {
      const { resolves } = this;
      const array = resolves.slice(0);
      resolves.length = 0;
      for (const resolve of array) {
        resolve();
      }
    }
  };
  _PrepareBase.uploadsPerFrame = 4;
  var PrepareBase = _PrepareBase;

  // node_modules/pixi.js/lib/prepare/PrepareQueue.mjs
  init_TextureSource();
  init_Texture();
  init_Container();
  init_Graphics();
  init_GraphicsContext();

  // node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs
  init_pointInTriangle();
  init_Geometry();
  init_State();
  init_Texture();
  init_deprecation();
  init_ViewContainer();
  init_MeshGeometry();
  var Mesh = class extends ViewContainer {
    constructor(...args) {
      var _b;
      let options = args[0];
      if (options instanceof Geometry) {
        deprecation(v8_0_0, "Mesh: use new Mesh({ geometry, shader }) instead");
        options = {
          geometry: options,
          shader: args[1]
        };
        if (args[3]) {
          deprecation(v8_0_0, "Mesh: drawMode argument has been removed, use geometry.topology instead");
          options.geometry.topology = args[3];
        }
      }
      const _a2 = options, { geometry, shader, texture, roundPixels, state } = _a2, rest = __objRest(_a2, ["geometry", "shader", "texture", "roundPixels", "state"]);
      super(__spreadValues({
        label: "Mesh"
      }, rest));
      this.renderPipeId = "mesh";
      this._shader = null;
      this.allowChildren = false;
      this.shader = shader != null ? shader : null;
      this.texture = (_b = texture != null ? texture : shader == null ? void 0 : shader.texture) != null ? _b : Texture.WHITE;
      this.state = state != null ? state : State.for2d();
      this._geometry = geometry;
      this._geometry.on("update", this.onViewUpdate, this);
      this.roundPixels = roundPixels != null ? roundPixels : false;
    }
    /** Alias for {@link Mesh#shader}. */
    get material() {
      deprecation(v8_0_0, "mesh.material property has been removed, use mesh.shader instead");
      return this._shader;
    }
    /**
     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
     * Can be shared between multiple Mesh objects.
     */
    set shader(value) {
      if (this._shader === value)
        return;
      this._shader = value;
      this.onViewUpdate();
    }
    get shader() {
      return this._shader;
    }
    /**
     * Includes vertex positions, face indices, colors, UVs, and
     * custom attributes within buffers, reducing the cost of passing all
     * this data to the GPU. Can be shared between multiple Mesh objects.
     */
    set geometry(value) {
      var _a2;
      if (this._geometry === value)
        return;
      (_a2 = this._geometry) == null ? void 0 : _a2.off("update", this.onViewUpdate, this);
      value.on("update", this.onViewUpdate, this);
      this._geometry = value;
      this.onViewUpdate();
    }
    get geometry() {
      return this._geometry;
    }
    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
    set texture(value) {
      value || (value = Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture === value)
        return;
      if (currentTexture && currentTexture.dynamic)
        currentTexture.off("update", this.onViewUpdate, this);
      if (value.dynamic)
        value.on("update", this.onViewUpdate, this);
      if (this.shader) {
        this.shader.texture = value;
      }
      this._texture = value;
      this.onViewUpdate();
    }
    get texture() {
      return this._texture;
    }
    get batched() {
      if (this._shader)
        return false;
      if ((this.state.data & 12) !== 0)
        return false;
      if (this._geometry instanceof MeshGeometry) {
        if (this._geometry.batchMode === "auto") {
          return this._geometry.positions.length / 2 <= 100;
        }
        return this._geometry.batchMode === "batch";
      }
      return false;
    }
    /**
     * The local bounds of the mesh.
     * @type {Bounds}
     */
    get bounds() {
      return this._geometry.bounds;
    }
    /**
     * Update local bounds of the mesh.
     * @private
     */
    updateBounds() {
      this._bounds = this._geometry.bounds;
    }
    /**
     * Checks if the object contains the given point.
     * @param point - The point to check
     */
    containsPoint(point) {
      const { x: x2, y: y2 } = point;
      if (!this.bounds.containsPoint(x2, y2))
        return false;
      const vertices = this.geometry.getBuffer("aPosition").data;
      const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
      if (this.geometry.getIndex()) {
        const indices = this.geometry.getIndex().data;
        const len = indices.length;
        for (let i3 = 0; i3 + 2 < len; i3 += step) {
          const ind0 = indices[i3] * 2;
          const ind1 = indices[i3 + 1] * 2;
          const ind2 = indices[i3 + 2] * 2;
          if (pointInTriangle2(
            x2,
            y2,
            vertices[ind0],
            vertices[ind0 + 1],
            vertices[ind1],
            vertices[ind1 + 1],
            vertices[ind2],
            vertices[ind2 + 1]
          )) {
            return true;
          }
        }
      } else {
        const len = vertices.length / 2;
        for (let i3 = 0; i3 + 2 < len; i3 += step) {
          const ind0 = i3 * 2;
          const ind1 = (i3 + 1) * 2;
          const ind2 = (i3 + 2) * 2;
          if (pointInTriangle2(
            x2,
            y2,
            vertices[ind0],
            vertices[ind0 + 1],
            vertices[ind1],
            vertices[ind1 + 1],
            vertices[ind2],
            vertices[ind2 + 1]
          )) {
            return true;
          }
        }
      }
      return false;
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @example
     * mesh.destroy();
     * mesh.destroy(true);
     * mesh.destroy({ texture: true, textureSource: true });
     */
    destroy(options) {
      var _a2;
      super.destroy(options);
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        this._texture.destroy(destroyTextureSource);
      }
      (_a2 = this._geometry) == null ? void 0 : _a2.off("update", this.onViewUpdate, this);
      this._texture = null;
      this._geometry = null;
      this._shader = null;
    }
  };

  // node_modules/pixi.js/lib/prepare/PrepareQueue.mjs
  init_Sprite();

  // node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs
  init_Texture();
  init_const2();
  init_Ticker();
  init_Sprite();
  var AnimatedSprite = class _AnimatedSprite extends Sprite {
    constructor(...args) {
      let options = args[0];
      if (Array.isArray(args[0])) {
        options = {
          textures: args[0],
          autoUpdate: args[1]
        };
      }
      const _a2 = options, {
        animationSpeed = 1,
        autoPlay = false,
        autoUpdate = true,
        loop = true,
        onComplete = null,
        onFrameChange = null,
        onLoop = null,
        textures,
        updateAnchor = false
      } = _a2, rest = __objRest(_a2, [
        "animationSpeed",
        "autoPlay",
        "autoUpdate",
        "loop",
        "onComplete",
        "onFrameChange",
        "onLoop",
        "textures",
        "updateAnchor"
      ]);
      const [firstFrame] = textures;
      super(__spreadProps(__spreadValues({}, rest), {
        texture: firstFrame instanceof Texture ? firstFrame : firstFrame.texture
      }));
      this._textures = null;
      this._durations = null;
      this._autoUpdate = autoUpdate;
      this._isConnectedToTicker = false;
      this.animationSpeed = animationSpeed;
      this.loop = loop;
      this.updateAnchor = updateAnchor;
      this.onComplete = onComplete;
      this.onFrameChange = onFrameChange;
      this.onLoop = onLoop;
      this._currentTime = 0;
      this._playing = false;
      this._previousFrame = null;
      this.textures = textures;
      if (autoPlay) {
        this.play();
      }
    }
    /**
     * Stops the animation playback and freezes the current frame.
     * Does not reset the current frame or animation progress.
     * @example
     * ```ts
     * // Create an animated sprite
     * const sprite = new AnimatedSprite({
     *     textures: [
     *         Texture.from('walk1.png'),
     *         Texture.from('walk2.png'),
     *         Texture.from('walk3.png')
     *     ],
     *     autoPlay: true
     * });
     *
     * // Stop at current frame
     * sprite.stop();
     *
     * // Stop at specific frame
     * sprite.gotoAndStop(1); // Stops at second frame
     *
     * // Stop and reset
     * sprite.stop();
     * sprite.currentFrame = 0;
     *
     * // Stop with completion check
     * if (sprite.playing) {
     *     sprite.stop();
     *     sprite.onComplete?.();
     * }
     * ```
     * @see {@link AnimatedSprite#play} For starting playback
     * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame
     * @see {@link AnimatedSprite#playing} For checking play state
     */
    stop() {
      if (!this._playing) {
        return;
      }
      this._playing = false;
      if (this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
    }
    /**
     * Starts or resumes the animation playback.
     * If the animation was previously stopped, it will continue from where it left off.
     * @example
     * ```ts
     * // Basic playback
     * const sprite = new AnimatedSprite({
     *     textures: [
     *         Texture.from('walk1.png'),
     *         Texture.from('walk2.png'),
     *     ],
     *     autoPlay: false
     * });
     * sprite.play();
     *
     * // Play after stopping
     * sprite.stop();
     * sprite.currentFrame = 0; // Reset to start
     * sprite.play(); // Play from beginning
     *
     * // Play with auto-update disabled
     * sprite.autoUpdate = false;
     * sprite.play();
     * app.ticker.add(() => {
     *     sprite.update(app.ticker); // Manual updates
     * });
     * ```
     * @see {@link AnimatedSprite#stop} For stopping playback
     * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame
     * @see {@link AnimatedSprite#playing} For checking play state
     */
    play() {
      if (this._playing) {
        return;
      }
      this._playing = true;
      if (this._autoUpdate && !this._isConnectedToTicker) {
        Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
        this._isConnectedToTicker = true;
      }
    }
    /**
     * Stops the AnimatedSprite and sets it to a specific frame.
     * @example
     * ```ts
     * // Create an animated sprite
     * const sprite = new AnimatedSprite({
     *     textures: [
     *         Texture.from('walk1.png'),
     *         Texture.from('walk2.png'),
     *         Texture.from('walk3.png'),
     *     ]
     * });
     *
     * // Go to specific frames
     * sprite.gotoAndStop(0);  // First frame
     * sprite.gotoAndStop(2);  // Third frame
     *
     * // Jump to last frame
     * sprite.gotoAndStop(sprite.totalFrames - 1);
     * ```
     * @param frameNumber - Frame index to stop at (0-based)
     * @throws {Error} If frameNumber is out of bounds
     * @see {@link AnimatedSprite#gotoAndPlay} For going to a frame and playing
     * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame
     * @see {@link AnimatedSprite#totalFrames} For total number of frames
     */
    gotoAndStop(frameNumber) {
      this.stop();
      this.currentFrame = frameNumber;
    }
    /**
     * Goes to a specific frame and begins playing the AnimatedSprite from that point.
     * Combines frame navigation and playback start in one operation.
     * @example
     * ```ts
     * // Start from specific frame
     * sprite.gotoAndPlay(1); // Starts playing from second frame
     * ```
     * @param frameNumber - Frame index to start playing from (0-based)
     * @throws {Error} If frameNumber is out of bounds
     * @see {@link AnimatedSprite#gotoAndStop} For going to a frame without playing
     * @see {@link AnimatedSprite#play} For playing from current frame
     * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame
     */
    gotoAndPlay(frameNumber) {
      this.currentFrame = frameNumber;
      this.play();
    }
    /**
     * Updates the object transform for rendering. This method handles animation timing, frame updates,
     * and manages looping behavior.
     * @example
     * ```ts
     * // Create an animated sprite with manual updates
     * const sprite = new AnimatedSprite({
     *     textures: [
     *         Texture.from('frame1.png'),
     *         Texture.from('frame2.png'),
     *         Texture.from('frame3.png')
     *     ],
     *     autoUpdate: false // Disable automatic updates
     * });
     *
     * // Manual update with app ticker
     * app.ticker.add((ticker) => {
     *     sprite.update(ticker);
     * });
     * ```
     * @param ticker - The ticker to use for updating the animation timing
     * @see {@link AnimatedSprite#autoUpdate} For controlling automatic updates
     * @see {@link AnimatedSprite#animationSpeed} For controlling animation speed
     * @see {@link Ticker} For timing system details
     */
    update(ticker) {
      if (!this._playing) {
        return;
      }
      const deltaTime = ticker.deltaTime;
      const elapsed = this.animationSpeed * deltaTime;
      const previousFrame = this.currentFrame;
      if (this._durations !== null) {
        let lag = this._currentTime % 1 * this._durations[this.currentFrame];
        lag += elapsed / 60 * 1e3;
        while (lag < 0) {
          this._currentTime--;
          lag += this._durations[this.currentFrame];
        }
        const sign2 = Math.sign(this.animationSpeed * deltaTime);
        this._currentTime = Math.floor(this._currentTime);
        while (lag >= this._durations[this.currentFrame]) {
          lag -= this._durations[this.currentFrame] * sign2;
          this._currentTime += sign2;
        }
        this._currentTime += lag / this._durations[this.currentFrame];
      } else {
        this._currentTime += elapsed;
      }
      if (this._currentTime < 0 && !this.loop) {
        this.gotoAndStop(0);
        if (this.onComplete) {
          this.onComplete();
        }
      } else if (this._currentTime >= this._textures.length && !this.loop) {
        this.gotoAndStop(this._textures.length - 1);
        if (this.onComplete) {
          this.onComplete();
        }
      } else if (previousFrame !== this.currentFrame) {
        if (this.loop && this.onLoop) {
          if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
            this.onLoop();
          }
        }
        this._updateTexture();
      }
    }
    /** Updates the displayed texture to match the current frame index. */
    _updateTexture() {
      const currentFrame = this.currentFrame;
      if (this._previousFrame === currentFrame) {
        return;
      }
      this._previousFrame = currentFrame;
      this.texture = this._textures[currentFrame];
      if (this.updateAnchor && this.texture.defaultAnchor) {
        this.anchor.copyFrom(this.texture.defaultAnchor);
      }
      if (this.onFrameChange) {
        this.onFrameChange(this.currentFrame);
      }
    }
    /**
     * Stops the AnimatedSprite and destroys it.
     * This method stops the animation playback, removes it from the ticker,
     * and cleans up any resources associated with the sprite.
     * @param options - Options for destroying the sprite, such as whether to remove from parent
     * @example
     * ```ts
     * // Destroy the sprite when done
     * sprite.destroy();
     * // Or with options
     * sprite.destroy({ children: true, texture: true, textureSource: true });
     * ```
     */
    destroy(options = false) {
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        this._textures.forEach((texture) => {
          if (this.texture !== texture) {
            texture.destroy(destroyTextureSource);
          }
        });
      }
      this._textures = [];
      this._durations = null;
      this.stop();
      super.destroy(options);
      this.onComplete = null;
      this.onFrameChange = null;
      this.onLoop = null;
    }
    /**
     * A short hand way of creating an AnimatedSprite from an array of frame ids.
     * Uses texture frames from the cache to create an animation sequence.
     * @example
     * ```ts
     * // Create from frame IDs
     * const frameIds = [
     *     'walk_001.png',
     *     'walk_002.png',
     *     'walk_003.png'
     * ];
     *
     * const walkingAnimation = AnimatedSprite.fromFrames(frameIds);
     * walkingAnimation.play();
     * ```
     * @param frames - The array of frame ids to use for the animation
     * @returns A new animated sprite using the frames
     * @see {@link Texture.from} For texture creation from frames
     * @see {@link Spritesheet} For loading spritesheets
     */
    static fromFrames(frames) {
      const textures = [];
      for (let i3 = 0; i3 < frames.length; ++i3) {
        textures.push(Texture.from(frames[i3]));
      }
      return new _AnimatedSprite(textures);
    }
    /**
     * A short hand way of creating an AnimatedSprite from an array of image urls.
     * Each image will be used as a frame in the animation.
     * @example
     * ```ts
     * // Create from image URLs
     * const images = [
     *     'assets/walk1.png',
     *     'assets/walk2.png',
     *     'assets/walk3.png'
     * ];
     *
     * const walkingSprite = AnimatedSprite.fromImages(images);
     * walkingSprite.play();
     * ```
     * @param images - The array of image urls to use as frames
     * @returns A new animated sprite using the images as frames
     * @see {@link Assets} For asset loading and management
     * @see {@link Texture.from} For texture creation from images
     */
    static fromImages(images) {
      const textures = [];
      for (let i3 = 0; i3 < images.length; ++i3) {
        textures.push(Texture.from(images[i3]));
      }
      return new _AnimatedSprite(textures);
    }
    /**
     * The total number of frames in the AnimatedSprite. This is the same as number of textures
     * assigned to the AnimatedSprite.
     * @example
     * ```ts
     * // Create an animated sprite
     * const sprite = new AnimatedSprite({
     *     textures: [
     *         Texture.from('frame1.png'),
     *         Texture.from('frame2.png'),
     *         Texture.from('frame3.png')
     *     ]
     * });
     *
     * // Get total frames
     * console.log(sprite.totalFrames); // Outputs: 3
     *
     * // Use with frame navigation
     * sprite.gotoAndStop(sprite.totalFrames - 1); // Go to last frame
     * ```
     * @readonly
     * @see {@link AnimatedSprite#currentFrame} For the current frame index
     * @see {@link AnimatedSprite#textures} For the array of textures
     * @returns {number} The total number of frames
     */
    get totalFrames() {
      return this._textures.length;
    }
    /**
     * The array of textures or frame objects used for the animation sequence.
     * Can be set to either an array of Textures or an array of FrameObjects with custom timing.
     * @example
     * ```ts
     * // Update textures at runtime
     * sprite.textures = [
     *     Texture.from('run1.png'),
     *     Texture.from('run2.png')
     * ];
     *
     * // Use custom frame timing
     * sprite.textures = [
     *     { texture: Texture.from('explosion1.png'), time: 100 },
     *     { texture: Texture.from('explosion2.png'), time: 200 },
     *     { texture: Texture.from('explosion3.png'), time: 300 }
     * ];
     *
     * // Use with spritesheet
     * const sheet = await Assets.load('animations.json');
     * sprite.textures = sheet.animations['walk'];
     * ```
     * @type {AnimatedSpriteFrames}
     * @see {@link FrameObject} For frame timing options
     * @see {@link Spritesheet} For loading from spritesheets
     */
    get textures() {
      return this._textures;
    }
    set textures(value) {
      if (value[0] instanceof Texture) {
        this._textures = value;
        this._durations = null;
      } else {
        this._textures = [];
        this._durations = [];
        for (let i3 = 0; i3 < value.length; i3++) {
          this._textures.push(value[i3].texture);
          this._durations.push(value[i3].time);
        }
      }
      this._previousFrame = null;
      this.gotoAndStop(0);
      this._updateTexture();
    }
    /**
     * Gets or sets the current frame index of the animation.
     * When setting, the value will be clamped between 0 and totalFrames - 1.
     * @example
     * ```ts
     * // Create an animated sprite
     * const sprite = new AnimatedSprite({
     *     textures: [
     *         Texture.from('walk1.png'),
     *         Texture.from('walk2.png'),
     *         Texture.from('walk3.png')
     *     ]
     * });
     *
     * // Get current frame
     * console.log(sprite.currentFrame); // 0
     *
     * // Set specific frame
     * sprite.currentFrame = 1; // Show second frame
     *
     * // Use with frame callbacks
     * sprite.onFrameChange = (frame) => {
     *     console.log(`Now showing frame: ${frame}`);
     * };
     * sprite.currentFrame = 2;
     * ```
     * @throws {Error} If attempting to set a frame index out of bounds
     * @see {@link AnimatedSprite#totalFrames} For the total number of frames
     * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame
     * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame
     */
    get currentFrame() {
      let currentFrame = Math.floor(this._currentTime) % this._textures.length;
      if (currentFrame < 0) {
        currentFrame += this._textures.length;
      }
      return currentFrame;
    }
    set currentFrame(value) {
      if (value < 0 || value > this.totalFrames - 1) {
        throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
      }
      const previousFrame = this.currentFrame;
      this._currentTime = value;
      if (previousFrame !== this.currentFrame) {
        this._updateTexture();
      }
    }
    /**
     * Indicates if the AnimatedSprite is currently playing.
     * This is a read-only property that reflects the current playback state.
     * @example
     * ```ts
     * // Check if animation is playing
     * console.log('Playing:', sprite.playing); // true
     *
     * // Use with play control
     * if (!sprite.playing) {
     *     sprite.play();
     * }
     * ```
     * @readonly
     * @returns {boolean} True if the animation is currently playing
     * @see {@link AnimatedSprite#play} For starting playback
     * @see {@link AnimatedSprite#stop} For stopping playback
     * @see {@link AnimatedSprite#loop} For controlling looping behavior
     */
    get playing() {
      return this._playing;
    }
    /**
     * Controls whether the animation automatically updates using the shared ticker.
     * When enabled, the animation will update on each frame. When disabled, you must
     * manually call update() to advance the animation.
     * @example
     * ```ts
     * // Create sprite with auto-update disabled
     * const sprite = new AnimatedSprite({
     *     textures: [],
     *     autoUpdate: false
     * });
     *
     * // Manual update with app ticker
     * app.ticker.add((ticker) => {
     *     sprite.update(ticker);
     * });
     *
     * // Enable auto-update later
     * sprite.autoUpdate = true;
     * ```
     * @default true
     * @see {@link AnimatedSprite#update} For manual animation updates
     * @see {@link Ticker} For the timing system
     */
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    }
  };

  // node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs
  init_Cache();
  init_ObservablePoint();
  init_Texture();
  init_deprecation();

  // node_modules/pixi.js/lib/utils/misc/Transform.mjs
  init_Matrix();
  init_ObservablePoint();
  var Transform = class {
    /**
     * @param options - Options for the transform.
     * @param options.matrix - The matrix to use.
     * @param options.observer - The observer to use.
     */
    constructor({ matrix, observer } = {}) {
      this.dirty = true;
      this._matrix = matrix != null ? matrix : new Matrix();
      this.observer = observer;
      this.position = new ObservablePoint(this, 0, 0);
      this.scale = new ObservablePoint(this, 1, 1);
      this.pivot = new ObservablePoint(this, 0, 0);
      this.skew = new ObservablePoint(this, 0, 0);
      this._rotation = 0;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
    }
    /**
     * The transformation matrix computed from the transform's properties.
     * Combines position, scale, rotation, skew, and pivot into a single matrix.
     * @example
     * ```ts
     * // Get current matrix
     * const matrix = transform.matrix;
     * console.log(matrix.toString());
     * ```
     * @readonly
     * @see {@link Matrix} For matrix operations
     * @see {@link Transform.setFromMatrix} For setting transform from matrix
     */
    get matrix() {
      const lt = this._matrix;
      if (!this.dirty)
        return lt;
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this.dirty = false;
      return lt;
    }
    /**
     * Called when a value changes.
     * @param point
     * @internal
     */
    _onUpdate(point) {
      var _a2;
      this.dirty = true;
      if (point === this.skew) {
        this.updateSkew();
      }
      (_a2 = this.observer) == null ? void 0 : _a2._onUpdate(this);
    }
    /** Called when the skew or the rotation changes. */
    updateSkew() {
      this._cx = Math.cos(this._rotation + this.skew.y);
      this._sx = Math.sin(this._rotation + this.skew.y);
      this._cy = -Math.sin(this._rotation - this.skew.x);
      this._sy = Math.cos(this._rotation - this.skew.x);
      this.dirty = true;
    }
    toString() {
      return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
    }
    /**
     * Decomposes a matrix and sets the transforms properties based on it.
     * @example
     * ```ts
     * // Basic matrix decomposition
     * const transform = new Transform();
     * const matrix = new Matrix()
     *     .translate(100, 100)
     *     .rotate(Math.PI / 4)
     *     .scale(2, 2);
     *
     * transform.setFromMatrix(matrix);
     * console.log(transform.position.x); // 100
     * console.log(transform.rotation); // ~0.785 (/4)
     * ```
     * @param matrix - The matrix to decompose
     * @see {@link Matrix#decompose} For the decomposition logic
     * @see {@link Transform#matrix} For getting the current matrix
     */
    setFromMatrix(matrix) {
      matrix.decompose(this);
      this.dirty = true;
    }
    /**
     * The rotation of the object in radians.
     * @example
     * ```ts
     * // Basic rotation
     * transform.rotation = Math.PI / 4; // 45 degrees
     *
     * // Rotate around pivot point
     * transform.pivot.set(50, 50);
     * transform.rotation = Math.PI; // 180 degrees around pivot
     *
     * // Animate rotation
     * app.ticker.add(() => {
     *     transform.rotation += 0.1;
     * });
     * ```
     * @see {@link Transform#pivot} For rotation point
     * @see {@link Transform#skew} For skew effects
     */
    get rotation() {
      return this._rotation;
    }
    set rotation(value) {
      if (this._rotation !== value) {
        this._rotation = value;
        this._onUpdate(this.skew);
      }
    }
  };

  // node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs
  init_ViewContainer();
  var _TilingSprite = class _TilingSprite2 extends ViewContainer {
    constructor(...args) {
      let options = args[0] || {};
      if (options instanceof Texture) {
        options = { texture: options };
      }
      if (args.length > 1) {
        deprecation(v8_0_0, "use new TilingSprite({ texture, width:100, height:100 }) instead");
        options.width = args[1];
        options.height = args[2];
      }
      options = __spreadValues(__spreadValues({}, _TilingSprite2.defaultOptions), options);
      const _a2 = options != null ? options : {}, {
        texture,
        anchor,
        tilePosition,
        tileScale,
        tileRotation,
        width,
        height,
        applyAnchorToTexture,
        roundPixels
      } = _a2, rest = __objRest(_a2, [
        "texture",
        "anchor",
        "tilePosition",
        "tileScale",
        "tileRotation",
        "width",
        "height",
        "applyAnchorToTexture",
        "roundPixels"
      ]);
      super(__spreadValues({
        label: "TilingSprite"
      }, rest));
      this.renderPipeId = "tilingSprite";
      this.batched = true;
      this.allowChildren = false;
      this._anchor = new ObservablePoint(
        {
          _onUpdate: () => {
            this.onViewUpdate();
          }
        }
      );
      this.applyAnchorToTexture = applyAnchorToTexture;
      this.texture = texture;
      this._width = width != null ? width : texture.width;
      this._height = height != null ? height : texture.height;
      this._tileTransform = new Transform({
        observer: {
          _onUpdate: () => this.onViewUpdate()
        }
      });
      if (anchor)
        this.anchor = anchor;
      this.tilePosition = tilePosition;
      this.tileScale = tileScale;
      this.tileRotation = tileRotation;
      this.roundPixels = roundPixels != null ? roundPixels : false;
    }
    /**
     * Creates a new tiling sprite based on a source texture or image path.
     * This is a convenience method that automatically creates and manages textures.
     * @example
     * ```ts
     * // Create a new tiling sprite from an image path
     * const pattern = TilingSprite.from('pattern.png');
     * pattern.width = 300; // Set the width of the tiling area
     * pattern.height = 200; // Set the height of the tiling area
     *
     * // Create from options
     * const texture = Texture.from('pattern.png');
     * const pattern = TilingSprite.from(texture, {
     *     width: 300,
     *     height: 200,
     *     tileScale: { x: 0.5, y: 0.5 }
     * });
     * ```
     * @param source - The source to create the sprite from. Can be a path to an image or a texture
     * @param options - Additional options for the tiling sprite
     * @returns A new tiling sprite based on the source
     * @see {@link Texture.from} For texture creation details
     * @see {@link Assets} For asset loading and management
     */
    static from(source11, options = {}) {
      if (typeof source11 === "string") {
        return new _TilingSprite2(__spreadValues({
          texture: Cache.get(source11)
        }, options));
      }
      return new _TilingSprite2(__spreadValues({
        texture: source11
      }, options));
    }
    /**
     * @see {@link TilingSpriteOptions.applyAnchorToTexture}
     * @deprecated since 8.0.0
     * @advanced
     */
    get uvRespectAnchor() {
      deprecation(v8_0_0, "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
      return this.applyAnchorToTexture;
    }
    /** @advanced */
    set uvRespectAnchor(value) {
      deprecation(v8_0_0, "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
      this.applyAnchorToTexture = value;
    }
    /**
     * Changes frame clamping in corresponding textureMatrix
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     * @default 0.5
     * @type {number}
     * @advanced
     */
    get clampMargin() {
      return this._texture.textureMatrix.clampMargin;
    }
    /** @advanced */
    set clampMargin(value) {
      this._texture.textureMatrix.clampMargin = value;
    }
    /**
     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
     * and passed to the constructor.
     *
     * - The default is `(0,0)`, this means the sprite's origin is the top left.
     * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
     * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
     *
     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
     * @example
     * ```ts
     * // Center the anchor point
     * sprite.anchor = 0.5; // Sets both x and y to 0.5
     * sprite.position.set(400, 300); // Sprite will be centered at this position
     *
     * // Set specific x/y anchor points
     * sprite.anchor = {
     *     x: 1, // Right edge
     *     y: 0  // Top edge
     * };
     *
     * // Using individual coordinates
     * sprite.anchor.set(0.5, 1); // Center-bottom
     *
     * // For rotation around center
     * sprite.anchor.set(0.5);
     * sprite.rotation = Math.PI / 4; // 45 degrees around center
     *
     * // For scaling from center
     * sprite.anchor.set(0.5);
     * sprite.scale.set(2); // Scales from center point
     * ```
     */
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    /**
     * The offset of the tiling texture.
     * Used to scroll or position the repeated pattern.
     * @example
     * ```ts
     * // Offset the tiling pattern by 100 pixels in both x and y directions
     * tilingSprite.tilePosition = { x: 100, y: 100 };
     * ```
     * @default {x: 0, y: 0}
     */
    get tilePosition() {
      return this._tileTransform.position;
    }
    set tilePosition(value) {
      this._tileTransform.position.copyFrom(value);
    }
    /**
     * Scale of the tiling texture.
     * Affects the size of each repeated instance of the texture.
     * @example
     * ```ts
     * // Scale the texture by 1.5 in both x and y directions
     * tilingSprite.tileScale = { x: 1.5, y: 1.5 };
     * ```
     * @default {x: 1, y: 1}
     */
    get tileScale() {
      return this._tileTransform.scale;
    }
    set tileScale(value) {
      typeof value === "number" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);
    }
    set tileRotation(value) {
      this._tileTransform.rotation = value;
    }
    /**
     * Rotation of the tiling texture in radians.
     * This controls the rotation applied to the texture before tiling.
     * @example
     * ```ts
     * // Rotate the texture by 45 degrees (in radians)
     * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees
     * ```
     * @default 0
     */
    get tileRotation() {
      return this._tileTransform.rotation;
    }
    /**
     * The transform object that controls the tiling texture's position, scale, and rotation.
     * This transform is independent of the sprite's own transform properties.
     * @example
     * ```ts
     * // Access transform properties directly
     * sprite.tileTransform.position.set(100, 50);
     * sprite.tileTransform.scale.set(2);
     * sprite.tileTransform.rotation = Math.PI / 4;
     *
     * // Create smooth scrolling animation
     * app.ticker.add(() => {
     *     sprite.tileTransform.position.x += 1;
     *     sprite.tileTransform.rotation += 0.01;
     * });
     *
     * // Reset transform
     * sprite.tileTransform.position.set(0);
     * sprite.tileTransform.scale.set(1);
     * sprite.tileTransform.rotation = 0;
     * ```
     * @returns {Transform} The transform object for the tiling texture
     * @see {@link Transform} For transform operations
     * @see {@link TilingSprite#tilePosition} For position control
     * @see {@link TilingSprite#tileScale} For scale control
     * @see {@link TilingSprite#tileRotation} For rotation control
     * @advanced
     */
    get tileTransform() {
      return this._tileTransform;
    }
    set texture(value) {
      value || (value = Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture === value)
        return;
      if (currentTexture && currentTexture.dynamic)
        currentTexture.off("update", this.onViewUpdate, this);
      if (value.dynamic)
        value.on("update", this.onViewUpdate, this);
      this._texture = value;
      this.onViewUpdate();
    }
    /**
     * The texture to use for tiling.
     * This is the image that will be repeated across the sprite.
     * @example
     * ```ts
     * // Use a texture from the asset cache
     * tilingSprite.texture = Texture.from('assets/pattern.png');
     * ```
     * @default Texture.WHITE
     */
    get texture() {
      return this._texture;
    }
    /**
     * The width of the tiling area. This defines how wide the area is that the texture will be tiled across.
     * @example
     * ```ts
     * // Create a tiling sprite
     * const sprite = new TilingSprite({
     *     texture: Texture.from('pattern.png'),
     *     width: 500,
     *     height: 300
     * });
     *
     * // Adjust width dynamically
     * sprite.width = 800; // Expands tiling area
     *
     * // Update on resize
     * window.addEventListener('resize', () => {
     *     sprite.width = app.screen.width;
     * });
     * ```
     * @see {@link TilingSprite#setSize} For setting both width and height efficiently
     * @see {@link TilingSprite#height} For setting height
     */
    set width(value) {
      this._width = value;
      this.onViewUpdate();
    }
    get width() {
      return this._width;
    }
    set height(value) {
      this._height = value;
      this.onViewUpdate();
    }
    /**
     * The height of the tiling area. This defines how tall the area is that the texture will be tiled across.
     * @example
     * ```ts
     * // Create a tiling sprite
     * const sprite = new TilingSprite({
     *     texture: Texture.from('pattern.png'),
     *     width: 500,
     *     height: 300
     * });
     *
     * // Adjust width dynamically
     * sprite.height = 800; // Expands tiling area
     *
     * // Update on resize
     * window.addEventListener('resize', () => {
     *     sprite.height = app.screen.height;
     * });
     * ```
     * @see {@link TilingSprite#setSize} For setting both width and height efficiently
     * @see {@link TilingSprite#width} For setting width
     */
    get height() {
      return this._height;
    }
    /**
     * Sets the size of the TilingSprite to the specified width and height.
     * This is faster than setting width and height separately as it only triggers one update.
     * @example
     * ```ts
     * // Set specific dimensions
     * sprite.setSize(300, 200); // Width: 300, Height: 200
     *
     * // Set uniform size (square)
     * sprite.setSize(400); // Width: 400, Height: 400
     *
     * // Set size using object
     * sprite.setSize({
     *     width: 500,
     *     height: 300
     * });
     * ```
     * @param value - This can be either a number for uniform sizing or a Size object with width/height properties
     * @param height - The height to set. Defaults to the value of `width` if not provided
     * @see {@link TilingSprite#width} For setting width only
     * @see {@link TilingSprite#height} For setting height only
     */
    setSize(value, height) {
      var _a2;
      if (typeof value === "object") {
        height = (_a2 = value.height) != null ? _a2 : value.width;
        value = value.width;
      }
      this._width = value;
      this._height = height != null ? height : value;
      this.onViewUpdate();
    }
    /**
     * Retrieves the size of the TilingSprite as a {@link Size} object.
     * This method is more efficient than getting width and height separately as it only allocates one object.
     * @example
     * ```ts
     * // Get basic size
     * const size = sprite.getSize();
     * console.log(`Size: ${size.width}x${size.height}`);
     *
     * // Reuse existing size object
     * const reuseSize = { width: 0, height: 0 };
     * sprite.getSize(reuseSize);
     * ```
     * @param out - Optional object to store the size in, to avoid allocating a new object
     * @returns The size of the TilingSprite
     * @see {@link TilingSprite#width} For getting just the width
     * @see {@link TilingSprite#height} For getting just the height
     * @see {@link TilingSprite#setSize} For setting both width and height efficiently
     */
    getSize(out2) {
      out2 || (out2 = {});
      out2.width = this._width;
      out2.height = this._height;
      return out2;
    }
    /** @private */
    updateBounds() {
      const bounds = this._bounds;
      const anchor = this._anchor;
      const width = this._width;
      const height = this._height;
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
    /**
     * Checks if the object contains the given point in local coordinates.
     * Takes into account the anchor offset when determining boundaries.
     * @example
     * ```ts
     * // Create a tiling sprite
     * const sprite = new TilingSprite({
     *     texture: Texture.from('pattern.png'),
     *     width: 200,
     *     height: 100,
     *     anchor: 0.5 // Center anchor
     * });
     *
     * // Basic point check
     * const contains = sprite.containsPoint({ x: 50, y: 25 });
     * console.log('Point is inside:', contains);
     *
     * // Check with different anchors
     * sprite.anchor.set(0); // Top-left anchor
     * console.log('Contains point:', sprite.containsPoint({ x: 150, y: 75 }));
     * ```
     * @param point - The point to check in local coordinates
     * @returns True if the point is within the sprite's bounds
     * @see {@link TilingSprite#toLocal} For converting global coordinates to local
     * @see {@link TilingSprite#anchor} For understanding boundary calculations
     */
    containsPoint(point) {
      const width = this._width;
      const height = this._height;
      const x1 = -width * this._anchor._x;
      let y1 = 0;
      if (point.x >= x1 && point.x <= x1 + width) {
        y1 = -height * this._anchor._y;
        if (point.y >= y1 && point.y <= y1 + height)
          return true;
      }
      return false;
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @example
     * tilingSprite.destroy();
     * tilingSprite.destroy(true);
     * tilingSprite.destroy({ texture: true, textureSource: true });
     */
    destroy(options = false) {
      super.destroy(options);
      this._anchor = null;
      this._tileTransform = null;
      this._bounds = null;
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        this._texture.destroy(destroyTextureSource);
      }
      this._texture = null;
    }
  };
  _TilingSprite.defaultOptions = {
    /** The texture to use for the sprite. */
    texture: Texture.EMPTY,
    /** The anchor point of the sprite */
    anchor: { x: 0, y: 0 },
    /** The offset of the image that is being tiled. */
    tilePosition: { x: 0, y: 0 },
    /** Scaling of the image that is being tiled. */
    tileScale: { x: 1, y: 1 },
    /** The rotation of the image that is being tiled. */
    tileRotation: 0,
    /**
     * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in
     * local space.
     *
     * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without
     * this, the top-left corner always gets the (0, 0) texture coordinate.
     * @default false
     */
    applyAnchorToTexture: false
  };
  var TilingSprite = _TilingSprite;

  // node_modules/pixi.js/lib/scene/text/Text.mjs
  init_TextureStyle();

  // node_modules/pixi.js/lib/scene/text/AbstractText.mjs
  init_ObservablePoint();
  init_deprecation();
  init_ViewContainer();
  var AbstractText = class extends ViewContainer {
    constructor(options, styleClass) {
      const _a2 = options, { text, resolution, style, anchor, width, height, roundPixels } = _a2, rest = __objRest(_a2, ["text", "resolution", "style", "anchor", "width", "height", "roundPixels"]);
      super(__spreadValues({}, rest));
      this.batched = true;
      this._resolution = null;
      this._autoResolution = true;
      this._didTextUpdate = true;
      this._styleClass = styleClass;
      this.text = text != null ? text : "";
      this.style = style;
      this.resolution = resolution != null ? resolution : null;
      this.allowChildren = false;
      this._anchor = new ObservablePoint(
        {
          _onUpdate: () => {
            this.onViewUpdate();
          }
        }
      );
      if (anchor)
        this.anchor = anchor;
      this.roundPixels = roundPixels != null ? roundPixels : false;
      if (width !== void 0)
        this.width = width;
      if (height !== void 0)
        this.height = height;
    }
    /**
     * The anchor point of the text that controls the origin point for positioning and rotation.
     * Can be a number (same value for x/y) or a PointData object.
     * - (0,0) is top-left
     * - (0.5,0.5) is center
     * - (1,1) is bottom-right
     * ```ts
     * // Set anchor to center
     * const text = new Text({
     *     text: 'Hello Pixi!',
     *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }
     * });
     * // Set anchor to top-left
     * const text2 = new Text({
     *     text: 'Hello Pixi!',
     *     anchor: { x: 0, y: 0 } // Top-left corner
     * });
     * // Set anchor to bottom-right
     * const text3 = new Text({
     *     text: 'Hello Pixi!',
     *     anchor: { x: 1, y: 1 } // Bottom-right corner
     * });
     * ```
     * @default { x: 0, y: 0 }
     */
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    /**
     * The text content to display. Use '\n' for line breaks.
     * Accepts strings, numbers, or objects with toString() method.
     * @example
     * ```ts
     * const text = new Text({
     *     text: 'Hello Pixi!',
     * });
     * const multilineText = new Text({
     *     text: 'Line 1\nLine 2\nLine 3',
     * });
     * const numberText = new Text({
     *     text: 12345, // Will be converted to '12345'
     * });
     * const objectText = new Text({
     *     text: { toString: () => 'Object Text' }, // Custom toString
     * });
     *
     * // Update text dynamically
     * text.text = 'Updated Text'; // Re-renders with new text
     * text.text = 67890; // Updates to '67890'
     * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method
     * // Clear text
     * text.text = ''; // Clears the text
     * ```
     * @default ''
     */
    set text(value) {
      value = value.toString();
      if (this._text === value)
        return;
      this._text = value;
      this.onViewUpdate();
    }
    get text() {
      return this._text;
    }
    /**
     * The resolution/device pixel ratio for rendering.
     * Higher values result in sharper text at the cost of performance.
     * Set to null for auto-resolution based on device.
     * @example
     * ```ts
     * const text = new Text({
     *     text: 'Hello Pixi!',
     *     resolution: 2 // High DPI for sharper text
     * });
     * const autoResText = new Text({
     *     text: 'Auto Resolution',
     *     resolution: null // Use device's pixel ratio
     * });
     * ```
     * @default null
     */
    set resolution(value) {
      this._autoResolution = value === null;
      this._resolution = value;
      this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    /**
     * The style configuration for the text.
     * Can be a TextStyle instance or a configuration object.
     * Supports canvas text styles, HTML text styles, and bitmap text styles.
     * @example
     * ```ts
     * const text = new Text({
     *     text: 'Styled Text',
     *     style: {
     *         fontSize: 24,
     *         fill: 0xff1010, // Red color
     *         fontFamily: 'Arial',
     *         align: 'center', // Center alignment
     *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke
     *         dropShadow: {
     *             color: '#000000', // Black shadow
     *             blur: 4, // Shadow blur
     *             distance: 6 // Shadow distance
     *         }
     *     }
     * });
     * const htmlText = new HTMLText({
     *     text: 'HTML Styled Text',
     *     style: {
     *         fontSize: '20px',
     *         fill: 'blue',
     *         fontFamily: 'Verdana',
     *     }
     * });
     * const bitmapText = new BitmapText({
     *     text: 'Bitmap Styled Text',
     *     style: {
     *         fontName: 'Arial',
     *         fontSize: 32,
     *     }
     * })
     *
     * // Update style dynamically
     * text.style = {
     *     fontSize: 30, // Change font size
     *     fill: 0x00ff00, // Change color to green
     *     align: 'right', // Change alignment to right
     *     stroke: { color: '#000000', width: 2 }, // Add black stroke
     * }
     */
    set style(style) {
      var _a2;
      style || (style = {});
      (_a2 = this._style) == null ? void 0 : _a2.off("update", this.onViewUpdate, this);
      if (style instanceof this._styleClass) {
        this._style = style;
      } else {
        this._style = new this._styleClass(style);
      }
      this._style.on("update", this.onViewUpdate, this);
      this.onViewUpdate();
    }
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set.
     * @example
     * ```ts
     * // Set width directly
     * texture.width = 200;
     * console.log(texture.scale.x); // Scale adjusted to match width
     *
     * // For better performance when setting both width and height
     * texture.setSize(300, 400); // Avoids recalculating bounds twice
     * ```
     */
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(value) {
      this._setWidth(value, this.bounds.width);
    }
    /**
     * The height of the sprite, setting this will actually modify the scale to achieve the value set.
     * @example
     * ```ts
     * // Set height directly
     * texture.height = 200;
     * console.log(texture.scale.y); // Scale adjusted to match height
     *
     * // For better performance when setting both width and height
     * texture.setSize(300, 400); // Avoids recalculating bounds twice
     * ```
     */
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(value) {
      this._setHeight(value, this.bounds.height);
    }
    /**
     * Retrieves the size of the Text as a [Size]{@link Size} object based on the texture dimensions and scale.
     * This is faster than getting width and height separately as it only calculates the bounds once.
     * @example
     * ```ts
     * // Basic size retrieval
     * const text = new Text({
     *     text: 'Hello Pixi!',
     *     style: { fontSize: 24 }
     * });
     * const size = text.getSize();
     * console.log(`Size: ${size.width}x${size.height}`);
     *
     * // Reuse existing size object
     * const reuseSize = { width: 0, height: 0 };
     * text.getSize(reuseSize);
     * ```
     * @param out - Optional object to store the size in, to avoid allocating a new object
     * @returns The size of the Sprite
     * @see {@link Text#width} For getting just the width
     * @see {@link Text#height} For getting just the height
     * @see {@link Text#setSize} For setting both width and height
     */
    getSize(out2) {
      out2 || (out2 = {});
      out2.width = Math.abs(this.scale.x) * this.bounds.width;
      out2.height = Math.abs(this.scale.y) * this.bounds.height;
      return out2;
    }
    /**
     * Sets the size of the Text to the specified width and height.
     * This is faster than setting width and height separately as it only recalculates bounds once.
     * @example
     * ```ts
     * // Basic size setting
     * const text = new Text({
     *    text: 'Hello Pixi!',
     *    style: { fontSize: 24 }
     * });
     * text.setSize(100, 200); // Width: 100, Height: 200
     *
     * // Set uniform size
     * text.setSize(100); // Sets both width and height to 100
     *
     * // Set size with object
     * text.setSize({
     *     width: 200,
     *     height: 300
     * });
     * ```
     * @param value - This can be either a number or a {@link Size} object
     * @param height - The height to set. Defaults to the value of `width` if not provided
     * @see {@link Text#width} For setting width only
     * @see {@link Text#height} For setting height only
     */
    setSize(value, height) {
      var _a2;
      if (typeof value === "object") {
        height = (_a2 = value.height) != null ? _a2 : value.width;
        value = value.width;
      } else {
        height != null ? height : height = value;
      }
      value !== void 0 && this._setWidth(value, this.bounds.width);
      height !== void 0 && this._setHeight(height, this.bounds.height);
    }
    /**
     * Checks if the object contains the given point in local coordinates.
     * Uses the text's bounds for hit testing.
     * @example
     * ```ts
     * // Basic point check
     * const localPoint = { x: 50, y: 25 };
     * const contains = text.containsPoint(localPoint);
     * console.log('Point is inside:', contains);
     * ```
     * @param point - The point to check in local coordinates
     * @returns True if the point is within the text's bounds
     * @see {@link Container#toLocal} For converting global coordinates to local
     */
    containsPoint(point) {
      const width = this.bounds.width;
      const height = this.bounds.height;
      const x1 = -width * this.anchor.x;
      let y1 = 0;
      if (point.x >= x1 && point.x <= x1 + width) {
        y1 = -height * this.anchor.y;
        if (point.y >= y1 && point.y <= y1 + height)
          return true;
      }
      return false;
    }
    /** @internal */
    onViewUpdate() {
      if (!this.didViewUpdate)
        this._didTextUpdate = true;
      super.onViewUpdate();
    }
    /**
     * Destroys this text renderable and optionally its style texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @example
     * // Destroys the text and its style
     * text.destroy({ style: true, texture: true, textureSource: true });
     * text.destroy(true);
     * text.destroy() // Destroys the text, but not its style
     */
    destroy(options = false) {
      super.destroy(options);
      this.owner = null;
      this._bounds = null;
      this._anchor = null;
      if (typeof options === "boolean" ? options : options == null ? void 0 : options.style) {
        this._style.destroy(options);
      }
      this._style = null;
      this._text = null;
    }
    /**
     * Returns a unique key for this instance.
     * This key is used for caching.
     * @returns {string} Unique key for the instance
     */
    get styleKey() {
      return `${this._text}:${this._style.styleKey}:${this._resolution}`;
    }
  };
  function ensureTextOptions(args, name) {
    var _a2;
    let options = (_a2 = args[0]) != null ? _a2 : {};
    if (typeof options === "string" || args[1]) {
      deprecation(v8_0_0, `use new ${name}({ text: "hi!", style }) instead`);
      options = {
        text: options,
        style: args[1]
      };
    }
    return options;
  }

  // node_modules/pixi.js/lib/scene/text/Text.mjs
  init_CanvasTextGenerator();
  init_CanvasTextMetrics();
  init_TextStyle();
  var Text = class extends AbstractText {
    constructor(...args) {
      const options = ensureTextOptions(args, "Text");
      super(options, TextStyle);
      this.renderPipeId = "text";
      if (options.textureStyle) {
        this.textureStyle = options.textureStyle instanceof TextureStyle ? options.textureStyle : new TextureStyle(options.textureStyle);
      }
    }
    /** @private */
    updateBounds() {
      const bounds = this._bounds;
      const anchor = this._anchor;
      let width = 0;
      let height = 0;
      if (this._style.trim) {
        const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({
          text: this.text,
          style: this._style,
          resolution: 1
        });
        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
        width = frame.width;
        height = frame.height;
      } else {
        const canvasMeasurement = CanvasTextMetrics.measureText(
          this._text,
          this._style
        );
        width = canvasMeasurement.width;
        height = canvasMeasurement.height;
      }
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
  };

  // node_modules/pixi.js/lib/prepare/PrepareQueue.mjs
  var PrepareQueue = class extends PrepareBase {
    /**
     * Resolve the given resource type and return an item for the queue
     * @param source
     * @param queue
     */
    resolveQueueItem(source11, queue) {
      if (source11 instanceof Container) {
        this.resolveContainerQueueItem(source11, queue);
      } else if (source11 instanceof TextureSource || source11 instanceof Texture) {
        queue.push(source11.source);
      } else if (source11 instanceof GraphicsContext) {
        queue.push(source11);
      }
      return null;
    }
    /**
     * Resolve the given container and return an item for the queue
     * @param container
     * @param queue
     */
    resolveContainerQueueItem(container, queue) {
      if (container instanceof Sprite || container instanceof TilingSprite || container instanceof Mesh) {
        queue.push(container.texture.source);
      } else if (container instanceof Text) {
        queue.push(container);
      } else if (container instanceof Graphics) {
        queue.push(container.context);
      } else if (container instanceof AnimatedSprite) {
        container.textures.forEach((textureOrFrame) => {
          if (textureOrFrame.source) {
            queue.push(textureOrFrame.source);
          } else {
            queue.push(textureOrFrame.texture.source);
          }
        });
      }
    }
    /**
     * Resolve the given graphics context and return an item for the queue
     * @param graphicsContext
     */
    resolveGraphicsContextQueueItem(graphicsContext) {
      this.renderer.graphicsContext.getGpuContext(graphicsContext);
      const { instructions } = graphicsContext;
      for (const instruction of instructions) {
        if (instruction.action === "texture") {
          const { image } = instruction.data;
          return image.source;
        } else if (instruction.action === "fill") {
          const { texture } = instruction.data.style;
          return texture.source;
        }
      }
      return null;
    }
  };

  // node_modules/pixi.js/lib/prepare/PrepareSystem.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/prepare/PrepareUpload.mjs
  init_TextureSource();
  init_GraphicsContext();

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs
  init_warn();
  init_TextStyle();
  init_BitmapFontManager();
  var BitmapText = class extends AbstractText {
    constructor(...args) {
      var _a3, _b;
      var _a2;
      const options = ensureTextOptions(args, "BitmapText");
      (_a3 = options.style) != null ? _a3 : options.style = options.style || {};
      (_b = (_a2 = options.style).fill) != null ? _b : _a2.fill = 16777215;
      super(options, TextStyle);
      this.renderPipeId = "bitmapText";
    }
    /**
     * @param now - The current time in milliseconds.
     * @internal
     */
    _onTouch(now) {
      var _a2;
      this._gcLastUsed = now;
      for (const key in this._gpuData) {
        (_a2 = this._gpuData[key]) == null ? void 0 : _a2._onTouch(now);
      }
    }
    /** @private */
    updateBounds() {
      const bounds = this._bounds;
      const anchor = this._anchor;
      const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);
      const scale = bitmapMeasurement.scale;
      const offset = bitmapMeasurement.offsetY * scale;
      let width = bitmapMeasurement.width * scale;
      let height = bitmapMeasurement.height * scale;
      const stroke = this._style._stroke;
      if (stroke) {
        width += stroke.width;
        height += stroke.width;
      }
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * (height + offset);
      bounds.maxY = bounds.minY + height;
    }
    /**
     * The resolution / device pixel ratio for text rendering.
     * Unlike other text types, BitmapText resolution is managed by the BitmapFont.
     * Individual resolution changes are not supported.
     * @example
     * ```ts
     * //  Incorrect: Setting resolution directly (will trigger warning)
     * const text = new BitmapText({
     *     text: 'Hello',
     *     resolution: 2 // This will be ignored
     * });
     *
     * //  Correct: Set resolution when installing the font
     * BitmapFont.install({
     *     name: 'MyFont',
     *     style: {
     *         fontFamily: 'Arial',
     *     },
     *     resolution: 2 // Resolution is set here
     * });
     *
     * const text = new BitmapText({
     *     text: 'Hello',
     *     style: {
     *         fontFamily: 'MyFont' // Uses font's resolution
     *     }
     * });
     * ```
     * @default 1
     * @see {@link BitmapFont.install} For setting font resolution
     * @throws {Warning} When attempting to change resolution directly
     * @readonly
     */
    set resolution(value) {
      if (value !== null) {
        warn(
          // eslint-disable-next-line max-len
          "[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont."
        );
      }
    }
    get resolution() {
      return this._resolution;
    }
  };

  // node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs
  init_TextureStyle();

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs
  init_warn();
  init_TextStyle();

  // node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs
  init_Color();
  function textStyleToCSS(style) {
    const stroke = style._stroke;
    const fill = style._fill;
    const cssStyleString = [
      `color: ${Color.shared.setValue(fill.color).toHex()}`,
      `font-size: ${style.fontSize}px`,
      `font-family: ${style.fontFamily}`,
      `font-weight: ${style.fontWeight}`,
      `font-style: ${style.fontStyle}`,
      `font-variant: ${style.fontVariant}`,
      `letter-spacing: ${style.letterSpacing}px`,
      `text-align: ${style.align}`,
      `padding: ${style.padding}px`,
      `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,
      ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],
      ...style.wordWrap ? [
        `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${style.wordWrapWidth}px`
      ] : [],
      ...stroke ? [strokeToCSS(stroke)] : [],
      ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],
      ...style.cssOverrides
    ].join(";");
    const cssStyles = [`div { ${cssStyleString} }`];
    tagStyleToCSS(style.tagStyles, cssStyles);
    return cssStyles.join(" ");
  }
  function dropShadowToCSS(dropShadowStyle) {
    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
    const x2 = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
    const y2 = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
    const position = `${x2}px ${y2}px`;
    if (dropShadowStyle.blur > 0) {
      return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
  }
  function strokeToCSS(stroke) {
    return [
      `-webkit-text-stroke-width: ${stroke.width}px`,
      `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
      `text-stroke-width: ${stroke.width}px`,
      `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
      "paint-order: stroke"
    ].join(";");
  }
  var templates = {
    fontSize: `font-size: {{VALUE}}px`,
    fontFamily: `font-family: {{VALUE}}`,
    fontWeight: `font-weight: {{VALUE}}`,
    fontStyle: `font-style: {{VALUE}}`,
    fontVariant: `font-variant: {{VALUE}}`,
    letterSpacing: `letter-spacing: {{VALUE}}px`,
    align: `text-align: {{VALUE}}`,
    padding: `padding: {{VALUE}}px`,
    whiteSpace: `white-space: {{VALUE}}`,
    lineHeight: `line-height: {{VALUE}}px`,
    wordWrapWidth: `max-width: {{VALUE}}px`
  };
  var transform = {
    fill: (value) => `color: ${Color.shared.setValue(value).toHex()}`,
    breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,
    stroke: strokeToCSS,
    dropShadow: dropShadowToCSS
  };
  function tagStyleToCSS(tagStyles, out2) {
    for (const i3 in tagStyles) {
      const tagStyle = tagStyles[i3];
      const cssTagStyle = [];
      for (const j2 in tagStyle) {
        if (transform[j2]) {
          cssTagStyle.push(transform[j2](tagStyle[j2]));
        } else if (templates[j2]) {
          cssTagStyle.push(templates[j2].replace("{{VALUE}}", tagStyle[j2]));
        }
      }
      out2.push(`${i3} { ${cssTagStyle.join(";")} }`);
    }
  }

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs
  var HTMLTextStyle = class _HTMLTextStyle extends TextStyle {
    constructor(options = {}) {
      var _a2, _b;
      super(options);
      this._cssOverrides = [];
      this.cssOverrides = (_a2 = options.cssOverrides) != null ? _a2 : [];
      this.tagStyles = (_b = options.tagStyles) != null ? _b : {};
    }
    /**
     * List of CSS style overrides to apply to the HTML text.
     * These styles are added after the built-in styles and can override any default styling.
     * @advanced
     */
    set cssOverrides(value) {
      this._cssOverrides = value instanceof Array ? value : [value];
      this.update();
    }
    /** @advanced */
    get cssOverrides() {
      return this._cssOverrides;
    }
    /**
     * Updates the text style and triggers a refresh of the CSS style cache.
     * This method is called automatically when style properties are changed.
     * @example
     * ```ts
     * // Update after multiple changes
     * const text = new HTMLText({
     *     text: 'Hello World',
     *     style
     * });
     *
     * style.fontSize = 32;
     * style.fill = '#00ff00';
     * style.fontFamily = 'Arial';
     * style.update(); // Apply all changes at once
     * ```
     * @advanced
     * @see {@link HTMLTextStyle#cssStyle} For accessing the generated CSS
     * @see {@link HTMLTextStyle#cssOverrides} For managing CSS overrides
     */
    update() {
      this._cssStyle = null;
      super.update();
    }
    /**
     * Creates a new HTMLTextStyle object with the same values as this one.
     * This creates a deep copy of all style properties, including dropShadow and tag styles.
     * @example
     * ```ts
     * // Create original style
     * const originalStyle = new HTMLTextStyle({
     *     fontSize: 24,
     *     fill: '#ff0000',
     *     tagStyles: {
     *         header: { fontSize: 32, fill: '#00ff00' }
     *     }
     * });
     *
     * // Clone the style
     * const clonedStyle = originalStyle.clone();
     *
     * // Modify cloned style independently
     * clonedStyle.fontSize = 36;
     * clonedStyle.fill = '#0000ff';
     *
     * // Original style remains unchanged
     * console.log(originalStyle.fontSize); // Still 24
     * console.log(originalStyle.fill); // Still '#ff0000'
     * ```
     *
     * Properties that are cloned:
     * - Basic text properties (fontSize, fontFamily, etc.)
     * - Fill and stroke styles
     * - Drop shadow configuration
     * - CSS overrides
     * - Tag styles (deep copied)
     * - Word wrap settings
     * - Alignment and spacing
     * @returns {HTMLTextStyle} A new HTMLTextStyle instance with the same properties
     * @see {@link HTMLTextStyle} For available style properties
     * @see {@link HTMLTextStyle#cssOverrides} For CSS override handling
     * @see {@link HTMLTextStyle#tagStyles} For tag style configuration
     * @standard
     */
    clone() {
      return new _HTMLTextStyle({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this.dropShadow ? __spreadValues({}, this.dropShadow) : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth,
        cssOverrides: this.cssOverrides,
        tagStyles: __spreadValues({}, this.tagStyles)
      });
    }
    /**
     * The CSS style string that will be applied to the HTML text.
     * @advanced
     */
    get cssStyle() {
      if (!this._cssStyle) {
        this._cssStyle = textStyleToCSS(this);
      }
      return this._cssStyle;
    }
    /**
     * Add a style override, this can be any CSS property
     * it will override any built-in style. This is the
     * property and the value as a string (e.g., `color: red`).
     * This will override any other internal style.
     * @param {string} value - CSS style(s) to add.
     * @example
     * style.addOverride('background-color: red');
     * @advanced
     */
    addOverride(...value) {
      const toAdd = value.filter((v2) => !this.cssOverrides.includes(v2));
      if (toAdd.length > 0) {
        this.cssOverrides.push(...toAdd);
        this.update();
      }
    }
    /**
     * Remove any overrides that match the value.
     * @param {string} value - CSS style to remove.
     * @example
     * style.removeOverride('background-color: red');
     * @advanced
     */
    removeOverride(...value) {
      const toRemove = value.filter((v2) => this.cssOverrides.includes(v2));
      if (toRemove.length > 0) {
        this.cssOverrides = this.cssOverrides.filter((v2) => !toRemove.includes(v2));
        this.update();
      }
    }
    /**
     * Sets the fill style for the text. HTML text only supports color fills (string or number values).
     * Texture fills are not supported and will trigger a warning in debug mode.
     * @example
     * ```ts
     * // Using hex colors
     * const text = new HTMLText({
     *     text: 'Colored Text',
     *     style: {
     *         fill: 0xff0000 // Red color
     *     }
     * });
     *
     * // Using CSS color strings
     * text.style.fill = '#00ff00';     // Hex string (Green)
     * text.style.fill = 'blue';        // Named color
     * text.style.fill = 'rgb(255,0,0)' // RGB
     * text.style.fill = '#f0f';        // Short hex
     *
     * // Invalid usage (will trigger warning in debug)
     * text.style.fill = {
     *     type: 'pattern',
     *     texture: Texture.from('pattern.png')
     * }; // Not supported, falls back to default
     * ```
     * @param value - The fill color to use. Must be a string or number.
     * @throws {Warning} In debug mode when attempting to use unsupported fill types
     * @see {@link TextStyle#fill} For full fill options in canvas text
     * @standard
     */
    set fill(value) {
      if (typeof value !== "string" && typeof value !== "number") {
        warn("[HTMLTextStyle] only color fill is not supported by HTMLText");
      }
      super.fill = value;
    }
    /**
     * Sets the stroke style for the text. HTML text only supports color strokes (string or number values).
     * Texture strokes are not supported and will trigger a warning in debug mode.
     * @example
     * ```ts
     * // Using hex colors
     * const text = new HTMLText({
     *     text: 'Outlined Text',
     *     style: {
     *         stroke: 0xff0000 // Red outline
     *     }
     * });
     *
     * // Using CSS color strings
     * text.style.stroke = '#00ff00';     // Hex string (Green)
     * text.style.stroke = 'blue';        // Named color
     * text.style.stroke = 'rgb(255,0,0)' // RGB
     * text.style.stroke = '#f0f';        // Short hex
     *
     * // Using stroke width
     * text.style = {
     *     stroke: {
     *         color: '#ff0000',
     *         width: 2
     *     }
     * };
     *
     * // Remove stroke
     * text.style.stroke = null;
     *
     * // Invalid usage (will trigger warning in debug)
     * text.style.stroke = {
     *     type: 'pattern',
     *     texture: Texture.from('pattern.png')
     * }; // Not supported, falls back to default
     * ```
     * @param value - The stroke style to use. Must be a string, number, or stroke configuration object
     * @throws {Warning} In debug mode when attempting to use unsupported stroke types
     * @see {@link TextStyle#stroke} For full stroke options in canvas text
     * @standard
     */
    set stroke(value) {
      if (value && typeof value !== "string" && typeof value !== "number") {
        warn("[HTMLTextStyle] only color stroke is not supported by HTMLText");
      }
      super.stroke = value;
    }
  };

  // node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs
  init_measureHtmlText();
  var HTMLText = class extends AbstractText {
    constructor(...args) {
      const options = ensureTextOptions(args, "HtmlText");
      super(options, HTMLTextStyle);
      this.renderPipeId = "htmlText";
      if (options.textureStyle) {
        this.textureStyle = options.textureStyle instanceof TextureStyle ? options.textureStyle : new TextureStyle(options.textureStyle);
      }
    }
    /** @private */
    updateBounds() {
      const bounds = this._bounds;
      const anchor = this._anchor;
      const htmlMeasurement = measureHtmlText(this.text, this._style);
      const { width, height } = htmlMeasurement;
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
    get text() {
      return this._text;
    }
    /**
     * The text content to display. Use '\n' for line breaks.
     * Accepts strings, numbers, or objects with toString() method.
     * @example
     * ```ts
     * const text = new HTMLText({
     *     text: 'Hello Pixi!',
     * });
     * const multilineText = new HTMLText({
     *     text: 'Line 1\nLine 2\nLine 3',
     * });
     * const numberText = new HTMLText({
     *     text: 12345, // Will be converted to '12345'
     * });
     * const objectText = new HTMLText({
     *     text: { toString: () => 'Object Text' }, // Custom toString
     * });
     *
     * // Update text dynamically
     * text.text = 'Updated Text'; // Re-renders with new text
     * text.text = 67890; // Updates to '67890'
     * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method
     * // Clear text
     * text.text = ''; // Clears the text
     * ```
     * @default ''
     */
    set text(text) {
      const sanitisedText = this._sanitiseText(text.toString());
      super.text = sanitisedText;
    }
    /**
     * Sanitise text - replace `<br>` with `<br/>`, `&nbsp;` with `&#160;`
     * @param text
     * @see https://www.sitepoint.com/community/t/xhtml-1-0-transitional-xml-parsing-error-entity-nbsp-not-defined/3392/3
     */
    _sanitiseText(text) {
      return this._removeInvalidHtmlTags(text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;"));
    }
    _removeInvalidHtmlTags(input) {
      const brokenTagPattern = /<[^>]*?(?=<|$)/g;
      return input.replace(brokenTagPattern, "");
    }
  };

  // node_modules/pixi.js/lib/prepare/PrepareUpload.mjs
  var PrepareUpload = class extends PrepareQueue {
    /**
     * Upload the given queue item
     * @param item
     */
    uploadQueueItem(item) {
      if (item instanceof TextureSource) {
        this.uploadTextureSource(item);
      } else if (item instanceof Text) {
        this.uploadText(item);
      } else if (item instanceof HTMLText) {
        this.uploadHTMLText(item);
      } else if (item instanceof BitmapText) {
        this.uploadBitmapText(item);
      } else if (item instanceof GraphicsContext) {
        this.uploadGraphicsContext(item);
      }
    }
    uploadTextureSource(textureSource) {
      this.renderer.texture.initSource(textureSource);
    }
    uploadText(_text) {
      this.renderer.renderPipes.text.initGpuText(_text);
    }
    uploadBitmapText(_text) {
      this.renderer.renderPipes.bitmapText.initGpuText(_text);
    }
    uploadHTMLText(_text) {
      this.renderer.renderPipes.htmlText.initGpuText(_text);
    }
    /**
     * Resolve the given graphics context and return an item for the queue
     * @param graphicsContext
     */
    uploadGraphicsContext(graphicsContext) {
      this.renderer.graphicsContext.getGpuContext(graphicsContext);
      const { instructions } = graphicsContext;
      for (const instruction of instructions) {
        if (instruction.action === "texture") {
          const { image } = instruction.data;
          this.uploadTextureSource(image.source);
        } else if (instruction.action === "fill") {
          const { texture } = instruction.data.style;
          this.uploadTextureSource(texture.source);
        }
      }
      return null;
    }
  };

  // node_modules/pixi.js/lib/prepare/PrepareSystem.mjs
  var PrepareSystem = class extends PrepareUpload {
    /** Destroys the plugin, don't use after this. */
    destroy() {
      super.destroy();
      clearTimeout(this.timeout);
      this.renderer = null;
      this.queue = null;
      this.resolves = null;
    }
  };
  PrepareSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "prepare"
  };

  // node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.mjs
  function generateGPULayout(maxTextures) {
    const gpuLayout = [];
    let bindIndex = 0;
    for (let i3 = 0; i3 < maxTextures; i3++) {
      gpuLayout[bindIndex] = {
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        },
        binding: bindIndex,
        visibility: GPUShaderStage.FRAGMENT
      };
      bindIndex++;
      gpuLayout[bindIndex] = {
        sampler: {
          type: "filtering"
        },
        binding: bindIndex,
        visibility: GPUShaderStage.FRAGMENT
      };
      bindIndex++;
    }
    return gpuLayout;
  }

  // node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.mjs
  function generateLayout(maxTextures) {
    const layout = {};
    let bindIndex = 0;
    for (let i3 = 0; i3 < maxTextures; i3++) {
      layout[`textureSource${i3 + 1}`] = bindIndex++;
      layout[`textureSampler${i3 + 1}`] = bindIndex++;
    }
    return layout;
  }

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.mjs
  function formatShader(shader) {
    const spl = shader.split(/([\n{}])/g).map((a2) => a2.trim()).filter((a2) => a2.length);
    let indent = "";
    const formatted = spl.map((a2) => {
      let indentedLine = indent + a2;
      if (a2 === "{") {
        indent += "    ";
      } else if (a2 === "}") {
        indent = indent.substr(0, indent.length - 4);
        indentedLine = indent + a2;
      }
      return indentedLine;
    }).join("\n");
    return formatted;
  }

  // node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.mjs
  init_addMaskBounds();
  init_addMaskLocalBounds();
  var ScissorMask = class {
    constructor(mask) {
      this.priority = 0;
      this.pipe = "scissorMask";
      this.mask = mask;
      this.mask.renderable = false;
      this.mask.measurable = false;
    }
    addBounds(bounds, skipUpdateTransform) {
      addMaskBounds(this.mask, bounds, skipUpdateTransform);
    }
    addLocalBounds(bounds, localRoot) {
      addMaskLocalBounds(this.mask, bounds, localRoot);
    }
    containsPoint(point, hitTestFn) {
      const mask = this.mask;
      return hitTestFn(mask, point);
    }
    reset() {
      if (this.mask === null)
        return;
      this.mask.measurable = true;
      this.mask = null;
    }
    destroy() {
      this.reset();
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs
  function migrateFragmentFromV7toV8(fragmentShader) {
    fragmentShader = fragmentShader.replaceAll("texture2D", "texture").replaceAll("gl_FragColor", "finalColor").replaceAll("varying", "in");
    fragmentShader = `
        out vec4 finalColor;
    ${fragmentShader}
    `;
    return fragmentShader;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs
  var GLSL_TO_SIZE = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
  };
  function mapSize(type) {
    return GLSL_TO_SIZE[type];
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.mjs
  init_deprecation();
  var DEPRECATED_DRAW_MODES = {
    POINTS: "point-list",
    LINES: "line-list",
    LINE_STRIP: "line-strip",
    TRIANGLES: "triangle-list",
    TRIANGLE_STRIP: "triangle-strip"
  };
  var DRAW_MODES = new Proxy(DEPRECATED_DRAW_MODES, {
    get(target, prop) {
      deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_DRAW_MODES[prop]}' instead`);
      return target[prop];
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.mjs
  init_deprecation();
  var DEPRECATED_WRAP_MODES = /* @__PURE__ */ ((DEPRECATED_WRAP_MODES2) => {
    DEPRECATED_WRAP_MODES2["CLAMP"] = "clamp-to-edge";
    DEPRECATED_WRAP_MODES2["REPEAT"] = "repeat";
    DEPRECATED_WRAP_MODES2["MIRRORED_REPEAT"] = "mirror-repeat";
    return DEPRECATED_WRAP_MODES2;
  })(DEPRECATED_WRAP_MODES || {});
  var WRAP_MODES = new Proxy(DEPRECATED_WRAP_MODES, {
    get(target, prop) {
      deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_WRAP_MODES[prop]}' instead`);
      return target[prop];
    }
  });
  var DEPRECATED_SCALE_MODES = /* @__PURE__ */ ((DEPRECATED_SCALE_MODES2) => {
    DEPRECATED_SCALE_MODES2["NEAREST"] = "nearest";
    DEPRECATED_SCALE_MODES2["LINEAR"] = "linear";
    return DEPRECATED_SCALE_MODES2;
  })(DEPRECATED_SCALE_MODES || {});
  var SCALE_MODES = new Proxy(DEPRECATED_SCALE_MODES, {
    get(target, prop) {
      deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_SCALE_MODES[prop]}' instead`);
      return target[prop];
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.mjs
  init_groupD8();
  var TextureUvs = class {
    constructor() {
      this.x0 = 0;
      this.y0 = 0;
      this.x1 = 1;
      this.y1 = 0;
      this.x2 = 1;
      this.y2 = 1;
      this.x3 = 0;
      this.y3 = 1;
      this.uvsFloat32 = new Float32Array(8);
    }
    /**
     * Sets the texture Uvs based on the given frame information.
     * @protected
     * @param frame - The frame of the texture
     * @param baseFrame - The base frame of the texture
     * @param rotate - Rotation of frame, see {@link groupD8}
     */
    set(frame, baseFrame, rotate) {
      const tw = baseFrame.width;
      const th = baseFrame.height;
      if (rotate) {
        const w2 = frame.width / 2 / tw;
        const h2 = frame.height / 2 / th;
        const cX = frame.x / tw + w2;
        const cY = frame.y / th + h2;
        rotate = groupD8.add(rotate, groupD8.NW);
        this.x0 = cX + w2 * groupD8.uX(rotate);
        this.y0 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x1 = cX + w2 * groupD8.uX(rotate);
        this.y1 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x2 = cX + w2 * groupD8.uX(rotate);
        this.y2 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x3 = cX + w2 * groupD8.uX(rotate);
        this.y3 = cY + h2 * groupD8.uY(rotate);
      } else {
        this.x0 = frame.x / tw;
        this.y0 = frame.y / th;
        this.x1 = (frame.x + frame.width) / tw;
        this.y1 = frame.y / th;
        this.x2 = (frame.x + frame.width) / tw;
        this.y2 = (frame.y + frame.height) / th;
        this.x3 = frame.x / tw;
        this.y3 = (frame.y + frame.height) / th;
      }
      this.uvsFloat32[0] = this.x0;
      this.uvsFloat32[1] = this.y0;
      this.uvsFloat32[2] = this.x1;
      this.uvsFloat32[3] = this.y1;
      this.uvsFloat32[4] = this.x2;
      this.uvsFloat32[5] = this.y2;
      this.uvsFloat32[6] = this.x3;
      this.uvsFloat32[7] = this.y3;
    }
    toString() {
      return `[pixi.js/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.mjs
  function parseFunctionBody(fn) {
    const fnStr = fn.toString();
    const bodyStart = fnStr.indexOf("{");
    const bodyEnd = fnStr.lastIndexOf("}");
    if (bodyStart === -1 || bodyEnd === -1) {
      throw new Error("getFunctionBody: No body found in function definition");
    }
    return fnStr.slice(bodyStart + 1, bodyEnd).trim();
  }

  // node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs
  init_deprecation();
  function getFastGlobalBounds(target, bounds) {
    deprecation("8.7.0", "Use container.getFastGlobalBounds() instead");
    return target.getFastGlobalBounds(true, bounds);
  }

  // node_modules/pixi.js/lib/scene/container/RenderContainer.mjs
  init_ViewContainer();
  var RenderContainer = class extends ViewContainer {
    /**
     * @param options - The options for the container.
     */
    constructor(options) {
      var _b, _c;
      if (typeof options === "function") {
        options = { render: options };
      }
      const _a2 = options, { render: render3 } = _a2, rest = __objRest(_a2, ["render"]);
      super(__spreadValues({
        label: "RenderContainer"
      }, rest));
      this.renderPipeId = "customRender";
      this.batched = false;
      if (render3)
        this.render = render3;
      this.containsPoint = (_b = options.containsPoint) != null ? _b : (() => false);
      this.addBounds = (_c = options.addBounds) != null ? _c : (() => false);
    }
    /** @private */
    updateBounds() {
      this._bounds.clear();
      this.addBounds(this._bounds);
    }
    /**
     * An overridable function that can be used to render the object using the current renderer.
     * @param _renderer - The current renderer
     */
    render(_renderer) {
    }
  };

  // node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.mjs
  init_deprecation();
  function collectAllRenderables(container, instructionSet, rendererOrPipes) {
    deprecation("8.7.0", "Please use container.collectRenderables instead.");
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    return container.collectRenderables(instructionSet, renderer, null);
  }

  // node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs
  function updateLocalTransform(lt, container) {
    const scale = container._scale;
    const pivot = container._pivot;
    const position = container._position;
    const sx = scale._x;
    const sy = scale._y;
    const px = pivot._x;
    const py = pivot._y;
    lt.a = container._cx * sx;
    lt.b = container._sx * sx;
    lt.c = container._cy * sy;
    lt.d = container._sy * sy;
    lt.tx = position._x - (px * lt.a + py * lt.c);
    lt.ty = position._y - (px * lt.b + py * lt.d);
  }

  // node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.mjs
  function updateWorldTransform(local, parent, world) {
    const lta = local.a;
    const ltb = local.b;
    const ltc = local.c;
    const ltd = local.d;
    const lttx = local.tx;
    const ltty = local.ty;
    const pta = parent.a;
    const ptb = parent.b;
    const ptc = parent.c;
    const ptd = parent.d;
    world.a = lta * pta + ltb * ptc;
    world.b = lta * ptb + ltb * ptd;
    world.c = ltc * pta + ltd * ptc;
    world.d = ltc * ptb + ltd * ptd;
    world.tx = lttx * pta + ltty * ptc + parent.tx;
    world.ty = lttx * ptb + ltty * ptd + parent.ty;
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/buildGeometryFromPath.mjs
  init_buildUvs();
  init_transformVertices();
  init_MeshGeometry();
  init_GraphicsPath();
  init_buildContextBatches();
  function buildGeometryFromPath(options) {
    if (options instanceof GraphicsPath) {
      options = {
        path: options,
        textureMatrix: null,
        out: null
      };
    }
    const vertices = [];
    const uvs = [];
    const indices = [];
    const shapePath = options.path.shapePath;
    const textureMatrix = options.textureMatrix;
    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }) => {
      const indexOffset = indices.length;
      const vertOffset = vertices.length / 2;
      const points = [];
      const build = shapeBuilders[shape.type];
      build.build(shape, points);
      if (matrix) {
        transformVertices(points, matrix);
      }
      build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      const uvsOffset = uvs.length / 2;
      if (textureMatrix) {
        if (matrix) {
          textureMatrix.append(matrix.clone().invert());
        }
        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
    });
    const out2 = options.out;
    if (out2) {
      out2.positions = new Float32Array(vertices);
      out2.uvs = new Float32Array(uvs);
      out2.indices = new Uint32Array(indices);
      return out2;
    }
    const geometry = new MeshGeometry({
      positions: new Float32Array(vertices),
      uvs: new Float32Array(uvs),
      indices: new Uint32Array(indices)
    });
    return geometry;
  }

  // node_modules/pixi.js/lib/scene/layers/RenderLayer.mjs
  init_warn();
  init_Container();
  var _RenderLayer = class _RenderLayer2 extends Container {
    /**
     * Creates a new RenderLayer instance
     * @param options - Configuration options for the RenderLayer
     * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render
     * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex
     */
    constructor(options = {}) {
      options = __spreadValues(__spreadValues({}, _RenderLayer2.defaultOptions), options);
      super();
      this.renderLayerChildren = [];
      this.sortableChildren = options.sortableChildren;
      this.sortFunction = options.sortFunction;
    }
    /**
     * Adds one or more Containers to this render layer. The Containers will be rendered as part of this layer
     * while maintaining their original parent in the scene graph.
     *
     * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.
     * @example
     * ```ts
     * const layer = new RenderLayer();
     * const container = new Container();
     * const sprite1 = new Sprite(texture1);
     * const sprite2 = new Sprite(texture2);
     *
     * // Add sprites to scene graph for transforms
     * container.addChild(sprite1, sprite2);
     *
     * // Add sprites to layer for render order control
     * layer.attach(sprite1, sprite2);
     *
     * // Add single sprite with type checking
     * const typedSprite = layer.attach<Sprite>(new Sprite(texture3));
     * typedSprite.tint = 'red';
     *
     * // Automatically removes from previous layer if needed
     * const otherLayer = new RenderLayer();
     * otherLayer.attach(sprite1); // Removes from previous layer
     * ```
     * @param children - The Container(s) to add to this layer. Can be any Container or array of Containers.
     * @returns The first child that was added, for method chaining
     * @see {@link RenderLayer#detach} For removing objects from the layer
     * @see {@link RenderLayer#detachAll} For removing all objects from the layer
     * @see {@link Container#addChild} For adding to scene graph hierarchy
     */
    attach(...children) {
      for (let i3 = 0; i3 < children.length; i3++) {
        const child = children[i3];
        if (child.parentRenderLayer) {
          if (child.parentRenderLayer === this)
            continue;
          child.parentRenderLayer.detach(child);
        }
        this.renderLayerChildren.push(child);
        child.parentRenderLayer = this;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
      }
      return children[0];
    }
    /**
     * Removes one or more Containers from this render layer. The Containers will maintain their
     * original parent in the scene graph but will no longer be rendered as part of this layer.
     * @example
     * ```ts
     * const layer = new RenderLayer();
     * const container = new Container();
     * const sprite1 = new Sprite(texture1);
     * const sprite2 = new Sprite(texture2);
     *
     * // Add sprites to scene graph and layer
     * container.addChild(sprite1, sprite2);
     * layer.attach(sprite1, sprite2);
     *
     * // Remove single sprite from layer
     * layer.detach(sprite1);
     * // sprite1 is still child of container but not rendered in layer
     *
     * // Remove multiple sprites at once
     * const otherLayer = new RenderLayer();
     * otherLayer.attach(sprite3, sprite4);
     * otherLayer.detach(sprite3, sprite4);
     *
     * // Type-safe detachment
     * const typedSprite = layer.detach<Sprite>(spriteInLayer);
     * typedSprite.texture = newTexture; // TypeScript knows this is a Sprite
     * ```
     * @param children - The Container(s) to remove from this layer
     * @returns The first child that was removed, for method chaining
     * @see {@link RenderLayer#attach} For adding objects to the layer
     * @see {@link RenderLayer#detachAll} For removing all objects from the layer
     * @see {@link Container#removeChild} For removing from scene graph hierarchy
     */
    detach(...children) {
      for (let i3 = 0; i3 < children.length; i3++) {
        const child = children[i3];
        const index = this.renderLayerChildren.indexOf(child);
        if (index !== -1) {
          this.renderLayerChildren.splice(index, 1);
        }
        child.parentRenderLayer = null;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
      }
      return children[0];
    }
    /**
     * Removes all objects from this render layer. Objects will maintain their
     * original parent in the scene graph but will no longer be rendered as part of this layer.
     * @example
     * ```ts
     * const layer = new RenderLayer();
     * const container = new Container();
     *
     * // Add multiple sprites to scene graph and layer
     * const sprites = [
     *     new Sprite(texture1),
     *     new Sprite(texture2),
     *     new Sprite(texture3)
     * ];
     *
     * container.addChild(...sprites);  // Add to scene graph
     * layer.attach(...sprites);       // Add to render layer
     *
     * // Later, remove all sprites from layer at once
     * layer.detachAll();
     * console.log(layer.renderLayerChildren.length); // 0
     * console.log(container.children.length);        // 3 (still in scene graph)
     * ```
     * @returns The RenderLayer instance for method chaining
     * @see {@link RenderLayer#attach} For adding objects to the layer
     * @see {@link RenderLayer#detach} For removing individual objects
     * @see {@link Container#removeChildren} For removing from scene graph
     */
    detachAll() {
      const layerChildren = this.renderLayerChildren;
      for (let i3 = 0; i3 < layerChildren.length; i3++) {
        layerChildren[i3].parentRenderLayer = null;
      }
      this.renderLayerChildren.length = 0;
    }
    /**
     * Collects renderables for this layer and its children.
     * This method is called by the renderer to gather all objects that should be rendered in this layer.
     * @param instructionSet - The set of instructions to collect renderables into.
     * @param renderer - The renderer that is collecting renderables.
     * @param _currentLayer - The current render layer being processed.
     * @internal
     */
    collectRenderables(instructionSet, renderer, _currentLayer) {
      const layerChildren = this.renderLayerChildren;
      const length = layerChildren.length;
      if (this.sortableChildren) {
        this.sortRenderLayerChildren();
      }
      for (let i3 = 0; i3 < length; i3++) {
        if (!layerChildren[i3].parent) {
          warn(
            "Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)",
            layerChildren[i3]
          );
        }
        layerChildren[i3].collectRenderables(instructionSet, renderer, this);
      }
    }
    /**
     * Sort the layer's children using the defined sort function. This method allows manual sorting
     * of layer children and is automatically called during rendering if sortableChildren is true.
     * @example
     * ```ts
     * const layer = new RenderLayer();
     *
     * // Add multiple sprites at different depths
     * const sprite1 = new Sprite(texture);
     * const sprite2 = new Sprite(texture);
     * const sprite3 = new Sprite(texture);
     *
     * sprite1.zIndex = 3;
     * sprite2.zIndex = 1;
     * sprite3.zIndex = 2;
     *
     * layer.attach(sprite1, sprite2, sprite3);
     *
     * // Manual sorting with default zIndex sort
     * layer.sortRenderLayerChildren();
     * // Order is now: sprite2 (1), sprite3 (2), sprite1 (3)
     *
     * // Custom sort by y position
     * layer.sortFunction = (a, b) => a.y - b.y;
     * layer.sortRenderLayerChildren();
     *
     * // Automatic sorting
     * layer.sortableChildren = true; // Will sort each render
     * ```
     * @returns The RenderLayer instance for method chaining
     * @see {@link RenderLayer#sortableChildren} For enabling automatic sorting
     * @see {@link RenderLayer#sortFunction} For customizing the sort logic
     */
    sortRenderLayerChildren() {
      this.renderLayerChildren.sort(this.sortFunction);
    }
    /**
     * Recursively calculates the global bounds of this RenderLayer and its children.
     * @param factorRenderLayers
     * @param bounds
     * @param _currentLayer
     * @internal
     */
    _getGlobalBoundsRecursive(factorRenderLayers, bounds, _currentLayer) {
      if (!factorRenderLayers)
        return;
      const children = this.renderLayerChildren;
      for (let i3 = 0; i3 < children.length; i3++) {
        children[i3]._getGlobalBoundsRecursive(true, bounds, this);
      }
    }
    /**
     * @inheritdoc
     * @internal
     */
    getFastGlobalBounds(factorRenderLayers, bounds) {
      return super.getFastGlobalBounds(factorRenderLayers, bounds);
    }
    /**
     * This method is not available in RenderLayer.
     *
     * Calling this method will throw an error. Please use `RenderLayer.attach()` instead.
     * @param {...any} _children
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    addChild(..._children) {
      throw new Error(
        "RenderLayer.addChild() is not available. Please use RenderLayer.attach()"
      );
    }
    /**
     * This method is not available in RenderLayer.
     * Calling this method will throw an error. Please use `RenderLayer.detach()` instead.
     * @param {...any} _children
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    removeChild(..._children) {
      throw new Error(
        "RenderLayer.removeChild() is not available. Please use RenderLayer.detach()"
      );
    }
    /**
     * This method is not available in RenderLayer.
     *
     * Calling this method will throw an error. Please use `RenderLayer.detach()` instead.
     * @param {number} [_beginIndex]
     * @param {number} [_endIndex]
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    removeChildren(_beginIndex, _endIndex) {
      throw new Error(
        "RenderLayer.removeChildren() is not available. Please use RenderLayer.detach()"
      );
    }
    /**
     * This method is not available in RenderLayer.
     *
     * Calling this method will throw an error.
     * @param {number} _index
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    removeChildAt(_index) {
      throw new Error(
        "RenderLayer.removeChildAt() is not available"
      );
    }
    /**
     * This method is not available in RenderLayer.
     *
     * Calling this method will throw an error.
     * @param {number} _index
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    getChildAt(_index) {
      throw new Error(
        "RenderLayer.getChildAt() is not available"
      );
    }
    /**
     * This method is not available in RenderLayer.
     *
     * Calling this method will throw an error.
     * @param {Container} _child
     * @param {number} _index
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    setChildIndex(_child, _index) {
      throw new Error(
        "RenderLayer.setChildIndex() is not available"
      );
    }
    /**
     * This method is not available in RenderLayer.
     *
     * Calling this method will throw an error.
     * @param {Container} _child
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    getChildIndex(_child) {
      throw new Error(
        "RenderLayer.getChildIndex() is not available"
      );
    }
    /**
     * This method is not available in RenderLayer.
     *
     * Calling this method will throw an error.
     * @param {Container} _child
     * @param {number} _index
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    addChildAt(_child, _index) {
      throw new Error(
        "RenderLayer.addChildAt() is not available"
      );
    }
    /**
     * This method is not available in RenderLayer.
     *
     * Calling this method will throw an error.
     * @param {Container} _child
     * @param {Container} _child2
     * @ignore
     */
    swapChildren(_child, _child2) {
      throw new Error(
        "RenderLayer.swapChildren() is not available"
      );
    }
    /**
     * This method is not available in RenderLayer.
     *
     * Calling this method will throw an error.
     * @param _child - The child to reparent
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    reparentChild(..._child) {
      throw new Error("RenderLayer.reparentChild() is not available with the render layer");
    }
    /**
     * This method is not available in RenderLayer.
     *
     * Calling this method will throw an error.
     * @param _child - The child to reparent
     * @param _index - The index to reparent the child to
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    reparentChildAt(_child, _index) {
      throw new Error("RenderLayer.reparentChildAt() is not available with the render layer");
    }
  };
  _RenderLayer.defaultOptions = {
    /** If true, layer children will be automatically sorted each render. Default is false. */
    sortableChildren: false,
    /**
     * Function used to sort layer children.
     * Default sorts by zIndex. Accepts two Container objects and returns
     * a number indicating their relative order.
     * @param a - First container to compare
     * @param b - Second container to compare
     * @returns Negative if a should render before b, positive if b should render before a
     */
    sortFunction: (a2, b2) => a2.zIndex - b2.zIndex
  };
  var RenderLayer = _RenderLayer;

  // node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.mjs
  init_Texture();
  init_definedProps();

  // node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs
  init_PlaneGeometry();

  // node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs
  function applyProjectiveTransformationToPlane(width, height, geometry, transformationMatrix) {
    const buffer = geometry.buffers[0];
    const vertices = buffer.data;
    const { verticesX, verticesY } = geometry;
    const sizeX = width / (verticesX - 1);
    const sizeY = height / (verticesY - 1);
    let index = 0;
    const a00 = transformationMatrix[0];
    const a01 = transformationMatrix[1];
    const a02 = transformationMatrix[2];
    const a10 = transformationMatrix[3];
    const a11 = transformationMatrix[4];
    const a12 = transformationMatrix[5];
    const a20 = transformationMatrix[6];
    const a21 = transformationMatrix[7];
    const a22 = transformationMatrix[8];
    for (let i3 = 0; i3 < vertices.length; i3 += 2) {
      const x2 = index % verticesX * sizeX;
      const y2 = (index / verticesX | 0) * sizeY;
      const newX = a00 * x2 + a01 * y2 + a02;
      const newY = a10 * x2 + a11 * y2 + a12;
      const w2 = a20 * x2 + a21 * y2 + a22;
      vertices[i3] = newX / w2;
      vertices[i3 + 1] = newY / w2;
      index++;
    }
    buffer.update();
  }

  // node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs
  function computeAdjugate(out2, matrix) {
    const a00 = matrix[0];
    const a01 = matrix[1];
    const a02 = matrix[2];
    const a10 = matrix[3];
    const a11 = matrix[4];
    const a12 = matrix[5];
    const a20 = matrix[6];
    const a21 = matrix[7];
    const a22 = matrix[8];
    out2[0] = a11 * a22 - a12 * a21;
    out2[1] = a02 * a21 - a01 * a22;
    out2[2] = a01 * a12 - a02 * a11;
    out2[3] = a12 * a20 - a10 * a22;
    out2[4] = a00 * a22 - a02 * a20;
    out2[5] = a02 * a10 - a00 * a12;
    out2[6] = a10 * a21 - a11 * a20;
    out2[7] = a01 * a20 - a00 * a21;
    out2[8] = a00 * a11 - a01 * a10;
    return out2;
  }
  function multiplyMatrix3x3(out2, a2, b2) {
    const a00 = a2[0];
    const a01 = a2[1];
    const a02 = a2[2];
    const a10 = a2[3];
    const a11 = a2[4];
    const a12 = a2[5];
    const a20 = a2[6];
    const a21 = a2[7];
    const a22 = a2[8];
    const b00 = b2[0];
    const b01 = b2[1];
    const b02 = b2[2];
    const b10 = b2[3];
    const b11 = b2[4];
    const b12 = b2[5];
    const b20 = b2[6];
    const b21 = b2[7];
    const b22 = b2[8];
    out2[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out2[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out2[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out2[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out2[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out2[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out2[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out2[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out2[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out2;
  }
  function multiplyMatrixAndVector(out2, m2, v2) {
    const x2 = v2[0];
    const y2 = v2[1];
    const z = v2[2];
    out2[0] = m2[0] * x2 + m2[1] * y2 + m2[2] * z;
    out2[1] = m2[3] * x2 + m2[4] * y2 + m2[5] * z;
    out2[2] = m2[6] * x2 + m2[7] * y2 + m2[8] * z;
    return out2;
  }
  var tempMatrix7 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  var tempVec = [0, 0, 0];
  var tempVec2 = [0, 0, 0];
  function generateBasisToPointsMatrix(out2, x1, y1, x2, y2, x3, y3, x4, y4) {
    const m2 = tempMatrix7;
    m2[0] = x1;
    m2[1] = x2;
    m2[2] = x3;
    m2[3] = y1;
    m2[4] = y2;
    m2[5] = y3;
    m2[6] = 1;
    m2[7] = 1;
    m2[8] = 1;
    const adjugateM = computeAdjugate(
      out2,
      // reusing out as adjugateM is only used once
      m2
    );
    tempVec2[0] = x4;
    tempVec2[1] = y4;
    tempVec2[2] = 1;
    const v2 = multiplyMatrixAndVector(
      tempVec,
      adjugateM,
      tempVec2
    );
    const diagonalMatrix = out2;
    out2[0] = v2[0];
    out2[1] = 0;
    out2[2] = 0;
    out2[3] = 0;
    out2[4] = v2[1];
    out2[5] = 0;
    out2[6] = 0;
    out2[7] = 0;
    out2[8] = v2[2];
    return multiplyMatrix3x3(out2, diagonalMatrix, m2);
  }
  var tempSourceMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  var tempDestinationMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  function compute2DProjection(out2, x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d, x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {
    const sourceMatrix = generateBasisToPointsMatrix(
      tempSourceMatrix,
      x1s,
      y1s,
      x2s,
      y2s,
      x3s,
      y3s,
      x4s,
      y4s
    );
    const destinationMatrix = generateBasisToPointsMatrix(
      tempDestinationMatrix,
      x1d,
      y1d,
      x2d,
      y2d,
      x3d,
      y3d,
      x4d,
      y4d
    );
    return multiplyMatrix3x3(
      out2,
      computeAdjugate(sourceMatrix, sourceMatrix),
      destinationMatrix
    );
  }

  // node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs
  var PerspectivePlaneGeometry = class extends PlaneGeometry {
    /**
     * @param options - Options to be applied to MeshPlane
     * @param options.width - The width of the plane
     * @param options.height - The height of the plane
     * @param options.verticesX - The amount of vertices on the x axis
     * @param options.verticesY - The amount of vertices on the y axis
     */
    constructor(options) {
      super(options);
      this._projectionMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      const { width, height } = options;
      this.corners = [0, 0, width, 0, width, height, 0, height];
    }
    /**
     * Will set the corners of the quad to the given coordinates
     * Calculating the perspective so it looks correct!
     * @param x0 - x coordinate of the first corner
     * @param y0 - y coordinate of the first corner
     * @param x1 - x coordinate of the second corner
     * @param y1 - y coordinate of the second corner
     * @param x2 - x coordinate of the third corner
     * @param y2 - y coordinate of the third corner
     * @param x3 - x coordinate of the fourth corner
     * @param y3 - y coordinate of the fourth corner
     */
    setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
      const corners = this.corners;
      corners[0] = x0;
      corners[1] = y0;
      corners[2] = x1;
      corners[3] = y1;
      corners[4] = x2;
      corners[5] = y2;
      corners[6] = x3;
      corners[7] = y3;
      this.updateProjection();
    }
    /** Update the projection matrix based on the corners */
    updateProjection() {
      const { width, height } = this;
      const corners = this.corners;
      const projectionMatrix = compute2DProjection(
        this._projectionMatrix,
        0,
        0,
        // top-left source
        corners[0],
        corners[1],
        // top-left dest
        width,
        0,
        // top-right source
        corners[2],
        corners[3],
        // top-right dest
        width,
        height,
        // bottom-right source
        corners[4],
        corners[5],
        // bottom-right dest
        0,
        height,
        // bottom-left source
        corners[6],
        corners[7]
        // bottom-left dest
      );
      applyProjectiveTransformationToPlane(
        width,
        height,
        this,
        projectionMatrix
      );
    }
  };

  // node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.mjs
  var _PerspectiveMesh = class _PerspectiveMesh2 extends Mesh {
    /**
     * @param options - Options to be applied to PerspectiveMesh
     */
    constructor(options) {
      options = __spreadValues(__spreadValues({}, _PerspectiveMesh2.defaultOptions), options);
      const _a2 = options, { texture, verticesX, verticesY } = _a2, rest = __objRest(_a2, ["texture", "verticesX", "verticesY"]);
      const planeGeometry = new PerspectivePlaneGeometry(definedProps({
        width: texture.width,
        height: texture.height,
        verticesX,
        verticesY
      }));
      super(definedProps(__spreadProps(__spreadValues({}, rest), { geometry: planeGeometry })));
      this._texture = texture;
      this.geometry.setCorners(
        options.x0,
        options.y0,
        options.x1,
        options.y1,
        options.x2,
        options.y2,
        options.x3,
        options.y3
      );
    }
    /** Update the geometry when the texture is updated */
    textureUpdated() {
      const geometry = this.geometry;
      if (!geometry)
        return;
      const { width, height } = this.texture;
      if (geometry.width !== width || geometry.height !== height) {
        geometry.width = width;
        geometry.height = height;
        geometry.updateProjection();
      }
    }
    set texture(value) {
      if (this._texture === value)
        return;
      super.texture = value;
      this.textureUpdated();
    }
    /**
     * The texture that the mesh uses for rendering. When changed, automatically updates
     * the geometry to match the new texture dimensions.
     * @example
     * ```ts
     * const mesh = new PerspectiveMesh({
     *     texture: Texture.from('initial.png'),
     * });
     *
     * // Update texture and maintain perspective
     * mesh.texture = Texture.from('newImage.png');
     * ```
     * @see {@link Texture} For texture creation and management
     * @see {@link PerspectiveMesh#setCorners} For adjusting the mesh perspective
     */
    get texture() {
      return this._texture;
    }
    /**
     * Sets the corners of the mesh to create a perspective transformation. The corners should be
     * specified in clockwise order starting from the top-left.
     *
     * The mesh automatically recalculates the UV coordinates to create the perspective effect.
     * @example
     * ```ts
     * const mesh = new PerspectiveMesh({
     *     texture: Texture.from('myImage.png'),
     * });
     *
     * // Create a basic perspective tilt
     * mesh.setCorners(
     *     0, 0,      // Top-left
     *     100, 20,   // Top-right (raised)
     *     100, 100,  // Bottom-right
     *     0, 80      // Bottom-left
     * );
     *
     * // Create a skewed billboard effect
     * mesh.setCorners(
     *     0, 30,     // Top-left (shifted down)
     *     128, 0,    // Top-right (raised)
     *     128, 128,  // Bottom-right
     *     0, 98      // Bottom-left (shifted up)
     * );
     *
     * // Animate perspective
     * app.ticker.add((delta) => {
     *     const time = performance.now() / 1000;
     *     const wave = Math.sin(time) * 20;
     *
     *     mesh.setCorners(
     *         0, wave,      // Top-left
     *         100, -wave,   // Top-right
     *         100, 100,     // Bottom-right
     *         0, 100        // Bottom-left
     *     );
     * });
     * ```
     * @param x0 - x-coordinate of the top-left corner
     * @param y0 - y-coordinate of the top-left corner
     * @param x1 - x-coordinate of the top-right corner
     * @param y1 - y-coordinate of the top-right corner
     * @param x2 - x-coordinate of the bottom-right corner
     * @param y2 - y-coordinate of the bottom-right corner
     * @param x3 - x-coordinate of the bottom-left corner
     * @param y3 - y-coordinate of the bottom-left corner
     * @returns The PerspectiveMesh instance for method chaining
     * @see {@link PerspectivePlaneGeometry} For the underlying geometry calculations
     */
    setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
      this.geometry.setCorners(x0, y0, x1, y1, x2, y2, x3, y3);
    }
  };
  _PerspectiveMesh.defaultOptions = {
    texture: Texture.WHITE,
    verticesX: 10,
    verticesY: 10,
    x0: 0,
    y0: 0,
    x1: 100,
    y1: 0,
    x2: 100,
    y2: 100,
    x3: 0,
    y3: 100
  };
  var PerspectiveMesh = _PerspectiveMesh;

  // node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.mjs
  init_definedProps();
  init_PlaneGeometry();
  var MeshPlane = class extends Mesh {
    /**
     * @param options - Options to be applied to MeshPlane
     */
    constructor(options) {
      const _a2 = options, { texture, verticesX, verticesY } = _a2, rest = __objRest(_a2, ["texture", "verticesX", "verticesY"]);
      const planeGeometry = new PlaneGeometry(definedProps({
        width: texture.width,
        height: texture.height,
        verticesX,
        verticesY
      }));
      super(definedProps(__spreadProps(__spreadValues({}, rest), { geometry: planeGeometry, texture })));
      this.texture = texture;
      this.autoResize = true;
    }
    /**
     * Method used for overrides, to do something in case texture frame was changed.
     * Meshes based on plane can override it and change more details based on texture.
     * @internal
     */
    textureUpdated() {
      const geometry = this.geometry;
      const { width, height } = this.texture;
      if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
        geometry.width = width;
        geometry.height = height;
        geometry.build({});
      }
    }
    set texture(value) {
      var _a2;
      (_a2 = this._texture) == null ? void 0 : _a2.off("update", this.textureUpdated, this);
      super.texture = value;
      value.on("update", this.textureUpdated, this);
      this.textureUpdated();
    }
    /**
     * The texture that the mesh plane uses for rendering. When changed, automatically updates
     * geometry dimensions if autoResize is true and manages texture update event listeners.
     * @example
     * ```ts
     * const plane = new MeshPlane({
     *     texture: Assets.get('initial.png'),
     *     verticesX: 10,
     *     verticesY: 10
     * });
     *
     * // Update texture and auto-resize geometry
     * plane.texture = Assets.get('larger.png');
     * ```
     * @see {@link MeshPlane#autoResize} For controlling automatic geometry updates
     * @see {@link PlaneGeometry} For manual geometry updates
     * @see {@link Texture} For texture creation and management
     */
    get texture() {
      return this._texture;
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @example
     * meshPlane.destroy();
     * meshPlane.destroy(true);
     * meshPlane.destroy({ texture: true, textureSource: true });
     */
    destroy(options) {
      this.texture.off("update", this.textureUpdated, this);
      super.destroy(options);
    }
  };

  // node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.mjs
  init_definedProps();

  // node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs
  init_MeshGeometry();
  var _RopeGeometry = class _RopeGeometry2 extends MeshGeometry {
    /**
     * @param options - Options to be applied to rope geometry
     */
    constructor(options) {
      const { width, points, textureScale } = __spreadValues(__spreadValues({}, _RopeGeometry2.defaultOptions), options);
      super({
        positions: new Float32Array(points.length * 4),
        uvs: new Float32Array(points.length * 4),
        indices: new Uint32Array((points.length - 1) * 6)
      });
      this.points = points;
      this._width = width;
      this.textureScale = textureScale;
      this._build();
    }
    /**
     * The width (i.e., thickness) of the rope.
     * @readonly
     */
    get width() {
      return this._width;
    }
    /** Refreshes Rope indices and uvs */
    _build() {
      const points = this.points;
      if (!points)
        return;
      const vertexBuffer = this.getBuffer("aPosition");
      const uvBuffer = this.getBuffer("aUV");
      const indexBuffer = this.getIndex();
      if (points.length < 1) {
        return;
      }
      if (vertexBuffer.data.length / 4 !== points.length) {
        vertexBuffer.data = new Float32Array(points.length * 4);
        uvBuffer.data = new Float32Array(points.length * 4);
        indexBuffer.data = new Uint16Array((points.length - 1) * 6);
      }
      const uvs = uvBuffer.data;
      const indices = indexBuffer.data;
      uvs[0] = 0;
      uvs[1] = 0;
      uvs[2] = 0;
      uvs[3] = 1;
      let amount = 0;
      let prev = points[0];
      const textureWidth = this._width * this.textureScale;
      const total = points.length;
      for (let i3 = 0; i3 < total; i3++) {
        const index = i3 * 4;
        if (this.textureScale > 0) {
          const dx = prev.x - points[i3].x;
          const dy = prev.y - points[i3].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          prev = points[i3];
          amount += distance / textureWidth;
        } else {
          amount = i3 / (total - 1);
        }
        uvs[index] = amount;
        uvs[index + 1] = 0;
        uvs[index + 2] = amount;
        uvs[index + 3] = 1;
      }
      let indexCount = 0;
      for (let i3 = 0; i3 < total - 1; i3++) {
        const index = i3 * 2;
        indices[indexCount++] = index;
        indices[indexCount++] = index + 1;
        indices[indexCount++] = index + 2;
        indices[indexCount++] = index + 2;
        indices[indexCount++] = index + 1;
        indices[indexCount++] = index + 3;
      }
      uvBuffer.update();
      indexBuffer.update();
      this.updateVertices();
    }
    /** refreshes vertices of Rope mesh */
    updateVertices() {
      const points = this.points;
      if (points.length < 1) {
        return;
      }
      let lastPoint = points[0];
      let nextPoint;
      let perpX = 0;
      let perpY = 0;
      const vertices = this.buffers[0].data;
      const total = points.length;
      const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
      for (let i3 = 0; i3 < total; i3++) {
        const point = points[i3];
        const index = i3 * 4;
        if (i3 < points.length - 1) {
          nextPoint = points[i3 + 1];
        } else {
          nextPoint = point;
        }
        perpY = -(nextPoint.x - lastPoint.x);
        perpX = nextPoint.y - lastPoint.y;
        let ratio = (1 - i3 / (total - 1)) * 10;
        if (ratio > 1) {
          ratio = 1;
        }
        const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        if (perpLength < 1e-6) {
          perpX = 0;
          perpY = 0;
        } else {
          perpX /= perpLength;
          perpY /= perpLength;
          perpX *= halfWidth;
          perpY *= halfWidth;
        }
        vertices[index] = point.x + perpX;
        vertices[index + 1] = point.y + perpY;
        vertices[index + 2] = point.x - perpX;
        vertices[index + 3] = point.y - perpY;
        lastPoint = point;
      }
      this.buffers[0].update();
    }
    /** Refreshes Rope indices and uvs */
    update() {
      if (this.textureScale > 0) {
        this._build();
      } else {
        this.updateVertices();
      }
    }
  };
  _RopeGeometry.defaultOptions = {
    /** The width (i.e., thickness) of the rope. */
    width: 200,
    /** An array of points that determine the rope. */
    points: [],
    /** Rope texture scale, if zero then the rope texture is stretched. */
    textureScale: 0
  };
  var RopeGeometry = _RopeGeometry;

  // node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.mjs
  var _MeshRope = class _MeshRope2 extends Mesh {
    /**
     * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.
     * @param options
     * @param options.texture - The texture to use on the rope.
     * @param options.points - An array of {@link math.Point} objects to construct this rope.
     * @param {number} options.textureScale - Optional. Positive values scale rope texture
     * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture
     * and downsampling here. If set to zero, texture will be stretched instead.
     */
    constructor(options) {
      const _a2 = __spreadValues(__spreadValues({}, _MeshRope2.defaultOptions), options), { texture, points, textureScale } = _a2, rest = __objRest(_a2, ["texture", "points", "textureScale"]);
      const ropeGeometry = new RopeGeometry(definedProps({ width: texture.height, points, textureScale }));
      if (textureScale > 0) {
        texture.source.style.addressMode = "repeat";
      }
      super(definedProps(__spreadProps(__spreadValues({}, rest), {
        texture,
        geometry: ropeGeometry
      })));
      this.autoUpdate = true;
      this.onRender = this._render;
    }
    _render() {
      const geometry = this.geometry;
      if (this.autoUpdate || geometry._width !== this.texture.height) {
        geometry._width = this.texture.height;
        geometry.update();
      }
    }
  };
  _MeshRope.defaultOptions = {
    textureScale: 0
  };
  var MeshRope = _MeshRope;

  // node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.mjs
  init_definedProps();
  init_MeshGeometry();
  var MeshSimple = class extends Mesh {
    /**
     * @param options - Options to be used for construction
     */
    constructor(options) {
      const _a2 = options, { texture, vertices, uvs, indices, topology } = _a2, rest = __objRest(_a2, ["texture", "vertices", "uvs", "indices", "topology"]);
      const geometry = new MeshGeometry(definedProps({
        positions: vertices,
        uvs,
        indices,
        topology
      }));
      super(definedProps(__spreadProps(__spreadValues({}, rest), {
        texture,
        geometry
      })));
      this.autoUpdate = true;
      this.onRender = this._render;
    }
    /**
     * The vertex positions of the mesh as a TypedArray. Each vertex is represented by two
     * consecutive values (x, y) in the array. Changes to these values will update the mesh's shape.
     * @example
     * ```ts
     * // Read vertex positions
     * const vertices = mesh.vertices;
     * console.log('First vertex:', vertices[0], vertices[1]);
     *
     * // Modify vertices directly
     * vertices[0] += 10;  // Move first vertex right
     * vertices[1] -= 20;  // Move first vertex up
     *
     * // Animate vertices
     * app.ticker.add(() => {
     *     const time = performance.now() / 1000;
     *     const vertices = mesh.vertices;
     *
     *     // Wave motion
     *     for (let i = 0; i < vertices.length; i += 2) {
     *         vertices[i + 1] = Math.sin(time + i * 0.5) * 20;
     *     }
     * });
     * ```
     * @see {@link MeshSimple#autoUpdate} For controlling vertex buffer updates
     * @see {@link MeshGeometry#getBuffer} For direct buffer access
     */
    get vertices() {
      return this.geometry.getBuffer("aPosition").data;
    }
    set vertices(value) {
      this.geometry.getBuffer("aPosition").data = value;
    }
    _render() {
      if (this.autoUpdate) {
        this.geometry.getBuffer("aPosition").update();
      }
    }
  };

  // node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.mjs
  function getTextureDefaultMatrix(texture, out2) {
    const { width, height } = texture.frame;
    out2.scale(1 / width, 1 / height);
    return out2;
  }

  // node_modules/pixi.js/lib/scene/particle-container/shared/Particle.mjs
  init_Color();
  init_Texture();
  init_getGlobalMixin();
  init_assignWithIgnore();
  var _Particle = class _Particle2 {
    constructor(options) {
      if (options instanceof Texture) {
        this.texture = options;
        assignWithIgnore(this, _Particle2.defaultOptions, {});
      } else {
        const combined = __spreadValues(__spreadValues({}, _Particle2.defaultOptions), options);
        assignWithIgnore(this, combined, {});
      }
    }
    /**
     * The transparency of the particle. Values range from 0 (fully transparent)
     * to 1 (fully opaque). Values outside this range are clamped.
     * @example
     * ```ts
     * // Create a semi-transparent particle
     * const particle = new Particle({
     *     texture: Texture.from('particle.png'),
     *     alpha: 0.5
     * });
     *
     * // Fade out
     * particle.alpha *= 0.9;
     *
     * // Fade in
     * particle.alpha = Math.min(particle.alpha + 0.1, 1);
     *
     * // Values are clamped to valid range
     * particle.alpha = 1.5; // Becomes 1.0
     * particle.alpha = -0.5; // Becomes 0.0
     *
     * // Animate transparency
     * app.ticker.add((delta) => {
     *     const time = performance.now() / 1000;
     *     particle.alpha = 0.5 + Math.sin(time) * 0.5; // Pulse between 0-1
     * });
     * ```
     * @default 1
     * @see {@link Particle#tint} For controlling particle color
     * @see {@link Particle#color} For the combined color and alpha value
     */
    get alpha() {
      return this._alpha;
    }
    set alpha(value) {
      this._alpha = Math.min(Math.max(value, 0), 1);
      this._updateColor();
    }
    /**
     * The tint color of the particle. Can be set using hex numbers or CSS color strings.
     * The tint is multiplied with the texture color to create the final particle color.
     * @example
     * ```ts
     * // Create a red particle
     * const particle = new Particle({
     *     texture: Texture.from('particle.png'),
     *     tint: 0xff0000
     * });
     *
     * // Use CSS color strings
     * particle.tint = '#00ff00';  // Green
     * particle.tint = 'blue';     // Blue
     *
     * // Animate tint color
     * app.ticker.add(() => {
     *     const time = performance.now() / 1000;
     *
     *     // Cycle through hues
     *     const hue = (time * 50) % 360;
     *     particle.tint = `hsl(${hue}, 100%, 50%)`;
     * });
     *
     * // Reset to white (no tint)
     * particle.tint = 0xffffff;
     * ```
     * @type {ColorSource} Hex number or CSS color string
     * @default 0xffffff
     * @see {@link Particle#alpha} For controlling transparency
     * @see {@link Particle#color} For the combined color and alpha value
     * @see {@link Color} For supported color formats
     */
    get tint() {
      return bgr2rgb(this._tint);
    }
    set tint(value) {
      this._tint = Color.shared.setValue(value != null ? value : 16777215).toBgrNumber();
      this._updateColor();
    }
    _updateColor() {
      this.color = this._tint + ((this._alpha * 255 | 0) << 24);
    }
  };
  _Particle.defaultOptions = {
    anchorX: 0,
    anchorY: 0,
    x: 0,
    y: 0,
    scaleX: 1,
    scaleY: 1,
    rotation: 0,
    tint: 16777215,
    alpha: 1
  };
  var Particle = _Particle;

  // node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.mjs
  init_Bounds();
  init_ViewContainer();

  // node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs
  var particleData = {
    vertex: {
      attributeName: "aVertex",
      format: "float32x2",
      code: `
            const texture = p.texture;
            const sx = p.scaleX;
            const sy = p.scaleY;
            const ax = p.anchorX;
            const ay = p.anchorY;
            const trim = texture.trim;
            const orig = texture.orig;

            if (trim)
            {
                w1 = trim.x - (ax * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (ay * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w1 = -ax * (orig.width);
                w0 = w1 + orig.width;

                h1 = -ay * (orig.height);
                h0 = h1 + orig.height;
            }

            f32v[offset] = w1 * sx;
            f32v[offset + 1] = h1 * sy;

            f32v[offset + stride] = w0 * sx;
            f32v[offset + stride + 1] = h1 * sy;

            f32v[offset + (stride * 2)] = w0 * sx;
            f32v[offset + (stride * 2) + 1] = h0 * sy;

            f32v[offset + (stride * 3)] = w1 * sx;
            f32v[offset + (stride * 3) + 1] = h0 * sy;
        `,
      dynamic: false
    },
    // positionData
    position: {
      attributeName: "aPosition",
      format: "float32x2",
      code: `
            var x = p.x;
            var y = p.y;

            f32v[offset] = x;
            f32v[offset + 1] = y;

            f32v[offset + stride] = x;
            f32v[offset + stride + 1] = y;

            f32v[offset + (stride * 2)] = x;
            f32v[offset + (stride * 2) + 1] = y;

            f32v[offset + (stride * 3)] = x;
            f32v[offset + (stride * 3) + 1] = y;
        `,
      dynamic: true
    },
    // rotationData
    rotation: {
      attributeName: "aRotation",
      format: "float32",
      code: `
            var rotation = p.rotation;

            f32v[offset] = rotation;
            f32v[offset + stride] = rotation;
            f32v[offset + (stride * 2)] = rotation;
            f32v[offset + (stride * 3)] = rotation;
        `,
      dynamic: false
    },
    // uvsData
    uvs: {
      attributeName: "aUV",
      format: "float32x2",
      code: `
            var uvs = p.texture.uvs;

            f32v[offset] = uvs.x0;
            f32v[offset + 1] = uvs.y0;

            f32v[offset + stride] = uvs.x1;
            f32v[offset + stride + 1] = uvs.y1;

            f32v[offset + (stride * 2)] = uvs.x2;
            f32v[offset + (stride * 2) + 1] = uvs.y2;

            f32v[offset + (stride * 3)] = uvs.x3;
            f32v[offset + (stride * 3) + 1] = uvs.y3;
        `,
      dynamic: false
    },
    // tintData
    color: {
      attributeName: "aColor",
      format: "unorm8x4",
      code: `
            const c = p.color;

            u32v[offset] = c;
            u32v[offset + stride] = c;
            u32v[offset + (stride * 2)] = c;
            u32v[offset + (stride * 3)] = c;
        `,
      dynamic: false
    }
  };

  // node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.mjs
  var emptyBounds = new Bounds(0, 0, 0, 0);
  var _ParticleContainer = class _ParticleContainer2 extends ViewContainer {
    /**
     * @param options - The options for creating the sprite.
     */
    constructor(options = {}) {
      options = __spreadProps(__spreadValues(__spreadValues({}, _ParticleContainer2.defaultOptions), options), {
        dynamicProperties: __spreadValues(__spreadValues({}, _ParticleContainer2.defaultOptions.dynamicProperties), options == null ? void 0 : options.dynamicProperties)
      });
      const _a2 = options, { dynamicProperties, shader, roundPixels, texture, particles } = _a2, rest = __objRest(_a2, ["dynamicProperties", "shader", "roundPixels", "texture", "particles"]);
      super(__spreadValues({
        label: "ParticleContainer"
      }, rest));
      this.renderPipeId = "particle";
      this.batched = false;
      this._childrenDirty = false;
      this.texture = texture || null;
      this.shader = shader;
      this._properties = {};
      for (const key in particleData) {
        const property = particleData[key];
        const dynamic = dynamicProperties[key];
        this._properties[key] = __spreadProps(__spreadValues({}, property), {
          dynamic
        });
      }
      this.allowChildren = true;
      this.roundPixels = roundPixels != null ? roundPixels : false;
      this.particleChildren = particles != null ? particles : [];
    }
    /**
     * Adds one or more particles to the container. The particles will be rendered using the container's shared texture
     * and properties. When adding multiple particles, they must all share the same base texture.
     * @example
     * ```ts
     * const container = new ParticleContainer();
     *
     * // Add a single particle
     * const particle = new Particle(Assets.get('particleTexture'));
     * container.addParticle(particle);
     *
     * // Add multiple particles at once
     * const particles = [
     *     new Particle(Assets.get('particleTexture')),
     *     new Particle(Assets.get('particleTexture')),
     *     new Particle(Assets.get('particleTexture'))
     * ];
     *
     * container.addParticle(...particles);
     * ```
     * @param children - The Particle(s) to add to the container
     * @returns The first particle that was added, for method chaining
     * @see {@link ParticleContainer#texture} For setting the shared texture
     * @see {@link ParticleContainer#update} For updating after modifications
     */
    addParticle(...children) {
      for (let i3 = 0; i3 < children.length; i3++) {
        this.particleChildren.push(children[i3]);
      }
      this.onViewUpdate();
      return children[0];
    }
    /**
     * Removes one or more particles from the container. The particles must already be children
     * of this container to be removed.
     * @example
     * ```ts
     * // Remove a single particle
     * container.removeParticle(particle1);
     *
     * // Remove multiple particles at once
     * container.removeParticle(particle2, particle3);
     * ```
     * @param children - The Particle(s) to remove from the container
     * @returns The first particle that was removed, for method chaining
     * @see {@link ParticleContainer#particleChildren} For accessing all particles
     * @see {@link ParticleContainer#removeParticles} For removing particles by index
     * @see {@link ParticleContainer#removeParticleAt} For removing a particle at a specific index
     */
    removeParticle(...children) {
      let didRemove = false;
      for (let i3 = 0; i3 < children.length; i3++) {
        const index = this.particleChildren.indexOf(children[i3]);
        if (index > -1) {
          this.particleChildren.splice(index, 1);
          didRemove = true;
        }
      }
      if (didRemove)
        this.onViewUpdate();
      return children[0];
    }
    /**
     * Updates the particle container's internal state. Call this method after manually modifying
     * the particleChildren array or when changing static properties of particles.
     * @example
     * ```ts
     * // Batch modify particles
     * container.particleChildren.push(...particles);
     * container.update(); // Required after direct array modification
     *
     * // Update static properties
     * container.particleChildren.forEach(particle => {
     *     particle.position.set(
     *         Math.random() * 800,
     *         Math.random() * 600
     *     );
     * });
     * container.update(); // Required after changing static positions
     * ```
     * @see {@link ParticleProperties} For configuring dynamic vs static properties
     * @see {@link ParticleContainer#particleChildren} For direct array access
     */
    update() {
      this._childrenDirty = true;
    }
    onViewUpdate() {
      this._childrenDirty = true;
      super.onViewUpdate();
    }
    /**
     * Returns a static empty bounds object since ParticleContainer does not calculate bounds automatically
     * for performance reasons. Use the `boundsArea` property to manually set container bounds.
     * @example
     * ```ts
     * const container = new ParticleContainer({
     *     texture: Texture.from('particle.png')
     * });
     *
     * // Default bounds are empty
     * console.log(container.bounds); // Bounds(0, 0, 0, 0)
     *
     * // Set manual bounds for the particle area
     * container.boundsArea = {
     *     minX: 0,
     *     minY: 0,
     *     maxX: 800,
     *     maxY: 600
     * };
     * ```
     * @readonly
     * @returns {Bounds} An empty bounds object (0,0,0,0)
     * @see {@link Container#boundsArea} For manually setting container bounds
     * @see {@link Bounds} For bounds object structure
     */
    get bounds() {
      return emptyBounds;
    }
    /** @private */
    updateBounds() {
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @example
     * particleContainer.destroy();
     * particleContainer.destroy(true);
     * particleContainer.destroy({ texture: true, textureSource: true, children: true });
     */
    destroy(options = false) {
      var _a2, _b, _c;
      super.destroy(options);
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        const texture = (_b = this.texture) != null ? _b : (_a2 = this.particleChildren[0]) == null ? void 0 : _a2.texture;
        if (texture) {
          texture.destroy(destroyTextureSource);
        }
      }
      this.texture = null;
      (_c = this.shader) == null ? void 0 : _c.destroy();
    }
    /**
     * Removes all particles from this container that are within the begin and end indexes.
     * @param beginIndex - The beginning position.
     * @param endIndex - The ending position. Default value is size of the container.
     * @returns - List of removed particles
     */
    removeParticles(beginIndex, endIndex) {
      beginIndex != null ? beginIndex : beginIndex = 0;
      endIndex != null ? endIndex : endIndex = this.particleChildren.length;
      const children = this.particleChildren.splice(
        beginIndex,
        endIndex - beginIndex
      );
      this.onViewUpdate();
      return children;
    }
    /**
     * Removes a particle from the specified index position.
     * @param index - The index to get the particle from
     * @returns The particle that was removed.
     */
    removeParticleAt(index) {
      const child = this.particleChildren.splice(index, 1);
      this.onViewUpdate();
      return child[0];
    }
    /**
     * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.
     * If the particle is already in this container, it will be moved to the specified index.
     * @param {Container} child - The particle to add.
     * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.
     * @returns {Container} The particle that was added.
     */
    addParticleAt(child, index) {
      this.particleChildren.splice(index, 0, child);
      this.onViewUpdate();
      return child;
    }
    /**
     * This method is not available in ParticleContainer.
     *
     * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.
     * @param {...any} _children
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    addChild(..._children) {
      throw new Error(
        "ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()"
      );
    }
    /**
     * This method is not available in ParticleContainer.
     * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.
     * @param {...any} _children
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    removeChild(..._children) {
      throw new Error(
        "ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()"
      );
    }
    /**
     * This method is not available in ParticleContainer.
     *
     * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.
     * @param {number} [_beginIndex]
     * @param {number} [_endIndex]
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    removeChildren(_beginIndex, _endIndex) {
      throw new Error(
        "ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()"
      );
    }
    /**
     * This method is not available in ParticleContainer.
     *
     * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.
     * @param {number} _index
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    removeChildAt(_index) {
      throw new Error(
        "ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()"
      );
    }
    /**
     * This method is not available in ParticleContainer.
     *
     * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.
     * @param {number} _index
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    getChildAt(_index) {
      throw new Error(
        "ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()"
      );
    }
    /**
     * This method is not available in ParticleContainer.
     *
     * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.
     * @param {ContainerChild} _child
     * @param {number} _index
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    setChildIndex(_child, _index) {
      throw new Error(
        "ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()"
      );
    }
    /**
     * This method is not available in ParticleContainer.
     *
     * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.
     * @param {ContainerChild} _child
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    getChildIndex(_child) {
      throw new Error(
        "ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()"
      );
    }
    /**
     * This method is not available in ParticleContainer.
     *
     * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.
     * @param {ContainerChild} _child
     * @param {number} _index
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    addChildAt(_child, _index) {
      throw new Error(
        "ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()"
      );
    }
    /**
     * This method is not available in ParticleContainer.
     *
     * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.
     * @param {ContainerChild} _child
     * @param {ContainerChild} _child2
     * @ignore
     */
    swapChildren(_child, _child2) {
      throw new Error(
        "ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()"
      );
    }
    /**
     * This method is not available in ParticleContainer.
     *
     * Calling this method will throw an error.
     * @param _child - The child to reparent
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    reparentChild(..._child) {
      throw new Error("ParticleContainer.reparentChild() is not available with the particle container");
    }
    /**
     * This method is not available in ParticleContainer.
     *
     * Calling this method will throw an error.
     * @param _child - The child to reparent
     * @param _index - The index to reparent the child to
     * @throws {Error} Always throws an error as this method is not available.
     * @ignore
     */
    reparentChildAt(_child, _index) {
      throw new Error("ParticleContainer.reparentChildAt() is not available with the particle container");
    }
  };
  _ParticleContainer.defaultOptions = {
    /** Specifies which properties are dynamic. */
    dynamicProperties: {
      /** Indicates if vertex positions are dynamic. */
      vertex: false,
      /** Indicates if particle positions are dynamic. */
      position: true,
      /** Indicates if particle rotations are dynamic. */
      rotation: false,
      /** Indicates if UV coordinates are dynamic. */
      uvs: false,
      /** Indicates if particle colors are dynamic. */
      color: false
    },
    /** Indicates if pixels should be rounded for rendering. */
    roundPixels: false
  };
  var ParticleContainer = _ParticleContainer;

  // node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.mjs
  init_ObservablePoint();
  init_Texture();
  init_deprecation();
  init_ViewContainer();
  init_NineSliceGeometry();
  var _NineSliceSprite = class _NineSliceSprite2 extends ViewContainer {
    constructor(options) {
      var _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (options instanceof Texture) {
        options = { texture: options };
      }
      const _a2 = options, {
        width,
        height,
        anchor,
        leftWidth,
        rightWidth,
        topHeight,
        bottomHeight,
        texture,
        roundPixels
      } = _a2, rest = __objRest(_a2, [
        "width",
        "height",
        "anchor",
        "leftWidth",
        "rightWidth",
        "topHeight",
        "bottomHeight",
        "texture",
        "roundPixels"
      ]);
      super(__spreadValues({
        label: "NineSliceSprite"
      }, rest));
      this.renderPipeId = "nineSliceSprite";
      this.batched = true;
      this._leftWidth = (_c = leftWidth != null ? leftWidth : (_b = texture == null ? void 0 : texture.defaultBorders) == null ? void 0 : _b.left) != null ? _c : NineSliceGeometry.defaultOptions.leftWidth;
      this._topHeight = (_e = topHeight != null ? topHeight : (_d = texture == null ? void 0 : texture.defaultBorders) == null ? void 0 : _d.top) != null ? _e : NineSliceGeometry.defaultOptions.topHeight;
      this._rightWidth = (_g = rightWidth != null ? rightWidth : (_f = texture == null ? void 0 : texture.defaultBorders) == null ? void 0 : _f.right) != null ? _g : NineSliceGeometry.defaultOptions.rightWidth;
      this._bottomHeight = (_i = bottomHeight != null ? bottomHeight : (_h = texture == null ? void 0 : texture.defaultBorders) == null ? void 0 : _h.bottom) != null ? _i : NineSliceGeometry.defaultOptions.bottomHeight;
      this._width = (_j = width != null ? width : texture.width) != null ? _j : NineSliceGeometry.defaultOptions.width;
      this._height = (_k = height != null ? height : texture.height) != null ? _k : NineSliceGeometry.defaultOptions.height;
      this.allowChildren = false;
      this.texture = texture != null ? texture : _NineSliceSprite2.defaultOptions.texture;
      this.roundPixels = roundPixels != null ? roundPixels : false;
      this._anchor = new ObservablePoint(
        {
          _onUpdate: () => {
            this.onViewUpdate();
          }
        }
      );
      if (anchor) {
        this.anchor = anchor;
      } else if (this.texture.defaultAnchor) {
        this.anchor = this.texture.defaultAnchor;
      }
    }
    /**
     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
     * and passed to the constructor.
     *
     * - The default is `(0,0)`, this means the sprite's origin is the top left.
     * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
     * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
     *
     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
     * @example
     * ```ts
     * // Center the anchor point
     * sprite.anchor = 0.5; // Sets both x and y to 0.5
     * sprite.position.set(400, 300); // Sprite will be centered at this position
     *
     * // Set specific x/y anchor points
     * sprite.anchor = {
     *     x: 1, // Right edge
     *     y: 0  // Top edge
     * };
     *
     * // Using individual coordinates
     * sprite.anchor.set(0.5, 1); // Center-bottom
     *
     * // For rotation around center
     * sprite.anchor.set(0.5);
     * sprite.rotation = Math.PI / 4; // 45 degrees around center
     *
     * // For scaling from center
     * sprite.anchor.set(0.5);
     * sprite.scale.set(2); // Scales from center point
     * ```
     */
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    /**
     * The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane.
     * The width affects how the middle sections are scaled.
     * @example
     * ```ts
     * // Create a nine-slice sprite with fixed width
     * const panel = new NineSliceSprite({
     *     texture: Texture.from('panel.png'),
     *     width: 200  // Sets initial width
     * });
     *
     * // Adjust width dynamically
     * panel.width = 300;  // Stretches middle sections
     * ```
     * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently
     * @see {@link NineSliceSprite#height} For setting height
     */
    get width() {
      return this._width;
    }
    set width(value) {
      this._width = value;
      this.onViewUpdate();
    }
    /**
     * The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane.
     * The height affects how the middle sections are scaled.
     * @example
     * ```ts
     * // Create a nine-slice sprite with fixed height
     * const panel = new NineSliceSprite({
     *     texture: Texture.from('panel.png'),
     *     height: 150  // Sets initial height
     * });
     *
     * // Adjust height dynamically
     * panel.height = 200;  // Stretches middle sections
     *
     * // Create responsive UI element
     * const dialog = new NineSliceSprite({
     *     texture: Texture.from('dialog.png'),
     *     topHeight: 30,
     *     bottomHeight: 30,
     *     height: parent.height * 0.5  // 50% of parent height
     * });
     * ```
     * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently
     * @see {@link NineSliceSprite#width} For setting width
     */
    get height() {
      return this._height;
    }
    set height(value) {
      this._height = value;
      this.onViewUpdate();
    }
    /**
     * Sets the size of the NineSliceSprite to the specified width and height.
     * This method directly modifies the vertices and UV coordinates of the sprite.
     *
     * Using this is more efficient than setting width and height separately as it only triggers one update.
     * @example
     * ```ts
     * // Set to specific dimensions
     * panel.setSize(300, 200); // Width: 300, Height: 200
     *
     * // Set uniform size
     * panel.setSize(200); // Makes a square 200x200
     *
     * // Set size using object
     * panel.setSize({
     *     width: 400,
     *     height: 300
     * });
     * ```
     * @param value - This can be either a number or a Size object with width/height properties
     * @param height - The height to set. Defaults to the value of `width` if not provided
     * @see {@link NineSliceSprite#width} For setting width only
     * @see {@link NineSliceSprite#height} For setting height only
     */
    setSize(value, height) {
      var _a2;
      if (typeof value === "object") {
        height = (_a2 = value.height) != null ? _a2 : value.width;
        value = value.width;
      }
      this._width = value;
      this._height = height != null ? height : value;
      this.onViewUpdate();
    }
    /**
     * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.
     * This method is more efficient than getting width and height separately.
     * @example
     * ```ts
     * // Get basic size
     * const size = panel.getSize();
     * console.log(`Size: ${size.width}x${size.height}`);
     *
     * // Reuse existing size object
     * const reuseSize = { width: 0, height: 0 };
     * panel.getSize(reuseSize);
     * ```
     * @param out - Optional object to store the size in, to avoid allocating a new object
     * @returns The size of the NineSliceSprite
     * @see {@link NineSliceSprite#width} For getting just the width
     * @see {@link NineSliceSprite#height} For getting just the height
     * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently
     */
    getSize(out2) {
      out2 || (out2 = {});
      out2.width = this._width;
      out2.height = this._height;
      return out2;
    }
    /**
     * Width of the left vertical bar (A).
     * Controls the size of the left edge that remains unscaled
     * @example
     * ```ts
     * const sprite = new NineSliceSprite({ ..., leftWidth: 20 });
     * sprite.leftWidth = 20; // Set left border width
     * ```
     * @default 10
     */
    get leftWidth() {
      return this._leftWidth;
    }
    set leftWidth(value) {
      this._leftWidth = value;
      this.onViewUpdate();
    }
    /**
     * Height of the top horizontal bar (C).
     * Controls the size of the top edge that remains unscaled
     * @example
     * ```ts
     * const sprite = new NineSliceSprite({ ..., topHeight: 20 });
     * sprite.topHeight = 20; // Set top border height
     * ```
     * @default 10
     */
    get topHeight() {
      return this._topHeight;
    }
    set topHeight(value) {
      this._topHeight = value;
      this.onViewUpdate();
    }
    /**
     * Width of the right vertical bar (B).
     * Controls the size of the right edge that remains unscaled
     * @example
     * ```ts
     * const sprite = new NineSliceSprite({ ..., rightWidth: 20 });
     * sprite.rightWidth = 20; // Set right border width
     * ```
     * @default 10
     */
    get rightWidth() {
      return this._rightWidth;
    }
    set rightWidth(value) {
      this._rightWidth = value;
      this.onViewUpdate();
    }
    /**
     * Height of the bottom horizontal bar (D).
     * Controls the size of the bottom edge that remains unscaled
     * @example
     * ```ts
     * const sprite = new NineSliceSprite({ ..., bottomHeight: 20 });
     * sprite.bottomHeight = 20; // Set bottom border height
     * ```
     * @default 10
     */
    get bottomHeight() {
      return this._bottomHeight;
    }
    set bottomHeight(value) {
      this._bottomHeight = value;
      this.onViewUpdate();
    }
    /**
     * The texture to use on the NineSliceSprite.
     * ```ts
     * // Create a sprite with a texture
     * const sprite = new NineSliceSprite({
     *     texture: Texture.from('path/to/image.png')
     * });
     * // Update the texture later
     * sprite.texture = Texture.from('path/to/another-image.png');
     * ```
     * @default Texture.EMPTY
     */
    get texture() {
      return this._texture;
    }
    set texture(value) {
      value || (value = Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture === value)
        return;
      if (currentTexture && currentTexture.dynamic)
        currentTexture.off("update", this.onViewUpdate, this);
      if (value.dynamic)
        value.on("update", this.onViewUpdate, this);
      this._texture = value;
      this.onViewUpdate();
    }
    /**
     * The original width of the texture before any nine-slice scaling.
     * This is the width of the source texture used to create the nine-slice sprite.
     * @example
     * ```ts
     * // Get original dimensions
     * console.log(`Original size: ${sprite.originalWidth}x${sprite.originalHeight}`);
     *
     * // Use for relative scaling
     * sprite.width = sprite.originalWidth * 2; // Double the original width
     *
     * // Reset to original size
     * sprite.setSize(sprite.originalWidth, sprite.originalHeight);
     * ```
     * @readonly
     * @see {@link NineSliceSprite#width} For the current displayed width
     * @see {@link Texture#width} For direct texture width access
     * @returns The original width of the texture
     */
    get originalWidth() {
      return this._texture.width;
    }
    /**
     * The original height of the texture before any nine-slice scaling.
     * This is the height of the source texture used to create the nine-slice sprite.
     * @example
     * ```ts
     * // Get original dimensions
     * console.log(`Original size: ${sprite.originalWidth}x${sprite.originalHeight}`);
     *
     * // Use for relative scaling
     * sprite.height = sprite.originalHeight * 2; // Double the original height
     *
     * // Reset to original size
     * sprite.setSize(sprite.originalWidth, sprite.originalHeight);
     * ```
     * @readonly
     * @see {@link NineSliceSprite#height} For the current displayed height
     * @see {@link Texture#height} For direct texture height access
     * @returns The original height of the texture
     */
    get originalHeight() {
      return this._texture.height;
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @example
     * nineSliceSprite.destroy();
     * nineSliceSprite.destroy(true);
     * nineSliceSprite.destroy({ texture: true, textureSource: true });
     */
    destroy(options) {
      super.destroy(options);
      const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
        this._texture.destroy(destroyTextureSource);
      }
      this._texture = null;
    }
    /** @private */
    updateBounds() {
      const bounds = this._bounds;
      const anchor = this._anchor;
      const width = this._width;
      const height = this._height;
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
  };
  _NineSliceSprite.defaultOptions = {
    /** @default Texture.EMPTY */
    texture: Texture.EMPTY
  };
  var NineSliceSprite = _NineSliceSprite;
  var NineSlicePlane = class extends NineSliceSprite {
    constructor(...args) {
      let options = args[0];
      if (options instanceof Texture) {
        deprecation(v8_0_0, "NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}");
        options = {
          texture: options,
          leftWidth: args[1],
          topHeight: args[2],
          rightWidth: args[3],
          bottomHeight: args[4]
        };
      }
      deprecation(v8_0_0, "NineSlicePlane is deprecated. Use NineSliceSprite instead.");
      super(options);
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/utils/bitmapTextSplit.mjs
  init_Container();
  init_CanvasTextMetrics();
  init_BitmapFontManager();
  init_getBitmapTextLayout();
  function bitmapTextSplit(options) {
    const { text, style, chars: existingChars } = options;
    const textStyle = style;
    const font = BitmapFontManager.getFont(text, textStyle);
    const segments = CanvasTextMetrics.graphemeSegmenter(text);
    const layout = getBitmapTextLayout(segments, textStyle, font, true);
    const scale = layout.scale;
    const chars = [];
    const words = [];
    const lines = [];
    const lineHeight = style.lineHeight ? style.lineHeight : font.lineHeight * scale;
    let yOffset = 0;
    for (const line of layout.lines) {
      if (line.chars.length === 0)
        continue;
      const lineContainer = new Container({ label: "line" });
      lineContainer.y = yOffset;
      lines.push(lineContainer);
      let currentWordContainer = new Container({ label: "word" });
      let currentWordStartIndex = 0;
      for (let i3 = 0; i3 < line.chars.length; i3++) {
        const char = line.chars[i3];
        if (!char)
          continue;
        const charData = font.chars[char];
        if (!charData)
          continue;
        const isSpace = char === " ";
        const isLastChar = i3 === line.chars.length - 1;
        let charInstance;
        if (existingChars.length > 0) {
          charInstance = existingChars.shift();
          charInstance.text = char;
          charInstance.style = textStyle;
          charInstance.label = `char-${char}`;
          charInstance.x = line.charPositions[i3] * scale - line.charPositions[currentWordStartIndex] * scale;
        } else {
          charInstance = new BitmapText({
            text: char,
            style: textStyle,
            label: `char-${char}`,
            x: line.charPositions[i3] * scale - line.charPositions[currentWordStartIndex] * scale
          });
        }
        if (!isSpace) {
          chars.push(charInstance);
          currentWordContainer.addChild(charInstance);
        }
        if (isSpace || isLastChar) {
          if (currentWordContainer.children.length > 0) {
            currentWordContainer.x = line.charPositions[currentWordStartIndex] * scale;
            words.push(currentWordContainer);
            lineContainer.addChild(currentWordContainer);
            currentWordContainer = new Container({ label: "word" });
            currentWordStartIndex = i3 + 1;
          }
        }
      }
      yOffset += lineHeight;
    }
    return { chars, lines, words };
  }

  // node_modules/pixi.js/lib/scene/text-split/AbstractSplitText.mjs
  init_Container();
  init_TextStyle();
  var AbstractSplitText = class extends Container {
    constructor(config3) {
      const _a2 = config3, {
        text,
        style,
        autoSplit,
        lineAnchor,
        wordAnchor,
        charAnchor
      } = _a2, options = __objRest(_a2, [
        "text",
        "style",
        "autoSplit",
        "lineAnchor",
        "wordAnchor",
        "charAnchor"
      ]);
      super(options);
      this._dirty = false;
      this._canReuseChars = false;
      this.chars = [];
      this.words = [];
      this.lines = [];
      this._originalText = text;
      this._autoSplit = autoSplit;
      this._lineAnchor = lineAnchor;
      this._wordAnchor = wordAnchor;
      this._charAnchor = charAnchor;
      this.style = style;
    }
    /**
     * Splits the text into lines, words, and characters.
     * Call this manually when autoSplit is false.
     * @example Manual Splitting
     * ```ts
     * const text = new SplitText({
     *   text: 'Manual Update',
     *   autoSplit: false
     * });
     *
     * text.text = 'New Content';
     * text.style = { fontSize: 32 };
     * text.split(); // Apply changes
     * ```
     */
    split() {
      const res = this.splitFn();
      this.chars = res.chars;
      this.words = res.words;
      this.lines = res.lines;
      this.addChild(...this.lines);
      this.charAnchor = this._charAnchor;
      this.wordAnchor = this._wordAnchor;
      this.lineAnchor = this._lineAnchor;
      this._dirty = false;
      this._canReuseChars = true;
    }
    get text() {
      return this._originalText;
    }
    /**
     * Gets or sets the text content.
     * Setting new text triggers splitting if autoSplit is true.
     * > [!NOTE] Setting this frequently can have a performance impact, especially with large texts and canvas text.
     * @example Dynamic Text Updates
     * ```ts
     * const text = new SplitText({
     *   text: 'Original',
     *   autoSplit: true
     * });
     *
     * // Auto-splits on change
     * text.text = 'Updated Content';
     *
     * // Manual update
     * text.autoSplit = false;
     * text.text = 'Manual Update';
     * text.split();
     * ```
     */
    set text(value) {
      this._originalText = value;
      this.lines.forEach((line) => line.destroy({ children: true }));
      this.lines.length = 0;
      this.words.length = 0;
      this.chars.length = 0;
      this._canReuseChars = false;
      this.onTextUpdate();
    }
    _setOrigin(value, elements, property) {
      let originPoint;
      if (typeof value === "number") {
        originPoint = { x: value, y: value };
      } else {
        originPoint = { x: value.x, y: value.y };
      }
      elements.forEach((element) => {
        const localBounds = element.getLocalBounds();
        const originX = localBounds.minX + localBounds.width * originPoint.x;
        const originY = localBounds.minY + localBounds.height * originPoint.y;
        element.origin.set(originX, originY);
      });
      this[property] = value;
    }
    /**
     * Gets or sets the transform anchor for line segments.
     * The anchor point determines the center of rotation and scaling for each line.
     * @example Setting Line Anchors
     * ```ts
     * // Center rotation/scaling
     * text.lineAnchor = 0.5;
     *
     * // Rotate/scale from top-right corner
     * text.lineAnchor = { x: 1, y: 0 };
     *
     * // Custom anchor point
     * text.lineAnchor = {
     *   x: 0.2, // 20% from left
     *   y: 0.8  // 80% from top
     * };
     * ```
     */
    get lineAnchor() {
      return this._lineAnchor;
    }
    set lineAnchor(value) {
      this._setOrigin(value, this.lines, "_lineAnchor");
    }
    /**
     * Gets or sets the transform anchor for word segments.
     * The anchor point determines the center of rotation and scaling for each word.
     * @example
     * ```ts
     * // Center each word
     * text.wordAnchor = 0.5;
     *
     * // Scale from bottom-left
     * text.wordAnchor = { x: 0, y: 1 };
     *
     * // Rotate around custom point
     * text.wordAnchor = {
     *   x: 0.75,  // 75% from left
     *   y: 0.5    // Middle vertically
     * };
     * ```
     */
    get wordAnchor() {
      return this._wordAnchor;
    }
    set wordAnchor(value) {
      this._setOrigin(value, this.words, "_wordAnchor");
    }
    /**
     * Gets or sets the transform anchor for character segments.
     * The anchor point determines the center of rotation and scaling for each character.
     * @example Setting Character Anchors
     * ```ts
     * // Center each character
     * text.charAnchor = 0.5;
     *
     * // Rotate from top-center
     * text.charAnchor = { x: 0.5, y: 0 };
     *
     * // Scale from bottom-right
     * text.charAnchor = { x: 1, y: 1 };
     * ```
     * @example Animation with Anchors
     * ```ts
     * // Rotate characters around their centers
     * text.charAnchor = 0.5;
     * text.chars.forEach((char, i) => {
     *   gsap.to(char, {
     *     rotation: Math.PI * 2,
     *     duration: 1,
     *     delay: i * 0.1,
     *     repeat: -1
     *   });
     * });
     * ```
     */
    get charAnchor() {
      return this._charAnchor;
    }
    set charAnchor(value) {
      this._setOrigin(value, this.chars, "_charAnchor");
    }
    get style() {
      return this._style;
    }
    /**
     * The style configuration for the text.
     * Can be a TextStyle instance or a configuration object.
     * @example
     * ```ts
     * const text = new Text({
     *     text: 'Styled Text',
     *     style: {
     *         fontSize: 24,
     *         fill: 0xff1010, // Red color
     *         fontFamily: 'Arial',
     *         align: 'center', // Center alignment
     *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke
     *         dropShadow: {
     *             color: '#000000', // Black shadow
     *             blur: 4, // Shadow blur
     *             distance: 6 // Shadow distance
     *         }
     *     }
     * });
     * // Update style dynamically
     * text.style = {
     *     fontSize: 30, // Change font size
     *     fill: 0x00ff00, // Change color to green
     *     align: 'right', // Change alignment to right
     *     stroke: { color: '#000000', width: 2 }, // Add black stroke
     * }
     */
    set style(style) {
      style || (style = {});
      this._style = new TextStyle(style);
      this.words.forEach((word) => word.destroy());
      this.words.length = 0;
      this.lines.forEach((line) => line.destroy());
      this.lines.length = 0;
      this._canReuseChars = true;
      this.onTextUpdate();
    }
    onTextUpdate() {
      this._dirty = true;
      if (this._autoSplit) {
        this.split();
      }
    }
    /**
     * Destroys the SplitText instance and all its resources.
     * Cleans up all segment arrays, event listeners, and optionally the text style.
     * @param options - Destroy configuration options
     * @example
     * ```ts
     * // Clean up everything
     * text.destroy({ children: true, texture: true, style: true });
     *
     * // Remove from parent but keep style
     * text.destroy({ children: true, style: false });
     * ```
     */
    destroy(options) {
      super.destroy(options);
      this.chars = [];
      this.words = [];
      this.lines = [];
      if (typeof options === "boolean" ? options : options == null ? void 0 : options.style) {
        this._style.destroy(options);
      }
      this._style = null;
      this._originalText = "";
    }
  };

  // node_modules/pixi.js/lib/scene/text-split/SplitBitmapText.mjs
  init_TextStyle();
  var _SplitBitmapText = class _SplitBitmapText2 extends AbstractSplitText {
    constructor(config3) {
      const completeOptions = __spreadValues(__spreadValues({}, _SplitBitmapText2.defaultOptions), config3);
      super(completeOptions);
    }
    /**
     * Creates a SplitBitmapText instance from an existing text object.
     * Useful for converting standard Text or BitmapText objects into segmented versions.
     * @param text - The source text object to convert
     * @param options - Additional splitting options
     * @returns A new SplitBitmapText instance
     * @example
     * ```ts
     * const bitmapText = new BitmapText({
     *   text: 'Bitmap Text',
     *   style: { fontFamily: 'Arial' }
     * });
     *
     * const segmented = SplitBitmapText.from(bitmapText);
     *
     * // with additional options
     * const segmentedWithOptions = SplitBitmapText.from(bitmapText, {
     *   autoSplit: false,
     *   lineAnchor: 0.5,
     *   wordAnchor: { x: 0, y: 0.5 },
     * })
     * ```
     */
    static from(text, options) {
      const completeOptions = __spreadProps(__spreadValues(__spreadValues({}, _SplitBitmapText2.defaultOptions), options), {
        text: text.text,
        style: new TextStyle(text.style)
      });
      return new _SplitBitmapText2(__spreadValues({}, completeOptions));
    }
    splitFn() {
      return bitmapTextSplit({
        text: this._originalText,
        style: this._style,
        chars: this._canReuseChars ? this.chars : []
      });
    }
  };
  _SplitBitmapText.defaultOptions = {
    autoSplit: true,
    // Auto-update on text/style changes
    lineAnchor: 0,
    // Top-left alignment
    wordAnchor: 0,
    // Top-left alignment
    charAnchor: 0
    // Top-left alignment
  };
  var SplitBitmapText = _SplitBitmapText;

  // node_modules/pixi.js/lib/scene/text-split/SplitText.mjs
  init_TextStyle();

  // node_modules/pixi.js/lib/scene/text/utils/canvasTextSplit.mjs
  init_Matrix();
  init_Container();
  init_CanvasTextMetrics();
  function getAlignmentOffset(alignment, lineWidth, largestLine) {
    switch (alignment) {
      case "center":
        return (largestLine - lineWidth) / 2;
      case "right":
        return largestLine - lineWidth;
      case "left":
      default:
        return 0;
    }
  }
  function isNewlineCharacter(char) {
    return char === "\r" || char === "\n" || char === "\r\n";
  }
  function groupTextSegments(segments, measuredText, textStyle) {
    const groupedSegments = [];
    let currentLine = measuredText.lines[0];
    let matchedLine = "";
    let chars = [];
    let lineCount = 0;
    textStyle.wordWrap = false;
    segments.forEach((segment) => {
      const isWhitespace = /^\s*$/.test(segment);
      const isNewline = isNewlineCharacter(segment);
      const isSpaceAtStart = matchedLine.length === 0 && isWhitespace;
      if (isWhitespace && !isNewline && isSpaceAtStart) {
        return;
      }
      if (!isNewline)
        matchedLine += segment;
      const metric = CanvasTextMetrics.measureText(segment, textStyle);
      chars.push({ char: segment, metric });
      if (matchedLine.length >= currentLine.length) {
        groupedSegments.push({
          line: matchedLine,
          chars,
          width: chars.reduce((acc, seg) => acc + seg.metric.width, 0)
        });
        chars = [];
        matchedLine = "";
        lineCount++;
        currentLine = measuredText.lines[lineCount];
      }
    });
    return groupedSegments;
  }
  function canvasTextSplit(options) {
    var _a2, _b;
    const { text, style, chars: existingChars } = options;
    const textStyle = style;
    const measuredText = CanvasTextMetrics.measureText(text, textStyle);
    const segments = CanvasTextMetrics.graphemeSegmenter(text);
    const groupedSegments = groupTextSegments(segments, measuredText, textStyle.clone());
    const alignment = textStyle.align;
    const largestLine = measuredText.lineWidths.reduce((max, line) => Math.max(max, line), 0);
    const chars = [];
    const lineContainers = [];
    const wordContainers = [];
    let yOffset = 0;
    const strokeWidth = ((_a2 = textStyle.stroke) == null ? void 0 : _a2.width) || 0;
    const dropShadowDistance = ((_b = textStyle.dropShadow) == null ? void 0 : _b.distance) || 0;
    groupedSegments.forEach((group, i3) => {
      const lineContainer = new Container({ label: `line-${i3}` });
      lineContainer.y = yOffset;
      lineContainers.push(lineContainer);
      const lineWidth = measuredText.lineWidths[i3];
      let xOffset = getAlignmentOffset(alignment, lineWidth, largestLine);
      let currentWordContainer = new Container({ label: "word" });
      currentWordContainer.x = xOffset;
      group.chars.forEach((segment, i22) => {
        if (segment.metric.width === 0) {
          return;
        }
        if (isNewlineCharacter(segment.char)) {
          xOffset += segment.metric.width - strokeWidth;
          return;
        }
        if (segment.char === " ") {
          if (currentWordContainer.children.length > 0) {
            wordContainers.push(currentWordContainer);
            lineContainer.addChild(currentWordContainer);
          }
          xOffset += segment.metric.width + textStyle.letterSpacing - strokeWidth;
          currentWordContainer = new Container({ label: "word" });
          currentWordContainer.x = xOffset;
        } else {
          let char;
          if (existingChars.length > 0) {
            char = existingChars.shift();
            char.text = segment.char;
            char.style = textStyle;
            char.setFromMatrix(Matrix.IDENTITY);
            char.x = xOffset - currentWordContainer.x - dropShadowDistance * i22;
          } else {
            char = new Text({
              text: segment.char,
              style: textStyle,
              x: xOffset - currentWordContainer.x - dropShadowDistance * i22
            });
          }
          chars.push(char);
          currentWordContainer.addChild(char);
          xOffset += segment.metric.width + textStyle.letterSpacing - strokeWidth;
        }
      });
      if (currentWordContainer.children.length > 0) {
        wordContainers.push(currentWordContainer);
        lineContainer.addChild(currentWordContainer);
      }
      yOffset += measuredText.lineHeight;
    });
    return { chars, lines: lineContainers, words: wordContainers };
  }

  // node_modules/pixi.js/lib/scene/text-split/SplitText.mjs
  var _SplitText = class _SplitText2 extends AbstractSplitText {
    constructor(config3) {
      const completeOptions = __spreadValues(__spreadValues({}, _SplitText2.defaultOptions), config3);
      super(completeOptions);
    }
    /**
     * Creates a SplitText instance from an existing text object.
     * Useful for converting standard Text or Text objects into segmented versions.
     * @param text - The source text object to convert
     * @param options - Additional splitting options
     * @returns A new SplitText instance
     * @example
     * ```ts
     * const text = new Text({
     *   text: 'Bitmap Text',
     *   style: { fontFamily: 'Arial' }
     * });
     *
     * const segmented = SplitText.from(text);
     *
     * // with additional options
     * const segmentedWithOptions = SplitText.from(text, {
     *   autoSplit: false,
     *   lineAnchor: 0.5,
     *   wordAnchor: { x: 0, y: 0.5 },
     * })
     * ```
     */
    static from(text, options) {
      const completeOptions = __spreadProps(__spreadValues(__spreadValues({}, _SplitText2.defaultOptions), options), {
        text: text.text,
        style: new TextStyle(text.style)
      });
      return new _SplitText2(__spreadValues({}, completeOptions));
    }
    splitFn() {
      return canvasTextSplit({
        text: this._originalText,
        style: this._style,
        chars: this._canReuseChars ? this.chars : []
      });
    }
  };
  _SplitText.defaultOptions = {
    autoSplit: true,
    // Auto-update on text/style changes
    lineAnchor: 0,
    // Top-left alignment
    wordAnchor: 0,
    // Top-left alignment
    charAnchor: 0
    // Top-left alignment
  };
  var SplitText = _SplitText;

  // node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs
  init_Color();
  var valuesToIterateForKeys = [
    "align",
    "breakWords",
    "cssOverrides",
    "fontVariant",
    "fontWeight",
    "leading",
    "letterSpacing",
    "lineHeight",
    "padding",
    "textBaseline",
    "trim",
    "whiteSpace",
    "wordWrap",
    "wordWrapWidth",
    "fontFamily",
    "fontStyle",
    "fontSize"
  ];
  function generateTextStyleKey(style) {
    const key = [];
    let index = 0;
    for (let i3 = 0; i3 < valuesToIterateForKeys.length; i3++) {
      const prop = `_${valuesToIterateForKeys[i3]}`;
      key[index++] = style[prop];
    }
    index = addFillStyleKey(style._fill, key, index);
    index = addStokeStyleKey(style._stroke, key, index);
    index = addDropShadowKey(style.dropShadow, key, index);
    index = addFiltersKey(style.filters, key, index);
    return key.join("-");
  }
  function addFiltersKey(filters, key, index) {
    if (!filters)
      return index;
    for (const filter of filters) {
      key[index++] = filter.uid;
    }
    return index;
  }
  function addFillStyleKey(fillStyle, key, index) {
    var _a2;
    if (!fillStyle)
      return index;
    key[index++] = fillStyle.color;
    key[index++] = fillStyle.alpha;
    key[index++] = (_a2 = fillStyle.fill) == null ? void 0 : _a2.styleKey;
    return index;
  }
  function addStokeStyleKey(strokeStyle, key, index) {
    if (!strokeStyle)
      return index;
    index = addFillStyleKey(strokeStyle, key, index);
    key[index++] = strokeStyle.width;
    key[index++] = strokeStyle.alignment;
    key[index++] = strokeStyle.cap;
    key[index++] = strokeStyle.join;
    key[index++] = strokeStyle.miterLimit;
    return index;
  }
  function addDropShadowKey(dropShadow, key, index) {
    if (!dropShadow)
      return index;
    key[index++] = dropShadow.alpha;
    key[index++] = dropShadow.angle;
    key[index++] = dropShadow.blur;
    key[index++] = dropShadow.distance;
    key[index++] = Color.shared.setValue(dropShadow.color).toNumber();
    return index;
  }

  // node_modules/pixi.js/lib/utils/logging/logDebugTexture.mjs
  function logDebugTexture(texture, renderer, size = 200) {
    return __async(this, null, function* () {
      const base64 = yield renderer.extract.base64(texture);
      yield renderer.encoder.commandFinished;
      const width = size;
      console.log(`logging texture ${texture.source.width}px ${texture.source.height}px`);
      const style = [
        "font-size: 1px;",
        `padding: ${width}px ${300}px;`,
        `background: url(${base64}) no-repeat;`,
        "background-size: contain;"
      ].join(" ");
      console.log("%c ", style);
    });
  }

  // node_modules/pixi.js/lib/utils/logging/logScene.mjs
  init_Sprite();
  var colors = [
    "#000080",
    // Navy Blue
    "#228B22",
    // Forest Green
    "#8B0000",
    // Dark Red
    "#4169E1",
    // Royal Blue
    "#008080",
    // Teal
    "#800000",
    // Maroon
    "#9400D3",
    // Dark Violet
    "#FF8C00",
    // Dark Orange
    "#556B2F",
    // Olive Green
    "#8B008B"
    // Dark Magenta
  ];
  var colorTick = 0;
  function logScene(container, depth = 0, data = { color: "#000000" }) {
    if (container.renderGroup) {
      data.color = colors[colorTick++];
    }
    let spaces = "";
    for (let i3 = 0; i3 < depth; i3++) {
      spaces += "    ";
    }
    let label = container.label;
    if (!label && container instanceof Sprite) {
      label = `sprite:${container.texture.label}`;
    }
    let output = `%c ${spaces}|- ${label} (worldX:${container.worldTransform.tx}, relativeRenderX:${container.relativeGroupTransform.tx}, renderX:${container.groupTransform.tx}, localX:${container.x})`;
    if (container.renderGroup) {
      output += " (RenderGroup)";
    }
    if (container.filters) {
      output += "(*filters)";
    }
    console.log(output, `color:${data.color}; font-weight:bold;`);
    depth++;
    for (let i3 = 0; i3 < container.children.length; i3++) {
      const child = container.children[i3];
      logScene(child, depth, __spreadValues({}, data));
    }
  }
  function logRenderGroupScene(renderGroup, depth = 0, data = { index: 0, color: "#000000" }) {
    let spaces = "";
    for (let i3 = 0; i3 < depth; i3++) {
      spaces += "    ";
    }
    const output = `%c ${spaces}- ${data.index}: ${renderGroup.root.label} worldX:${renderGroup.worldTransform.tx}`;
    console.log(output, `color:${data.color}; font-weight:bold;`);
    depth++;
    for (let i3 = 0; i3 < renderGroup.renderGroupChildren.length; i3++) {
      const child = renderGroup.renderGroupChildren[i3];
      logRenderGroupScene(child, depth, __spreadProps(__spreadValues({}, data), { index: i3 }));
    }
  }

  // node_modules/pixi.js/lib/index.mjs
  init_AccessibilitySystem();
  init_accessibilityTarget();
  init_ResizePlugin();
  init_TickerPlugin();
  init_Cache();
  init_LoaderParser();
  init_Resolver();
  init_convertToList();
  init_copySearchParams();
  init_createStringVariations();
  init_isSingleItem();
  init_Color();
  init_cullingMixin();
  init_CanvasObserver();
  init_DOMContainer();
  init_DOMPipe();
  init_adapter();
  init_autoDetectEnvironment();
  init_BrowserAdapter();
  init_EventBoundary();
  init_EventSystem();
  init_EventTicker();
  init_FederatedEvent();
  init_FederatedEventTarget();
  init_FederatedMouseEvent();
  init_FederatedPointerEvent();
  init_FederatedWheelEvent();
  init_defaultFilter_vert();
  init_passthrough_frag();
  init_passthrough_wgsl();
  init_mask_frag();
  init_mask_vert();
  init_mask_wgsl();
  init_PassthroughFilter();
  init_Filter();
  init_FilterEffect();
  init_FilterPipe();
  init_FilterSystem();
  init_MaskFilter();
  init_groupD8();
  init_Matrix();
  init_const();
  init_pow2();
  init_squaredDistanceToLineSegment();
  init_ObservablePoint();
  init_Point();
  init_pointInTriangle();
  init_Circle();
  init_Ellipse();
  init_Polygon();
  init_Rectangle();
  init_RoundedRectangle();
  init_Triangle();
  init_GlBatchAdaptor();
  init_checkMaxIfStatementsInShader();
  init_maxRecommendedTextures();
  init_getTextureBatchBindGroup();
  init_GpuBatchAdaptor();
  init_Batcher();
  init_BatcherPipe();
  init_BatchGeometry();
  init_BatchTextureArray();
  init_DefaultBatcher();
  init_DefaultShader();
  init_compileHighShaderToProgram();
  init_compileHighShader();
  init_addBits();
  init_compileHooks();
  init_compileInputs();
  init_compileOutputs();
  init_injectBits();
  init_defaultProgramTemplate();
  init_colorBit();
  init_generateTextureBatchBit();
  init_globalUniformsBit();
  init_localUniformBit();
  init_roundPixelsBit();
  init_textureBit();
  init_AlphaMask();
  init_AlphaMaskPipe();
  init_ColorMask();
  init_ColorMaskPipe();
  init_MaskEffectManager();
  init_StencilMask();
  init_StencilMaskPipe();
  init_addMaskBounds();
  init_addMaskLocalBounds();
  init_const9();
  init_GlBuffer();
  init_GlBufferSystem();
  init_const7();
  init_GlContextSystem();
  init_GlGeometrySystem();
  init_getGlTypeFromFormat();
  init_GlBackBufferSystem();
  init_GlColorMaskSystem();
  init_GlEncoderSystem();
  init_GlLimitsSystem();
  init_GlRenderTarget();
  init_GlStencilSystem();
  init_GlUboSystem();
  init_GlRenderTargetAdaptor();
  init_GlRenderTargetSystem();
  init_GenerateShaderSyncCode();
  init_getBatchSamplersUniformGroup();
  init_GlProgram();
  init_GlProgramData();
  init_GlShaderSystem();
  init_GlUniformGroupSystem();
  init_compileShader();
  init_defaultValue();
  init_ensureAttributes();
  init_extractAttributesFromGlProgram();
  init_generateProgram();
  init_getMaxFragmentPrecision();
  init_getTestContext();
  init_getUboData();
  init_getUniformData();
  init_logProgramError();
  init_mapType();
  init_addProgramDefines();
  init_ensurePrecision();
  init_insertVersion();
  init_setProgramName();
  init_stripVersion();
  init_createUboElementsSTD40();
  init_createUboSyncSTD40();
  init_generateArraySyncSTD40();
  init_generateUniformsSync();
  init_generateUniformsSyncTypes();
  init_GlStateSystem();
  init_mapWebGLBlendModesToPixi();
  init_const10();
  init_GlTexture();
  init_GlTextureSystem();
  init_glUploadBufferImageResource();
  init_glUploadCompressedTextureResource();
  init_glUploadImageResource();
  init_glUploadVideoResource();
  init_applyStyleParams();
  init_mapFormatToGlFormat();
  init_mapFormatToGlInternalFormat();
  init_mapFormatToGlType();
  init_pixiToGlMaps();
  init_unpremultiplyAlpha();
  init_WebGLRenderer();
  init_BindGroupSystem();
  init_GpuBufferSystem();
  init_UboBatch();
  init_GpuColorMaskSystem();
  init_GpuDeviceSystem();
  init_GpuEncoderSystem();
  init_GpuLimitsSystem();
  init_GpuStencilSystem();
  init_GpuUboSystem();
  init_GpuUniformBatchPipe();
  init_PipelineSystem();
  init_calculateProjection();
  init_GpuRenderTarget();
  init_GpuRenderTargetAdaptor();
  init_GpuRenderTargetSystem();
  init_BindGroup();
  init_GpuProgram();
  init_GpuShaderSystem();
  init_createUboElementsWGSL();
  init_createUboSyncFunctionWGSL();
  init_extractAttributesFromGpuProgram();
  init_extractStructAndGroups();
  init_generateArraySyncWGSL();
  init_generateGpuLayoutGroups();
  init_generateLayoutHash();
  init_removeStructAndGroupDuplicates();
  init_GpuBlendModesToPixi();
  init_GpuStateSystem();
  init_GpuStencilModesToPixi();
  init_GpuTextureSystem();
  init_gpuUploadBufferImageResource();
  init_gpuUploadCompressedTextureResource();
  init_gpuUploadImageSource();
  init_gpuUploadVideoSource();
  init_GpuMipmapGenerator();
  init_WebGPURenderer();
  init_BackgroundSystem();
  init_BlendModePipe();
  init_Buffer();
  init_BufferResource();
  init_const4();
  init_fastCopy();
  init_ExtractSystem();
  init_GenerateTextureSystem();
  init_GCSystem();
  init_Geometry();
  init_buildUvs();
  init_ensureIsBuffer();
  init_getAttributeInfoFromFormat();
  init_getGeometryBounds();
  init_transformVertices();
  init_InstructionSet();
  init_GlobalUniformSystem();
  init_isRenderingToScreen();
  init_RenderTarget();
  init_RenderTargetSystem();
  init_SchedulerSystem();
  init_const5();
  init_Shader();
  init_types();
  init_UboSystem();
  init_UniformGroup();
  init_createUboSyncFunction();
  init_getDefaultUniformValue();
  init_uboSyncFunctions();
  init_uniformParsers();
  init_HelloSystem();
  init_const3();
  init_getAdjustedBlendModeBlend();
  init_State();
  init_AbstractRenderer();
  init_SharedSystems();
  init_SystemRunner();
  init_CanvasPool();
  init_RenderableGCSystem();
  init_RenderTexture();
  init_BufferImageSource();
  init_CanvasSource();
  init_ImageSource();
  init_TextureSource();
  init_VideoSource();
  init_Texture();
  init_TextureGCSystem();
  init_TextureMatrix();
  init_TexturePool();
  init_TextureStyle();
  init_getCanvasTexture();
  init_textureFrom();
  init_createIdFromString();
  init_ViewSystem();
  init_types2();
  init_particles_frag();
  init_particles_vert();
  init_particles_wgsl();
  init_Bounds();
  init_getGlobalBounds();
  init_getLocalBounds();
  init_getRenderableBounds();
  init_matrixAndBoundsPool();
  init_cacheAsTextureMixin();
  init_childrenHelperMixin();
  init_collectRenderablesMixin();
  init_effectsMixin();
  init_findMixin();
  init_getFastGlobalBoundsMixin();
  init_getGlobalMixin();
  init_measureMixin();
  init_onRenderMixin();
  init_sortMixin();
  init_toLocalGlobalMixin();
  init_Container();
  init_CustomRenderPipe();
  init_RenderGroup();
  init_RenderGroupPipe();
  init_RenderGroupSystem();
  init_assignWithIgnore();
  init_checkChildrenDidChange();
  init_clearList();
  init_definedProps();
  init_executeInstructions();
  init_multiplyColors();
  init_multiplyHexColors();
  init_updateRenderGroupTransforms();
  init_validateRenderables();
  init_GlGraphicsAdaptor();
  init_colorToUniform();
  init_GpuGraphicsAdaptor();
  init_BatchableGraphics();
  init_buildAdaptiveBezier();
  init_buildAdaptiveQuadratic();
  init_buildArc();
  init_buildArcTo();
  init_buildArcToSvg();
  init_buildCircle();
  init_buildLine();
  init_buildPixelLine();
  init_buildPolygon();
  init_buildRectangle();
  init_buildTriangle();
  init_const6();
  init_FillGradient();
  init_FillPattern();
  init_Graphics();
  init_GraphicsContext();
  init_GraphicsContextSystem();
  init_GraphicsPipe();
  init_GraphicsPath();
  init_roundShape();
  init_ShapePath();
  init_parseSVGDefinitions();
  init_parseSVGFloatAttribute();
  init_parseSVGPath();
  init_parseSVGStyle();
  init_SVGParser();
  init_extractSvgUrlId();
  init_fillOperations();
  init_pathOperations();
  init_buildContextBatches();
  init_convertFillInputToFillStyle();
  init_generateTextureFillMatrix();
  init_getOrientationOfPoints();
  init_triangulateWithHoles();
  init_PlaneGeometry();
  init_GlMeshAdaptor();
  init_GpuMeshAdapter();
  init_BatchableMesh();
  init_MeshGeometry();
  init_MeshPipe();
  init_GlParticleContainerAdaptor();
  init_GpuParticleContainerAdaptor();
  init_GlParticleContainerPipe();
  init_GpuParticleContainerPipe();
  init_ParticleBuffer();
  init_ParticleContainerPipe();
  init_ParticleShader();
  init_createIndicesForQuads();
  init_generateParticleUpdateFunction();
  init_NineSliceGeometry();
  init_NineSliceSpritePipe();
  init_tilingBit();
  init_TilingSpriteShader();
  init_TilingSpritePipe();
  init_applyMatrix();
  init_QuadGeometry();
  init_setPositions();
  init_setUvs();
  init_BatchableSprite();
  init_Sprite();
  init_SpritePipe();
  init_AbstractBitmapFont();
  init_BitmapFontManager();
  init_BitmapTextPipe();
  init_DynamicBitmapFont();
  init_getBitmapTextLayout();
  init_resolveCharacters();
  init_BatchableHTMLText();
  init_HTMLTextPipe();
  init_HTMLTextRenderData();
  init_HTMLTextSystem();
  init_extractFontFamilies();
  init_getFontCss();
  init_getSVGUrl();
  init_getTemporaryCanvasFromImage();
  init_loadFontAsBase64();
  init_loadFontCSS();
  init_loadSVGImage();
  init_measureHtmlText();
  init_BatchableText();
  init_CanvasTextGenerator();
  init_CanvasTextMetrics();
  init_CanvasTextPipe();
  init_CanvasTextSystem();
  init_fontStringFromTextStyle();
  init_getCanvasFillStyle();
  init_SdfShader();
  init_localUniformMSDFBit();
  init_mSDFBit();
  init_TextStyle();
  init_getPo2TextureFromSource();
  init_updateTextBounds();
  init_ViewContainer();
  init_Spritesheet();
  init_spritesheetAsset();
  init_const2();
  init_Ticker();
  init_TickerListener();
  init_detectVideoAlphaMode();
  init_isMobile2();
  init_isSafari();
  init_unsafeEvalSupported();
  init_getCanvasBoundingBox();
  init_const8();
  init_eventemitter3();
  init_clean();
  init_GCManagedHash();
  init_removeItems();
  init_uid();
  init_updateQuadBounds();
  init_ViewableBuffer();
  init_globalHooks();
  init_deprecation();
  init_warn();
  init_NOOP();
  init_path();
  init_GlobalResourceRegistry();
  init_Pool();
  init_PoolGroup();
  init_sayHello();
  init_utils();
  extensions.add(browserExt, webworkerExt);

  // node_modules/pixi-filters/lib/defaults/default2.mjs
  var vertex5 = "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

  // node_modules/pixi-filters/lib/defaults/default.mjs
  var wgslVertex = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}";

  // node_modules/pixi-filters/lib/kawase-blur/kawase-blur.mjs
  var fragment8 = "\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    finalColor = color;\n}";

  // node_modules/pixi-filters/lib/kawase-blur/kawase-blur2.mjs
  var source8 = "struct KawaseBlurUniforms {\n  uOffset:vec2<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOffset = kawaseBlurUniforms.uOffset;\n  var color: vec4<f32> = vec4<f32>(0.0);\n\n  // Sample top left pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));\n  // Sample top right pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));\n  // Sample bottom right pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));\n  // Sample bottom left pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));\n  // Average\n  color *= 0.25;\n\n  return color;\n}";

  // node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp.mjs
  var fragmentClamp = "\nprecision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uOffset;\n\nuniform vec4 uInputClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample top right pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    finalColor = color;\n}\n";

  // node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp2.mjs
  var sourceClamp = "struct KawaseBlurUniforms {\n  uOffset:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOffset = kawaseBlurUniforms.uOffset;\n  var color: vec4<f32> = vec4(0.0);\n\n  // Sample top left pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample top right pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample bottom right pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample bottom left pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Average\n  color *= 0.25;\n    \n  return color;\n}";

  // node_modules/pixi-filters/lib/kawase-blur/KawaseBlurFilter.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var _KawaseBlurFilter = class _KawaseBlurFilter2 extends Filter {
    /** @ignore */
    constructor(...args) {
      var _a2, _b, _c;
      let options = (_a2 = args[0]) != null ? _a2 : {};
      if (typeof options === "number" || Array.isArray(options)) {
        deprecation("6.0.0", "KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }");
        options = { strength: options };
        if (args[1] !== void 0)
          options.quality = args[1];
        if (args[2] !== void 0)
          options.clamp = args[2];
      }
      options = __spreadValues(__spreadValues({}, _KawaseBlurFilter2.DEFAULT_OPTIONS), options);
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source: wgslVertex,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: (options == null ? void 0 : options.clamp) ? sourceClamp : source8,
          entryPoint: "mainFragment"
        }
      });
      const glProgram3 = GlProgram.from({
        vertex: vertex5,
        fragment: (options == null ? void 0 : options.clamp) ? fragmentClamp : fragment8,
        name: "kawase-blur-filter"
      });
      super({
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        resources: {
          kawaseBlurUniforms: {
            uOffset: { value: new Float32Array(2), type: "vec2<f32>" }
          }
        }
      });
      __publicField2(this, "uniforms");
      __publicField2(this, "_pixelSize", { x: 0, y: 0 });
      __publicField2(this, "_clamp");
      __publicField2(this, "_kernels", []);
      __publicField2(this, "_blur");
      __publicField2(this, "_quality");
      this.uniforms = this.resources.kawaseBlurUniforms.uniforms;
      this.pixelSize = (_b = options.pixelSize) != null ? _b : { x: 1, y: 1 };
      if (Array.isArray(options.strength)) {
        this.kernels = options.strength;
      } else if (typeof options.strength === "number") {
        this._blur = options.strength;
        this.quality = (_c = options.quality) != null ? _c : 3;
      }
      this._clamp = !!options.clamp;
    }
    /**
     * Override existing apply method in `Filter`
     * @override
     * @ignore
     */
    apply(filterManager, input, output, clearMode) {
      const uvX = this.pixelSizeX / input.source.width;
      const uvY = this.pixelSizeY / input.source.height;
      let offset;
      if (this._quality === 1 || this._blur === 0) {
        offset = this._kernels[0] + 0.5;
        this.uniforms.uOffset[0] = offset * uvX;
        this.uniforms.uOffset[1] = offset * uvY;
        filterManager.applyFilter(this, input, output, clearMode);
      } else {
        const renderTarget = TexturePool.getSameSizeTexture(input);
        let source22 = input;
        let target = renderTarget;
        let tmp;
        const last = this._quality - 1;
        for (let i3 = 0; i3 < last; i3++) {
          offset = this._kernels[i3] + 0.5;
          this.uniforms.uOffset[0] = offset * uvX;
          this.uniforms.uOffset[1] = offset * uvY;
          filterManager.applyFilter(this, source22, target, true);
          tmp = source22;
          source22 = target;
          target = tmp;
        }
        offset = this._kernels[last] + 0.5;
        this.uniforms.uOffset[0] = offset * uvX;
        this.uniforms.uOffset[1] = offset * uvY;
        filterManager.applyFilter(this, source22, output, clearMode);
        TexturePool.returnTexture(renderTarget);
      }
    }
    /**
      * The amount of blur, value greater than `0`.
      * @default 4
      */
    get strength() {
      return this._blur;
    }
    set strength(value) {
      this._blur = value;
      this._generateKernels();
    }
    /**
      * The quality of the filter, integer greater than `1`.
      * @default 3
      */
    get quality() {
      return this._quality;
    }
    set quality(value) {
      this._quality = Math.max(1, Math.round(value));
      this._generateKernels();
    }
    /**
      * The kernel size of the blur filter, for advanced usage
      * @default [0]
      */
    get kernels() {
      return this._kernels;
    }
    set kernels(value) {
      if (Array.isArray(value) && value.length > 0) {
        this._kernels = value;
        this._quality = value.length;
        this._blur = Math.max(...value);
      } else {
        this._kernels = [0];
        this._quality = 1;
      }
    }
    /**
      * The size of the pixels. Large size is blurrier. For advanced usage.
      * @default {x:1,y:1}
      */
    get pixelSize() {
      return this._pixelSize;
    }
    set pixelSize(value) {
      if (typeof value === "number") {
        this.pixelSizeX = this.pixelSizeY = value;
        return;
      }
      if (Array.isArray(value)) {
        this.pixelSizeX = value[0];
        this.pixelSizeY = value[1];
        return;
      }
      this._pixelSize = value;
    }
    /**
      * The size of the pixels on the `x` axis. Large size is blurrier. For advanced usage.
      * @default 1
      */
    get pixelSizeX() {
      return this.pixelSize.x;
    }
    set pixelSizeX(value) {
      this.pixelSize.x = value;
    }
    /**
      * The size of the pixels on the `y` axis. Large size is blurrier. For advanced usage.
      * @default 1
      */
    get pixelSizeY() {
      return this.pixelSize.y;
    }
    set pixelSizeY(value) {
      this.pixelSize.y = value;
    }
    /**
      * Get the if the filter is clamped
      * @default false
      */
    get clamp() {
      return this._clamp;
    }
    /** Update padding based on kernel data */
    _updatePadding() {
      this.padding = Math.ceil(this._kernels.reduce((acc, v2) => acc + v2 + 0.5, 0));
    }
    /** Auto generate kernels by blur & quality */
    _generateKernels() {
      const blur = this._blur;
      const quality = this._quality;
      const kernels = [blur];
      if (blur > 0) {
        let k2 = blur;
        const step = blur / quality;
        for (let i3 = 1; i3 < quality; i3++) {
          k2 -= step;
          kernels.push(k2);
        }
      }
      this._kernels = kernels;
      this._updatePadding();
    }
  };
  __publicField2(_KawaseBlurFilter, "DEFAULT_OPTIONS", {
    strength: 4,
    quality: 3,
    clamp: false,
    pixelSize: { x: 1, y: 1 }
  });
  var KawaseBlurFilter = _KawaseBlurFilter;

  // node_modules/pixi-filters/lib/drop-shadow/drop-shadow.mjs
  var fragment9 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uAlpha;\nuniform vec3 uColor;\nuniform vec2 uOffset;\n\nuniform vec4 uInputSize;\n\nvoid main(void){\n    vec4 sample = texture(uTexture, vTextureCoord - uOffset * uInputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = uColor.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= uAlpha;\n\n    finalColor = sample;\n}";

  // node_modules/pixi-filters/lib/drop-shadow/drop-shadow2.mjs
  var source9 = "struct DropShadowUniforms {\n  uAlpha: f32,\n  uColor: vec3<f32>,\n  uOffset: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> dropShadowUniforms : DropShadowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv - dropShadowUniforms.uOffset * gfu.uInputSize.zw);\n\n  // Premultiply alpha\n  color = vec4<f32>(vec3<f32>(dropShadowUniforms.uColor.rgb * color.a), color.a);\n  // alpha user alpha\n  color *= dropShadowUniforms.uAlpha;\n\n  return color;\n}";

  // node_modules/pixi-filters/lib/drop-shadow/DropShadowFilter.mjs
  var __defProp3 = Object.defineProperty;
  var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField3 = (obj, key, value) => {
    __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var _DropShadowFilter = class _DropShadowFilter2 extends Filter {
    /**
     * @param options - Options for the DropShadowFilter constructor.
     */
    constructor(options) {
      var _a2, _b;
      options = __spreadValues(__spreadValues({}, _DropShadowFilter2.DEFAULT_OPTIONS), options);
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source: wgslVertex,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source9,
          entryPoint: "mainFragment"
        }
      });
      const glProgram3 = GlProgram.from({
        vertex: vertex5,
        fragment: fragment9,
        name: "drop-shadow-filter"
      });
      super({
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        resources: {
          dropShadowUniforms: {
            uAlpha: { value: options.alpha, type: "f32" },
            uColor: { value: new Float32Array(3), type: "vec3<f32>" },
            uOffset: { value: options.offset, type: "vec2<f32>" }
          }
        },
        resolution: options.resolution
      });
      __publicField3(this, "uniforms");
      __publicField3(this, "shadowOnly", false);
      __publicField3(this, "_color");
      __publicField3(this, "_blurFilter");
      __publicField3(this, "_basePass");
      this.uniforms = this.resources.dropShadowUniforms.uniforms;
      this._color = new Color();
      this.color = (_a2 = options.color) != null ? _a2 : 0;
      this._blurFilter = new KawaseBlurFilter({
        strength: (_b = options.kernels) != null ? _b : options.blur,
        quality: options.kernels ? void 0 : options.quality
      });
      this._basePass = new Filter({
        gpuProgram: GpuProgram.from({
          vertex: {
            source: wgslVertex,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: `
                    @group(0) @binding(1) var uTexture: texture_2d<f32>; 
                    @group(0) @binding(2) var uSampler: sampler;
                    @fragment
                    fn mainFragment(
                        @builtin(position) position: vec4<f32>,
                        @location(0) uv : vec2<f32>
                    ) -> @location(0) vec4<f32> {
                        return textureSample(uTexture, uSampler, uv);
                    }
                    `,
            entryPoint: "mainFragment"
          }
        }),
        glProgram: GlProgram.from({
          vertex: vertex5,
          fragment: `
                in vec2 vTextureCoord;
                out vec4 finalColor;
                uniform sampler2D uTexture;

                void main(void){
                    finalColor = texture(uTexture, vTextureCoord);
                }
                `,
          name: "drop-shadow-filter"
        }),
        resources: {}
      });
      Object.assign(this, options);
    }
    /**
     * Override existing apply method in `Filter`
     * @override
     * @ignore
     */
    apply(filterManager, input, output, clearMode) {
      const renderTarget = TexturePool.getSameSizeTexture(input);
      filterManager.applyFilter(this, input, renderTarget, true);
      this._blurFilter.apply(filterManager, renderTarget, output, clearMode);
      if (!this.shadowOnly) {
        filterManager.applyFilter(this._basePass, input, output, false);
      }
      TexturePool.returnTexture(renderTarget);
    }
    /**
     * Set the offset position of the drop-shadow relative to the original image.
     * @default [4,4]
     */
    get offset() {
      return this.uniforms.uOffset;
    }
    set offset(value) {
      this.uniforms.uOffset = value;
      this._updatePadding();
    }
    /**
     * Set the offset position of the drop-shadow relative to the original image on the `x` axis
     * @default 4
     */
    get offsetX() {
      return this.offset.x;
    }
    set offsetX(value) {
      this.offset.x = value;
      this._updatePadding();
    }
    /**
     * Set the offset position of the drop-shadow relative to the original image on the `y` axis
     * @default 4
     */
    get offsetY() {
      return this.offset.y;
    }
    set offsetY(value) {
      this.offset.y = value;
      this._updatePadding();
    }
    /**
     * The color value of shadow.
     * @example [0.0, 0.0, 0.0] = 0x000000
     * @default 0x000000
     */
    get color() {
      return this._color.value;
    }
    set color(value) {
      this._color.setValue(value);
      const [r2, g2, b2] = this._color.toArray();
      this.uniforms.uColor[0] = r2;
      this.uniforms.uColor[1] = g2;
      this.uniforms.uColor[2] = b2;
    }
    /**
     * Coefficient for alpha multiplication
     * @default 1
     */
    get alpha() {
      return this.uniforms.uAlpha;
    }
    set alpha(value) {
      this.uniforms.uAlpha = value;
    }
    /**
     * The strength of the shadow's blur.
     * @default 2
     */
    get blur() {
      return this._blurFilter.strength;
    }
    set blur(value) {
      this._blurFilter.strength = value;
      this._updatePadding();
    }
    /**
     * Sets the quality of the Blur Filter
     * @default 4
     */
    get quality() {
      return this._blurFilter.quality;
    }
    set quality(value) {
      this._blurFilter.quality = value;
      this._updatePadding();
    }
    /** Sets the kernels of the Blur Filter */
    get kernels() {
      return this._blurFilter.kernels;
    }
    set kernels(value) {
      this._blurFilter.kernels = value;
    }
    /**
     * Sets the pixelSize of the Kawase Blur filter
     * @default [1,1]
     */
    get pixelSize() {
      return this._blurFilter.pixelSize;
    }
    set pixelSize(value) {
      if (typeof value === "number") {
        value = { x: value, y: value };
      }
      if (Array.isArray(value)) {
        value = { x: value[0], y: value[1] };
      }
      this._blurFilter.pixelSize = value;
    }
    /**
     * Sets the pixelSize of the Kawase Blur filter on the `x` axis
     * @default 1
     */
    get pixelSizeX() {
      return this._blurFilter.pixelSizeX;
    }
    set pixelSizeX(value) {
      this._blurFilter.pixelSizeX = value;
    }
    /**
     * Sets the pixelSize of the Kawase Blur filter on the `y` axis
     * @default 1
     */
    get pixelSizeY() {
      return this._blurFilter.pixelSizeY;
    }
    set pixelSizeY(value) {
      this._blurFilter.pixelSizeY = value;
    }
    /**
     * Recalculate the proper padding amount.
     * @private
     */
    _updatePadding() {
      const offsetPadding = Math.max(
        Math.abs(this.offsetX),
        Math.abs(this.offsetY)
      );
      this.padding = offsetPadding + this.blur * 2 + this.quality * 4;
    }
  };
  __publicField3(_DropShadowFilter, "DEFAULT_OPTIONS", {
    offset: { x: 4, y: 4 },
    color: 0,
    alpha: 0.5,
    shadowOnly: false,
    kernels: void 0,
    blur: 2,
    quality: 3,
    pixelSize: { x: 1, y: 1 },
    resolution: 1
  });
  var DropShadowFilter = _DropShadowFilter;

  // node_modules/pixi-filters/lib/outline/outline.mjs
  var fragment10 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uThickness;\nuniform vec3 uColor;\nuniform float uAlpha;\nuniform float uKnockout;\n\nuniform vec4 uInputClamp;\n\nconst float DOUBLE_PI = 2. * 3.14159265358979323846264;\nconst float ANGLE_STEP = ${ANGLE_STEP};\n\nfloat outlineMaxAlphaAtPos(vec2 pos) {\n    if (uThickness.x == 0. || uThickness.y == 0.) {\n        return 0.;\n    }\n\n    vec4 displacedColor;\n    vec2 displacedPos;\n    float maxAlpha = 0.;\n\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\n        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);\n        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);\n        displacedColor = texture(uTexture, clamp(displacedPos, uInputClamp.xy, uInputClamp.zw));\n        maxAlpha = max(maxAlpha, displacedColor.a);\n    }\n\n    return maxAlpha;\n}\n\nvoid main(void) {\n    vec4 sourceColor = texture(uTexture, vTextureCoord);\n    vec4 contentColor = sourceColor * float(uKnockout < 0.5);\n    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);\n    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);\n    finalColor = contentColor + outlineColor;\n}\n";

  // node_modules/pixi-filters/lib/outline/outline2.mjs
  var source10 = "struct OutlineUniforms {\n  uThickness:vec2<f32>,\n  uColor:vec3<f32>,\n  uAlpha:f32,\n  uAngleStep:f32,\n  uKnockout:f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> outlineUniforms : OutlineUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let sourceColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let contentColor: vec4<f32> = sourceColor * (1. - outlineUniforms.uKnockout);\n  \n  let outlineAlpha: f32 = outlineUniforms.uAlpha * outlineMaxAlphaAtPos(uv) * (1. - sourceColor.a);\n  let outlineColor: vec4<f32> = vec4<f32>(vec3<f32>(outlineUniforms.uColor) * outlineAlpha, outlineAlpha);\n  \n  return contentColor + outlineColor;\n}\n\nfn outlineMaxAlphaAtPos(uv: vec2<f32>) -> f32 {\n  let thickness = outlineUniforms.uThickness;\n\n  if (thickness.x == 0. || thickness.y == 0.) {\n    return 0.;\n  }\n  \n  let angleStep = outlineUniforms.uAngleStep;\n\n  var displacedColor: vec4<f32>;\n  var displacedPos: vec2<f32>;\n\n  var maxAlpha: f32 = 0.;\n  var displaced: vec2<f32>;\n  var curColor: vec4<f32>;\n\n  for (var angle = 0.; angle <= DOUBLE_PI; angle += angleStep)\n  {\n    displaced.x = uv.x + thickness.x * cos(angle);\n    displaced.y = uv.y + thickness.y * sin(angle);\n    curColor = textureSample(uTexture, uSampler, clamp(displaced, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n    maxAlpha = max(maxAlpha, curColor.a);\n  }\n\n  return maxAlpha;\n}\n\nconst DOUBLE_PI: f32 = 3.14159265358979323846264 * 2.;";

  // node_modules/pixi-filters/lib/outline/OutlineFilter.mjs
  var __defProp4 = Object.defineProperty;
  var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField4 = (obj, key, value) => {
    __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var _OutlineFilter = class _OutlineFilter2 extends Filter {
    /** @ignore */
    constructor(...args) {
      var _a2, _b, _c;
      let options = (_a2 = args[0]) != null ? _a2 : {};
      if (typeof options === "number") {
        deprecation("6.0.0", "OutlineFilter constructor params are now options object. See params: { thickness, color, quality, alpha, knockout }");
        options = { thickness: options };
        if (args[1] !== void 0)
          options.color = args[1];
        if (args[2] !== void 0)
          options.quality = args[2];
        if (args[3] !== void 0)
          options.alpha = args[3];
        if (args[4] !== void 0)
          options.knockout = args[4];
      }
      options = __spreadValues(__spreadValues({}, _OutlineFilter2.DEFAULT_OPTIONS), options);
      const quality = (_b = options.quality) != null ? _b : 0.1;
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source: wgslVertex,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source10,
          entryPoint: "mainFragment"
        }
      });
      const glProgram3 = GlProgram.from({
        vertex: vertex5,
        fragment: fragment10.replace(/\$\{ANGLE_STEP\}/, _OutlineFilter2.getAngleStep(quality).toFixed(7)),
        name: "outline-filter"
      });
      super({
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        resources: {
          outlineUniforms: {
            uThickness: { value: new Float32Array(2), type: "vec2<f32>" },
            uColor: { value: new Float32Array(3), type: "vec3<f32>" },
            uAlpha: { value: options.alpha, type: "f32" },
            uAngleStep: { value: 0, type: "f32" },
            uKnockout: { value: options.knockout ? 1 : 0, type: "f32" }
          }
        }
      });
      __publicField4(this, "uniforms");
      __publicField4(this, "_thickness");
      __publicField4(this, "_quality");
      __publicField4(this, "_color");
      this.uniforms = this.resources.outlineUniforms.uniforms;
      this.uniforms.uAngleStep = _OutlineFilter2.getAngleStep(quality);
      this._color = new Color();
      this.color = (_c = options.color) != null ? _c : 0;
      Object.assign(this, options);
    }
    /**
     * Override existing apply method in `Filter`
     * @override
     * @ignore
     */
    apply(filterManager, input, output, clearMode) {
      this.uniforms.uThickness[0] = this.thickness / input.source.width;
      this.uniforms.uThickness[1] = this.thickness / input.source.height;
      filterManager.applyFilter(this, input, output, clearMode);
    }
    /**
     * Get the angleStep by quality
     * @param quality
     */
    static getAngleStep(quality) {
      return parseFloat((Math.PI * 2 / Math.max(
        quality * _OutlineFilter2.MAX_SAMPLES,
        _OutlineFilter2.MIN_SAMPLES
      )).toFixed(7));
    }
    /**
     * The thickness of the outline
     * @default 1
     */
    get thickness() {
      return this._thickness;
    }
    set thickness(value) {
      this._thickness = this.padding = value;
    }
    /**
     * The color value of the ambient color
     * @example [1.0, 1.0, 1.0] = 0xffffff
     * @default 0x000000
     */
    get color() {
      return this._color.value;
    }
    set color(value) {
      this._color.setValue(value);
      const [r2, g2, b2] = this._color.toArray();
      this.uniforms.uColor[0] = r2;
      this.uniforms.uColor[1] = g2;
      this.uniforms.uColor[2] = b2;
    }
    /**
     * Coefficient for alpha multiplication
     * @default 1
     */
    get alpha() {
      return this.uniforms.uAlpha;
    }
    set alpha(value) {
      this.uniforms.uAlpha = value;
    }
    /**
     * The quality of the outline from `0` to `1`.
     * Using a higher quality setting will result in more accuracy but slower performance
     * @default 0.1
     */
    get quality() {
      return this._quality;
    }
    set quality(value) {
      this._quality = value;
      this.uniforms.uAngleStep = _OutlineFilter2.getAngleStep(value);
    }
    /**
     * Whether to only render outline, not the contents.
     * @default false
     */
    get knockout() {
      return this.uniforms.uKnockout === 1;
    }
    set knockout(value) {
      this.uniforms.uKnockout = value ? 1 : 0;
    }
  };
  __publicField4(_OutlineFilter, "DEFAULT_OPTIONS", {
    thickness: 1,
    color: 0,
    alpha: 1,
    quality: 0.1,
    knockout: false
  });
  __publicField4(_OutlineFilter, "MIN_SAMPLES", 1);
  __publicField4(_OutlineFilter, "MAX_SAMPLES", 100);
  var OutlineFilter = _OutlineFilter;

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/require-shim.js
  if (typeof window !== "undefined" && window.PIXI) {
    const prevRequire = window.require;
    window.require = (x2) => {
      if (prevRequire)
        return prevRequire(x2);
      else if (x2.startsWith("@pixi/") || x2.startsWith("pixi.js"))
        return window.PIXI;
    };
  }

  // node_modules/@esotericsoftware/spine-core/dist/Utils.js
  var StringSet = class {
    constructor() {
      __publicField(this, "entries", {});
      __publicField(this, "size", 0);
    }
    add(value) {
      let contains = this.entries[value];
      this.entries[value] = true;
      if (!contains) {
        this.size++;
        return true;
      }
      return false;
    }
    addAll(values) {
      let oldSize = this.size;
      for (var i3 = 0, n2 = values.length; i3 < n2; i3++)
        this.add(values[i3]);
      return oldSize != this.size;
    }
    contains(value) {
      return this.entries[value];
    }
    clear() {
      this.entries = {};
      this.size = 0;
    }
  };
  var _Color3 = class _Color3 {
    constructor(r2 = 0, g2 = 0, b2 = 0, a2 = 0) {
      __publicField(this, "r");
      __publicField(this, "g");
      __publicField(this, "b");
      __publicField(this, "a");
      this.r = r2;
      this.g = g2;
      this.b = b2;
      this.a = a2;
    }
    set(r2, g2, b2, a2) {
      this.r = r2;
      this.g = g2;
      this.b = b2;
      this.a = a2;
      return this.clamp();
    }
    setFromColor(c2) {
      this.r = c2.r;
      this.g = c2.g;
      this.b = c2.b;
      this.a = c2.a;
      return this;
    }
    setFromString(hex) {
      hex = hex.charAt(0) == "#" ? hex.substr(1) : hex;
      this.r = parseInt(hex.substr(0, 2), 16) / 255;
      this.g = parseInt(hex.substr(2, 2), 16) / 255;
      this.b = parseInt(hex.substr(4, 2), 16) / 255;
      this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;
      return this;
    }
    add(r2, g2, b2, a2) {
      this.r += r2;
      this.g += g2;
      this.b += b2;
      this.a += a2;
      return this.clamp();
    }
    clamp() {
      if (this.r < 0)
        this.r = 0;
      else if (this.r > 1)
        this.r = 1;
      if (this.g < 0)
        this.g = 0;
      else if (this.g > 1)
        this.g = 1;
      if (this.b < 0)
        this.b = 0;
      else if (this.b > 1)
        this.b = 1;
      if (this.a < 0)
        this.a = 0;
      else if (this.a > 1)
        this.a = 1;
      return this;
    }
    static rgba8888ToColor(color, value) {
      color.r = ((value & 4278190080) >>> 24) / 255;
      color.g = ((value & 16711680) >>> 16) / 255;
      color.b = ((value & 65280) >>> 8) / 255;
      color.a = (value & 255) / 255;
    }
    static rgb888ToColor(color, value) {
      color.r = ((value & 16711680) >>> 16) / 255;
      color.g = ((value & 65280) >>> 8) / 255;
      color.b = (value & 255) / 255;
    }
    toRgb888() {
      const hex = (x2) => ("0" + (x2 * 255).toString(16)).slice(-2);
      return Number("0x" + hex(this.r) + hex(this.g) + hex(this.b));
    }
    static fromString(hex, color = new _Color3()) {
      return color.setFromString(hex);
    }
  };
  __publicField(_Color3, "WHITE", new _Color3(1, 1, 1, 1));
  __publicField(_Color3, "RED", new _Color3(1, 0, 0, 1));
  __publicField(_Color3, "GREEN", new _Color3(0, 1, 0, 1));
  __publicField(_Color3, "BLUE", new _Color3(0, 0, 1, 1));
  __publicField(_Color3, "MAGENTA", new _Color3(1, 0, 1, 1));
  var Color2 = _Color3;
  var _MathUtils = class _MathUtils {
    static clamp(value, min, max) {
      if (value < min)
        return min;
      if (value > max)
        return max;
      return value;
    }
    static cosDeg(degrees) {
      return Math.cos(degrees * _MathUtils.degRad);
    }
    static sinDeg(degrees) {
      return Math.sin(degrees * _MathUtils.degRad);
    }
    static atan2Deg(y2, x2) {
      return Math.atan2(y2, x2) * _MathUtils.degRad;
    }
    static signum(value) {
      return value > 0 ? 1 : value < 0 ? -1 : 0;
    }
    static toInt(x2) {
      return x2 > 0 ? Math.floor(x2) : Math.ceil(x2);
    }
    static cbrt(x2) {
      let y2 = Math.pow(Math.abs(x2), 1 / 3);
      return x2 < 0 ? -y2 : y2;
    }
    static randomTriangular(min, max) {
      return _MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);
    }
    static randomTriangularWith(min, max, mode) {
      let u2 = Math.random();
      let d2 = max - min;
      if (u2 <= (mode - min) / d2)
        return min + Math.sqrt(u2 * d2 * (mode - min));
      return max - Math.sqrt((1 - u2) * d2 * (max - mode));
    }
    static isPowerOfTwo(value) {
      return value && (value & value - 1) === 0;
    }
  };
  __publicField(_MathUtils, "PI", 3.1415927);
  __publicField(_MathUtils, "PI2", _MathUtils.PI * 2);
  __publicField(_MathUtils, "invPI2", 1 / _MathUtils.PI2);
  __publicField(_MathUtils, "radiansToDegrees", 180 / _MathUtils.PI);
  __publicField(_MathUtils, "radDeg", _MathUtils.radiansToDegrees);
  __publicField(_MathUtils, "degreesToRadians", _MathUtils.PI / 180);
  __publicField(_MathUtils, "degRad", _MathUtils.degreesToRadians);
  var MathUtils = _MathUtils;
  var _Utils = class _Utils {
    static arrayCopy(source11, sourceStart, dest, destStart, numElements) {
      for (let i3 = sourceStart, j2 = destStart; i3 < sourceStart + numElements; i3++, j2++) {
        dest[j2] = source11[i3];
      }
    }
    static arrayFill(array, fromIndex, toIndex, value) {
      for (let i3 = fromIndex; i3 < toIndex; i3++)
        array[i3] = value;
    }
    static setArraySize(array, size, value = 0) {
      let oldSize = array.length;
      if (oldSize == size)
        return array;
      array.length = size;
      if (oldSize < size) {
        for (let i3 = oldSize; i3 < size; i3++)
          array[i3] = value;
      }
      return array;
    }
    static ensureArrayCapacity(array, size, value = 0) {
      if (array.length >= size)
        return array;
      return _Utils.setArraySize(array, size, value);
    }
    static newArray(size, defaultValue2) {
      let array = new Array(size);
      for (let i3 = 0; i3 < size; i3++)
        array[i3] = defaultValue2;
      return array;
    }
    static newFloatArray(size) {
      if (_Utils.SUPPORTS_TYPED_ARRAYS)
        return new Float32Array(size);
      else {
        let array = new Array(size);
        for (let i3 = 0; i3 < array.length; i3++)
          array[i3] = 0;
        return array;
      }
    }
    static newShortArray(size) {
      if (_Utils.SUPPORTS_TYPED_ARRAYS)
        return new Int16Array(size);
      else {
        let array = new Array(size);
        for (let i3 = 0; i3 < array.length; i3++)
          array[i3] = 0;
        return array;
      }
    }
    static toFloatArray(array) {
      return _Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
    }
    static toSinglePrecision(value) {
      return _Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;
    }
    // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109
    static webkit602BugfixHelper(alpha, blend) {
    }
    static contains(array, element, identity = true) {
      for (var i3 = 0; i3 < array.length; i3++)
        if (array[i3] == element)
          return true;
      return false;
    }
    static enumValue(type, name) {
      return type[name[0].toUpperCase() + name.slice(1)];
    }
  };
  __publicField(_Utils, "SUPPORTS_TYPED_ARRAYS", typeof Float32Array !== "undefined");
  var Utils = _Utils;
  var Pool2 = class {
    constructor(instantiator) {
      __publicField(this, "items", new Array());
      __publicField(this, "instantiator");
      this.instantiator = instantiator;
    }
    obtain() {
      return this.items.length > 0 ? this.items.pop() : this.instantiator();
    }
    free(item) {
      if (item.reset)
        item.reset();
      this.items.push(item);
    }
    freeAll(items) {
      for (let i3 = 0; i3 < items.length; i3++)
        this.free(items[i3]);
    }
    clear() {
      this.items.length = 0;
    }
  };
  var Vector2 = class {
    constructor(x2 = 0, y2 = 0) {
      __publicField(this, "x");
      __publicField(this, "y");
      this.x = x2;
      this.y = y2;
    }
    set(x2, y2) {
      this.x = x2;
      this.y = y2;
      return this;
    }
    length() {
      let x2 = this.x;
      let y2 = this.y;
      return Math.sqrt(x2 * x2 + y2 * y2);
    }
    normalize() {
      let len = this.length();
      if (len != 0) {
        this.x /= len;
        this.y /= len;
      }
      return this;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/attachments/Attachment.js
  var Attachment = class {
    constructor(name) {
      __publicField(this, "name");
      if (!name)
        throw new Error("name cannot be null.");
      this.name = name;
    }
  };
  var _VertexAttachment = class _VertexAttachment extends Attachment {
    constructor(name) {
      super(name);
      /** The unique ID for this attachment. */
      __publicField(this, "id", _VertexAttachment.nextID++);
      /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting
       * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null
       * if this attachment has no weights. */
      __publicField(this, "bones", null);
      /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`
       * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting
       * each vertex. */
      __publicField(this, "vertices", []);
      /** The maximum number of world vertex values that can be output by
       * {@link #computeWorldVertices()} using the `count` parameter. */
      __publicField(this, "worldVerticesLength", 0);
      /** Timelines for the timeline attachment are also applied to this attachment.
       * May be null if no attachment-specific timelines should be applied. */
      __publicField(this, "timelineAttachment", this);
    }
    /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is
     * not empty, it is used to deform the vertices.
     *
     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
     * Runtimes Guide.
     * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.
     * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.
     * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *
     *           `stride` / 2.
     * @param offset The `worldVertices` index to begin writing values.
     * @param stride The number of `worldVertices` entries between the value pairs written. */
    computeWorldVertices(slot, start, count2, worldVertices, offset, stride) {
      count2 = offset + (count2 >> 1) * stride;
      let skeleton = slot.bone.skeleton;
      let deformArray = slot.deform;
      let vertices = this.vertices;
      let bones = this.bones;
      if (!bones) {
        if (deformArray.length > 0)
          vertices = deformArray;
        let bone = slot.bone;
        let x2 = bone.worldX;
        let y2 = bone.worldY;
        let a2 = bone.a, b2 = bone.b, c2 = bone.c, d2 = bone.d;
        for (let v3 = start, w2 = offset; w2 < count2; v3 += 2, w2 += stride) {
          let vx2 = vertices[v3], vy2 = vertices[v3 + 1];
          worldVertices[w2] = vx2 * a2 + vy2 * b2 + x2;
          worldVertices[w2 + 1] = vx2 * c2 + vy2 * d2 + y2;
        }
        return;
      }
      let v2 = 0, skip = 0;
      for (let i3 = 0; i3 < start; i3 += 2) {
        let n2 = bones[v2];
        v2 += n2 + 1;
        skip += n2;
      }
      let skeletonBones = skeleton.bones;
      if (deformArray.length == 0) {
        for (let w2 = offset, b2 = skip * 3; w2 < count2; w2 += stride) {
          let wx = 0, wy = 0;
          let n2 = bones[v2++];
          n2 += v2;
          for (; v2 < n2; v2++, b2 += 3) {
            let bone = skeletonBones[bones[v2]];
            let vx2 = vertices[b2], vy2 = vertices[b2 + 1], weight = vertices[b2 + 2];
            wx += (vx2 * bone.a + vy2 * bone.b + bone.worldX) * weight;
            wy += (vx2 * bone.c + vy2 * bone.d + bone.worldY) * weight;
          }
          worldVertices[w2] = wx;
          worldVertices[w2 + 1] = wy;
        }
      } else {
        let deform = deformArray;
        for (let w2 = offset, b2 = skip * 3, f2 = skip << 1; w2 < count2; w2 += stride) {
          let wx = 0, wy = 0;
          let n2 = bones[v2++];
          n2 += v2;
          for (; v2 < n2; v2++, b2 += 3, f2 += 2) {
            let bone = skeletonBones[bones[v2]];
            let vx2 = vertices[b2] + deform[f2], vy2 = vertices[b2 + 1] + deform[f2 + 1], weight = vertices[b2 + 2];
            wx += (vx2 * bone.a + vy2 * bone.b + bone.worldX) * weight;
            wy += (vx2 * bone.c + vy2 * bone.d + bone.worldY) * weight;
          }
          worldVertices[w2] = wx;
          worldVertices[w2 + 1] = wy;
        }
      }
    }
    /** Does not copy id (generated) or name (set on construction). **/
    copyTo(attachment) {
      if (this.bones) {
        attachment.bones = new Array(this.bones.length);
        Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
      } else
        attachment.bones = null;
      if (this.vertices) {
        attachment.vertices = Utils.newFloatArray(this.vertices.length);
        Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
      }
      attachment.worldVerticesLength = this.worldVerticesLength;
      attachment.timelineAttachment = this.timelineAttachment;
    }
  };
  __publicField(_VertexAttachment, "nextID", 0);
  var VertexAttachment = _VertexAttachment;

  // node_modules/@esotericsoftware/spine-core/dist/attachments/Sequence.js
  var _Sequence = class _Sequence {
    constructor(count2) {
      __publicField(this, "id", _Sequence.nextID());
      __publicField(this, "regions");
      __publicField(this, "start", 0);
      __publicField(this, "digits", 0);
      /** The index of the region to show for the setup pose. */
      __publicField(this, "setupIndex", 0);
      this.regions = new Array(count2);
    }
    copy() {
      let copy = new _Sequence(this.regions.length);
      Utils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);
      copy.start = this.start;
      copy.digits = this.digits;
      copy.setupIndex = this.setupIndex;
      return copy;
    }
    apply(slot, attachment) {
      let index = slot.sequenceIndex;
      if (index == -1)
        index = this.setupIndex;
      if (index >= this.regions.length)
        index = this.regions.length - 1;
      let region = this.regions[index];
      if (attachment.region != region) {
        attachment.region = region;
        attachment.updateRegion();
      }
    }
    getPath(basePath, index) {
      let result = basePath;
      let frame = (this.start + index).toString();
      for (let i3 = this.digits - frame.length; i3 > 0; i3--)
        result += "0";
      result += frame;
      return result;
    }
    static nextID() {
      return _Sequence._nextID++;
    }
  };
  __publicField(_Sequence, "_nextID", 0);
  var Sequence = _Sequence;
  var SequenceMode;
  (function(SequenceMode2) {
    SequenceMode2[SequenceMode2["hold"] = 0] = "hold";
    SequenceMode2[SequenceMode2["once"] = 1] = "once";
    SequenceMode2[SequenceMode2["loop"] = 2] = "loop";
    SequenceMode2[SequenceMode2["pingpong"] = 3] = "pingpong";
    SequenceMode2[SequenceMode2["onceReverse"] = 4] = "onceReverse";
    SequenceMode2[SequenceMode2["loopReverse"] = 5] = "loopReverse";
    SequenceMode2[SequenceMode2["pingpongReverse"] = 6] = "pingpongReverse";
  })(SequenceMode || (SequenceMode = {}));
  var SequenceModeValues = [
    SequenceMode.hold,
    SequenceMode.once,
    SequenceMode.loop,
    SequenceMode.pingpong,
    SequenceMode.onceReverse,
    SequenceMode.loopReverse,
    SequenceMode.pingpongReverse
  ];

  // node_modules/@esotericsoftware/spine-core/dist/Animation.js
  var Animation2 = class {
    constructor(name, timelines, duration) {
      /** The animation's name, which is unique across all animations in the skeleton. */
      __publicField(this, "name");
      __publicField(this, "timelines", []);
      __publicField(this, "timelineIds", new StringSet());
      /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */
      __publicField(this, "duration");
      if (!name)
        throw new Error("name cannot be null.");
      this.name = name;
      this.setTimelines(timelines);
      this.duration = duration;
    }
    setTimelines(timelines) {
      if (!timelines)
        throw new Error("timelines cannot be null.");
      this.timelines = timelines;
      this.timelineIds.clear();
      for (var i3 = 0; i3 < timelines.length; i3++)
        this.timelineIds.addAll(timelines[i3].getPropertyIds());
    }
    hasTimeline(ids) {
      for (let i3 = 0; i3 < ids.length; i3++)
        if (this.timelineIds.contains(ids[i3]))
          return true;
      return false;
    }
    /** Applies all the animation's timelines to the specified skeleton.
     *
     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.
     * @param loop If true, the animation repeats after {@link #getDuration()}.
     * @param events May be null to ignore fired events. */
    apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      if (loop && this.duration != 0) {
        time %= this.duration;
        if (lastTime > 0)
          lastTime %= this.duration;
      }
      let timelines = this.timelines;
      for (let i3 = 0, n2 = timelines.length; i3 < n2; i3++)
        timelines[i3].apply(skeleton, lastTime, time, events, alpha, blend, direction);
    }
  };
  var MixBlend;
  (function(MixBlend2) {
    MixBlend2[MixBlend2["setup"] = 0] = "setup";
    MixBlend2[MixBlend2["first"] = 1] = "first";
    MixBlend2[MixBlend2["replace"] = 2] = "replace";
    MixBlend2[MixBlend2["add"] = 3] = "add";
  })(MixBlend || (MixBlend = {}));
  var MixDirection;
  (function(MixDirection2) {
    MixDirection2[MixDirection2["mixIn"] = 0] = "mixIn";
    MixDirection2[MixDirection2["mixOut"] = 1] = "mixOut";
  })(MixDirection || (MixDirection = {}));
  var Property = {
    rotate: 0,
    x: 1,
    y: 2,
    scaleX: 3,
    scaleY: 4,
    shearX: 5,
    shearY: 6,
    inherit: 7,
    rgb: 8,
    alpha: 9,
    rgb2: 10,
    attachment: 11,
    deform: 12,
    event: 13,
    drawOrder: 14,
    ikConstraint: 15,
    transformConstraint: 16,
    pathConstraintPosition: 17,
    pathConstraintSpacing: 18,
    pathConstraintMix: 19,
    physicsConstraintInertia: 20,
    physicsConstraintStrength: 21,
    physicsConstraintDamping: 22,
    physicsConstraintMass: 23,
    physicsConstraintWind: 24,
    physicsConstraintGravity: 25,
    physicsConstraintMix: 26,
    physicsConstraintReset: 27,
    sequence: 28
  };
  var Timeline2 = class {
    constructor(frameCount, propertyIds) {
      __publicField(this, "propertyIds");
      __publicField(this, "frames");
      this.propertyIds = propertyIds;
      this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());
    }
    getPropertyIds() {
      return this.propertyIds;
    }
    getFrameEntries() {
      return 1;
    }
    getFrameCount() {
      return this.frames.length / this.getFrameEntries();
    }
    getDuration() {
      return this.frames[this.frames.length - this.getFrameEntries()];
    }
    static search1(frames, time) {
      let n2 = frames.length;
      for (let i3 = 1; i3 < n2; i3++)
        if (frames[i3] > time)
          return i3 - 1;
      return n2 - 1;
    }
    static search(frames, time, step) {
      let n2 = frames.length;
      for (let i3 = step; i3 < n2; i3 += step)
        if (frames[i3] > time)
          return i3 - step;
      return n2 - step;
    }
  };
  var CurveTimeline = class extends Timeline2 {
    // type, x, y, ...
    constructor(frameCount, bezierCount, propertyIds) {
      super(frameCount, propertyIds);
      __publicField(this, "curves");
      this.curves = Utils.newFloatArray(
        frameCount + bezierCount * 18
        /*BEZIER_SIZE*/
      );
      this.curves[frameCount - 1] = 1;
    }
    /** Sets the specified key frame to linear interpolation. */
    setLinear(frame) {
      this.curves[frame] = 0;
    }
    /** Sets the specified key frame to stepped interpolation. */
    setStepped(frame) {
      this.curves[frame] = 1;
    }
    /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger
     * than the actual number of Bezier curves. */
    shrink(bezierCount) {
      let size = this.getFrameCount() + bezierCount * 18;
      if (this.curves.length > size) {
        let newCurves = Utils.newFloatArray(size);
        Utils.arrayCopy(this.curves, 0, newCurves, 0, size);
        this.curves = newCurves;
      }
    }
    /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than
     * one curve per frame.
     * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified
     *           in the constructor), inclusive.
     * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.
     * @param value The index of the value for this frame that this curve is used for.
     * @param time1 The time for the first key.
     * @param value1 The value for the first key.
     * @param cx1 The time for the first Bezier handle.
     * @param cy1 The value for the first Bezier handle.
     * @param cx2 The time of the second Bezier handle.
     * @param cy2 The value for the second Bezier handle.
     * @param time2 The time for the second key.
     * @param value2 The value for the second key. */
    setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
      let curves = this.curves;
      let i3 = this.getFrameCount() + bezier * 18;
      if (value == 0)
        curves[frame] = 2 + i3;
      let tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = (value1 - cy1 * 2 + cy2) * 0.03;
      let dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3, dddy = ((cy1 - cy2) * 3 - value1 + value2) * 6e-3;
      let ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;
      let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;
      let x2 = time1 + dx, y2 = value1 + dy;
      for (let n2 = i3 + 18; i3 < n2; i3 += 2) {
        curves[i3] = x2;
        curves[i3 + 1] = y2;
        dx += ddx;
        dy += ddy;
        ddx += dddx;
        ddy += dddy;
        x2 += dx;
        y2 += dy;
      }
    }
    /** Returns the Bezier interpolated value for the specified time.
     * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.
     * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.
     * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */
    getBezierValue(time, frameIndex, valueOffset, i3) {
      let curves = this.curves;
      if (curves[i3] > time) {
        let x3 = this.frames[frameIndex], y3 = this.frames[frameIndex + valueOffset];
        return y3 + (time - x3) / (curves[i3] - x3) * (curves[i3 + 1] - y3);
      }
      let n2 = i3 + 18;
      for (i3 += 2; i3 < n2; i3 += 2) {
        if (curves[i3] >= time) {
          let x3 = curves[i3 - 2], y3 = curves[i3 - 1];
          return y3 + (time - x3) / (curves[i3] - x3) * (curves[i3 + 1] - y3);
        }
      }
      frameIndex += this.getFrameEntries();
      let x2 = curves[n2 - 2], y2 = curves[n2 - 1];
      return y2 + (time - x2) / (this.frames[frameIndex] - x2) * (this.frames[frameIndex + valueOffset] - y2);
    }
  };
  var CurveTimeline1 = class extends CurveTimeline {
    constructor(frameCount, bezierCount, propertyId) {
      super(frameCount, bezierCount, [propertyId]);
    }
    getFrameEntries() {
      return 2;
    }
    /** Sets the time and value for the specified frame.
     * @param frame Between 0 and <code>frameCount</code>, inclusive.
     * @param time The frame time in seconds. */
    setFrame(frame, time, value) {
      frame <<= 1;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*VALUE*/
      ] = value;
    }
    /** Returns the interpolated value for the specified time. */
    getCurveValue(time) {
      let frames = this.frames;
      let i3 = frames.length - 2;
      for (let ii = 2; ii <= i3; ii += 2) {
        if (frames[ii] > time) {
          i3 = ii - 2;
          break;
        }
      }
      let curveType = this.curves[i3 >> 1];
      switch (curveType) {
        case 0:
          let before = frames[i3], value = frames[
            i3 + 1
            /*VALUE*/
          ];
          return value + (time - before) / (frames[
            i3 + 2
            /*ENTRIES*/
          ] - before) * (frames[
            i3 + 2 + 1
            /*VALUE*/
          ] - value);
        case 1:
          return frames[
            i3 + 1
            /*VALUE*/
          ];
      }
      return this.getBezierValue(
        time,
        i3,
        1,
        curveType - 2
        /*BEZIER*/
      );
    }
    getRelativeValue(time, alpha, blend, current, setup) {
      if (time < this.frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            return setup;
          case MixBlend.first:
            return current + (setup - current) * alpha;
        }
        return current;
      }
      let value = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          return setup + value * alpha;
        case MixBlend.first:
        case MixBlend.replace:
          value += setup - current;
      }
      return current + value * alpha;
    }
    getAbsoluteValue(time, alpha, blend, current, setup) {
      if (time < this.frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            return setup;
          case MixBlend.first:
            return current + (setup - current) * alpha;
        }
        return current;
      }
      let value = this.getCurveValue(time);
      if (blend == MixBlend.setup)
        return setup + (value - setup) * alpha;
      return current + (value - current) * alpha;
    }
    getAbsoluteValue2(time, alpha, blend, current, setup, value) {
      if (time < this.frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            return setup;
          case MixBlend.first:
            return current + (setup - current) * alpha;
        }
        return current;
      }
      if (blend == MixBlend.setup)
        return setup + (value - setup) * alpha;
      return current + (value - current) * alpha;
    }
    getScaleValue(time, alpha, blend, direction, current, setup) {
      const frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            return setup;
          case MixBlend.first:
            return current + (setup - current) * alpha;
        }
        return current;
      }
      let value = this.getCurveValue(time) * setup;
      if (alpha == 1) {
        if (blend == MixBlend.add)
          return current + value - setup;
        return value;
      }
      if (direction == MixDirection.mixOut) {
        switch (blend) {
          case MixBlend.setup:
            return setup + (Math.abs(value) * MathUtils.signum(setup) - setup) * alpha;
          case MixBlend.first:
          case MixBlend.replace:
            return current + (Math.abs(value) * MathUtils.signum(current) - current) * alpha;
        }
      } else {
        let s2 = 0;
        switch (blend) {
          case MixBlend.setup:
            s2 = Math.abs(setup) * MathUtils.signum(value);
            return s2 + (value - s2) * alpha;
          case MixBlend.first:
          case MixBlend.replace:
            s2 = Math.abs(current) * MathUtils.signum(value);
            return s2 + (value - s2) * alpha;
        }
      }
      return current + (value - setup) * alpha;
    }
  };
  var CurveTimeline2 = class extends CurveTimeline {
    /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.
     * @param propertyIds Unique identifiers for the properties the timeline modifies. */
    constructor(frameCount, bezierCount, propertyId1, propertyId2) {
      super(frameCount, bezierCount, [propertyId1, propertyId2]);
    }
    getFrameEntries() {
      return 3;
    }
    /** Sets the time and values for the specified frame.
     * @param frame Between 0 and <code>frameCount</code>, inclusive.
     * @param time The frame time in seconds. */
    setFrame(frame, time, value1, value2) {
      frame *= 3;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*VALUE1*/
      ] = value1;
      this.frames[
        frame + 2
        /*VALUE2*/
      ] = value2;
    }
  };
  var RotateTimeline = class extends CurveTimeline1 {
    constructor(frameCount, bezierCount, boneIndex) {
      super(frameCount, bezierCount, Property.rotate + "|" + boneIndex);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (bone.active)
        bone.rotation = this.getRelativeValue(time, alpha, blend, bone.rotation, bone.data.rotation);
    }
  };
  var TranslateTimeline = class extends CurveTimeline2 {
    constructor(frameCount, bezierCount, boneIndex) {
      super(frameCount, bezierCount, Property.x + "|" + boneIndex, Property.y + "|" + boneIndex);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      let frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.x = bone.data.x;
            bone.y = bone.data.y;
            return;
          case MixBlend.first:
            bone.x += (bone.data.x - bone.x) * alpha;
            bone.y += (bone.data.y - bone.y) * alpha;
        }
        return;
      }
      let x2 = 0, y2 = 0;
      let i3 = Timeline2.search(
        frames,
        time,
        3
        /*ENTRIES*/
      );
      let curveType = this.curves[
        i3 / 3
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          let before = frames[i3];
          x2 = frames[
            i3 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i3 + 2
            /*VALUE2*/
          ];
          let t2 = (time - before) / (frames[
            i3 + 3
            /*ENTRIES*/
          ] - before);
          x2 += (frames[
            i3 + 3 + 1
            /*VALUE1*/
          ] - x2) * t2;
          y2 += (frames[
            i3 + 3 + 2
            /*VALUE2*/
          ] - y2) * t2;
          break;
        case 1:
          x2 = frames[
            i3 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i3 + 2
            /*VALUE2*/
          ];
          break;
        default:
          x2 = this.getBezierValue(
            time,
            i3,
            1,
            curveType - 2
            /*BEZIER*/
          );
          y2 = this.getBezierValue(
            time,
            i3,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x + x2 * alpha;
          bone.y = bone.data.y + y2 * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.x += (bone.data.x + x2 - bone.x) * alpha;
          bone.y += (bone.data.y + y2 - bone.y) * alpha;
          break;
        case MixBlend.add:
          bone.x += x2 * alpha;
          bone.y += y2 * alpha;
      }
    }
  };
  var TranslateXTimeline = class extends CurveTimeline1 {
    constructor(frameCount, bezierCount, boneIndex) {
      super(frameCount, bezierCount, Property.x + "|" + boneIndex);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (bone.active)
        bone.x = this.getRelativeValue(time, alpha, blend, bone.x, bone.data.x);
    }
  };
  var TranslateYTimeline = class extends CurveTimeline1 {
    constructor(frameCount, bezierCount, boneIndex) {
      super(frameCount, bezierCount, Property.y + "|" + boneIndex);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (bone.active)
        bone.y = this.getRelativeValue(time, alpha, blend, bone.y, bone.data.y);
    }
  };
  var ScaleTimeline = class extends CurveTimeline2 {
    constructor(frameCount, bezierCount, boneIndex) {
      super(frameCount, bezierCount, Property.scaleX + "|" + boneIndex, Property.scaleY + "|" + boneIndex);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      let frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleX = bone.data.scaleX;
            bone.scaleY = bone.data.scaleY;
            return;
          case MixBlend.first:
            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
        }
        return;
      }
      let x2, y2;
      let i3 = Timeline2.search(
        frames,
        time,
        3
        /*ENTRIES*/
      );
      let curveType = this.curves[
        i3 / 3
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          let before = frames[i3];
          x2 = frames[
            i3 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i3 + 2
            /*VALUE2*/
          ];
          let t2 = (time - before) / (frames[
            i3 + 3
            /*ENTRIES*/
          ] - before);
          x2 += (frames[
            i3 + 3 + 1
            /*VALUE1*/
          ] - x2) * t2;
          y2 += (frames[
            i3 + 3 + 2
            /*VALUE2*/
          ] - y2) * t2;
          break;
        case 1:
          x2 = frames[
            i3 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i3 + 2
            /*VALUE2*/
          ];
          break;
        default:
          x2 = this.getBezierValue(
            time,
            i3,
            1,
            curveType - 2
            /*BEZIER*/
          );
          y2 = this.getBezierValue(
            time,
            i3,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      x2 *= bone.data.scaleX;
      y2 *= bone.data.scaleY;
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          bone.scaleX += x2 - bone.data.scaleX;
          bone.scaleY += y2 - bone.data.scaleY;
        } else {
          bone.scaleX = x2;
          bone.scaleY = y2;
        }
      } else {
        let bx = 0, by = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              bx = bone.data.scaleX;
              by = bone.data.scaleY;
              bone.scaleX = bx + (Math.abs(x2) * MathUtils.signum(bx) - bx) * alpha;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - by) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x2) * MathUtils.signum(bx) - bx) * alpha;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - by) * alpha;
              break;
            case MixBlend.add:
              bone.scaleX += (x2 - bone.data.scaleX) * alpha;
              bone.scaleY += (y2 - bone.data.scaleY) * alpha;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x2);
              by = Math.abs(bone.data.scaleY) * MathUtils.signum(y2);
              bone.scaleX = bx + (x2 - bx) * alpha;
              bone.scaleY = by + (y2 - by) * alpha;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = Math.abs(bone.scaleX) * MathUtils.signum(x2);
              by = Math.abs(bone.scaleY) * MathUtils.signum(y2);
              bone.scaleX = bx + (x2 - bx) * alpha;
              bone.scaleY = by + (y2 - by) * alpha;
              break;
            case MixBlend.add:
              bone.scaleX += (x2 - bone.data.scaleX) * alpha;
              bone.scaleY += (y2 - bone.data.scaleY) * alpha;
          }
        }
      }
    }
  };
  var ScaleXTimeline = class extends CurveTimeline1 {
    constructor(frameCount, bezierCount, boneIndex) {
      super(frameCount, bezierCount, Property.scaleX + "|" + boneIndex);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (bone.active)
        bone.scaleX = this.getScaleValue(time, alpha, blend, direction, bone.scaleX, bone.data.scaleX);
    }
  };
  var ScaleYTimeline = class extends CurveTimeline1 {
    constructor(frameCount, bezierCount, boneIndex) {
      super(frameCount, bezierCount, Property.scaleY + "|" + boneIndex);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (bone.active)
        bone.scaleY = this.getScaleValue(time, alpha, blend, direction, bone.scaleY, bone.data.scaleY);
    }
  };
  var ShearTimeline = class extends CurveTimeline2 {
    constructor(frameCount, bezierCount, boneIndex) {
      super(frameCount, bezierCount, Property.shearX + "|" + boneIndex, Property.shearY + "|" + boneIndex);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      let frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearX = bone.data.shearX;
            bone.shearY = bone.data.shearY;
            return;
          case MixBlend.first:
            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
        }
        return;
      }
      let x2 = 0, y2 = 0;
      let i3 = Timeline2.search(
        frames,
        time,
        3
        /*ENTRIES*/
      );
      let curveType = this.curves[
        i3 / 3
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          let before = frames[i3];
          x2 = frames[
            i3 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i3 + 2
            /*VALUE2*/
          ];
          let t2 = (time - before) / (frames[
            i3 + 3
            /*ENTRIES*/
          ] - before);
          x2 += (frames[
            i3 + 3 + 1
            /*VALUE1*/
          ] - x2) * t2;
          y2 += (frames[
            i3 + 3 + 2
            /*VALUE2*/
          ] - y2) * t2;
          break;
        case 1:
          x2 = frames[
            i3 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i3 + 2
            /*VALUE2*/
          ];
          break;
        default:
          x2 = this.getBezierValue(
            time,
            i3,
            1,
            curveType - 2
            /*BEZIER*/
          );
          y2 = this.getBezierValue(
            time,
            i3,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX + x2 * alpha;
          bone.shearY = bone.data.shearY + y2 * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearX += (bone.data.shearX + x2 - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY + y2 - bone.shearY) * alpha;
          break;
        case MixBlend.add:
          bone.shearX += x2 * alpha;
          bone.shearY += y2 * alpha;
      }
    }
  };
  var ShearXTimeline = class extends CurveTimeline1 {
    constructor(frameCount, bezierCount, boneIndex) {
      super(frameCount, bezierCount, Property.shearX + "|" + boneIndex);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (bone.active)
        bone.shearX = this.getRelativeValue(time, alpha, blend, bone.shearX, bone.data.shearX);
    }
  };
  var ShearYTimeline = class extends CurveTimeline1 {
    constructor(frameCount, bezierCount, boneIndex) {
      super(frameCount, bezierCount, Property.shearY + "|" + boneIndex);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (bone.active)
        bone.shearY = this.getRelativeValue(time, alpha, blend, bone.shearY, bone.data.shearY);
    }
  };
  var InheritTimeline = class extends Timeline2 {
    constructor(frameCount, boneIndex) {
      super(frameCount, [Property.inherit + "|" + boneIndex]);
      __publicField(this, "boneIndex", 0);
      this.boneIndex = boneIndex;
    }
    getFrameEntries() {
      return 2;
    }
    /** Sets the transform mode for the specified frame.
     * @param frame Between 0 and <code>frameCount</code>, inclusive.
     * @param time The frame time in seconds. */
    setFrame(frame, time, inherit) {
      frame *= 2;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*INHERIT*/
      ] = inherit;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      if (direction == MixDirection.mixOut) {
        if (blend == MixBlend.setup)
          bone.inherit = bone.data.inherit;
        return;
      }
      let frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          bone.inherit = bone.data.inherit;
        return;
      }
      bone.inherit = this.frames[
        Timeline2.search(
          frames,
          time,
          2
          /*ENTRIES*/
        ) + 1
        /*INHERIT*/
      ];
    }
  };
  var RGBATimeline = class extends CurveTimeline {
    constructor(frameCount, bezierCount, slotIndex) {
      super(frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex,
        Property.alpha + "|" + slotIndex
      ]);
      __publicField(this, "slotIndex", 0);
      this.slotIndex = slotIndex;
    }
    getFrameEntries() {
      return 5;
    }
    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
    setFrame(frame, time, r2, g2, b2, a2) {
      frame *= 5;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*R*/
      ] = r2;
      this.frames[
        frame + 2
        /*G*/
      ] = g2;
      this.frames[
        frame + 3
        /*B*/
      ] = b2;
      this.frames[
        frame + 4
        /*A*/
      ] = a2;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      let frames = this.frames;
      let color = slot.color;
      if (time < frames[0]) {
        let setup = slot.data.color;
        switch (blend) {
          case MixBlend.setup:
            color.setFromColor(setup);
            return;
          case MixBlend.first:
            color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
        }
        return;
      }
      let r2 = 0, g2 = 0, b2 = 0, a2 = 0;
      let i3 = Timeline2.search(
        frames,
        time,
        5
        /*ENTRIES*/
      );
      let curveType = this.curves[
        i3 / 5
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          let before = frames[i3];
          r2 = frames[
            i3 + 1
            /*R*/
          ];
          g2 = frames[
            i3 + 2
            /*G*/
          ];
          b2 = frames[
            i3 + 3
            /*B*/
          ];
          a2 = frames[
            i3 + 4
            /*A*/
          ];
          let t2 = (time - before) / (frames[
            i3 + 5
            /*ENTRIES*/
          ] - before);
          r2 += (frames[
            i3 + 5 + 1
            /*R*/
          ] - r2) * t2;
          g2 += (frames[
            i3 + 5 + 2
            /*G*/
          ] - g2) * t2;
          b2 += (frames[
            i3 + 5 + 3
            /*B*/
          ] - b2) * t2;
          a2 += (frames[
            i3 + 5 + 4
            /*A*/
          ] - a2) * t2;
          break;
        case 1:
          r2 = frames[
            i3 + 1
            /*R*/
          ];
          g2 = frames[
            i3 + 2
            /*G*/
          ];
          b2 = frames[
            i3 + 3
            /*B*/
          ];
          a2 = frames[
            i3 + 4
            /*A*/
          ];
          break;
        default:
          r2 = this.getBezierValue(
            time,
            i3,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g2 = this.getBezierValue(
            time,
            i3,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b2 = this.getBezierValue(
            time,
            i3,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          a2 = this.getBezierValue(
            time,
            i3,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
      }
      if (alpha == 1)
        color.set(r2, g2, b2, a2);
      else {
        if (blend == MixBlend.setup)
          color.setFromColor(slot.data.color);
        color.add((r2 - color.r) * alpha, (g2 - color.g) * alpha, (b2 - color.b) * alpha, (a2 - color.a) * alpha);
      }
    }
  };
  var RGBTimeline = class extends CurveTimeline {
    constructor(frameCount, bezierCount, slotIndex) {
      super(frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex
      ]);
      __publicField(this, "slotIndex", 0);
      this.slotIndex = slotIndex;
    }
    getFrameEntries() {
      return 4;
    }
    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
    setFrame(frame, time, r2, g2, b2) {
      frame <<= 2;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*R*/
      ] = r2;
      this.frames[
        frame + 2
        /*G*/
      ] = g2;
      this.frames[
        frame + 3
        /*B*/
      ] = b2;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      let frames = this.frames;
      let color = slot.color;
      if (time < frames[0]) {
        let setup = slot.data.color;
        switch (blend) {
          case MixBlend.setup:
            color.r = setup.r;
            color.g = setup.g;
            color.b = setup.b;
            return;
          case MixBlend.first:
            color.r += (setup.r - color.r) * alpha;
            color.g += (setup.g - color.g) * alpha;
            color.b += (setup.b - color.b) * alpha;
        }
        return;
      }
      let r2 = 0, g2 = 0, b2 = 0;
      let i3 = Timeline2.search(
        frames,
        time,
        4
        /*ENTRIES*/
      );
      let curveType = this.curves[i3 >> 2];
      switch (curveType) {
        case 0:
          let before = frames[i3];
          r2 = frames[
            i3 + 1
            /*R*/
          ];
          g2 = frames[
            i3 + 2
            /*G*/
          ];
          b2 = frames[
            i3 + 3
            /*B*/
          ];
          let t2 = (time - before) / (frames[
            i3 + 4
            /*ENTRIES*/
          ] - before);
          r2 += (frames[
            i3 + 4 + 1
            /*R*/
          ] - r2) * t2;
          g2 += (frames[
            i3 + 4 + 2
            /*G*/
          ] - g2) * t2;
          b2 += (frames[
            i3 + 4 + 3
            /*B*/
          ] - b2) * t2;
          break;
        case 1:
          r2 = frames[
            i3 + 1
            /*R*/
          ];
          g2 = frames[
            i3 + 2
            /*G*/
          ];
          b2 = frames[
            i3 + 3
            /*B*/
          ];
          break;
        default:
          r2 = this.getBezierValue(
            time,
            i3,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g2 = this.getBezierValue(
            time,
            i3,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b2 = this.getBezierValue(
            time,
            i3,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
      }
      if (alpha == 1) {
        color.r = r2;
        color.g = g2;
        color.b = b2;
      } else {
        if (blend == MixBlend.setup) {
          let setup = slot.data.color;
          color.r = setup.r;
          color.g = setup.g;
          color.b = setup.b;
        }
        color.r += (r2 - color.r) * alpha;
        color.g += (g2 - color.g) * alpha;
        color.b += (b2 - color.b) * alpha;
      }
    }
  };
  var AlphaTimeline = class extends CurveTimeline1 {
    constructor(frameCount, bezierCount, slotIndex) {
      super(frameCount, bezierCount, Property.alpha + "|" + slotIndex);
      __publicField(this, "slotIndex", 0);
      this.slotIndex = slotIndex;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      let color = slot.color;
      if (time < this.frames[0]) {
        let setup = slot.data.color;
        switch (blend) {
          case MixBlend.setup:
            color.a = setup.a;
            return;
          case MixBlend.first:
            color.a += (setup.a - color.a) * alpha;
        }
        return;
      }
      let a2 = this.getCurveValue(time);
      if (alpha == 1)
        color.a = a2;
      else {
        if (blend == MixBlend.setup)
          color.a = slot.data.color.a;
        color.a += (a2 - color.a) * alpha;
      }
    }
  };
  var RGBA2Timeline = class extends CurveTimeline {
    constructor(frameCount, bezierCount, slotIndex) {
      super(frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex,
        Property.alpha + "|" + slotIndex,
        Property.rgb2 + "|" + slotIndex
      ]);
      __publicField(this, "slotIndex", 0);
      this.slotIndex = slotIndex;
    }
    getFrameEntries() {
      return 8;
    }
    /** Sets the time in seconds, light, and dark colors for the specified key frame. */
    setFrame(frame, time, r2, g2, b2, a2, r22, g22, b22) {
      frame <<= 3;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*R*/
      ] = r2;
      this.frames[
        frame + 2
        /*G*/
      ] = g2;
      this.frames[
        frame + 3
        /*B*/
      ] = b2;
      this.frames[
        frame + 4
        /*A*/
      ] = a2;
      this.frames[
        frame + 5
        /*R2*/
      ] = r22;
      this.frames[
        frame + 6
        /*G2*/
      ] = g22;
      this.frames[
        frame + 7
        /*B2*/
      ] = b22;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      let frames = this.frames;
      let light = slot.color, dark = slot.darkColor;
      if (time < frames[0]) {
        let setupLight = slot.data.color, setupDark = slot.data.darkColor;
        switch (blend) {
          case MixBlend.setup:
            light.setFromColor(setupLight);
            dark.r = setupDark.r;
            dark.g = setupDark.g;
            dark.b = setupDark.b;
            return;
          case MixBlend.first:
            light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
            dark.r += (setupDark.r - dark.r) * alpha;
            dark.g += (setupDark.g - dark.g) * alpha;
            dark.b += (setupDark.b - dark.b) * alpha;
        }
        return;
      }
      let r2 = 0, g2 = 0, b2 = 0, a2 = 0, r22 = 0, g22 = 0, b22 = 0;
      let i3 = Timeline2.search(
        frames,
        time,
        8
        /*ENTRIES*/
      );
      let curveType = this.curves[i3 >> 3];
      switch (curveType) {
        case 0:
          let before = frames[i3];
          r2 = frames[
            i3 + 1
            /*R*/
          ];
          g2 = frames[
            i3 + 2
            /*G*/
          ];
          b2 = frames[
            i3 + 3
            /*B*/
          ];
          a2 = frames[
            i3 + 4
            /*A*/
          ];
          r22 = frames[
            i3 + 5
            /*R2*/
          ];
          g22 = frames[
            i3 + 6
            /*G2*/
          ];
          b22 = frames[
            i3 + 7
            /*B2*/
          ];
          let t2 = (time - before) / (frames[
            i3 + 8
            /*ENTRIES*/
          ] - before);
          r2 += (frames[
            i3 + 8 + 1
            /*R*/
          ] - r2) * t2;
          g2 += (frames[
            i3 + 8 + 2
            /*G*/
          ] - g2) * t2;
          b2 += (frames[
            i3 + 8 + 3
            /*B*/
          ] - b2) * t2;
          a2 += (frames[
            i3 + 8 + 4
            /*A*/
          ] - a2) * t2;
          r22 += (frames[
            i3 + 8 + 5
            /*R2*/
          ] - r22) * t2;
          g22 += (frames[
            i3 + 8 + 6
            /*G2*/
          ] - g22) * t2;
          b22 += (frames[
            i3 + 8 + 7
            /*B2*/
          ] - b22) * t2;
          break;
        case 1:
          r2 = frames[
            i3 + 1
            /*R*/
          ];
          g2 = frames[
            i3 + 2
            /*G*/
          ];
          b2 = frames[
            i3 + 3
            /*B*/
          ];
          a2 = frames[
            i3 + 4
            /*A*/
          ];
          r22 = frames[
            i3 + 5
            /*R2*/
          ];
          g22 = frames[
            i3 + 6
            /*G2*/
          ];
          b22 = frames[
            i3 + 7
            /*B2*/
          ];
          break;
        default:
          r2 = this.getBezierValue(
            time,
            i3,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g2 = this.getBezierValue(
            time,
            i3,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b2 = this.getBezierValue(
            time,
            i3,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          a2 = this.getBezierValue(
            time,
            i3,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
          r22 = this.getBezierValue(
            time,
            i3,
            5,
            curveType + 18 * 4 - 2
            /*BEZIER*/
          );
          g22 = this.getBezierValue(
            time,
            i3,
            6,
            curveType + 18 * 5 - 2
            /*BEZIER*/
          );
          b22 = this.getBezierValue(
            time,
            i3,
            7,
            curveType + 18 * 6 - 2
            /*BEZIER*/
          );
      }
      if (alpha == 1) {
        light.set(r2, g2, b2, a2);
        dark.r = r22;
        dark.g = g22;
        dark.b = b22;
      } else {
        if (blend == MixBlend.setup) {
          light.setFromColor(slot.data.color);
          let setupDark = slot.data.darkColor;
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
        }
        light.add((r2 - light.r) * alpha, (g2 - light.g) * alpha, (b2 - light.b) * alpha, (a2 - light.a) * alpha);
        dark.r += (r22 - dark.r) * alpha;
        dark.g += (g22 - dark.g) * alpha;
        dark.b += (b22 - dark.b) * alpha;
      }
    }
  };
  var RGB2Timeline = class extends CurveTimeline {
    constructor(frameCount, bezierCount, slotIndex) {
      super(frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex,
        Property.rgb2 + "|" + slotIndex
      ]);
      __publicField(this, "slotIndex", 0);
      this.slotIndex = slotIndex;
    }
    getFrameEntries() {
      return 7;
    }
    /** Sets the time in seconds, light, and dark colors for the specified key frame. */
    setFrame(frame, time, r2, g2, b2, r22, g22, b22) {
      frame *= 7;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*R*/
      ] = r2;
      this.frames[
        frame + 2
        /*G*/
      ] = g2;
      this.frames[
        frame + 3
        /*B*/
      ] = b2;
      this.frames[
        frame + 4
        /*R2*/
      ] = r22;
      this.frames[
        frame + 5
        /*G2*/
      ] = g22;
      this.frames[
        frame + 6
        /*B2*/
      ] = b22;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      let frames = this.frames;
      let light = slot.color, dark = slot.darkColor;
      if (time < frames[0]) {
        let setupLight = slot.data.color, setupDark = slot.data.darkColor;
        switch (blend) {
          case MixBlend.setup:
            light.r = setupLight.r;
            light.g = setupLight.g;
            light.b = setupLight.b;
            dark.r = setupDark.r;
            dark.g = setupDark.g;
            dark.b = setupDark.b;
            return;
          case MixBlend.first:
            light.r += (setupLight.r - light.r) * alpha;
            light.g += (setupLight.g - light.g) * alpha;
            light.b += (setupLight.b - light.b) * alpha;
            dark.r += (setupDark.r - dark.r) * alpha;
            dark.g += (setupDark.g - dark.g) * alpha;
            dark.b += (setupDark.b - dark.b) * alpha;
        }
        return;
      }
      let r2 = 0, g2 = 0, b2 = 0, a2 = 0, r22 = 0, g22 = 0, b22 = 0;
      let i3 = Timeline2.search(
        frames,
        time,
        7
        /*ENTRIES*/
      );
      let curveType = this.curves[
        i3 / 7
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          let before = frames[i3];
          r2 = frames[
            i3 + 1
            /*R*/
          ];
          g2 = frames[
            i3 + 2
            /*G*/
          ];
          b2 = frames[
            i3 + 3
            /*B*/
          ];
          r22 = frames[
            i3 + 4
            /*R2*/
          ];
          g22 = frames[
            i3 + 5
            /*G2*/
          ];
          b22 = frames[
            i3 + 6
            /*B2*/
          ];
          let t2 = (time - before) / (frames[
            i3 + 7
            /*ENTRIES*/
          ] - before);
          r2 += (frames[
            i3 + 7 + 1
            /*R*/
          ] - r2) * t2;
          g2 += (frames[
            i3 + 7 + 2
            /*G*/
          ] - g2) * t2;
          b2 += (frames[
            i3 + 7 + 3
            /*B*/
          ] - b2) * t2;
          r22 += (frames[
            i3 + 7 + 4
            /*R2*/
          ] - r22) * t2;
          g22 += (frames[
            i3 + 7 + 5
            /*G2*/
          ] - g22) * t2;
          b22 += (frames[
            i3 + 7 + 6
            /*B2*/
          ] - b22) * t2;
          break;
        case 1:
          r2 = frames[
            i3 + 1
            /*R*/
          ];
          g2 = frames[
            i3 + 2
            /*G*/
          ];
          b2 = frames[
            i3 + 3
            /*B*/
          ];
          r22 = frames[
            i3 + 4
            /*R2*/
          ];
          g22 = frames[
            i3 + 5
            /*G2*/
          ];
          b22 = frames[
            i3 + 6
            /*B2*/
          ];
          break;
        default:
          r2 = this.getBezierValue(
            time,
            i3,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g2 = this.getBezierValue(
            time,
            i3,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b2 = this.getBezierValue(
            time,
            i3,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          r22 = this.getBezierValue(
            time,
            i3,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
          g22 = this.getBezierValue(
            time,
            i3,
            5,
            curveType + 18 * 4 - 2
            /*BEZIER*/
          );
          b22 = this.getBezierValue(
            time,
            i3,
            6,
            curveType + 18 * 5 - 2
            /*BEZIER*/
          );
      }
      if (alpha == 1) {
        light.r = r2;
        light.g = g2;
        light.b = b2;
        dark.r = r22;
        dark.g = g22;
        dark.b = b22;
      } else {
        if (blend == MixBlend.setup) {
          let setupLight = slot.data.color, setupDark = slot.data.darkColor;
          light.r = setupLight.r;
          light.g = setupLight.g;
          light.b = setupLight.b;
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
        }
        light.r += (r2 - light.r) * alpha;
        light.g += (g2 - light.g) * alpha;
        light.b += (b2 - light.b) * alpha;
        dark.r += (r22 - dark.r) * alpha;
        dark.g += (g22 - dark.g) * alpha;
        dark.b += (b22 - dark.b) * alpha;
      }
    }
  };
  var AttachmentTimeline = class extends Timeline2 {
    constructor(frameCount, slotIndex) {
      super(frameCount, [
        Property.attachment + "|" + slotIndex
      ]);
      __publicField(this, "slotIndex", 0);
      /** The attachment name for each key frame. May contain null values to clear the attachment. */
      __publicField(this, "attachmentNames");
      this.slotIndex = slotIndex;
      this.attachmentNames = new Array(frameCount);
    }
    getFrameCount() {
      return this.frames.length;
    }
    /** Sets the time in seconds and the attachment name for the specified key frame. */
    setFrame(frame, time, attachmentName) {
      this.frames[frame] = time;
      this.attachmentNames[frame] = attachmentName;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      if (direction == MixDirection.mixOut) {
        if (blend == MixBlend.setup)
          this.setAttachment(skeleton, slot, slot.data.attachmentName);
        return;
      }
      if (time < this.frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          this.setAttachment(skeleton, slot, slot.data.attachmentName);
        return;
      }
      this.setAttachment(skeleton, slot, this.attachmentNames[Timeline2.search1(this.frames, time)]);
    }
    setAttachment(skeleton, slot, attachmentName) {
      slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
    }
  };
  var DeformTimeline = class extends CurveTimeline {
    constructor(frameCount, bezierCount, slotIndex, attachment) {
      super(frameCount, bezierCount, [
        Property.deform + "|" + slotIndex + "|" + attachment.id
      ]);
      __publicField(this, "slotIndex", 0);
      /** The attachment that will be deformed. */
      __publicField(this, "attachment");
      /** The vertices for each key frame. */
      __publicField(this, "vertices");
      this.slotIndex = slotIndex;
      this.attachment = attachment;
      this.vertices = new Array(frameCount);
    }
    getFrameCount() {
      return this.frames.length;
    }
    /** Sets the time in seconds and the vertices for the specified key frame.
     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */
    setFrame(frame, time, vertices) {
      this.frames[frame] = time;
      this.vertices[frame] = vertices;
    }
    /** @param value1 Ignored (0 is used for a deform timeline).
     * @param value2 Ignored (1 is used for a deform timeline). */
    setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
      let curves = this.curves;
      let i3 = this.getFrameCount() + bezier * 18;
      if (value == 0)
        curves[frame] = 2 + i3;
      let tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = cy2 * 0.03 - cy1 * 0.06;
      let dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3, dddy = (cy1 - cy2 + 0.33333333) * 0.018;
      let ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;
      let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;
      let x2 = time1 + dx, y2 = dy;
      for (let n2 = i3 + 18; i3 < n2; i3 += 2) {
        curves[i3] = x2;
        curves[i3 + 1] = y2;
        dx += ddx;
        dy += ddy;
        ddx += dddx;
        ddy += dddy;
        x2 += dx;
        y2 += dy;
      }
    }
    getCurvePercent(time, frame) {
      let curves = this.curves;
      let i3 = curves[frame];
      switch (i3) {
        case 0:
          let x3 = this.frames[frame];
          return (time - x3) / (this.frames[frame + this.getFrameEntries()] - x3);
        case 1:
          return 0;
      }
      i3 -= 2;
      if (curves[i3] > time) {
        let x3 = this.frames[frame];
        return curves[i3 + 1] * (time - x3) / (curves[i3] - x3);
      }
      let n2 = i3 + 18;
      for (i3 += 2; i3 < n2; i3 += 2) {
        if (curves[i3] >= time) {
          let x3 = curves[i3 - 2], y3 = curves[i3 - 1];
          return y3 + (time - x3) / (curves[i3] - x3) * (curves[i3 + 1] - y3);
        }
      }
      let x2 = curves[n2 - 2], y2 = curves[n2 - 1];
      return y2 + (1 - y2) * (time - x2) / (this.frames[frame + this.getFrameEntries()] - x2);
    }
    apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      let slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      let slotAttachment = slot.getAttachment();
      if (!slotAttachment)
        return;
      if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.timelineAttachment != this.attachment)
        return;
      let deform = slot.deform;
      if (deform.length == 0)
        blend = MixBlend.setup;
      let vertices = this.vertices;
      let vertexCount = vertices[0].length;
      let frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            deform.length = 0;
            return;
          case MixBlend.first:
            if (alpha == 1) {
              deform.length = 0;
              return;
            }
            deform.length = vertexCount;
            let vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              let setupVertices = vertexAttachment.vertices;
              for (var i3 = 0; i3 < vertexCount; i3++)
                deform[i3] += (setupVertices[i3] - deform[i3]) * alpha;
            } else {
              alpha = 1 - alpha;
              for (var i3 = 0; i3 < vertexCount; i3++)
                deform[i3] *= alpha;
            }
        }
        return;
      }
      deform.length = vertexCount;
      if (time >= frames[frames.length - 1]) {
        let lastVertices = vertices[frames.length - 1];
        if (alpha == 1) {
          if (blend == MixBlend.add) {
            let vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              let setupVertices = vertexAttachment.vertices;
              for (let i4 = 0; i4 < vertexCount; i4++)
                deform[i4] += lastVertices[i4] - setupVertices[i4];
            } else {
              for (let i4 = 0; i4 < vertexCount; i4++)
                deform[i4] += lastVertices[i4];
            }
          } else
            Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
        } else {
          switch (blend) {
            case MixBlend.setup: {
              let vertexAttachment2 = slotAttachment;
              if (!vertexAttachment2.bones) {
                let setupVertices = vertexAttachment2.vertices;
                for (let i4 = 0; i4 < vertexCount; i4++) {
                  let setup = setupVertices[i4];
                  deform[i4] = setup + (lastVertices[i4] - setup) * alpha;
                }
              } else {
                for (let i4 = 0; i4 < vertexCount; i4++)
                  deform[i4] = lastVertices[i4] * alpha;
              }
              break;
            }
            case MixBlend.first:
            case MixBlend.replace:
              for (let i4 = 0; i4 < vertexCount; i4++)
                deform[i4] += (lastVertices[i4] - deform[i4]) * alpha;
              break;
            case MixBlend.add:
              let vertexAttachment = slotAttachment;
              if (!vertexAttachment.bones) {
                let setupVertices = vertexAttachment.vertices;
                for (let i4 = 0; i4 < vertexCount; i4++)
                  deform[i4] += (lastVertices[i4] - setupVertices[i4]) * alpha;
              } else {
                for (let i4 = 0; i4 < vertexCount; i4++)
                  deform[i4] += lastVertices[i4] * alpha;
              }
          }
        }
        return;
      }
      let frame = Timeline2.search1(frames, time);
      let percent = this.getCurvePercent(time, frame);
      let prevVertices = vertices[frame];
      let nextVertices = vertices[frame + 1];
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          let vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            let setupVertices = vertexAttachment.vertices;
            for (let i4 = 0; i4 < vertexCount; i4++) {
              let prev = prevVertices[i4];
              deform[i4] += prev + (nextVertices[i4] - prev) * percent - setupVertices[i4];
            }
          } else {
            for (let i4 = 0; i4 < vertexCount; i4++) {
              let prev = prevVertices[i4];
              deform[i4] += prev + (nextVertices[i4] - prev) * percent;
            }
          }
        } else {
          for (let i4 = 0; i4 < vertexCount; i4++) {
            let prev = prevVertices[i4];
            deform[i4] = prev + (nextVertices[i4] - prev) * percent;
          }
        }
      } else {
        switch (blend) {
          case MixBlend.setup: {
            let vertexAttachment2 = slotAttachment;
            if (!vertexAttachment2.bones) {
              let setupVertices = vertexAttachment2.vertices;
              for (let i4 = 0; i4 < vertexCount; i4++) {
                let prev = prevVertices[i4], setup = setupVertices[i4];
                deform[i4] = setup + (prev + (nextVertices[i4] - prev) * percent - setup) * alpha;
              }
            } else {
              for (let i4 = 0; i4 < vertexCount; i4++) {
                let prev = prevVertices[i4];
                deform[i4] = (prev + (nextVertices[i4] - prev) * percent) * alpha;
              }
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (let i4 = 0; i4 < vertexCount; i4++) {
              let prev = prevVertices[i4];
              deform[i4] += (prev + (nextVertices[i4] - prev) * percent - deform[i4]) * alpha;
            }
            break;
          case MixBlend.add:
            let vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              let setupVertices = vertexAttachment.vertices;
              for (let i4 = 0; i4 < vertexCount; i4++) {
                let prev = prevVertices[i4];
                deform[i4] += (prev + (nextVertices[i4] - prev) * percent - setupVertices[i4]) * alpha;
              }
            } else {
              for (let i4 = 0; i4 < vertexCount; i4++) {
                let prev = prevVertices[i4];
                deform[i4] += (prev + (nextVertices[i4] - prev) * percent) * alpha;
              }
            }
        }
      }
    }
  };
  var _EventTimeline = class _EventTimeline extends Timeline2 {
    constructor(frameCount) {
      super(frameCount, _EventTimeline.propertyIds);
      /** The event for each key frame. */
      __publicField(this, "events");
      this.events = new Array(frameCount);
    }
    getFrameCount() {
      return this.frames.length;
    }
    /** Sets the time in seconds and the event for the specified key frame. */
    setFrame(frame, event) {
      this.frames[frame] = event.time;
      this.events[frame] = event;
    }
    /** Fires events for frames > `lastTime` and <= `time`. */
    apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      if (!firedEvents)
        return;
      let frames = this.frames;
      let frameCount = this.frames.length;
      if (lastTime > time) {
        this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
        lastTime = -1;
      } else if (lastTime >= frames[frameCount - 1])
        return;
      if (time < frames[0])
        return;
      let i3 = 0;
      if (lastTime < frames[0])
        i3 = 0;
      else {
        i3 = Timeline2.search1(frames, lastTime) + 1;
        let frameTime = frames[i3];
        while (i3 > 0) {
          if (frames[i3 - 1] != frameTime)
            break;
          i3--;
        }
      }
      for (; i3 < frameCount && time >= frames[i3]; i3++)
        firedEvents.push(this.events[i3]);
    }
  };
  __publicField(_EventTimeline, "propertyIds", ["" + Property.event]);
  var EventTimeline = _EventTimeline;
  var _DrawOrderTimeline = class _DrawOrderTimeline extends Timeline2 {
    constructor(frameCount) {
      super(frameCount, _DrawOrderTimeline.propertyIds);
      /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */
      __publicField(this, "drawOrders");
      this.drawOrders = new Array(frameCount);
    }
    getFrameCount() {
      return this.frames.length;
    }
    /** Sets the time in seconds and the draw order for the specified key frame.
     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose
     *           draw order. */
    setFrame(frame, time, drawOrder) {
      this.frames[frame] = time;
      this.drawOrders[frame] = drawOrder;
    }
    apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      if (direction == MixDirection.mixOut) {
        if (blend == MixBlend.setup)
          Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      if (time < this.frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      let idx = Timeline2.search1(this.frames, time);
      let drawOrderToSetupIndex = this.drawOrders[idx];
      if (!drawOrderToSetupIndex)
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      else {
        let drawOrder = skeleton.drawOrder;
        let slots = skeleton.slots;
        for (let i3 = 0, n2 = drawOrderToSetupIndex.length; i3 < n2; i3++)
          drawOrder[i3] = slots[drawOrderToSetupIndex[i3]];
      }
    }
  };
  __publicField(_DrawOrderTimeline, "propertyIds", ["" + Property.drawOrder]);
  var DrawOrderTimeline = _DrawOrderTimeline;
  var IkConstraintTimeline = class extends CurveTimeline {
    constructor(frameCount, bezierCount, ikConstraintIndex) {
      super(frameCount, bezierCount, [
        Property.ikConstraint + "|" + ikConstraintIndex
      ]);
      /** The index of the IK constraint in {@link Skeleton#getIkConstraints()} that will be changed when this timeline is applied */
      __publicField(this, "constraintIndex", 0);
      this.constraintIndex = ikConstraintIndex;
    }
    getFrameEntries() {
      return 6;
    }
    /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */
    setFrame(frame, time, mix, softness, bendDirection, compress, stretch) {
      frame *= 6;
      this.frames[frame] = time;
      this.frames[
        frame + 1
        /*MIX*/
      ] = mix;
      this.frames[
        frame + 2
        /*SOFTNESS*/
      ] = softness;
      this.frames[
        frame + 3
        /*BEND_DIRECTION*/
      ] = bendDirection;
      this.frames[
        frame + 4
        /*COMPRESS*/
      ] = compress ? 1 : 0;
      this.frames[
        frame + 5
        /*STRETCH*/
      ] = stretch ? 1 : 0;
    }
    apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      let constraint = skeleton.ikConstraints[this.constraintIndex];
      if (!constraint.active)
        return;
      let frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.mix = constraint.data.mix;
            constraint.softness = constraint.data.softness;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
            return;
          case MixBlend.first:
            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
            constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
        }
        return;
      }
      let mix = 0, softness = 0;
      let i3 = Timeline2.search(
        frames,
        time,
        6
        /*ENTRIES*/
      );
      let curveType = this.curves[
        i3 / 6
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          let before = frames[i3];
          mix = frames[
            i3 + 1
            /*MIX*/
          ];
          softness = frames[
            i3 + 2
            /*SOFTNESS*/
          ];
          let t2 = (time - before) / (frames[
            i3 + 6
            /*ENTRIES*/
          ] - before);
          mix += (frames[
            i3 + 6 + 1
            /*MIX*/
          ] - mix) * t2;
          softness += (frames[
            i3 + 6 + 2
            /*SOFTNESS*/
          ] - softness) * t2;
          break;
        case 1:
          mix = frames[
            i3 + 1
            /*MIX*/
          ];
          softness = frames[
            i3 + 2
            /*SOFTNESS*/
          ];
          break;
        default:
          mix = this.getBezierValue(
            time,
            i3,
            1,
            curveType - 2
            /*BEZIER*/
          );
          softness = this.getBezierValue(
            time,
            i3,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      if (blend == MixBlend.setup) {
        constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;
        constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;
        if (direction == MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[
            i3 + 3
            /*BEND_DIRECTION*/
          ];
          constraint.compress = frames[
            i3 + 4
            /*COMPRESS*/
          ] != 0;
          constraint.stretch = frames[
            i3 + 5
            /*STRETCH*/
          ] != 0;
        }
      } else {
        constraint.mix += (mix - constraint.mix) * alpha;
        constraint.softness += (softness - constraint.softness) * alpha;
        if (direction == MixDirection.mixIn) {
          constraint.bendDirection = frames[
            i3 + 3
            /*BEND_DIRECTION*/
          ];
          constraint.compress = frames[
            i3 + 4
            /*COMPRESS*/
          ] != 0;
          constraint.stretch = frames[
            i3 + 5
            /*STRETCH*/
          ] != 0;
        }
      }
    }
  };
  var TransformConstraintTimeline = class extends CurveTimeline {
    constructor(frameCount, bezierCount, transformConstraintIndex) {
      super(frameCount, bezierCount, [
        Property.transformConstraint + "|" + transformConstraintIndex
      ]);
      /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */
      __publicField(this, "constraintIndex", 0);
      this.constraintIndex = transformConstraintIndex;
    }
    getFrameEntries() {
      return 7;
    }
    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */
    setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {
      let frames = this.frames;
      frame *= 7;
      frames[frame] = time;
      frames[
        frame + 1
        /*ROTATE*/
      ] = mixRotate;
      frames[
        frame + 2
        /*X*/
      ] = mixX;
      frames[
        frame + 3
        /*Y*/
      ] = mixY;
      frames[
        frame + 4
        /*SCALEX*/
      ] = mixScaleX;
      frames[
        frame + 5
        /*SCALEY*/
      ] = mixScaleY;
      frames[
        frame + 6
        /*SHEARY*/
      ] = mixShearY;
    }
    apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      let constraint = skeleton.transformConstraints[this.constraintIndex];
      if (!constraint.active)
        return;
      let frames = this.frames;
      if (time < frames[0]) {
        let data = constraint.data;
        switch (blend) {
          case MixBlend.setup:
            constraint.mixRotate = data.mixRotate;
            constraint.mixX = data.mixX;
            constraint.mixY = data.mixY;
            constraint.mixScaleX = data.mixScaleX;
            constraint.mixScaleY = data.mixScaleY;
            constraint.mixShearY = data.mixShearY;
            return;
          case MixBlend.first:
            constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;
            constraint.mixX += (data.mixX - constraint.mixX) * alpha;
            constraint.mixY += (data.mixY - constraint.mixY) * alpha;
            constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;
            constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;
            constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;
        }
        return;
      }
      let rotate, x2, y2, scaleX, scaleY, shearY;
      let i3 = Timeline2.search(
        frames,
        time,
        7
        /*ENTRIES*/
      );
      let curveType = this.curves[
        i3 / 7
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          let before = frames[i3];
          rotate = frames[
            i3 + 1
            /*ROTATE*/
          ];
          x2 = frames[
            i3 + 2
            /*X*/
          ];
          y2 = frames[
            i3 + 3
            /*Y*/
          ];
          scaleX = frames[
            i3 + 4
            /*SCALEX*/
          ];
          scaleY = frames[
            i3 + 5
            /*SCALEY*/
          ];
          shearY = frames[
            i3 + 6
            /*SHEARY*/
          ];
          let t2 = (time - before) / (frames[
            i3 + 7
            /*ENTRIES*/
          ] - before);
          rotate += (frames[
            i3 + 7 + 1
            /*ROTATE*/
          ] - rotate) * t2;
          x2 += (frames[
            i3 + 7 + 2
            /*X*/
          ] - x2) * t2;
          y2 += (frames[
            i3 + 7 + 3
            /*Y*/
          ] - y2) * t2;
          scaleX += (frames[
            i3 + 7 + 4
            /*SCALEX*/
          ] - scaleX) * t2;
          scaleY += (frames[
            i3 + 7 + 5
            /*SCALEY*/
          ] - scaleY) * t2;
          shearY += (frames[
            i3 + 7 + 6
            /*SHEARY*/
          ] - shearY) * t2;
          break;
        case 1:
          rotate = frames[
            i3 + 1
            /*ROTATE*/
          ];
          x2 = frames[
            i3 + 2
            /*X*/
          ];
          y2 = frames[
            i3 + 3
            /*Y*/
          ];
          scaleX = frames[
            i3 + 4
            /*SCALEX*/
          ];
          scaleY = frames[
            i3 + 5
            /*SCALEY*/
          ];
          shearY = frames[
            i3 + 6
            /*SHEARY*/
          ];
          break;
        default:
          rotate = this.getBezierValue(
            time,
            i3,
            1,
            curveType - 2
            /*BEZIER*/
          );
          x2 = this.getBezierValue(
            time,
            i3,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          y2 = this.getBezierValue(
            time,
            i3,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          scaleX = this.getBezierValue(
            time,
            i3,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
          scaleY = this.getBezierValue(
            time,
            i3,
            5,
            curveType + 18 * 4 - 2
            /*BEZIER*/
          );
          shearY = this.getBezierValue(
            time,
            i3,
            6,
            curveType + 18 * 5 - 2
            /*BEZIER*/
          );
      }
      if (blend == MixBlend.setup) {
        let data = constraint.data;
        constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
        constraint.mixX = data.mixX + (x2 - data.mixX) * alpha;
        constraint.mixY = data.mixY + (y2 - data.mixY) * alpha;
        constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;
        constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;
        constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;
      } else {
        constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
        constraint.mixX += (x2 - constraint.mixX) * alpha;
        constraint.mixY += (y2 - constraint.mixY) * alpha;
        constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;
        constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;
        constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;
      }
    }
  };
  var PathConstraintPositionTimeline = class extends CurveTimeline1 {
    constructor(frameCount, bezierCount, pathConstraintIndex) {
      super(frameCount, bezierCount, Property.pathConstraintPosition + "|" + pathConstraintIndex);
      /** The index of the path constraint in {@link Skeleton#getPathConstraints()} that will be changed when this timeline is
       * applied. */
      __publicField(this, "constraintIndex", 0);
      this.constraintIndex = pathConstraintIndex;
    }
    apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      let constraint = skeleton.pathConstraints[this.constraintIndex];
      if (constraint.active)
        constraint.position = this.getAbsoluteValue(time, alpha, blend, constraint.position, constraint.data.position);
    }
  };
  var PathConstraintSpacingTimeline = class extends CurveTimeline1 {
    constructor(frameCount, bezierCount, pathConstraintIndex) {
      super(frameCount, bezierCount, Property.pathConstraintSpacing + "|" + pathConstraintIndex);
      /** The index of the path constraint in {@link Skeleton#getPathConstraints()} that will be changed when this timeline is
       * applied. */
      __publicField(this, "constraintIndex", 0);
      this.constraintIndex = pathConstraintIndex;
    }
    apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      let constraint = skeleton.pathConstraints[this.constraintIndex];
      if (constraint.active)
        constraint.spacing = this.getAbsoluteValue(time, alpha, blend, constraint.spacing, constraint.data.spacing);
    }
  };
  var PathConstraintMixTimeline = class extends CurveTimeline {
    constructor(frameCount, bezierCount, pathConstraintIndex) {
      super(frameCount, bezierCount, [
        Property.pathConstraintMix + "|" + pathConstraintIndex
      ]);
      /** The index of the path constraint in {@link Skeleton#getPathConstraints()} that will be changed when this timeline is
       * applied. */
      __publicField(this, "constraintIndex", 0);
      this.constraintIndex = pathConstraintIndex;
    }
    getFrameEntries() {
      return 4;
    }
    setFrame(frame, time, mixRotate, mixX, mixY) {
      let frames = this.frames;
      frame <<= 2;
      frames[frame] = time;
      frames[
        frame + 1
        /*ROTATE*/
      ] = mixRotate;
      frames[
        frame + 2
        /*X*/
      ] = mixX;
      frames[
        frame + 3
        /*Y*/
      ] = mixY;
    }
    apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      let constraint = skeleton.pathConstraints[this.constraintIndex];
      if (!constraint.active)
        return;
      let frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.mixRotate = constraint.data.mixRotate;
            constraint.mixX = constraint.data.mixX;
            constraint.mixY = constraint.data.mixY;
            return;
          case MixBlend.first:
            constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;
            constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;
            constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;
        }
        return;
      }
      let rotate, x2, y2;
      let i3 = Timeline2.search(
        frames,
        time,
        4
        /*ENTRIES*/
      );
      let curveType = this.curves[i3 >> 2];
      switch (curveType) {
        case 0:
          let before = frames[i3];
          rotate = frames[
            i3 + 1
            /*ROTATE*/
          ];
          x2 = frames[
            i3 + 2
            /*X*/
          ];
          y2 = frames[
            i3 + 3
            /*Y*/
          ];
          let t2 = (time - before) / (frames[
            i3 + 4
            /*ENTRIES*/
          ] - before);
          rotate += (frames[
            i3 + 4 + 1
            /*ROTATE*/
          ] - rotate) * t2;
          x2 += (frames[
            i3 + 4 + 2
            /*X*/
          ] - x2) * t2;
          y2 += (frames[
            i3 + 4 + 3
            /*Y*/
          ] - y2) * t2;
          break;
        case 1:
          rotate = frames[
            i3 + 1
            /*ROTATE*/
          ];
          x2 = frames[
            i3 + 2
            /*X*/
          ];
          y2 = frames[
            i3 + 3
            /*Y*/
          ];
          break;
        default:
          rotate = this.getBezierValue(
            time,
            i3,
            1,
            curveType - 2
            /*BEZIER*/
          );
          x2 = this.getBezierValue(
            time,
            i3,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          y2 = this.getBezierValue(
            time,
            i3,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
      }
      if (blend == MixBlend.setup) {
        let data = constraint.data;
        constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
        constraint.mixX = data.mixX + (x2 - data.mixX) * alpha;
        constraint.mixY = data.mixY + (y2 - data.mixY) * alpha;
      } else {
        constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
        constraint.mixX += (x2 - constraint.mixX) * alpha;
        constraint.mixY += (y2 - constraint.mixY) * alpha;
      }
    }
  };
  var PhysicsConstraintTimeline = class extends CurveTimeline1 {
    /** @param physicsConstraintIndex -1 for all physics constraints in the skeleton. */
    constructor(frameCount, bezierCount, physicsConstraintIndex, property) {
      super(frameCount, bezierCount, property + "|" + physicsConstraintIndex);
      /** The index of the physics constraint in {@link Skeleton#getPhysicsConstraints()} that will be changed when this timeline
       * is applied, or -1 if all physics constraints in the skeleton will be changed. */
      __publicField(this, "constraintIndex", 0);
      this.constraintIndex = physicsConstraintIndex;
    }
    apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      let constraint;
      if (this.constraintIndex == -1) {
        const value = time >= this.frames[0] ? this.getCurveValue(time) : 0;
        for (const constraint2 of skeleton.physicsConstraints) {
          if (constraint2.active && this.global(constraint2.data))
            this.set(constraint2, this.getAbsoluteValue2(time, alpha, blend, this.get(constraint2), this.setup(constraint2), value));
        }
      } else {
        constraint = skeleton.physicsConstraints[this.constraintIndex];
        if (constraint.active)
          this.set(constraint, this.getAbsoluteValue(time, alpha, blend, this.get(constraint), this.setup(constraint)));
      }
    }
  };
  var PhysicsConstraintInertiaTimeline = class extends PhysicsConstraintTimeline {
    constructor(frameCount, bezierCount, physicsConstraintIndex) {
      super(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintInertia);
    }
    setup(constraint) {
      return constraint.data.inertia;
    }
    get(constraint) {
      return constraint.inertia;
    }
    set(constraint, value) {
      constraint.inertia = value;
    }
    global(constraint) {
      return constraint.inertiaGlobal;
    }
  };
  var PhysicsConstraintStrengthTimeline = class extends PhysicsConstraintTimeline {
    constructor(frameCount, bezierCount, physicsConstraintIndex) {
      super(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintStrength);
    }
    setup(constraint) {
      return constraint.data.strength;
    }
    get(constraint) {
      return constraint.strength;
    }
    set(constraint, value) {
      constraint.strength = value;
    }
    global(constraint) {
      return constraint.strengthGlobal;
    }
  };
  var PhysicsConstraintDampingTimeline = class extends PhysicsConstraintTimeline {
    constructor(frameCount, bezierCount, physicsConstraintIndex) {
      super(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintDamping);
    }
    setup(constraint) {
      return constraint.data.damping;
    }
    get(constraint) {
      return constraint.damping;
    }
    set(constraint, value) {
      constraint.damping = value;
    }
    global(constraint) {
      return constraint.dampingGlobal;
    }
  };
  var PhysicsConstraintMassTimeline = class extends PhysicsConstraintTimeline {
    constructor(frameCount, bezierCount, physicsConstraintIndex) {
      super(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintMass);
    }
    setup(constraint) {
      return 1 / constraint.data.massInverse;
    }
    get(constraint) {
      return 1 / constraint.massInverse;
    }
    set(constraint, value) {
      constraint.massInverse = 1 / value;
    }
    global(constraint) {
      return constraint.massGlobal;
    }
  };
  var PhysicsConstraintWindTimeline = class extends PhysicsConstraintTimeline {
    constructor(frameCount, bezierCount, physicsConstraintIndex) {
      super(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintWind);
    }
    setup(constraint) {
      return constraint.data.wind;
    }
    get(constraint) {
      return constraint.wind;
    }
    set(constraint, value) {
      constraint.wind = value;
    }
    global(constraint) {
      return constraint.windGlobal;
    }
  };
  var PhysicsConstraintGravityTimeline = class extends PhysicsConstraintTimeline {
    constructor(frameCount, bezierCount, physicsConstraintIndex) {
      super(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintGravity);
    }
    setup(constraint) {
      return constraint.data.gravity;
    }
    get(constraint) {
      return constraint.gravity;
    }
    set(constraint, value) {
      constraint.gravity = value;
    }
    global(constraint) {
      return constraint.gravityGlobal;
    }
  };
  var PhysicsConstraintMixTimeline = class extends PhysicsConstraintTimeline {
    constructor(frameCount, bezierCount, physicsConstraintIndex) {
      super(frameCount, bezierCount, physicsConstraintIndex, Property.physicsConstraintMix);
    }
    setup(constraint) {
      return constraint.data.mix;
    }
    get(constraint) {
      return constraint.mix;
    }
    set(constraint, value) {
      constraint.mix = value;
    }
    global(constraint) {
      return constraint.mixGlobal;
    }
  };
  var _PhysicsConstraintResetTimeline = class _PhysicsConstraintResetTimeline extends Timeline2 {
    /** @param physicsConstraintIndex -1 for all physics constraints in the skeleton. */
    constructor(frameCount, physicsConstraintIndex) {
      super(frameCount, _PhysicsConstraintResetTimeline.propertyIds);
      /** The index of the physics constraint in {@link Skeleton#getPhysicsConstraints()} that will be reset when this timeline is
      * applied, or -1 if all physics constraints in the skeleton will be reset. */
      __publicField(this, "constraintIndex");
      this.constraintIndex = physicsConstraintIndex;
    }
    getFrameCount() {
      return this.frames.length;
    }
    /** Sets the time for the specified frame.
     * @param frame Between 0 and <code>frameCount</code>, inclusive. */
    setFrame(frame, time) {
      this.frames[frame] = time;
    }
    /** Resets the physics constraint when frames > <code>lastTime</code> and <= <code>time</code>. */
    apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
      let constraint;
      if (this.constraintIndex != -1) {
        constraint = skeleton.physicsConstraints[this.constraintIndex];
        if (!constraint.active)
          return;
      }
      const frames = this.frames;
      if (lastTime > time) {
        this.apply(skeleton, lastTime, Number.MAX_VALUE, [], alpha, blend, direction);
        lastTime = -1;
      } else if (lastTime >= frames[frames.length - 1])
        return;
      if (time < frames[0])
        return;
      if (lastTime < frames[0] || time >= frames[Timeline2.search1(frames, lastTime) + 1]) {
        if (constraint != null)
          constraint.reset();
        else {
          for (const constraint2 of skeleton.physicsConstraints) {
            if (constraint2.active)
              constraint2.reset();
          }
        }
      }
    }
  };
  __publicField(_PhysicsConstraintResetTimeline, "propertyIds", [Property.physicsConstraintReset.toString()]);
  var PhysicsConstraintResetTimeline = _PhysicsConstraintResetTimeline;
  var _SequenceTimeline = class _SequenceTimeline extends Timeline2 {
    constructor(frameCount, slotIndex, attachment) {
      super(frameCount, [
        Property.sequence + "|" + slotIndex + "|" + attachment.sequence.id
      ]);
      __publicField(this, "slotIndex");
      __publicField(this, "attachment");
      this.slotIndex = slotIndex;
      this.attachment = attachment;
    }
    getFrameEntries() {
      return _SequenceTimeline.ENTRIES;
    }
    getSlotIndex() {
      return this.slotIndex;
    }
    getAttachment() {
      return this.attachment;
    }
    /** Sets the time, mode, index, and frame time for the specified frame.
     * @param frame Between 0 and <code>frameCount</code>, inclusive.
     * @param time Seconds between frames. */
    setFrame(frame, time, mode, index, delay) {
      let frames = this.frames;
      frame *= _SequenceTimeline.ENTRIES;
      frames[frame] = time;
      frames[frame + _SequenceTimeline.MODE] = mode | index << 4;
      frames[frame + _SequenceTimeline.DELAY] = delay;
    }
    apply(skeleton, lastTime, time, events, alpha, blend, direction) {
      let slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      let slotAttachment = slot.attachment;
      let attachment = this.attachment;
      if (slotAttachment != attachment) {
        if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.timelineAttachment != attachment)
          return;
      }
      if (direction == MixDirection.mixOut) {
        if (blend == MixBlend.setup)
          slot.sequenceIndex = -1;
        return;
      }
      let frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          slot.sequenceIndex = -1;
        return;
      }
      let i3 = Timeline2.search(frames, time, _SequenceTimeline.ENTRIES);
      let before = frames[i3];
      let modeAndIndex = frames[i3 + _SequenceTimeline.MODE];
      let delay = frames[i3 + _SequenceTimeline.DELAY];
      if (!this.attachment.sequence)
        return;
      let index = modeAndIndex >> 4, count2 = this.attachment.sequence.regions.length;
      let mode = SequenceModeValues[modeAndIndex & 15];
      if (mode != SequenceMode.hold) {
        index += (time - before) / delay + 1e-5 | 0;
        switch (mode) {
          case SequenceMode.once:
            index = Math.min(count2 - 1, index);
            break;
          case SequenceMode.loop:
            index %= count2;
            break;
          case SequenceMode.pingpong: {
            let n2 = (count2 << 1) - 2;
            index = n2 == 0 ? 0 : index % n2;
            if (index >= count2)
              index = n2 - index;
            break;
          }
          case SequenceMode.onceReverse:
            index = Math.max(count2 - 1 - index, 0);
            break;
          case SequenceMode.loopReverse:
            index = count2 - 1 - index % count2;
            break;
          case SequenceMode.pingpongReverse: {
            let n2 = (count2 << 1) - 2;
            index = n2 == 0 ? 0 : (index + count2 - 1) % n2;
            if (index >= count2)
              index = n2 - index;
          }
        }
      }
      slot.sequenceIndex = index;
    }
  };
  __publicField(_SequenceTimeline, "ENTRIES", 3);
  __publicField(_SequenceTimeline, "MODE", 1);
  __publicField(_SequenceTimeline, "DELAY", 2);
  var SequenceTimeline = _SequenceTimeline;

  // node_modules/@esotericsoftware/spine-core/dist/AnimationState.js
  var _AnimationState = class _AnimationState {
    constructor(data) {
      /** The AnimationStateData to look up mix durations. */
      __publicField(this, "data");
      /** The list of tracks that currently have animations, which may contain null entries. */
      __publicField(this, "tracks", new Array());
      /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower
       * or faster. Defaults to 1.
       *
       * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */
      __publicField(this, "timeScale", 1);
      __publicField(this, "unkeyedState", 0);
      __publicField(this, "events", new Array());
      __publicField(this, "listeners", new Array());
      __publicField(this, "queue", new EventQueue(this));
      __publicField(this, "propertyIDs", new StringSet());
      __publicField(this, "animationsChanged", false);
      __publicField(this, "trackEntryPool", new Pool2(() => new TrackEntry()));
      this.data = data;
    }
    static emptyAnimation() {
      return _AnimationState._emptyAnimation;
    }
    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */
    update(delta) {
      delta *= this.timeScale;
      let tracks = this.tracks;
      for (let i3 = 0, n2 = tracks.length; i3 < n2; i3++) {
        let current = tracks[i3];
        if (!current)
          continue;
        current.animationLast = current.nextAnimationLast;
        current.trackLast = current.nextTrackLast;
        let currentDelta = delta * current.timeScale;
        if (current.delay > 0) {
          current.delay -= currentDelta;
          if (current.delay > 0)
            continue;
          currentDelta = -current.delay;
          current.delay = 0;
        }
        let next = current.next;
        if (next) {
          let nextTime = current.trackLast - next.delay;
          if (nextTime >= 0) {
            next.delay = 0;
            next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
            current.trackTime += currentDelta;
            this.setCurrent(i3, next, true);
            while (next.mixingFrom) {
              next.mixTime += delta;
              next = next.mixingFrom;
            }
            continue;
          }
        } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {
          tracks[i3] = null;
          this.queue.end(current);
          this.clearNext(current);
          continue;
        }
        if (current.mixingFrom && this.updateMixingFrom(current, delta)) {
          let from = current.mixingFrom;
          current.mixingFrom = null;
          if (from)
            from.mixingTo = null;
          while (from) {
            this.queue.end(from);
            from = from.mixingFrom;
          }
        }
        current.trackTime += currentDelta;
      }
      this.queue.drain();
    }
    /** Returns true when all mixing from entries are complete. */
    updateMixingFrom(to, delta) {
      let from = to.mixingFrom;
      if (!from)
        return true;
      let finished = this.updateMixingFrom(from, delta);
      from.animationLast = from.nextAnimationLast;
      from.trackLast = from.nextTrackLast;
      if (to.nextTrackLast != -1 && to.mixTime >= to.mixDuration) {
        if (from.totalAlpha == 0 || to.mixDuration == 0) {
          to.mixingFrom = from.mixingFrom;
          if (from.mixingFrom != null)
            from.mixingFrom.mixingTo = to;
          to.interruptAlpha = from.interruptAlpha;
          this.queue.end(from);
        }
        return finished;
      }
      from.trackTime += delta * from.timeScale;
      to.mixTime += delta;
      return false;
    }
    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the
     * animation state can be applied to multiple skeletons to pose them identically.
     * @returns True if any animations were applied. */
    apply(skeleton) {
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      if (this.animationsChanged)
        this._animationsChanged();
      let events = this.events;
      let tracks = this.tracks;
      let applied = false;
      for (let i4 = 0, n3 = tracks.length; i4 < n3; i4++) {
        let current = tracks[i4];
        if (!current || current.delay > 0)
          continue;
        applied = true;
        let blend = i4 == 0 ? MixBlend.first : current.mixBlend;
        let alpha = current.alpha;
        if (current.mixingFrom)
          alpha *= this.applyMixingFrom(current, skeleton, blend);
        else if (current.trackTime >= current.trackEnd && !current.next)
          alpha = 0;
        let attachments = alpha >= current.alphaAttachmentThreshold;
        let animationLast = current.animationLast, animationTime = current.getAnimationTime(), applyTime = animationTime;
        let applyEvents = events;
        if (current.reverse) {
          applyTime = current.animation.duration - applyTime;
          applyEvents = null;
        }
        let timelines = current.animation.timelines;
        let timelineCount = timelines.length;
        if (i4 == 0 && alpha == 1 || blend == MixBlend.add) {
          if (i4 == 0)
            attachments = true;
          for (let ii = 0; ii < timelineCount; ii++) {
            Utils.webkit602BugfixHelper(alpha, blend);
            var timeline2 = timelines[ii];
            if (timeline2 instanceof AttachmentTimeline)
              this.applyAttachmentTimeline(timeline2, skeleton, applyTime, blend, attachments);
            else
              timeline2.apply(skeleton, animationLast, applyTime, applyEvents, alpha, blend, MixDirection.mixIn);
          }
        } else {
          let timelineMode = current.timelineMode;
          let shortestRotation = current.shortestRotation;
          let firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;
          if (firstFrame)
            current.timelinesRotation.length = timelineCount << 1;
          for (let ii = 0; ii < timelineCount; ii++) {
            let timeline3 = timelines[ii];
            let timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;
            if (!shortestRotation && timeline3 instanceof RotateTimeline) {
              this.applyRotateTimeline(timeline3, skeleton, applyTime, alpha, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);
            } else if (timeline3 instanceof AttachmentTimeline) {
              this.applyAttachmentTimeline(timeline3, skeleton, applyTime, blend, attachments);
            } else {
              Utils.webkit602BugfixHelper(alpha, blend);
              timeline3.apply(skeleton, animationLast, applyTime, applyEvents, alpha, timelineBlend, MixDirection.mixIn);
            }
          }
        }
        this.queueEvents(current, animationTime);
        events.length = 0;
        current.nextAnimationLast = animationTime;
        current.nextTrackLast = current.trackTime;
      }
      var setupState = this.unkeyedState + SETUP;
      var slots = skeleton.slots;
      for (var i3 = 0, n2 = skeleton.slots.length; i3 < n2; i3++) {
        var slot = slots[i3];
        if (slot.attachmentState == setupState) {
          var attachmentName = slot.data.attachmentName;
          slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
        }
      }
      this.unkeyedState += 2;
      this.queue.drain();
      return applied;
    }
    applyMixingFrom(to, skeleton, blend) {
      let from = to.mixingFrom;
      if (from.mixingFrom)
        this.applyMixingFrom(from, skeleton, blend);
      let mix = 0;
      if (to.mixDuration == 0) {
        mix = 1;
        if (blend == MixBlend.first)
          blend = MixBlend.setup;
      } else {
        mix = to.mixTime / to.mixDuration;
        if (mix > 1)
          mix = 1;
        if (blend != MixBlend.first)
          blend = from.mixBlend;
      }
      let attachments = mix < from.mixAttachmentThreshold, drawOrder = mix < from.mixDrawOrderThreshold;
      let timelines = from.animation.timelines;
      let timelineCount = timelines.length;
      let alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);
      let animationLast = from.animationLast, animationTime = from.getAnimationTime(), applyTime = animationTime;
      let events = null;
      if (from.reverse)
        applyTime = from.animation.duration - applyTime;
      else if (mix < from.eventThreshold)
        events = this.events;
      if (blend == MixBlend.add) {
        for (let i3 = 0; i3 < timelineCount; i3++)
          timelines[i3].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);
      } else {
        let timelineMode = from.timelineMode;
        let timelineHoldMix = from.timelineHoldMix;
        let shortestRotation = from.shortestRotation;
        let firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;
        if (firstFrame)
          from.timelinesRotation.length = timelineCount << 1;
        from.totalAlpha = 0;
        for (let i3 = 0; i3 < timelineCount; i3++) {
          let timeline2 = timelines[i3];
          let direction = MixDirection.mixOut;
          let timelineBlend;
          let alpha = 0;
          switch (timelineMode[i3]) {
            case SUBSEQUENT:
              if (!drawOrder && timeline2 instanceof DrawOrderTimeline)
                continue;
              timelineBlend = blend;
              alpha = alphaMix;
              break;
            case FIRST:
              timelineBlend = MixBlend.setup;
              alpha = alphaMix;
              break;
            case HOLD_SUBSEQUENT:
              timelineBlend = blend;
              alpha = alphaHold;
              break;
            case HOLD_FIRST:
              timelineBlend = MixBlend.setup;
              alpha = alphaHold;
              break;
            default:
              timelineBlend = MixBlend.setup;
              let holdMix = timelineHoldMix[i3];
              alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
              break;
          }
          from.totalAlpha += alpha;
          if (!shortestRotation && timeline2 instanceof RotateTimeline)
            this.applyRotateTimeline(timeline2, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i3 << 1, firstFrame);
          else if (timeline2 instanceof AttachmentTimeline)
            this.applyAttachmentTimeline(timeline2, skeleton, applyTime, timelineBlend, attachments && alpha >= from.alphaAttachmentThreshold);
          else {
            Utils.webkit602BugfixHelper(alpha, blend);
            if (drawOrder && timeline2 instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)
              direction = MixDirection.mixIn;
            timeline2.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);
          }
        }
      }
      if (to.mixDuration > 0)
        this.queueEvents(from, animationTime);
      this.events.length = 0;
      from.nextAnimationLast = animationTime;
      from.nextTrackLast = from.trackTime;
      return mix;
    }
    applyAttachmentTimeline(timeline2, skeleton, time, blend, attachments) {
      var slot = skeleton.slots[timeline2.slotIndex];
      if (!slot.bone.active)
        return;
      if (time < timeline2.frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
      } else
        this.setAttachment(skeleton, slot, timeline2.attachmentNames[Timeline2.search1(timeline2.frames, time)], attachments);
      if (slot.attachmentState <= this.unkeyedState)
        slot.attachmentState = this.unkeyedState + SETUP;
    }
    setAttachment(skeleton, slot, attachmentName, attachments) {
      slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      if (attachments)
        slot.attachmentState = this.unkeyedState + CURRENT;
    }
    applyRotateTimeline(timeline2, skeleton, time, alpha, blend, timelinesRotation, i3, firstFrame) {
      if (firstFrame)
        timelinesRotation[i3] = 0;
      if (alpha == 1) {
        timeline2.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
        return;
      }
      let bone = skeleton.bones[timeline2.boneIndex];
      if (!bone.active)
        return;
      let frames = timeline2.frames;
      let r1 = 0, r2 = 0;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
          default:
            return;
          case MixBlend.first:
            r1 = bone.rotation;
            r2 = bone.data.rotation;
        }
      } else {
        r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
        r2 = bone.data.rotation + timeline2.getCurveValue(time);
      }
      let total = 0, diff = r2 - r1;
      diff -= Math.ceil(diff / 360 - 0.5) * 360;
      if (diff == 0) {
        total = timelinesRotation[i3];
      } else {
        let lastTotal = 0, lastDiff = 0;
        if (firstFrame) {
          lastTotal = 0;
          lastDiff = diff;
        } else {
          lastTotal = timelinesRotation[i3];
          lastDiff = timelinesRotation[i3 + 1];
        }
        let loops = lastTotal - lastTotal % 360;
        total = diff + loops;
        let current = diff >= 0, dir = lastTotal >= 0;
        if (Math.abs(lastDiff) <= 90 && MathUtils.signum(lastDiff) != MathUtils.signum(diff)) {
          if (Math.abs(lastTotal - loops) > 180) {
            total += 360 * MathUtils.signum(lastTotal);
            dir = current;
          } else if (loops != 0)
            total -= 360 * MathUtils.signum(lastTotal);
          else
            dir = current;
        }
        if (dir != current)
          total += 360 * MathUtils.signum(lastTotal);
        timelinesRotation[i3] = total;
      }
      timelinesRotation[i3 + 1] = diff;
      bone.rotation = r1 + total * alpha;
    }
    queueEvents(entry, animationTime) {
      let animationStart = entry.animationStart, animationEnd = entry.animationEnd;
      let duration = animationEnd - animationStart;
      let trackLastWrapped = entry.trackLast % duration;
      let events = this.events;
      let i3 = 0, n2 = events.length;
      for (; i3 < n2; i3++) {
        let event = events[i3];
        if (event.time < trackLastWrapped)
          break;
        if (event.time > animationEnd)
          continue;
        this.queue.event(entry, event);
      }
      let complete = false;
      if (entry.loop) {
        if (duration == 0)
          complete = true;
        else {
          const cycles = Math.floor(entry.trackTime / duration);
          complete = cycles > 0 && cycles > Math.floor(entry.trackLast / duration);
        }
      } else
        complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
      if (complete)
        this.queue.complete(entry);
      for (; i3 < n2; i3++) {
        let event = events[i3];
        if (event.time < animationStart)
          continue;
        this.queue.event(entry, event);
      }
    }
    /** Removes all animations from all tracks, leaving skeletons in their current pose.
     *
     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
     * rather than leaving them in their current pose. */
    clearTracks() {
      let oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (let i3 = 0, n2 = this.tracks.length; i3 < n2; i3++)
        this.clearTrack(i3);
      this.tracks.length = 0;
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    }
    /** Removes all animations from the track, leaving skeletons in their current pose.
     *
     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
     * rather than leaving them in their current pose. */
    clearTrack(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return;
      let current = this.tracks[trackIndex];
      if (!current)
        return;
      this.queue.end(current);
      this.clearNext(current);
      let entry = current;
      while (true) {
        let from = entry.mixingFrom;
        if (!from)
          break;
        this.queue.end(from);
        entry.mixingFrom = null;
        entry.mixingTo = null;
        entry = from;
      }
      this.tracks[current.trackIndex] = null;
      this.queue.drain();
    }
    setCurrent(index, current, interrupt) {
      let from = this.expandToIndex(index);
      this.tracks[index] = current;
      current.previous = null;
      if (from) {
        if (interrupt)
          this.queue.interrupt(from);
        current.mixingFrom = from;
        from.mixingTo = current;
        current.mixTime = 0;
        if (from.mixingFrom && from.mixDuration > 0)
          current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
        from.timelinesRotation.length = 0;
      }
      this.queue.start(current);
    }
    /** Sets an animation by name.
      *
      * See {@link #setAnimationWith()}. */
    setAnimation(trackIndex, animationName, loop = false) {
      let animation = this.data.skeletonData.findAnimation(animationName);
      if (!animation)
        throw new Error("Animation not found: " + animationName);
      return this.setAnimationWith(trackIndex, animation, loop);
    }
    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
     * applied to a skeleton, it is replaced (not mixed from).
     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.
     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
     *         after the {@link AnimationStateListener#dispose()} event occurs. */
    setAnimationWith(trackIndex, animation, loop = false) {
      if (!animation)
        throw new Error("animation cannot be null.");
      let interrupt = true;
      let current = this.expandToIndex(trackIndex);
      if (current) {
        if (current.nextTrackLast == -1) {
          this.tracks[trackIndex] = current.mixingFrom;
          this.queue.interrupt(current);
          this.queue.end(current);
          this.clearNext(current);
          current = current.mixingFrom;
          interrupt = false;
        } else
          this.clearNext(current);
      }
      let entry = this.trackEntry(trackIndex, animation, loop, current);
      this.setCurrent(trackIndex, entry, interrupt);
      this.queue.drain();
      return entry;
    }
    /** Queues an animation by name.
     *
     * See {@link #addAnimationWith()}. */
    addAnimation(trackIndex, animationName, loop = false, delay = 0) {
      let animation = this.data.skeletonData.findAnimation(animationName);
      if (!animation)
        throw new Error("Animation not found: " + animationName);
      return this.addAnimationWith(trackIndex, animation, loop, delay);
    }
    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
     * equivalent to calling {@link #setAnimationWith()}.
     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix
     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the
     *           previous entry is looping, its next loop completion is used instead of its duration.
     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
     *         after the {@link AnimationStateListener#dispose()} event occurs. */
    addAnimationWith(trackIndex, animation, loop = false, delay = 0) {
      if (!animation)
        throw new Error("animation cannot be null.");
      let last = this.expandToIndex(trackIndex);
      if (last) {
        while (last.next)
          last = last.next;
      }
      let entry = this.trackEntry(trackIndex, animation, loop, last);
      if (!last) {
        this.setCurrent(trackIndex, entry, true);
        this.queue.drain();
        if (delay < 0)
          delay = 0;
      } else {
        last.next = entry;
        entry.previous = last;
        if (delay <= 0)
          delay = Math.max(delay + last.getTrackComplete() - entry.mixDuration, 0);
      }
      entry.delay = delay;
      return entry;
    }
    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.
     *
     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},
     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes
     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
     * 0 still mixes out over one frame.
     *
     * Mixing in is done by first setting an empty animation, then adding an animation using
     * {@link #addAnimation()} and on the returned track entry, set the
     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and
     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the
     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */
    setEmptyAnimation(trackIndex, mixDuration = 0) {
      let entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    }
    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling
     * {@link #setEmptyAnimation()}.
     *
     * See {@link #setEmptyAnimation()}.
     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or
     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next
     *           loop completion is used instead of its duration.
     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept
     *         after the {@link AnimationStateListener#dispose()} event occurs. */
    addEmptyAnimation(trackIndex, mixDuration = 0, delay = 0) {
      let entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false, delay);
      if (delay <= 0)
        entry.delay = Math.max(entry.delay + entry.mixDuration - mixDuration, 0);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    }
    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
      * duration. */
    setEmptyAnimations(mixDuration = 0) {
      let oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (let i3 = 0, n2 = this.tracks.length; i3 < n2; i3++) {
        let current = this.tracks[i3];
        if (current)
          this.setEmptyAnimation(current.trackIndex, mixDuration);
      }
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    }
    expandToIndex(index) {
      if (index < this.tracks.length)
        return this.tracks[index];
      Utils.ensureArrayCapacity(this.tracks, index + 1, null);
      this.tracks.length = index + 1;
      return null;
    }
    /** @param last May be null. */
    trackEntry(trackIndex, animation, loop, last) {
      let entry = this.trackEntryPool.obtain();
      entry.reset();
      entry.trackIndex = trackIndex;
      entry.animation = animation;
      entry.loop = loop;
      entry.holdPrevious = false;
      entry.reverse = false;
      entry.shortestRotation = false;
      entry.eventThreshold = 0;
      entry.alphaAttachmentThreshold = 0;
      entry.mixAttachmentThreshold = 0;
      entry.mixDrawOrderThreshold = 0;
      entry.animationStart = 0;
      entry.animationEnd = animation.duration;
      entry.animationLast = -1;
      entry.nextAnimationLast = -1;
      entry.delay = 0;
      entry.trackTime = 0;
      entry.trackLast = -1;
      entry.nextTrackLast = -1;
      entry.trackEnd = Number.MAX_VALUE;
      entry.timeScale = 1;
      entry.alpha = 1;
      entry.mixTime = 0;
      entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);
      entry.interruptAlpha = 1;
      entry.totalAlpha = 0;
      entry.mixBlend = MixBlend.replace;
      return entry;
    }
    /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */
    clearNext(entry) {
      let next = entry.next;
      while (next) {
        this.queue.dispose(next);
        next = next.next;
      }
      entry.next = null;
    }
    _animationsChanged() {
      this.animationsChanged = false;
      this.propertyIDs.clear();
      let tracks = this.tracks;
      for (let i3 = 0, n2 = tracks.length; i3 < n2; i3++) {
        let entry = tracks[i3];
        if (!entry)
          continue;
        while (entry.mixingFrom)
          entry = entry.mixingFrom;
        do {
          if (!entry.mixingTo || entry.mixBlend != MixBlend.add)
            this.computeHold(entry);
          entry = entry.mixingTo;
        } while (entry);
      }
    }
    computeHold(entry) {
      let to = entry.mixingTo;
      let timelines = entry.animation.timelines;
      let timelinesCount = entry.animation.timelines.length;
      let timelineMode = entry.timelineMode;
      timelineMode.length = timelinesCount;
      let timelineHoldMix = entry.timelineHoldMix;
      timelineHoldMix.length = 0;
      let propertyIDs = this.propertyIDs;
      if (to && to.holdPrevious) {
        for (let i3 = 0; i3 < timelinesCount; i3++)
          timelineMode[i3] = propertyIDs.addAll(timelines[i3].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;
        return;
      }
      outer: for (let i3 = 0; i3 < timelinesCount; i3++) {
        let timeline2 = timelines[i3];
        let ids = timeline2.getPropertyIds();
        if (!propertyIDs.addAll(ids))
          timelineMode[i3] = SUBSEQUENT;
        else if (!to || timeline2 instanceof AttachmentTimeline || timeline2 instanceof DrawOrderTimeline || timeline2 instanceof EventTimeline || !to.animation.hasTimeline(ids)) {
          timelineMode[i3] = FIRST;
        } else {
          for (let next = to.mixingTo; next; next = next.mixingTo) {
            if (next.animation.hasTimeline(ids))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i3] = HOLD_MIX;
              timelineHoldMix[i3] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i3] = HOLD_FIRST;
        }
      }
    }
    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */
    getCurrent(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return null;
      return this.tracks[trackIndex];
    }
    /** Adds a listener to receive events for all track entries. */
    addListener(listener) {
      if (!listener)
        throw new Error("listener cannot be null.");
      this.listeners.push(listener);
    }
    /** Removes the listener added with {@link #addListener()}. */
    removeListener(listener) {
      let index = this.listeners.indexOf(listener);
      if (index >= 0)
        this.listeners.splice(index, 1);
    }
    /** Removes all listeners added with {@link #addListener()}. */
    clearListeners() {
      this.listeners.length = 0;
    }
    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an
     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery
     * are not wanted because new animations are being set. */
    clearListenerNotifications() {
      this.queue.clear();
    }
  };
  __publicField(_AnimationState, "_emptyAnimation", new Animation2("<empty>", [], 0));
  var AnimationState = _AnimationState;
  var TrackEntry = class {
    constructor() {
      /** The animation to apply for this track entry. */
      __publicField(this, "animation", null);
      __publicField(this, "previous", null);
      /** The animation queued to start after this animation, or null. `next` makes up a linked list. */
      __publicField(this, "next", null);
      /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no
       * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */
      __publicField(this, "mixingFrom", null);
      /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is
       * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */
      __publicField(this, "mixingTo", null);
      /** The listener for events generated by this track entry, or null.
       *
       * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation
       * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */
      __publicField(this, "listener", null);
      /** The index of the track where this track entry is either current or queued.
       *
       * See {@link AnimationState#getCurrent()}. */
      __publicField(this, "trackIndex", 0);
      /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
       * duration. */
      __publicField(this, "loop", false);
      /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead
       * of being mixed out.
       *
       * When mixing between animations that key the same property, if a lower track also keys that property then the value will
       * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%
       * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation
       * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which
       * keys the property, only when a higher track also keys the property.
       *
       * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the
       * previous animation. */
      __publicField(this, "holdPrevious", false);
      __publicField(this, "reverse", false);
      __publicField(this, "shortestRotation", false);
      /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the
       * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event
       * timelines are not applied while this animation is being mixed out. */
      __publicField(this, "eventThreshold", 0);
      /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the
       * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to
       * 0, so attachment timelines are not applied while this animation is being mixed out. */
      __publicField(this, "mixAttachmentThreshold", 0);
      /** When {@link #getAlpha()} is greater than <code>alphaAttachmentThreshold</code>, attachment timelines are applied.
       * Defaults to 0, so attachment timelines are always applied. */
      __publicField(this, "alphaAttachmentThreshold", 0);
      /** When the mix percentage ({@link #getMixTime()} / {@link #getMixDuration()}) is less than the
       * <code>mixDrawOrderThreshold</code>, draw order timelines are applied while this animation is being mixed out. Defaults to
       * 0, so draw order timelines are not applied while this animation is being mixed out. */
      __publicField(this, "mixDrawOrderThreshold", 0);
      /** Seconds when this animation starts, both initially and after looping. Defaults to 0.
       *
       * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same
       * value to prevent timeline keys before the start time from triggering. */
      __publicField(this, "animationStart", 0);
      /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will
       * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */
      __publicField(this, "animationEnd", 0);
      /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this
       * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and
       * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation
       * is applied. */
      __publicField(this, "animationLast", 0);
      __publicField(this, "nextAnimationLast", 0);
      /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`
       * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from
       * the start of the previous animation to when this track entry will become the current track entry (ie when the previous
       * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).
       *
       * {@link #timeScale} affects the delay. */
      __publicField(this, "delay", 0);
      /** Current time in seconds this track entry has been the current track entry. The track time determines
       * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting
       * looping. */
      __publicField(this, "trackTime", 0);
      __publicField(this, "trackLast", 0);
      __publicField(this, "nextTrackLast", 0);
      /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float
       * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time
       * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the
       * properties keyed by the animation are set to the setup pose and the track is cleared.
       *
       * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation
       * abruptly cease being applied. */
      __publicField(this, "trackEnd", 0);
      /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or
       * faster. Defaults to 1.
       *
       * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to
       * match the animation speed.
       *
       * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the
       * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If
       * the time scale is not 1, the delay may need to be adjusted.
       *
       * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */
      __publicField(this, "timeScale", 0);
      /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults
       * to 1, which overwrites the skeleton's current pose with this animation.
       *
       * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to
       * use alpha on track 0 if the skeleton pose is from the last frame render. */
      __publicField(this, "alpha", 0);
      /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be
       * slightly more than `mixDuration` when the mix is complete. */
      __publicField(this, "mixTime", 0);
      /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData
       * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).
       *
       * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the
       * properties it was animating.
       *
       * The `mixDuration` can be set manually rather than use the value from
       * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new
       * track entry only before {@link AnimationState#update(float)} is first called.
       *
       * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the
       * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set
       * afterward. */
      __publicField(this, "_mixDuration", 0);
      __publicField(this, "interruptAlpha", 0);
      __publicField(this, "totalAlpha", 0);
      /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which
       * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to
       * the values from the lower tracks.
       *
       * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first
       * called. */
      __publicField(this, "mixBlend", MixBlend.replace);
      __publicField(this, "timelineMode", new Array());
      __publicField(this, "timelineHoldMix", new Array());
      __publicField(this, "timelinesRotation", new Array());
    }
    get mixDuration() {
      return this._mixDuration;
    }
    set mixDuration(mixDuration) {
      this._mixDuration = mixDuration;
    }
    setMixDurationWithDelay(mixDuration, delay) {
      this._mixDuration = mixDuration;
      if (delay <= 0) {
        if (this.previous != null)
          delay = Math.max(delay + this.previous.getTrackComplete() - mixDuration, 0);
        else
          delay = 0;
      }
      this.delay = delay;
    }
    reset() {
      this.next = null;
      this.previous = null;
      this.mixingFrom = null;
      this.mixingTo = null;
      this.animation = null;
      this.listener = null;
      this.timelineMode.length = 0;
      this.timelineHoldMix.length = 0;
      this.timelinesRotation.length = 0;
    }
    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}
     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the
     * `animationStart` time. */
    getAnimationTime() {
      if (this.loop) {
        let duration = this.animationEnd - this.animationStart;
        if (duration == 0)
          return this.animationStart;
        return this.trackTime % duration + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    }
    setAnimationLast(animationLast) {
      this.animationLast = animationLast;
      this.nextAnimationLast = animationLast;
    }
    /** Returns true if at least one loop has been completed.
     *
     * See {@link AnimationStateListener#complete()}. */
    isComplete() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    }
    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
     * long way around when using {@link #alpha} and starting animations on other tracks.
     *
     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:
     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */
    resetRotationDirections() {
      this.timelinesRotation.length = 0;
    }
    getTrackComplete() {
      let duration = this.animationEnd - this.animationStart;
      if (duration != 0) {
        if (this.loop)
          return duration * (1 + (this.trackTime / duration | 0));
        if (this.trackTime < duration)
          return duration;
      }
      return this.trackTime;
    }
    /** Returns true if this track entry has been applied at least once.
     * <p>
     * See {@link AnimationState#apply(Skeleton)}. */
    wasApplied() {
      return this.nextTrackLast != -1;
    }
    /** Returns true if there is a {@link #getNext()} track entry and it will become the current track entry during the next
     * {@link AnimationState#update(float)}. */
    isNextReady() {
      return this.next != null && this.nextTrackLast - this.next.delay >= 0;
    }
  };
  var EventQueue = class {
    constructor(animState) {
      __publicField(this, "objects", []);
      __publicField(this, "drainDisabled", false);
      __publicField(this, "animState");
      this.animState = animState;
    }
    start(entry) {
      this.objects.push(EventType.start);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    }
    interrupt(entry) {
      this.objects.push(EventType.interrupt);
      this.objects.push(entry);
    }
    end(entry) {
      this.objects.push(EventType.end);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    }
    dispose(entry) {
      this.objects.push(EventType.dispose);
      this.objects.push(entry);
    }
    complete(entry) {
      this.objects.push(EventType.complete);
      this.objects.push(entry);
    }
    event(entry, event) {
      this.objects.push(EventType.event);
      this.objects.push(entry);
      this.objects.push(event);
    }
    drain() {
      if (this.drainDisabled)
        return;
      this.drainDisabled = true;
      let objects = this.objects;
      let listeners = this.animState.listeners;
      for (let i3 = 0; i3 < objects.length; i3 += 2) {
        let type = objects[i3];
        let entry = objects[i3 + 1];
        switch (type) {
          case EventType.start:
            if (entry.listener && entry.listener.start)
              entry.listener.start(entry);
            for (let ii = 0; ii < listeners.length; ii++) {
              let listener = listeners[ii];
              if (listener.start)
                listener.start(entry);
            }
            break;
          case EventType.interrupt:
            if (entry.listener && entry.listener.interrupt)
              entry.listener.interrupt(entry);
            for (let ii = 0; ii < listeners.length; ii++) {
              let listener = listeners[ii];
              if (listener.interrupt)
                listener.interrupt(entry);
            }
            break;
          case EventType.end:
            if (entry.listener && entry.listener.end)
              entry.listener.end(entry);
            for (let ii = 0; ii < listeners.length; ii++) {
              let listener = listeners[ii];
              if (listener.end)
                listener.end(entry);
            }
          // Fall through.
          case EventType.dispose:
            if (entry.listener && entry.listener.dispose)
              entry.listener.dispose(entry);
            for (let ii = 0; ii < listeners.length; ii++) {
              let listener = listeners[ii];
              if (listener.dispose)
                listener.dispose(entry);
            }
            this.animState.trackEntryPool.free(entry);
            break;
          case EventType.complete:
            if (entry.listener && entry.listener.complete)
              entry.listener.complete(entry);
            for (let ii = 0; ii < listeners.length; ii++) {
              let listener = listeners[ii];
              if (listener.complete)
                listener.complete(entry);
            }
            break;
          case EventType.event:
            let event = objects[i3++ + 2];
            if (entry.listener && entry.listener.event)
              entry.listener.event(entry, event);
            for (let ii = 0; ii < listeners.length; ii++) {
              let listener = listeners[ii];
              if (listener.event)
                listener.event(entry, event);
            }
            break;
        }
      }
      this.clear();
      this.drainDisabled = false;
    }
    clear() {
      this.objects.length = 0;
    }
  };
  var EventType;
  (function(EventType2) {
    EventType2[EventType2["start"] = 0] = "start";
    EventType2[EventType2["interrupt"] = 1] = "interrupt";
    EventType2[EventType2["end"] = 2] = "end";
    EventType2[EventType2["dispose"] = 3] = "dispose";
    EventType2[EventType2["complete"] = 4] = "complete";
    EventType2[EventType2["event"] = 5] = "event";
  })(EventType || (EventType = {}));
  var SUBSEQUENT = 0;
  var FIRST = 1;
  var HOLD_SUBSEQUENT = 2;
  var HOLD_FIRST = 3;
  var HOLD_MIX = 4;
  var SETUP = 1;
  var CURRENT = 2;

  // node_modules/@esotericsoftware/spine-core/dist/AnimationStateData.js
  var AnimationStateData = class {
    constructor(skeletonData) {
      /** The SkeletonData to look up animations when they are specified by name. */
      __publicField(this, "skeletonData");
      __publicField(this, "animationToMixTime", {});
      /** The mix duration to use when no mix duration has been defined between two animations. */
      __publicField(this, "defaultMix", 0);
      if (!skeletonData)
        throw new Error("skeletonData cannot be null.");
      this.skeletonData = skeletonData;
    }
    /** Sets a mix duration by animation name.
     *
     * See {@link #setMixWith()}. */
    setMix(fromName, toName, duration) {
      let from = this.skeletonData.findAnimation(fromName);
      if (!from)
        throw new Error("Animation not found: " + fromName);
      let to = this.skeletonData.findAnimation(toName);
      if (!to)
        throw new Error("Animation not found: " + toName);
      this.setMixWith(from, to, duration);
    }
    /** Sets the mix duration when changing from the specified animation to the other.
     *
     * See {@link TrackEntry#mixDuration}. */
    setMixWith(from, to, duration) {
      if (!from)
        throw new Error("from cannot be null.");
      if (!to)
        throw new Error("to cannot be null.");
      let key = from.name + "." + to.name;
      this.animationToMixTime[key] = duration;
    }
    /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if
      * no mix duration has been set. */
    getMix(from, to) {
      let key = from.name + "." + to.name;
      let value = this.animationToMixTime[key];
      return value === void 0 ? this.defaultMix : value;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/attachments/BoundingBoxAttachment.js
  var BoundingBoxAttachment = class _BoundingBoxAttachment extends VertexAttachment {
    constructor(name) {
      super(name);
      __publicField(this, "color", new Color2(1, 1, 1, 1));
    }
    copy() {
      let copy = new _BoundingBoxAttachment(this.name);
      this.copyTo(copy);
      copy.color.setFromColor(this.color);
      return copy;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/attachments/ClippingAttachment.js
  var ClippingAttachment = class _ClippingAttachment extends VertexAttachment {
    // ce3a3aff
    constructor(name) {
      super(name);
      /** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of
       * the skeleton's rendering. */
      __publicField(this, "endSlot", null);
      // Nonessential.
      /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons
       * are not usually rendered at runtime. */
      __publicField(this, "color", new Color2(0.2275, 0.2275, 0.8078, 1));
    }
    copy() {
      let copy = new _ClippingAttachment(this.name);
      this.copyTo(copy);
      copy.endSlot = this.endSlot;
      copy.color.setFromColor(this.color);
      return copy;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/Texture.js
  var Texture2 = class {
    constructor(image) {
      __publicField(this, "_image");
      this._image = image;
    }
    getImage() {
      return this._image;
    }
  };
  var TextureFilter;
  (function(TextureFilter2) {
    TextureFilter2[TextureFilter2["Nearest"] = 9728] = "Nearest";
    TextureFilter2[TextureFilter2["Linear"] = 9729] = "Linear";
    TextureFilter2[TextureFilter2["MipMap"] = 9987] = "MipMap";
    TextureFilter2[TextureFilter2["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
    TextureFilter2[TextureFilter2["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
    TextureFilter2[TextureFilter2["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
    TextureFilter2[TextureFilter2["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
  })(TextureFilter || (TextureFilter = {}));
  var TextureWrap;
  (function(TextureWrap2) {
    TextureWrap2[TextureWrap2["MirroredRepeat"] = 33648] = "MirroredRepeat";
    TextureWrap2[TextureWrap2["ClampToEdge"] = 33071] = "ClampToEdge";
    TextureWrap2[TextureWrap2["Repeat"] = 10497] = "Repeat";
  })(TextureWrap || (TextureWrap = {}));
  var TextureRegion = class {
    constructor() {
      __publicField(this, "texture");
      __publicField(this, "u", 0);
      __publicField(this, "v", 0);
      __publicField(this, "u2", 0);
      __publicField(this, "v2", 0);
      __publicField(this, "width", 0);
      __publicField(this, "height", 0);
      __publicField(this, "degrees", 0);
      __publicField(this, "offsetX", 0);
      __publicField(this, "offsetY", 0);
      __publicField(this, "originalWidth", 0);
      __publicField(this, "originalHeight", 0);
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/TextureAtlas.js
  var TextureAtlas = class {
    constructor(atlasText) {
      __publicField(this, "pages", new Array());
      __publicField(this, "regions", new Array());
      let reader = new TextureAtlasReader(atlasText);
      let entry = new Array(4);
      let pageFields = {};
      pageFields["size"] = (page2) => {
        page2.width = parseInt(entry[1]);
        page2.height = parseInt(entry[2]);
      };
      pageFields["format"] = () => {
      };
      pageFields["filter"] = (page2) => {
        page2.minFilter = Utils.enumValue(TextureFilter, entry[1]);
        page2.magFilter = Utils.enumValue(TextureFilter, entry[2]);
      };
      pageFields["repeat"] = (page2) => {
        if (entry[1].indexOf("x") != -1)
          page2.uWrap = TextureWrap.Repeat;
        if (entry[1].indexOf("y") != -1)
          page2.vWrap = TextureWrap.Repeat;
      };
      pageFields["pma"] = (page2) => {
        page2.pma = entry[1] == "true";
      };
      var regionFields = {};
      regionFields["xy"] = (region) => {
        region.x = parseInt(entry[1]);
        region.y = parseInt(entry[2]);
      };
      regionFields["size"] = (region) => {
        region.width = parseInt(entry[1]);
        region.height = parseInt(entry[2]);
      };
      regionFields["bounds"] = (region) => {
        region.x = parseInt(entry[1]);
        region.y = parseInt(entry[2]);
        region.width = parseInt(entry[3]);
        region.height = parseInt(entry[4]);
      };
      regionFields["offset"] = (region) => {
        region.offsetX = parseInt(entry[1]);
        region.offsetY = parseInt(entry[2]);
      };
      regionFields["orig"] = (region) => {
        region.originalWidth = parseInt(entry[1]);
        region.originalHeight = parseInt(entry[2]);
      };
      regionFields["offsets"] = (region) => {
        region.offsetX = parseInt(entry[1]);
        region.offsetY = parseInt(entry[2]);
        region.originalWidth = parseInt(entry[3]);
        region.originalHeight = parseInt(entry[4]);
      };
      regionFields["rotate"] = (region) => {
        let value = entry[1];
        if (value == "true")
          region.degrees = 90;
        else if (value != "false")
          region.degrees = parseInt(value);
      };
      regionFields["index"] = (region) => {
        region.index = parseInt(entry[1]);
      };
      let line = reader.readLine();
      while (line && line.trim().length == 0)
        line = reader.readLine();
      while (true) {
        if (!line || line.trim().length == 0)
          break;
        if (reader.readEntry(entry, line) == 0)
          break;
        line = reader.readLine();
      }
      let page = null;
      let names = null;
      let values = null;
      while (true) {
        if (line === null)
          break;
        if (line.trim().length == 0) {
          page = null;
          line = reader.readLine();
        } else if (!page) {
          page = new TextureAtlasPage(line.trim());
          while (true) {
            if (reader.readEntry(entry, line = reader.readLine()) == 0)
              break;
            let field = pageFields[entry[0]];
            if (field)
              field(page);
          }
          this.pages.push(page);
        } else {
          let region = new TextureAtlasRegion(page, line);
          while (true) {
            let count2 = reader.readEntry(entry, line = reader.readLine());
            if (count2 == 0)
              break;
            let field = regionFields[entry[0]];
            if (field)
              field(region);
            else {
              if (!names)
                names = [];
              if (!values)
                values = [];
              names.push(entry[0]);
              let entryValues = [];
              for (let i3 = 0; i3 < count2; i3++)
                entryValues.push(parseInt(entry[i3 + 1]));
              values.push(entryValues);
            }
          }
          if (region.originalWidth == 0 && region.originalHeight == 0) {
            region.originalWidth = region.width;
            region.originalHeight = region.height;
          }
          if (names && names.length > 0 && values && values.length > 0) {
            region.names = names;
            region.values = values;
            names = null;
            values = null;
          }
          region.u = region.x / page.width;
          region.v = region.y / page.height;
          if (region.degrees == 90) {
            region.u2 = (region.x + region.height) / page.width;
            region.v2 = (region.y + region.width) / page.height;
          } else {
            region.u2 = (region.x + region.width) / page.width;
            region.v2 = (region.y + region.height) / page.height;
          }
          this.regions.push(region);
        }
      }
    }
    findRegion(name) {
      for (let i3 = 0; i3 < this.regions.length; i3++) {
        if (this.regions[i3].name == name) {
          return this.regions[i3];
        }
      }
      return null;
    }
    setTextures(assetManager, pathPrefix = "") {
      for (let page of this.pages)
        page.setTexture(assetManager.get(pathPrefix + page.name));
    }
    dispose() {
      var _a2;
      for (let i3 = 0; i3 < this.pages.length; i3++) {
        (_a2 = this.pages[i3].texture) == null ? void 0 : _a2.dispose();
      }
    }
  };
  var TextureAtlasReader = class {
    constructor(text) {
      __publicField(this, "lines");
      __publicField(this, "index", 0);
      this.lines = text.split(/\r\n|\r|\n/);
    }
    readLine() {
      if (this.index >= this.lines.length)
        return null;
      return this.lines[this.index++];
    }
    readEntry(entry, line) {
      if (!line)
        return 0;
      line = line.trim();
      if (line.length == 0)
        return 0;
      let colon = line.indexOf(":");
      if (colon == -1)
        return 0;
      entry[0] = line.substr(0, colon).trim();
      for (let i3 = 1, lastMatch = colon + 1; ; i3++) {
        let comma = line.indexOf(",", lastMatch);
        if (comma == -1) {
          entry[i3] = line.substr(lastMatch).trim();
          return i3;
        }
        entry[i3] = line.substr(lastMatch, comma - lastMatch).trim();
        lastMatch = comma + 1;
        if (i3 == 4)
          return 4;
      }
    }
  };
  var TextureAtlasPage = class {
    constructor(name) {
      __publicField(this, "name");
      __publicField(this, "minFilter", TextureFilter.Nearest);
      __publicField(this, "magFilter", TextureFilter.Nearest);
      __publicField(this, "uWrap", TextureWrap.ClampToEdge);
      __publicField(this, "vWrap", TextureWrap.ClampToEdge);
      __publicField(this, "texture", null);
      __publicField(this, "width", 0);
      __publicField(this, "height", 0);
      __publicField(this, "pma", false);
      __publicField(this, "regions", new Array());
      this.name = name;
    }
    setTexture(texture) {
      this.texture = texture;
      texture.setFilters(this.minFilter, this.magFilter);
      texture.setWraps(this.uWrap, this.vWrap);
      for (let region of this.regions)
        region.texture = texture;
    }
  };
  var TextureAtlasRegion = class extends TextureRegion {
    constructor(page, name) {
      super();
      __publicField(this, "page");
      __publicField(this, "name");
      __publicField(this, "x", 0);
      __publicField(this, "y", 0);
      __publicField(this, "offsetX", 0);
      __publicField(this, "offsetY", 0);
      __publicField(this, "originalWidth", 0);
      __publicField(this, "originalHeight", 0);
      __publicField(this, "index", 0);
      __publicField(this, "degrees", 0);
      __publicField(this, "names", null);
      __publicField(this, "values", null);
      this.page = page;
      this.name = name;
      page.regions.push(this);
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/attachments/MeshAttachment.js
  var MeshAttachment = class _MeshAttachment extends VertexAttachment {
    constructor(name, path2) {
      super(name);
      __publicField(this, "region", null);
      /** The name of the texture region for this attachment. */
      __publicField(this, "path");
      /** The UV pair for each vertex, normalized within the texture region. */
      __publicField(this, "regionUVs", []);
      /** The UV pair for each vertex, normalized within the entire texture.
       *
       * See {@link #updateUVs}. */
      __publicField(this, "uvs", []);
      /** Triplets of vertex indices which describe the mesh's triangulation. */
      __publicField(this, "triangles", []);
      /** The color to tint the mesh. */
      __publicField(this, "color", new Color2(1, 1, 1, 1));
      /** The width of the mesh's image. Available only when nonessential data was exported. */
      __publicField(this, "width", 0);
      /** The height of the mesh's image. Available only when nonessential data was exported. */
      __publicField(this, "height", 0);
      /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */
      __publicField(this, "hullLength", 0);
      /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if
       * nonessential data was exported. Triangulation is not performed at runtime. */
      __publicField(this, "edges", []);
      __publicField(this, "parentMesh", null);
      __publicField(this, "sequence", null);
      __publicField(this, "tempColor", new Color2(0, 0, 0, 0));
      this.path = path2;
    }
    /** Calculates {@link #uvs} using the {@link #regionUVs} and region. Must be called if the region, the region's properties, or
     * the {@link #regionUVs} are changed. */
    updateRegion() {
      if (!this.region)
        throw new Error("Region not set.");
      let regionUVs = this.regionUVs;
      if (!this.uvs || this.uvs.length != regionUVs.length)
        this.uvs = Utils.newFloatArray(regionUVs.length);
      let uvs = this.uvs;
      let n2 = this.uvs.length;
      let u2 = this.region.u, v2 = this.region.v, width = 0, height = 0;
      if (this.region instanceof TextureAtlasRegion) {
        let region = this.region, page = region.page;
        let textureWidth = page.width, textureHeight = page.height;
        switch (region.degrees) {
          case 90:
            u2 -= (region.originalHeight - region.offsetY - region.height) / textureWidth;
            v2 -= (region.originalWidth - region.offsetX - region.width) / textureHeight;
            width = region.originalHeight / textureWidth;
            height = region.originalWidth / textureHeight;
            for (let i3 = 0; i3 < n2; i3 += 2) {
              uvs[i3] = u2 + regionUVs[i3 + 1] * width;
              uvs[i3 + 1] = v2 + (1 - regionUVs[i3]) * height;
            }
            return;
          case 180:
            u2 -= (region.originalWidth - region.offsetX - region.width) / textureWidth;
            v2 -= region.offsetY / textureHeight;
            width = region.originalWidth / textureWidth;
            height = region.originalHeight / textureHeight;
            for (let i3 = 0; i3 < n2; i3 += 2) {
              uvs[i3] = u2 + (1 - regionUVs[i3]) * width;
              uvs[i3 + 1] = v2 + (1 - regionUVs[i3 + 1]) * height;
            }
            return;
          case 270:
            u2 -= region.offsetY / textureWidth;
            v2 -= region.offsetX / textureHeight;
            width = region.originalHeight / textureWidth;
            height = region.originalWidth / textureHeight;
            for (let i3 = 0; i3 < n2; i3 += 2) {
              uvs[i3] = u2 + (1 - regionUVs[i3 + 1]) * width;
              uvs[i3 + 1] = v2 + regionUVs[i3] * height;
            }
            return;
        }
        u2 -= region.offsetX / textureWidth;
        v2 -= (region.originalHeight - region.offsetY - region.height) / textureHeight;
        width = region.originalWidth / textureWidth;
        height = region.originalHeight / textureHeight;
      } else if (!this.region) {
        u2 = v2 = 0;
        width = height = 1;
      } else {
        width = this.region.u2 - u2;
        height = this.region.v2 - v2;
      }
      for (let i3 = 0; i3 < n2; i3 += 2) {
        uvs[i3] = u2 + regionUVs[i3] * width;
        uvs[i3 + 1] = v2 + regionUVs[i3 + 1] * height;
      }
    }
    /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},
     * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the
     * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */
    getParentMesh() {
      return this.parentMesh;
    }
    /** @param parentMesh May be null. */
    setParentMesh(parentMesh) {
      this.parentMesh = parentMesh;
      if (parentMesh) {
        this.bones = parentMesh.bones;
        this.vertices = parentMesh.vertices;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
        this.regionUVs = parentMesh.regionUVs;
        this.triangles = parentMesh.triangles;
        this.hullLength = parentMesh.hullLength;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
      }
    }
    copy() {
      if (this.parentMesh)
        return this.newLinkedMesh();
      let copy = new _MeshAttachment(this.name, this.path);
      copy.region = this.region;
      copy.color.setFromColor(this.color);
      this.copyTo(copy);
      copy.regionUVs = new Array(this.regionUVs.length);
      Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
      copy.uvs = this.uvs instanceof Float32Array ? Utils.newFloatArray(this.uvs.length) : new Array(this.uvs.length);
      Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);
      copy.triangles = new Array(this.triangles.length);
      Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
      copy.hullLength = this.hullLength;
      copy.sequence = this.sequence != null ? this.sequence.copy() : null;
      if (this.edges) {
        copy.edges = new Array(this.edges.length);
        Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
      }
      copy.width = this.width;
      copy.height = this.height;
      return copy;
    }
    computeWorldVertices(slot, start, count2, worldVertices, offset, stride) {
      if (this.sequence != null)
        this.sequence.apply(slot, this);
      super.computeWorldVertices(slot, start, count2, worldVertices, offset, stride);
    }
    /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/
    newLinkedMesh() {
      let copy = new _MeshAttachment(this.name, this.path);
      copy.region = this.region;
      copy.color.setFromColor(this.color);
      copy.timelineAttachment = this.timelineAttachment;
      copy.setParentMesh(this.parentMesh ? this.parentMesh : this);
      if (copy.region != null)
        copy.updateRegion();
      return copy;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/attachments/PathAttachment.js
  var PathAttachment = class _PathAttachment extends VertexAttachment {
    constructor(name) {
      super(name);
      /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */
      __publicField(this, "lengths", []);
      /** If true, the start and end knots are connected. */
      __publicField(this, "closed", false);
      /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer
       * calculations are performed but calculating positions along the path is less accurate. */
      __publicField(this, "constantSpeed", false);
      /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually
       * rendered at runtime. */
      __publicField(this, "color", new Color2(1, 1, 1, 1));
    }
    copy() {
      let copy = new _PathAttachment(this.name);
      this.copyTo(copy);
      copy.lengths = new Array(this.lengths.length);
      Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
      copy.closed = closed;
      copy.constantSpeed = this.constantSpeed;
      copy.color.setFromColor(this.color);
      return copy;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/attachments/PointAttachment.js
  var PointAttachment = class _PointAttachment extends VertexAttachment {
    constructor(name) {
      super(name);
      __publicField(this, "x", 0);
      __publicField(this, "y", 0);
      __publicField(this, "rotation", 0);
      /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments
       * are not usually rendered at runtime. */
      __publicField(this, "color", new Color2(0.38, 0.94, 0, 1));
    }
    computeWorldPosition(bone, point) {
      point.x = this.x * bone.a + this.y * bone.b + bone.worldX;
      point.y = this.x * bone.c + this.y * bone.d + bone.worldY;
      return point;
    }
    computeWorldRotation(bone) {
      const r2 = this.rotation * MathUtils.degRad, cos = Math.cos(r2), sin = Math.sin(r2);
      const x2 = cos * bone.a + sin * bone.b;
      const y2 = cos * bone.c + sin * bone.d;
      return MathUtils.atan2Deg(y2, x2);
    }
    copy() {
      let copy = new _PointAttachment(this.name);
      copy.x = this.x;
      copy.y = this.y;
      copy.rotation = this.rotation;
      copy.color.setFromColor(this.color);
      return copy;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/attachments/RegionAttachment.js
  var _RegionAttachment = class _RegionAttachment extends Attachment {
    constructor(name, path2) {
      super(name);
      /** The local x translation. */
      __publicField(this, "x", 0);
      /** The local y translation. */
      __publicField(this, "y", 0);
      /** The local scaleX. */
      __publicField(this, "scaleX", 1);
      /** The local scaleY. */
      __publicField(this, "scaleY", 1);
      /** The local rotation. */
      __publicField(this, "rotation", 0);
      /** The width of the region attachment in Spine. */
      __publicField(this, "width", 0);
      /** The height of the region attachment in Spine. */
      __publicField(this, "height", 0);
      /** The color to tint the region attachment. */
      __publicField(this, "color", new Color2(1, 1, 1, 1));
      /** The name of the texture region for this attachment. */
      __publicField(this, "path");
      __publicField(this, "region", null);
      __publicField(this, "sequence", null);
      /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.
       *
       * See {@link #updateOffset()}. */
      __publicField(this, "offset", Utils.newFloatArray(8));
      __publicField(this, "uvs", Utils.newFloatArray(8));
      __publicField(this, "tempColor", new Color2(1, 1, 1, 1));
      this.path = path2;
    }
    /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */
    updateRegion() {
      if (!this.region)
        throw new Error("Region not set.");
      let region = this.region;
      let uvs = this.uvs;
      if (region == null) {
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        uvs[4] = 1;
        uvs[5] = 1;
        uvs[6] = 1;
        uvs[7] = 0;
        return;
      }
      let regionScaleX = this.width / this.region.originalWidth * this.scaleX;
      let regionScaleY = this.height / this.region.originalHeight * this.scaleY;
      let localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
      let localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
      let localX2 = localX + this.region.width * regionScaleX;
      let localY2 = localY + this.region.height * regionScaleY;
      let radians = this.rotation * MathUtils.degRad;
      let cos = Math.cos(radians);
      let sin = Math.sin(radians);
      let x2 = this.x, y2 = this.y;
      let localXCos = localX * cos + x2;
      let localXSin = localX * sin;
      let localYCos = localY * cos + y2;
      let localYSin = localY * sin;
      let localX2Cos = localX2 * cos + x2;
      let localX2Sin = localX2 * sin;
      let localY2Cos = localY2 * cos + y2;
      let localY2Sin = localY2 * sin;
      let offset = this.offset;
      offset[0] = localXCos - localYSin;
      offset[1] = localYCos + localXSin;
      offset[2] = localXCos - localY2Sin;
      offset[3] = localY2Cos + localXSin;
      offset[4] = localX2Cos - localY2Sin;
      offset[5] = localY2Cos + localX2Sin;
      offset[6] = localX2Cos - localYSin;
      offset[7] = localYCos + localX2Sin;
      if (region.degrees == 90) {
        uvs[0] = region.u2;
        uvs[1] = region.v2;
        uvs[2] = region.u;
        uvs[3] = region.v2;
        uvs[4] = region.u;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v;
      } else {
        uvs[0] = region.u;
        uvs[1] = region.v2;
        uvs[2] = region.u;
        uvs[3] = region.v;
        uvs[4] = region.u2;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v2;
      }
    }
    /** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may
     * be changed.
     * <p>
     * See <a href="http://esotericsoftware.com/spine-runtime-skeletons#World-transforms">World transforms</a> in the Spine
     * Runtimes Guide.
     * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.
     * @param offset The <code>worldVertices</code> index to begin writing values.
     * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */
    computeWorldVertices(slot, worldVertices, offset, stride) {
      if (this.sequence != null)
        this.sequence.apply(slot, this);
      let bone = slot.bone;
      let vertexOffset = this.offset;
      let x2 = bone.worldX, y2 = bone.worldY;
      let a2 = bone.a, b2 = bone.b, c2 = bone.c, d2 = bone.d;
      let offsetX = 0, offsetY = 0;
      offsetX = vertexOffset[0];
      offsetY = vertexOffset[1];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x2;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[2];
      offsetY = vertexOffset[3];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x2;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[4];
      offsetY = vertexOffset[5];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x2;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[6];
      offsetY = vertexOffset[7];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x2;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
    }
    copy() {
      let copy = new _RegionAttachment(this.name, this.path);
      copy.region = this.region;
      copy.x = this.x;
      copy.y = this.y;
      copy.scaleX = this.scaleX;
      copy.scaleY = this.scaleY;
      copy.rotation = this.rotation;
      copy.width = this.width;
      copy.height = this.height;
      Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
      Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
      copy.color.setFromColor(this.color);
      copy.sequence = this.sequence != null ? this.sequence.copy() : null;
      return copy;
    }
  };
  __publicField(_RegionAttachment, "X1", 0);
  __publicField(_RegionAttachment, "Y1", 1);
  __publicField(_RegionAttachment, "C1R", 2);
  __publicField(_RegionAttachment, "C1G", 3);
  __publicField(_RegionAttachment, "C1B", 4);
  __publicField(_RegionAttachment, "C1A", 5);
  __publicField(_RegionAttachment, "U1", 6);
  __publicField(_RegionAttachment, "V1", 7);
  __publicField(_RegionAttachment, "X2", 8);
  __publicField(_RegionAttachment, "Y2", 9);
  __publicField(_RegionAttachment, "C2R", 10);
  __publicField(_RegionAttachment, "C2G", 11);
  __publicField(_RegionAttachment, "C2B", 12);
  __publicField(_RegionAttachment, "C2A", 13);
  __publicField(_RegionAttachment, "U2", 14);
  __publicField(_RegionAttachment, "V2", 15);
  __publicField(_RegionAttachment, "X3", 16);
  __publicField(_RegionAttachment, "Y3", 17);
  __publicField(_RegionAttachment, "C3R", 18);
  __publicField(_RegionAttachment, "C3G", 19);
  __publicField(_RegionAttachment, "C3B", 20);
  __publicField(_RegionAttachment, "C3A", 21);
  __publicField(_RegionAttachment, "U3", 22);
  __publicField(_RegionAttachment, "V3", 23);
  __publicField(_RegionAttachment, "X4", 24);
  __publicField(_RegionAttachment, "Y4", 25);
  __publicField(_RegionAttachment, "C4R", 26);
  __publicField(_RegionAttachment, "C4G", 27);
  __publicField(_RegionAttachment, "C4B", 28);
  __publicField(_RegionAttachment, "C4A", 29);
  __publicField(_RegionAttachment, "U4", 30);
  __publicField(_RegionAttachment, "V4", 31);
  var RegionAttachment = _RegionAttachment;

  // node_modules/@esotericsoftware/spine-core/dist/AtlasAttachmentLoader.js
  var AtlasAttachmentLoader = class {
    constructor(atlas) {
      __publicField(this, "atlas");
      this.atlas = atlas;
    }
    loadSequence(name, basePath, sequence) {
      let regions = sequence.regions;
      for (let i3 = 0, n2 = regions.length; i3 < n2; i3++) {
        let path2 = sequence.getPath(basePath, i3);
        let region = this.atlas.findRegion(path2);
        if (region == null)
          throw new Error("Region not found in atlas: " + path2 + " (sequence: " + name + ")");
        regions[i3] = region;
      }
    }
    newRegionAttachment(skin, name, path2, sequence) {
      let attachment = new RegionAttachment(name, path2);
      if (sequence != null) {
        this.loadSequence(name, path2, sequence);
      } else {
        let region = this.atlas.findRegion(path2);
        if (!region)
          throw new Error("Region not found in atlas: " + path2 + " (region attachment: " + name + ")");
        attachment.region = region;
      }
      return attachment;
    }
    newMeshAttachment(skin, name, path2, sequence) {
      let attachment = new MeshAttachment(name, path2);
      if (sequence != null) {
        this.loadSequence(name, path2, sequence);
      } else {
        let region = this.atlas.findRegion(path2);
        if (!region)
          throw new Error("Region not found in atlas: " + path2 + " (mesh attachment: " + name + ")");
        attachment.region = region;
      }
      return attachment;
    }
    newBoundingBoxAttachment(skin, name) {
      return new BoundingBoxAttachment(name);
    }
    newPathAttachment(skin, name) {
      return new PathAttachment(name);
    }
    newPointAttachment(skin, name) {
      return new PointAttachment(name);
    }
    newClippingAttachment(skin, name) {
      return new ClippingAttachment(name);
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/BoneData.js
  var BoneData = class {
    constructor(index, name, parent) {
      /** The index of the bone in {@link Skeleton#getBones()}. */
      __publicField(this, "index", 0);
      /** The name of the bone, which is unique across all bones in the skeleton. */
      __publicField(this, "name");
      /** @returns May be null. */
      __publicField(this, "parent", null);
      /** The bone's length. */
      __publicField(this, "length", 0);
      /** The local x translation. */
      __publicField(this, "x", 0);
      /** The local y translation. */
      __publicField(this, "y", 0);
      /** The local rotation in degrees, counter clockwise. */
      __publicField(this, "rotation", 0);
      /** The local scaleX. */
      __publicField(this, "scaleX", 1);
      /** The local scaleY. */
      __publicField(this, "scaleY", 1);
      /** The local shearX. */
      __publicField(this, "shearX", 0);
      /** The local shearX. */
      __publicField(this, "shearY", 0);
      /** The transform mode for how parent world transforms affect this bone. */
      __publicField(this, "inherit", Inherit.Normal);
      /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this
        * bone.
        * @see Skin#bones */
      __publicField(this, "skinRequired", false);
      /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually
       * rendered at runtime. */
      __publicField(this, "color", new Color2());
      /** The bone icon as it was in Spine, or null if nonessential data was not exported. */
      __publicField(this, "icon");
      /** False if the bone was hidden in Spine and nonessential data was exported. Does not affect runtime rendering. */
      __publicField(this, "visible", false);
      if (index < 0)
        throw new Error("index must be >= 0.");
      if (!name)
        throw new Error("name cannot be null.");
      this.index = index;
      this.name = name;
      this.parent = parent;
    }
  };
  var Inherit;
  (function(Inherit2) {
    Inherit2[Inherit2["Normal"] = 0] = "Normal";
    Inherit2[Inherit2["OnlyTranslation"] = 1] = "OnlyTranslation";
    Inherit2[Inherit2["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
    Inherit2[Inherit2["NoScale"] = 3] = "NoScale";
    Inherit2[Inherit2["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
  })(Inherit || (Inherit = {}));

  // node_modules/@esotericsoftware/spine-core/dist/Bone.js
  var Bone = class {
    /** @param parent May be null. */
    constructor(data, skeleton, parent) {
      /** The bone's setup pose data. */
      __publicField(this, "data");
      /** The skeleton this bone belongs to. */
      __publicField(this, "skeleton");
      /** The parent bone, or null if this is the root bone. */
      __publicField(this, "parent", null);
      /** The immediate children of this bone. */
      __publicField(this, "children", new Array());
      /** The local x translation. */
      __publicField(this, "x", 0);
      /** The local y translation. */
      __publicField(this, "y", 0);
      /** The local rotation in degrees, counter clockwise. */
      __publicField(this, "rotation", 0);
      /** The local scaleX. */
      __publicField(this, "scaleX", 0);
      /** The local scaleY. */
      __publicField(this, "scaleY", 0);
      /** The local shearX. */
      __publicField(this, "shearX", 0);
      /** The local shearY. */
      __publicField(this, "shearY", 0);
      /** The applied local x translation. */
      __publicField(this, "ax", 0);
      /** The applied local y translation. */
      __publicField(this, "ay", 0);
      /** The applied local rotation in degrees, counter clockwise. */
      __publicField(this, "arotation", 0);
      /** The applied local scaleX. */
      __publicField(this, "ascaleX", 0);
      /** The applied local scaleY. */
      __publicField(this, "ascaleY", 0);
      /** The applied local shearX. */
      __publicField(this, "ashearX", 0);
      /** The applied local shearY. */
      __publicField(this, "ashearY", 0);
      /** Part of the world transform matrix for the X axis. If changed, {@link #updateAppliedTransform()} should be called. */
      __publicField(this, "a", 0);
      /** Part of the world transform matrix for the Y axis. If changed, {@link #updateAppliedTransform()} should be called. */
      __publicField(this, "b", 0);
      /** Part of the world transform matrix for the X axis. If changed, {@link #updateAppliedTransform()} should be called. */
      __publicField(this, "c", 0);
      /** Part of the world transform matrix for the Y axis. If changed, {@link #updateAppliedTransform()} should be called. */
      __publicField(this, "d", 0);
      /** The world X position. If changed, {@link #updateAppliedTransform()} should be called. */
      __publicField(this, "worldY", 0);
      /** The world Y position. If changed, {@link #updateAppliedTransform()} should be called. */
      __publicField(this, "worldX", 0);
      __publicField(this, "inherit", Inherit.Normal);
      __publicField(this, "sorted", false);
      __publicField(this, "active", false);
      if (!data)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.skeleton = skeleton;
      this.parent = parent;
      this.setToSetupPose();
    }
    /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the
      * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */
    isActive() {
      return this.active;
    }
    /** Computes the world transform using the parent bone and this bone's local applied transform. */
    update(physics) {
      this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
    }
    /** Computes the world transform using the parent bone and this bone's local transform.
     *
     * See {@link #updateWorldTransformWith()}. */
    updateWorldTransform() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    }
    /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the
     * specified local transform. Child bones are not updated.
     *
     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
     * Runtimes Guide. */
    updateWorldTransformWith(x2, y2, rotation, scaleX, scaleY, shearX, shearY) {
      this.ax = x2;
      this.ay = y2;
      this.arotation = rotation;
      this.ascaleX = scaleX;
      this.ascaleY = scaleY;
      this.ashearX = shearX;
      this.ashearY = shearY;
      let parent = this.parent;
      if (!parent) {
        let skeleton = this.skeleton;
        const sx = skeleton.scaleX, sy = skeleton.scaleY;
        const rx = (rotation + shearX) * MathUtils.degRad;
        const ry = (rotation + 90 + shearY) * MathUtils.degRad;
        this.a = Math.cos(rx) * scaleX * sx;
        this.b = Math.cos(ry) * scaleY * sx;
        this.c = Math.sin(rx) * scaleX * sy;
        this.d = Math.sin(ry) * scaleY * sy;
        this.worldX = x2 * sx + skeleton.x;
        this.worldY = y2 * sy + skeleton.y;
        return;
      }
      let pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
      this.worldX = pa * x2 + pb * y2 + parent.worldX;
      this.worldY = pc * x2 + pd * y2 + parent.worldY;
      switch (this.inherit) {
        case Inherit.Normal: {
          const rx = (rotation + shearX) * MathUtils.degRad;
          const ry = (rotation + 90 + shearY) * MathUtils.degRad;
          const la = Math.cos(rx) * scaleX;
          const lb = Math.cos(ry) * scaleY;
          const lc = Math.sin(rx) * scaleX;
          const ld = Math.sin(ry) * scaleY;
          this.a = pa * la + pb * lc;
          this.b = pa * lb + pb * ld;
          this.c = pc * la + pd * lc;
          this.d = pc * lb + pd * ld;
          return;
        }
        case Inherit.OnlyTranslation: {
          const rx = (rotation + shearX) * MathUtils.degRad;
          const ry = (rotation + 90 + shearY) * MathUtils.degRad;
          this.a = Math.cos(rx) * scaleX;
          this.b = Math.cos(ry) * scaleY;
          this.c = Math.sin(rx) * scaleX;
          this.d = Math.sin(ry) * scaleY;
          break;
        }
        case Inherit.NoRotationOrReflection: {
          let sx = 1 / this.skeleton.scaleX, sy = 1 / this.skeleton.scaleY;
          pa *= sx;
          pc *= sy;
          let s2 = pa * pa + pc * pc;
          let prx = 0;
          if (s2 > 1e-4) {
            s2 = Math.abs(pa * pd * sy - pb * sx * pc) / s2;
            pb = pc * s2;
            pd = pa * s2;
            prx = Math.atan2(pc, pa) * MathUtils.radDeg;
          } else {
            pa = 0;
            pc = 0;
            prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;
          }
          const rx = (rotation + shearX - prx) * MathUtils.degRad;
          const ry = (rotation + shearY - prx + 90) * MathUtils.degRad;
          const la = Math.cos(rx) * scaleX;
          const lb = Math.cos(ry) * scaleY;
          const lc = Math.sin(rx) * scaleX;
          const ld = Math.sin(ry) * scaleY;
          this.a = pa * la - pb * lc;
          this.b = pa * lb - pb * ld;
          this.c = pc * la + pd * lc;
          this.d = pc * lb + pd * ld;
          break;
        }
        case Inherit.NoScale:
        case Inherit.NoScaleOrReflection: {
          rotation *= MathUtils.degRad;
          const cos = Math.cos(rotation), sin = Math.sin(rotation);
          let za = (pa * cos + pb * sin) / this.skeleton.scaleX;
          let zc = (pc * cos + pd * sin) / this.skeleton.scaleY;
          let s2 = Math.sqrt(za * za + zc * zc);
          if (s2 > 1e-5)
            s2 = 1 / s2;
          za *= s2;
          zc *= s2;
          s2 = Math.sqrt(za * za + zc * zc);
          if (this.inherit == Inherit.NoScale && pa * pd - pb * pc < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
            s2 = -s2;
          rotation = Math.PI / 2 + Math.atan2(zc, za);
          const zb = Math.cos(rotation) * s2;
          const zd = Math.sin(rotation) * s2;
          shearX *= MathUtils.degRad;
          shearY = (90 + shearY) * MathUtils.degRad;
          const la = Math.cos(shearX) * scaleX;
          const lb = Math.cos(shearY) * scaleY;
          const lc = Math.sin(shearX) * scaleX;
          const ld = Math.sin(shearY) * scaleY;
          this.a = za * la + zb * lc;
          this.b = za * lb + zb * ld;
          this.c = zc * la + zd * lc;
          this.d = zc * lb + zd * ld;
          break;
        }
      }
      this.a *= this.skeleton.scaleX;
      this.b *= this.skeleton.scaleX;
      this.c *= this.skeleton.scaleY;
      this.d *= this.skeleton.scaleY;
    }
    /** Sets this bone's local transform to the setup pose. */
    setToSetupPose() {
      let data = this.data;
      this.x = data.x;
      this.y = data.y;
      this.rotation = data.rotation;
      this.scaleX = data.scaleX;
      this.scaleY = data.scaleY;
      this.shearX = data.shearX;
      this.shearY = data.shearY;
      this.inherit = data.inherit;
    }
    /** Computes the applied transform values from the world transform.
     *
     * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so
     * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other
     * constraints).
     *
     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after
     * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */
    updateAppliedTransform() {
      let parent = this.parent;
      if (!parent) {
        this.ax = this.worldX - this.skeleton.x;
        this.ay = this.worldY - this.skeleton.y;
        this.arotation = Math.atan2(this.c, this.a) * MathUtils.radDeg;
        this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);
        this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);
        this.ashearX = 0;
        this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * MathUtils.radDeg;
        return;
      }
      let pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
      let pid = 1 / (pa * pd - pb * pc);
      let ia = pd * pid, ib = pb * pid, ic = pc * pid, id = pa * pid;
      let dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;
      this.ax = dx * ia - dy * ib;
      this.ay = dy * id - dx * ic;
      let ra, rb, rc, rd;
      if (this.inherit == Inherit.OnlyTranslation) {
        ra = this.a;
        rb = this.b;
        rc = this.c;
        rd = this.d;
      } else {
        switch (this.inherit) {
          case Inherit.NoRotationOrReflection: {
            let s3 = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
            pb = -pc * this.skeleton.scaleX * s3 / this.skeleton.scaleY;
            pd = pa * this.skeleton.scaleY * s3 / this.skeleton.scaleX;
            pid = 1 / (pa * pd - pb * pc);
            ia = pd * pid;
            ib = pb * pid;
            break;
          }
          case Inherit.NoScale:
          case Inherit.NoScaleOrReflection:
            let cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);
            pa = (pa * cos + pb * sin) / this.skeleton.scaleX;
            pc = (pc * cos + pd * sin) / this.skeleton.scaleY;
            let s2 = Math.sqrt(pa * pa + pc * pc);
            if (s2 > 1e-5)
              s2 = 1 / s2;
            pa *= s2;
            pc *= s2;
            s2 = Math.sqrt(pa * pa + pc * pc);
            if (this.inherit == Inherit.NoScale && pid < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
              s2 = -s2;
            let r2 = MathUtils.PI / 2 + Math.atan2(pc, pa);
            pb = Math.cos(r2) * s2;
            pd = Math.sin(r2) * s2;
            pid = 1 / (pa * pd - pb * pc);
            ia = pd * pid;
            ib = pb * pid;
            ic = pc * pid;
            id = pa * pid;
        }
        ra = ia * this.a - ib * this.c;
        rb = ia * this.b - ib * this.d;
        rc = id * this.c - ic * this.a;
        rd = id * this.d - ic * this.b;
      }
      this.ashearX = 0;
      this.ascaleX = Math.sqrt(ra * ra + rc * rc);
      if (this.ascaleX > 1e-4) {
        let det = ra * rd - rb * rc;
        this.ascaleY = det / this.ascaleX;
        this.ashearY = -Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;
        this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;
      } else {
        this.ascaleX = 0;
        this.ascaleY = Math.sqrt(rb * rb + rd * rd);
        this.ashearY = 0;
        this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;
      }
    }
    /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */
    getWorldRotationX() {
      return Math.atan2(this.c, this.a) * MathUtils.radDeg;
    }
    /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */
    getWorldRotationY() {
      return Math.atan2(this.d, this.b) * MathUtils.radDeg;
    }
    /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */
    getWorldScaleX() {
      return Math.sqrt(this.a * this.a + this.c * this.c);
    }
    /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */
    getWorldScaleY() {
      return Math.sqrt(this.b * this.b + this.d * this.d);
    }
    /** Transforms a point from world coordinates to the bone's local coordinates. */
    worldToLocal(world) {
      let invDet = 1 / (this.a * this.d - this.b * this.c);
      let x2 = world.x - this.worldX, y2 = world.y - this.worldY;
      world.x = x2 * this.d * invDet - y2 * this.b * invDet;
      world.y = y2 * this.a * invDet - x2 * this.c * invDet;
      return world;
    }
    /** Transforms a point from the bone's local coordinates to world coordinates. */
    localToWorld(local) {
      let x2 = local.x, y2 = local.y;
      local.x = x2 * this.a + y2 * this.b + this.worldX;
      local.y = x2 * this.c + y2 * this.d + this.worldY;
      return local;
    }
    /** Transforms a point from world coordinates to the parent bone's local coordinates. */
    worldToParent(world) {
      if (world == null)
        throw new Error("world cannot be null.");
      return this.parent == null ? world : this.parent.worldToLocal(world);
    }
    /** Transforms a point from the parent bone's coordinates to world coordinates. */
    parentToWorld(world) {
      if (world == null)
        throw new Error("world cannot be null.");
      return this.parent == null ? world : this.parent.localToWorld(world);
    }
    /** Transforms a world rotation to a local rotation. */
    worldToLocalRotation(worldRotation) {
      let sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);
      return Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * MathUtils.radDeg + this.rotation - this.shearX;
    }
    /** Transforms a local rotation to a world rotation. */
    localToWorldRotation(localRotation) {
      localRotation -= this.rotation - this.shearX;
      let sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);
      return Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * MathUtils.radDeg;
    }
    /** Rotates the world transform the specified amount.
     * <p>
     * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and
     * {@link #update(Physics)} will need to be called on any child bones, recursively. */
    rotateWorld(degrees) {
      degrees *= MathUtils.degRad;
      const sin = Math.sin(degrees), cos = Math.cos(degrees);
      const ra = this.a, rb = this.b;
      this.a = cos * ra - sin * this.c;
      this.b = cos * rb - sin * this.d;
      this.c = sin * ra + cos * this.c;
      this.d = sin * rb + cos * this.d;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/ConstraintData.js
  var ConstraintData = class {
    constructor(name, order, skinRequired) {
      __publicField(this, "name");
      __publicField(this, "order");
      __publicField(this, "skinRequired");
      this.name = name;
      this.order = order;
      this.skinRequired = skinRequired;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/Event.js
  var Event2 = class {
    constructor(time, data) {
      __publicField(this, "data");
      __publicField(this, "intValue", 0);
      __publicField(this, "floatValue", 0);
      __publicField(this, "stringValue", null);
      __publicField(this, "time", 0);
      __publicField(this, "volume", 0);
      __publicField(this, "balance", 0);
      if (!data)
        throw new Error("data cannot be null.");
      this.time = time;
      this.data = data;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/EventData.js
  var EventData = class {
    constructor(name) {
      __publicField(this, "name");
      __publicField(this, "intValue", 0);
      __publicField(this, "floatValue", 0);
      __publicField(this, "stringValue", null);
      __publicField(this, "audioPath", null);
      __publicField(this, "volume", 0);
      __publicField(this, "balance", 0);
      this.name = name;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/IkConstraint.js
  var IkConstraint = class {
    constructor(data, skeleton) {
      /** The IK constraint's setup pose data. */
      __publicField(this, "data");
      /** The bones that will be modified by this IK constraint. */
      __publicField(this, "bones");
      /** The bone that is the IK target. */
      __publicField(this, "target");
      /** Controls the bend direction of the IK bones, either 1 or -1. */
      __publicField(this, "bendDirection", 0);
      /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */
      __publicField(this, "compress", false);
      /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained
       * and the parent bone has local nonuniform scale, stretch is not applied. */
      __publicField(this, "stretch", false);
      /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */
      __publicField(this, "mix", 1);
      /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */
      __publicField(this, "softness", 0);
      __publicField(this, "active", false);
      if (!data)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.bones = new Array();
      for (let i3 = 0; i3 < data.bones.length; i3++) {
        let bone = skeleton.findBone(data.bones[i3].name);
        if (!bone)
          throw new Error(`Couldn't find bone ${data.bones[i3].name}`);
        this.bones.push(bone);
      }
      let target = skeleton.findBone(data.target.name);
      if (!target)
        throw new Error(`Couldn't find bone ${data.target.name}`);
      this.target = target;
      this.mix = data.mix;
      this.softness = data.softness;
      this.bendDirection = data.bendDirection;
      this.compress = data.compress;
      this.stretch = data.stretch;
    }
    isActive() {
      return this.active;
    }
    setToSetupPose() {
      const data = this.data;
      this.mix = data.mix;
      this.softness = data.softness;
      this.bendDirection = data.bendDirection;
      this.compress = data.compress;
      this.stretch = data.stretch;
    }
    update(physics) {
      if (this.mix == 0)
        return;
      let target = this.target;
      let bones = this.bones;
      switch (bones.length) {
        case 1:
          this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
          break;
        case 2:
          this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
          break;
      }
    }
    /** Applies 1 bone IK. The target is specified in the world coordinate system. */
    apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
      let p3 = bone.parent;
      if (!p3)
        throw new Error("IK bone must have parent.");
      let pa = p3.a, pb = p3.b, pc = p3.c, pd = p3.d;
      let rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;
      switch (bone.inherit) {
        case Inherit.OnlyTranslation:
          tx = (targetX - bone.worldX) * MathUtils.signum(bone.skeleton.scaleX);
          ty = (targetY - bone.worldY) * MathUtils.signum(bone.skeleton.scaleY);
          break;
        case Inherit.NoRotationOrReflection:
          let s2 = Math.abs(pa * pd - pb * pc) / Math.max(1e-4, pa * pa + pc * pc);
          let sa = pa / bone.skeleton.scaleX;
          let sc = pc / bone.skeleton.scaleY;
          pb = -sc * s2 * bone.skeleton.scaleX;
          pd = sa * s2 * bone.skeleton.scaleY;
          rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;
        // Fall through
        default:
          let x2 = targetX - p3.worldX, y2 = targetY - p3.worldY;
          let d2 = pa * pd - pb * pc;
          if (Math.abs(d2) <= 1e-4) {
            tx = 0;
            ty = 0;
          } else {
            tx = (x2 * pd - y2 * pb) / d2 - bone.ax;
            ty = (y2 * pa - x2 * pc) / d2 - bone.ay;
          }
      }
      rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;
      if (bone.ascaleX < 0)
        rotationIK += 180;
      if (rotationIK > 180)
        rotationIK -= 360;
      else if (rotationIK < -180)
        rotationIK += 360;
      let sx = bone.ascaleX, sy = bone.ascaleY;
      if (compress || stretch) {
        switch (bone.inherit) {
          case Inherit.NoScale:
          case Inherit.NoScaleOrReflection:
            tx = targetX - bone.worldX;
            ty = targetY - bone.worldY;
        }
        const b2 = bone.data.length * sx;
        if (b2 > 1e-4) {
          const dd = tx * tx + ty * ty;
          if (compress && dd < b2 * b2 || stretch && dd > b2 * b2) {
            const s2 = (Math.sqrt(dd) / b2 - 1) * alpha + 1;
            sx *= s2;
            if (uniform)
              sy *= s2;
          }
        }
      }
      bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
    }
    /** Applies 2 bone IK. The target is specified in the world coordinate system.
     * @param child A direct descendant of the parent bone. */
    apply2(parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {
      if (parent.inherit != Inherit.Normal || child.inherit != Inherit.Normal)
        return;
      let px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, sx = psx, sy = psy, csx = child.ascaleX;
      let os1 = 0, os2 = 0, s2 = 0;
      if (psx < 0) {
        psx = -psx;
        os1 = 180;
        s2 = -1;
      } else {
        os1 = 0;
        s2 = 1;
      }
      if (psy < 0) {
        psy = -psy;
        s2 = -s2;
      }
      if (csx < 0) {
        csx = -csx;
        os2 = 180;
      } else
        os2 = 0;
      let cx = child.ax, cy = 0, cwx = 0, cwy = 0, a2 = parent.a, b2 = parent.b, c2 = parent.c, d2 = parent.d;
      let u2 = Math.abs(psx - psy) <= 1e-4;
      if (!u2 || stretch) {
        cy = 0;
        cwx = a2 * cx + parent.worldX;
        cwy = c2 * cx + parent.worldY;
      } else {
        cy = child.ay;
        cwx = a2 * cx + b2 * cy + parent.worldX;
        cwy = c2 * cx + d2 * cy + parent.worldY;
      }
      let pp = parent.parent;
      if (!pp)
        throw new Error("IK parent must itself have a parent.");
      a2 = pp.a;
      b2 = pp.b;
      c2 = pp.c;
      d2 = pp.d;
      let id = a2 * d2 - b2 * c2, x2 = cwx - pp.worldX, y2 = cwy - pp.worldY;
      id = Math.abs(id) <= 1e-4 ? 0 : 1 / id;
      let dx = (x2 * d2 - y2 * b2) * id - px, dy = (y2 * a2 - x2 * c2) * id - py;
      let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a22;
      if (l1 < 1e-4) {
        this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
        child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
        return;
      }
      x2 = targetX - pp.worldX;
      y2 = targetY - pp.worldY;
      let tx = (x2 * d2 - y2 * b2) * id - px, ty = (y2 * a2 - x2 * c2) * id - py;
      let dd = tx * tx + ty * ty;
      if (softness != 0) {
        softness *= psx * (csx + 1) * 0.5;
        let td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;
        if (sd > 0) {
          let p3 = Math.min(1, sd / (softness * 2)) - 1;
          p3 = (sd - softness * (1 - p3 * p3)) / td;
          tx -= p3 * tx;
          ty -= p3 * ty;
          dd = tx * tx + ty * ty;
        }
      }
      outer: if (u2) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1) {
          cos = -1;
          a22 = Math.PI * bendDir;
        } else if (cos > 1) {
          cos = 1;
          a22 = 0;
          if (stretch) {
            a2 = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
            sx *= a2;
            if (uniform)
              sy *= a2;
          }
        } else
          a22 = Math.acos(cos) * bendDir;
        a2 = l1 + l2 * cos;
        b2 = l2 * Math.sin(a22);
        a1 = Math.atan2(ty * a2 - tx * b2, tx * a2 + ty * b2);
      } else {
        a2 = psx * l2;
        b2 = psy * l2;
        let aa = a2 * a2, bb = b2 * b2, ta = Math.atan2(ty, tx);
        c2 = bb * l1 * l1 + aa * dd - aa * bb;
        let c1 = -2 * bb * l1, c22 = bb - aa;
        d2 = c1 * c1 - 4 * c22 * c2;
        if (d2 >= 0) {
          let q = Math.sqrt(d2);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) * 0.5;
          let r0 = q / c22, r1 = c2 / q;
          let r2 = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          r0 = dd - r2 * r2;
          if (r0 >= 0) {
            y2 = Math.sqrt(r0) * bendDir;
            a1 = ta - Math.atan2(y2, r2);
            a22 = Math.atan2(y2 / psy, (r2 - l1) / psx);
            break outer;
          }
        }
        let minAngle = MathUtils.PI, minX = l1 - a2, minDist = minX * minX, minY = 0;
        let maxAngle = 0, maxX = l1 + a2, maxDist = maxX * maxX, maxY = 0;
        c2 = -a2 * l1 / (aa - bb);
        if (c2 >= -1 && c2 <= 1) {
          c2 = Math.acos(c2);
          x2 = a2 * Math.cos(c2) + l1;
          y2 = b2 * Math.sin(c2);
          d2 = x2 * x2 + y2 * y2;
          if (d2 < minDist) {
            minAngle = c2;
            minDist = d2;
            minX = x2;
            minY = y2;
          }
          if (d2 > maxDist) {
            maxAngle = c2;
            maxDist = d2;
            maxX = x2;
            maxY = y2;
          }
        }
        if (dd <= (minDist + maxDist) * 0.5) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a22 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a22 = maxAngle * bendDir;
        }
      }
      let os = Math.atan2(cy, cx) * s2;
      let rotation = parent.arotation;
      a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
      if (a1 > 180)
        a1 -= 360;
      else if (a1 < -180)
        a1 += 360;
      parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);
      rotation = child.arotation;
      a22 = ((a22 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
      if (a22 > 180)
        a22 -= 360;
      else if (a22 < -180)
        a22 += 360;
      child.updateWorldTransformWith(cx, cy, rotation + a22 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/IkConstraintData.js
  var IkConstraintData = class extends ConstraintData {
    constructor(name) {
      super(name, 0, false);
      /** The bones that are constrained by this IK constraint. */
      __publicField(this, "bones", new Array());
      /** The bone that is the IK target. */
      __publicField(this, "_target", null);
      /** Controls the bend direction of the IK bones, either 1 or -1. */
      __publicField(this, "bendDirection", 0);
      /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */
      __publicField(this, "compress", false);
      /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained
       * and the parent bone has local nonuniform scale, stretch is not applied. */
      __publicField(this, "stretch", false);
      /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone
       * is scaled on both the X and Y axes. */
      __publicField(this, "uniform", false);
      /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */
      __publicField(this, "mix", 0);
      /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */
      __publicField(this, "softness", 0);
    }
    set target(boneData) {
      this._target = boneData;
    }
    get target() {
      if (!this._target)
        throw new Error("BoneData not set.");
      else
        return this._target;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/PathConstraintData.js
  var PathConstraintData = class extends ConstraintData {
    constructor(name) {
      super(name, 0, false);
      /** The bones that will be modified by this path constraint. */
      __publicField(this, "bones", new Array());
      /** The slot whose path attachment will be used to constrained the bones. */
      __publicField(this, "_target", null);
      /** The mode for positioning the first bone on the path. */
      __publicField(this, "positionMode", PositionMode.Fixed);
      /** The mode for positioning the bones after the first bone on the path. */
      __publicField(this, "spacingMode", SpacingMode.Fixed);
      /** The mode for adjusting the rotation of the bones. */
      __publicField(this, "rotateMode", RotateMode.Chain);
      /** An offset added to the constrained bone rotation. */
      __publicField(this, "offsetRotation", 0);
      /** The position along the path. */
      __publicField(this, "position", 0);
      /** The spacing between bones. */
      __publicField(this, "spacing", 0);
      __publicField(this, "mixRotate", 0);
      __publicField(this, "mixX", 0);
      __publicField(this, "mixY", 0);
    }
    set target(slotData) {
      this._target = slotData;
    }
    get target() {
      if (!this._target)
        throw new Error("SlotData not set.");
      else
        return this._target;
    }
  };
  var PositionMode;
  (function(PositionMode2) {
    PositionMode2[PositionMode2["Fixed"] = 0] = "Fixed";
    PositionMode2[PositionMode2["Percent"] = 1] = "Percent";
  })(PositionMode || (PositionMode = {}));
  var SpacingMode;
  (function(SpacingMode2) {
    SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
    SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
    SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
    SpacingMode2[SpacingMode2["Proportional"] = 3] = "Proportional";
  })(SpacingMode || (SpacingMode = {}));
  var RotateMode;
  (function(RotateMode2) {
    RotateMode2[RotateMode2["Tangent"] = 0] = "Tangent";
    RotateMode2[RotateMode2["Chain"] = 1] = "Chain";
    RotateMode2[RotateMode2["ChainScale"] = 2] = "ChainScale";
  })(RotateMode || (RotateMode = {}));

  // node_modules/@esotericsoftware/spine-core/dist/PathConstraint.js
  var _PathConstraint = class _PathConstraint {
    constructor(data, skeleton) {
      /** The path constraint's setup pose data. */
      __publicField(this, "data");
      /** The bones that will be modified by this path constraint. */
      __publicField(this, "bones");
      /** The slot whose path attachment will be used to constrained the bones. */
      __publicField(this, "target");
      /** The position along the path. */
      __publicField(this, "position", 0);
      /** The spacing between bones. */
      __publicField(this, "spacing", 0);
      __publicField(this, "mixRotate", 0);
      __publicField(this, "mixX", 0);
      __publicField(this, "mixY", 0);
      __publicField(this, "spaces", new Array());
      __publicField(this, "positions", new Array());
      __publicField(this, "world", new Array());
      __publicField(this, "curves", new Array());
      __publicField(this, "lengths", new Array());
      __publicField(this, "segments", new Array());
      __publicField(this, "active", false);
      if (!data)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.bones = new Array();
      for (let i3 = 0, n2 = data.bones.length; i3 < n2; i3++) {
        let bone = skeleton.findBone(data.bones[i3].name);
        if (!bone)
          throw new Error(`Couldn't find bone ${data.bones[i3].name}.`);
        this.bones.push(bone);
      }
      let target = skeleton.findSlot(data.target.name);
      if (!target)
        throw new Error(`Couldn't find target bone ${data.target.name}`);
      this.target = target;
      this.position = data.position;
      this.spacing = data.spacing;
      this.mixRotate = data.mixRotate;
      this.mixX = data.mixX;
      this.mixY = data.mixY;
    }
    isActive() {
      return this.active;
    }
    setToSetupPose() {
      const data = this.data;
      this.position = data.position;
      this.spacing = data.spacing;
      this.mixRotate = data.mixRotate;
      this.mixX = data.mixX;
      this.mixY = data.mixY;
    }
    update(physics) {
      let attachment = this.target.getAttachment();
      if (!(attachment instanceof PathAttachment))
        return;
      let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY;
      if (mixRotate == 0 && mixX == 0 && mixY == 0)
        return;
      let data = this.data;
      let tangents = data.rotateMode == RotateMode.Tangent, scale = data.rotateMode == RotateMode.ChainScale;
      let bones = this.bones;
      let boneCount = bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
      let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths = scale ? this.lengths = Utils.setArraySize(this.lengths, boneCount) : [];
      let spacing = this.spacing;
      switch (data.spacingMode) {
        case SpacingMode.Percent:
          if (scale) {
            for (let i3 = 0, n2 = spacesCount - 1; i3 < n2; i3++) {
              let bone = bones[i3];
              let setupLength = bone.data.length;
              let x2 = setupLength * bone.a, y2 = setupLength * bone.c;
              lengths[i3] = Math.sqrt(x2 * x2 + y2 * y2);
            }
          }
          Utils.arrayFill(spaces, 1, spacesCount, spacing);
          break;
        case SpacingMode.Proportional:
          let sum = 0;
          for (let i3 = 0, n2 = spacesCount - 1; i3 < n2; ) {
            let bone = bones[i3];
            let setupLength = bone.data.length;
            if (setupLength < _PathConstraint.epsilon) {
              if (scale)
                lengths[i3] = 0;
              spaces[++i3] = spacing;
            } else {
              let x2 = setupLength * bone.a, y2 = setupLength * bone.c;
              let length = Math.sqrt(x2 * x2 + y2 * y2);
              if (scale)
                lengths[i3] = length;
              spaces[++i3] = length;
              sum += length;
            }
          }
          if (sum > 0) {
            sum = spacesCount / sum * spacing;
            for (let i3 = 1; i3 < spacesCount; i3++)
              spaces[i3] *= sum;
          }
          break;
        default:
          let lengthSpacing = data.spacingMode == SpacingMode.Length;
          for (let i3 = 0, n2 = spacesCount - 1; i3 < n2; ) {
            let bone = bones[i3];
            let setupLength = bone.data.length;
            if (setupLength < _PathConstraint.epsilon) {
              if (scale)
                lengths[i3] = 0;
              spaces[++i3] = spacing;
            } else {
              let x2 = setupLength * bone.a, y2 = setupLength * bone.c;
              let length = Math.sqrt(x2 * x2 + y2 * y2);
              if (scale)
                lengths[i3] = length;
              spaces[++i3] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
            }
          }
      }
      let positions = this.computeWorldPositions(attachment, spacesCount, tangents);
      let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
      let tip = false;
      if (offsetRotation == 0)
        tip = data.rotateMode == RotateMode.Chain;
      else {
        tip = false;
        let p3 = this.target.bone;
        offsetRotation *= p3.a * p3.d - p3.b * p3.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
      }
      for (let i3 = 0, p3 = 3; i3 < boneCount; i3++, p3 += 3) {
        let bone = bones[i3];
        bone.worldX += (boneX - bone.worldX) * mixX;
        bone.worldY += (boneY - bone.worldY) * mixY;
        let x2 = positions[p3], y2 = positions[p3 + 1], dx = x2 - boneX, dy = y2 - boneY;
        if (scale) {
          let length = lengths[i3];
          if (length != 0) {
            let s2 = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;
            bone.a *= s2;
            bone.c *= s2;
          }
        }
        boneX = x2;
        boneY = y2;
        if (mixRotate > 0) {
          let a2 = bone.a, b2 = bone.b, c2 = bone.c, d2 = bone.d, r2 = 0, cos = 0, sin = 0;
          if (tangents)
            r2 = positions[p3 - 1];
          else if (spaces[i3 + 1] == 0)
            r2 = positions[p3 + 2];
          else
            r2 = Math.atan2(dy, dx);
          r2 -= Math.atan2(c2, a2);
          if (tip) {
            cos = Math.cos(r2);
            sin = Math.sin(r2);
            let length = bone.data.length;
            boneX += (length * (cos * a2 - sin * c2) - dx) * mixRotate;
            boneY += (length * (sin * a2 + cos * c2) - dy) * mixRotate;
          } else {
            r2 += offsetRotation;
          }
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= mixRotate;
          cos = Math.cos(r2);
          sin = Math.sin(r2);
          bone.a = cos * a2 - sin * c2;
          bone.b = cos * b2 - sin * d2;
          bone.c = sin * a2 + cos * c2;
          bone.d = sin * b2 + cos * d2;
        }
        bone.updateAppliedTransform();
      }
    }
    computeWorldPositions(path2, spacesCount, tangents) {
      let target = this.target;
      let position = this.position;
      let spaces = this.spaces, out2 = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = this.world;
      let closed2 = path2.closed;
      let verticesLength = path2.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = _PathConstraint.NONE;
      if (!path2.constantSpeed) {
        let lengths = path2.lengths;
        curveCount -= closed2 ? 1 : 2;
        let pathLength2 = lengths[curveCount];
        if (this.data.positionMode == PositionMode.Percent)
          position *= pathLength2;
        let multiplier2;
        switch (this.data.spacingMode) {
          case SpacingMode.Percent:
            multiplier2 = pathLength2;
            break;
          case SpacingMode.Proportional:
            multiplier2 = pathLength2 / spacesCount;
            break;
          default:
            multiplier2 = 1;
        }
        world = Utils.setArraySize(this.world, 8);
        for (let i3 = 0, o2 = 0, curve = 0; i3 < spacesCount; i3++, o2 += 3) {
          let space = spaces[i3] * multiplier2;
          position += space;
          let p3 = position;
          if (closed2) {
            p3 %= pathLength2;
            if (p3 < 0)
              p3 += pathLength2;
            curve = 0;
          } else if (p3 < 0) {
            if (prevCurve != _PathConstraint.BEFORE) {
              prevCurve = _PathConstraint.BEFORE;
              path2.computeWorldVertices(target, 2, 4, world, 0, 2);
            }
            this.addBeforePosition(p3, world, 0, out2, o2);
            continue;
          } else if (p3 > pathLength2) {
            if (prevCurve != _PathConstraint.AFTER) {
              prevCurve = _PathConstraint.AFTER;
              path2.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
            }
            this.addAfterPosition(p3 - pathLength2, world, 0, out2, o2);
            continue;
          }
          for (; ; curve++) {
            let length = lengths[curve];
            if (p3 > length)
              continue;
            if (curve == 0)
              p3 /= length;
            else {
              let prev = lengths[curve - 1];
              p3 = (p3 - prev) / (length - prev);
            }
            break;
          }
          if (curve != prevCurve) {
            prevCurve = curve;
            if (closed2 && curve == curveCount) {
              path2.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
              path2.computeWorldVertices(target, 0, 4, world, 4, 2);
            } else
              path2.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
          }
          this.addCurvePosition(p3, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out2, o2, tangents || i3 > 0 && space == 0);
        }
        return out2;
      }
      if (closed2) {
        verticesLength += 2;
        world = Utils.setArraySize(this.world, verticesLength);
        path2.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
        path2.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
        world[verticesLength - 2] = world[0];
        world[verticesLength - 1] = world[1];
      } else {
        curveCount--;
        verticesLength -= 4;
        world = Utils.setArraySize(this.world, verticesLength);
        path2.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
      }
      let curves = Utils.setArraySize(this.curves, curveCount);
      let pathLength = 0;
      let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
      let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
      for (let i3 = 0, w2 = 2; i3 < curveCount; i3++, w2 += 6) {
        cx1 = world[w2];
        cy1 = world[w2 + 1];
        cx2 = world[w2 + 2];
        cy2 = world[w2 + 3];
        x2 = world[w2 + 4];
        y2 = world[w2 + 5];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        curves[i3] = pathLength;
        x1 = x2;
        y1 = y2;
      }
      if (this.data.positionMode == PositionMode.Percent)
        position *= pathLength;
      let multiplier;
      switch (this.data.spacingMode) {
        case SpacingMode.Percent:
          multiplier = pathLength;
          break;
        case SpacingMode.Proportional:
          multiplier = pathLength / spacesCount;
          break;
        default:
          multiplier = 1;
      }
      let segments = this.segments;
      let curveLength = 0;
      for (let i3 = 0, o2 = 0, curve = 0, segment = 0; i3 < spacesCount; i3++, o2 += 3) {
        let space = spaces[i3] * multiplier;
        position += space;
        let p3 = position;
        if (closed2) {
          p3 %= pathLength;
          if (p3 < 0)
            p3 += pathLength;
          curve = 0;
        } else if (p3 < 0) {
          this.addBeforePosition(p3, world, 0, out2, o2);
          continue;
        } else if (p3 > pathLength) {
          this.addAfterPosition(p3 - pathLength, world, verticesLength - 4, out2, o2);
          continue;
        }
        for (; ; curve++) {
          let length = curves[curve];
          if (p3 > length)
            continue;
          if (curve == 0)
            p3 /= length;
          else {
            let prev = curves[curve - 1];
            p3 = (p3 - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          let ii = curve * 6;
          x1 = world[ii];
          y1 = world[ii + 1];
          cx1 = world[ii + 2];
          cy1 = world[ii + 3];
          cx2 = world[ii + 4];
          cy2 = world[ii + 5];
          x2 = world[ii + 6];
          y2 = world[ii + 7];
          tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
          tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
          dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
          dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
          ddfx = tmpx * 2 + dddfx;
          ddfy = tmpy * 2 + dddfy;
          dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
          dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
          curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
          segments[0] = curveLength;
          for (ii = 1; ii < 8; ii++) {
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
            segments[ii] = curveLength;
          }
          dfx += ddfx;
          dfy += ddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[8] = curveLength;
          dfx += ddfx + dddfx;
          dfy += ddfy + dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[9] = curveLength;
          segment = 0;
        }
        p3 *= curveLength;
        for (; ; segment++) {
          let length = segments[segment];
          if (p3 > length)
            continue;
          if (segment == 0)
            p3 /= length;
          else {
            let prev = segments[segment - 1];
            p3 = segment + (p3 - prev) / (length - prev);
          }
          break;
        }
        this.addCurvePosition(p3 * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out2, o2, tangents || i3 > 0 && space == 0);
      }
      return out2;
    }
    addBeforePosition(p3, temp, i3, out2, o2) {
      let x1 = temp[i3], y1 = temp[i3 + 1], dx = temp[i3 + 2] - x1, dy = temp[i3 + 3] - y1, r2 = Math.atan2(dy, dx);
      out2[o2] = x1 + p3 * Math.cos(r2);
      out2[o2 + 1] = y1 + p3 * Math.sin(r2);
      out2[o2 + 2] = r2;
    }
    addAfterPosition(p3, temp, i3, out2, o2) {
      let x1 = temp[i3 + 2], y1 = temp[i3 + 3], dx = x1 - temp[i3], dy = y1 - temp[i3 + 1], r2 = Math.atan2(dy, dx);
      out2[o2] = x1 + p3 * Math.cos(r2);
      out2[o2 + 1] = y1 + p3 * Math.sin(r2);
      out2[o2 + 2] = r2;
    }
    addCurvePosition(p3, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out2, o2, tangents) {
      if (p3 == 0 || isNaN(p3)) {
        out2[o2] = x1;
        out2[o2 + 1] = y1;
        out2[o2 + 2] = Math.atan2(cy1 - y1, cx1 - x1);
        return;
      }
      let tt = p3 * p3, ttt = tt * p3, u2 = 1 - p3, uu = u2 * u2, uuu = uu * u2;
      let ut = u2 * p3, ut3 = ut * 3, uut3 = u2 * ut3, utt3 = ut3 * p3;
      let x3 = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y3 = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
      out2[o2] = x3;
      out2[o2 + 1] = y3;
      if (tangents) {
        if (p3 < 1e-3)
          out2[o2 + 2] = Math.atan2(cy1 - y1, cx1 - x1);
        else
          out2[o2 + 2] = Math.atan2(y3 - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x3 - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
      }
    }
  };
  __publicField(_PathConstraint, "NONE", -1);
  __publicField(_PathConstraint, "BEFORE", -2);
  __publicField(_PathConstraint, "AFTER", -3);
  __publicField(_PathConstraint, "epsilon", 1e-5);
  var PathConstraint = _PathConstraint;

  // node_modules/@esotericsoftware/spine-core/dist/PhysicsConstraint.js
  var PhysicsConstraint = class {
    constructor(data, skeleton) {
      __publicField(this, "data");
      __publicField(this, "_bone", null);
      __publicField(this, "inertia", 0);
      __publicField(this, "strength", 0);
      __publicField(this, "damping", 0);
      __publicField(this, "massInverse", 0);
      __publicField(this, "wind", 0);
      __publicField(this, "gravity", 0);
      __publicField(this, "mix", 0);
      __publicField(this, "_reset", true);
      __publicField(this, "ux", 0);
      __publicField(this, "uy", 0);
      __publicField(this, "cx", 0);
      __publicField(this, "cy", 0);
      __publicField(this, "tx", 0);
      __publicField(this, "ty", 0);
      __publicField(this, "xOffset", 0);
      __publicField(this, "xVelocity", 0);
      __publicField(this, "yOffset", 0);
      __publicField(this, "yVelocity", 0);
      __publicField(this, "rotateOffset", 0);
      __publicField(this, "rotateVelocity", 0);
      __publicField(this, "scaleOffset", 0);
      __publicField(this, "scaleVelocity", 0);
      __publicField(this, "active", false);
      __publicField(this, "skeleton");
      __publicField(this, "remaining", 0);
      __publicField(this, "lastTime", 0);
      this.data = data;
      this.skeleton = skeleton;
      this.bone = skeleton.bones[data.bone.index];
      this.inertia = data.inertia;
      this.strength = data.strength;
      this.damping = data.damping;
      this.massInverse = data.massInverse;
      this.wind = data.wind;
      this.gravity = data.gravity;
      this.mix = data.mix;
    }
    /** The bone constrained by this physics constraint. */
    set bone(bone) {
      this._bone = bone;
    }
    get bone() {
      if (!this._bone)
        throw new Error("Bone not set.");
      else
        return this._bone;
    }
    reset() {
      this.remaining = 0;
      this.lastTime = this.skeleton.time;
      this._reset = true;
      this.xOffset = 0;
      this.xVelocity = 0;
      this.yOffset = 0;
      this.yVelocity = 0;
      this.rotateOffset = 0;
      this.rotateVelocity = 0;
      this.scaleOffset = 0;
      this.scaleVelocity = 0;
    }
    setToSetupPose() {
      const data = this.data;
      this.inertia = data.inertia;
      this.strength = data.strength;
      this.damping = data.damping;
      this.massInverse = data.massInverse;
      this.wind = data.wind;
      this.gravity = data.gravity;
      this.mix = data.mix;
    }
    isActive() {
      return this.active;
    }
    /** Applies the constraint to the constrained bones. */
    update(physics) {
      const mix = this.mix;
      if (mix == 0)
        return;
      const x2 = this.data.x > 0, y2 = this.data.y > 0, rotateOrShearX = this.data.rotate > 0 || this.data.shearX > 0, scaleX = this.data.scaleX > 0;
      const bone = this.bone;
      const l2 = bone.data.length;
      switch (physics) {
        case Physics.none:
          return;
        case Physics.reset:
          this.reset();
        // Fall through.
        case Physics.update:
          const skeleton = this.skeleton;
          const delta = Math.max(this.skeleton.time - this.lastTime, 0);
          this.remaining += delta;
          this.lastTime = skeleton.time;
          const bx = bone.worldX, by = bone.worldY;
          if (this._reset) {
            this._reset = false;
            this.ux = bx;
            this.uy = by;
          } else {
            let a2 = this.remaining, i3 = this.inertia, t2 = this.data.step, f2 = this.skeleton.data.referenceScale, d2 = -1;
            let qx = this.data.limit * delta, qy = qx * Math.abs(skeleton.scaleY);
            qx *= Math.abs(skeleton.scaleX);
            if (x2 || y2) {
              if (x2) {
                const u2 = (this.ux - bx) * i3;
                this.xOffset += u2 > qx ? qx : u2 < -qx ? -qx : u2;
                this.ux = bx;
              }
              if (y2) {
                const u2 = (this.uy - by) * i3;
                this.yOffset += u2 > qy ? qy : u2 < -qy ? -qy : u2;
                this.uy = by;
              }
              if (a2 >= t2) {
                d2 = Math.pow(this.damping, 60 * t2);
                const m2 = this.massInverse * t2, e2 = this.strength, w2 = this.wind * f2 * skeleton.scaleX, g2 = this.gravity * f2 * skeleton.scaleY;
                do {
                  if (x2) {
                    this.xVelocity += (w2 - this.xOffset * e2) * m2;
                    this.xOffset += this.xVelocity * t2;
                    this.xVelocity *= d2;
                  }
                  if (y2) {
                    this.yVelocity -= (g2 + this.yOffset * e2) * m2;
                    this.yOffset += this.yVelocity * t2;
                    this.yVelocity *= d2;
                  }
                  a2 -= t2;
                } while (a2 >= t2);
              }
              if (x2)
                bone.worldX += this.xOffset * mix * this.data.x;
              if (y2)
                bone.worldY += this.yOffset * mix * this.data.y;
            }
            if (rotateOrShearX || scaleX) {
              let ca = Math.atan2(bone.c, bone.a), c2 = 0, s2 = 0, mr = 0;
              let dx = this.cx - bone.worldX, dy = this.cy - bone.worldY;
              if (dx > qx)
                dx = qx;
              else if (dx < -qx)
                dx = -qx;
              if (dy > qy)
                dy = qy;
              else if (dy < -qy)
                dy = -qy;
              if (rotateOrShearX) {
                mr = (this.data.rotate + this.data.shearX) * mix;
                let r2 = Math.atan2(dy + this.ty, dx + this.tx) - ca - this.rotateOffset * mr;
                this.rotateOffset += (r2 - Math.ceil(r2 * MathUtils.invPI2 - 0.5) * MathUtils.PI2) * i3;
                r2 = this.rotateOffset * mr + ca;
                c2 = Math.cos(r2);
                s2 = Math.sin(r2);
                if (scaleX) {
                  r2 = l2 * bone.getWorldScaleX();
                  if (r2 > 0)
                    this.scaleOffset += (dx * c2 + dy * s2) * i3 / r2;
                }
              } else {
                c2 = Math.cos(ca);
                s2 = Math.sin(ca);
                const r2 = l2 * bone.getWorldScaleX();
                if (r2 > 0)
                  this.scaleOffset += (dx * c2 + dy * s2) * i3 / r2;
              }
              a2 = this.remaining;
              if (a2 >= t2) {
                if (d2 == -1)
                  d2 = Math.pow(this.damping, 60 * t2);
                const m2 = this.massInverse * t2, e2 = this.strength, w2 = this.wind, g2 = Skeleton.yDown ? -this.gravity : this.gravity, h2 = l2 / f2;
                while (true) {
                  a2 -= t2;
                  if (scaleX) {
                    this.scaleVelocity += (w2 * c2 - g2 * s2 - this.scaleOffset * e2) * m2;
                    this.scaleOffset += this.scaleVelocity * t2;
                    this.scaleVelocity *= d2;
                  }
                  if (rotateOrShearX) {
                    this.rotateVelocity -= ((w2 * s2 + g2 * c2) * h2 + this.rotateOffset * e2) * m2;
                    this.rotateOffset += this.rotateVelocity * t2;
                    this.rotateVelocity *= d2;
                    if (a2 < t2)
                      break;
                    const r2 = this.rotateOffset * mr + ca;
                    c2 = Math.cos(r2);
                    s2 = Math.sin(r2);
                  } else if (a2 < t2)
                    break;
                }
              }
            }
            this.remaining = a2;
          }
          this.cx = bone.worldX;
          this.cy = bone.worldY;
          break;
        case Physics.pose:
          if (x2)
            bone.worldX += this.xOffset * mix * this.data.x;
          if (y2)
            bone.worldY += this.yOffset * mix * this.data.y;
      }
      if (rotateOrShearX) {
        let o2 = this.rotateOffset * mix, s2 = 0, c2 = 0, a2 = 0;
        if (this.data.shearX > 0) {
          let r2 = 0;
          if (this.data.rotate > 0) {
            r2 = o2 * this.data.rotate;
            s2 = Math.sin(r2);
            c2 = Math.cos(r2);
            a2 = bone.b;
            bone.b = c2 * a2 - s2 * bone.d;
            bone.d = s2 * a2 + c2 * bone.d;
          }
          r2 += o2 * this.data.shearX;
          s2 = Math.sin(r2);
          c2 = Math.cos(r2);
          a2 = bone.a;
          bone.a = c2 * a2 - s2 * bone.c;
          bone.c = s2 * a2 + c2 * bone.c;
        } else {
          o2 *= this.data.rotate;
          s2 = Math.sin(o2);
          c2 = Math.cos(o2);
          a2 = bone.a;
          bone.a = c2 * a2 - s2 * bone.c;
          bone.c = s2 * a2 + c2 * bone.c;
          a2 = bone.b;
          bone.b = c2 * a2 - s2 * bone.d;
          bone.d = s2 * a2 + c2 * bone.d;
        }
      }
      if (scaleX) {
        const s2 = 1 + this.scaleOffset * mix * this.data.scaleX;
        bone.a *= s2;
        bone.c *= s2;
      }
      if (physics != Physics.pose) {
        this.tx = l2 * bone.a;
        this.ty = l2 * bone.c;
      }
      bone.updateAppliedTransform();
    }
    /** Translates the physics constraint so next {@link #update(Physics)} forces are applied as if the bone moved an additional
     * amount in world space. */
    translate(x2, y2) {
      this.ux -= x2;
      this.uy -= y2;
      this.cx -= x2;
      this.cy -= y2;
    }
    /** Rotates the physics constraint so next {@link #update(Physics)} forces are applied as if the bone rotated around the
     * specified point in world space. */
    rotate(x2, y2, degrees) {
      const r2 = degrees * MathUtils.degRad, cos = Math.cos(r2), sin = Math.sin(r2);
      const dx = this.cx - x2, dy = this.cy - y2;
      this.translate(dx * cos - dy * sin - dx, dx * sin + dy * cos - dy);
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/Slot.js
  var Slot = class {
    constructor(data, bone) {
      /** The slot's setup pose data. */
      __publicField(this, "data");
      /** The bone this slot belongs to. */
      __publicField(this, "bone");
      /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two
       * color tinting. */
      __publicField(this, "color");
      /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark
       * color's alpha is not used. */
      __publicField(this, "darkColor", null);
      __publicField(this, "attachment", null);
      __publicField(this, "attachmentState", 0);
      /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the
       * {@link Sequence#getSetupIndex()}. */
      __publicField(this, "sequenceIndex", -1);
      /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a
       * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.
       *
       * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */
      __publicField(this, "deform", new Array());
      if (!data)
        throw new Error("data cannot be null.");
      if (!bone)
        throw new Error("bone cannot be null.");
      this.data = data;
      this.bone = bone;
      this.color = new Color2();
      this.darkColor = !data.darkColor ? null : new Color2();
      this.setToSetupPose();
    }
    /** The skeleton this slot belongs to. */
    getSkeleton() {
      return this.bone.skeleton;
    }
    /** The current attachment for the slot, or null if the slot has no attachment. */
    getAttachment() {
      return this.attachment;
    }
    /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.
     * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the
     * specified attachment. */
    setAttachment(attachment) {
      if (this.attachment == attachment)
        return;
      if (!(attachment instanceof VertexAttachment) || !(this.attachment instanceof VertexAttachment) || attachment.timelineAttachment != this.attachment.timelineAttachment) {
        this.deform.length = 0;
      }
      this.attachment = attachment;
      this.sequenceIndex = -1;
    }
    /** Sets this slot to the setup pose. */
    setToSetupPose() {
      this.color.setFromColor(this.data.color);
      if (this.darkColor)
        this.darkColor.setFromColor(this.data.darkColor);
      if (!this.data.attachmentName)
        this.attachment = null;
      else {
        this.attachment = null;
        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
      }
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/TransformConstraint.js
  var TransformConstraint = class {
    constructor(data, skeleton) {
      /** The transform constraint's setup pose data. */
      __publicField(this, "data");
      /** The bones that will be modified by this transform constraint. */
      __publicField(this, "bones");
      /** The target bone whose world transform will be copied to the constrained bones. */
      __publicField(this, "target");
      __publicField(this, "mixRotate", 0);
      __publicField(this, "mixX", 0);
      __publicField(this, "mixY", 0);
      __publicField(this, "mixScaleX", 0);
      __publicField(this, "mixScaleY", 0);
      __publicField(this, "mixShearY", 0);
      __publicField(this, "temp", new Vector2());
      __publicField(this, "active", false);
      if (!data)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data;
      this.bones = new Array();
      for (let i3 = 0; i3 < data.bones.length; i3++) {
        let bone = skeleton.findBone(data.bones[i3].name);
        if (!bone)
          throw new Error(`Couldn't find bone ${data.bones[i3].name}.`);
        this.bones.push(bone);
      }
      let target = skeleton.findBone(data.target.name);
      if (!target)
        throw new Error(`Couldn't find target bone ${data.target.name}.`);
      this.target = target;
      this.mixRotate = data.mixRotate;
      this.mixX = data.mixX;
      this.mixY = data.mixY;
      this.mixScaleX = data.mixScaleX;
      this.mixScaleY = data.mixScaleY;
      this.mixShearY = data.mixShearY;
    }
    isActive() {
      return this.active;
    }
    setToSetupPose() {
      const data = this.data;
      this.mixRotate = data.mixRotate;
      this.mixX = data.mixX;
      this.mixY = data.mixY;
      this.mixScaleX = data.mixScaleX;
      this.mixScaleY = data.mixScaleY;
      this.mixShearY = data.mixShearY;
    }
    update(physics) {
      if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleY == 0 && this.mixShearY == 0)
        return;
      if (this.data.local) {
        if (this.data.relative)
          this.applyRelativeLocal();
        else
          this.applyAbsoluteLocal();
      } else {
        if (this.data.relative)
          this.applyRelativeWorld();
        else
          this.applyAbsoluteWorld();
      }
    }
    applyAbsoluteWorld() {
      let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      let translate = mixX != 0 || mixY != 0;
      let target = this.target;
      let ta = target.a, tb = target.b, tc = target.c, td = target.d;
      let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
      let offsetRotation = this.data.offsetRotation * degRadReflect;
      let offsetShearY = this.data.offsetShearY * degRadReflect;
      let bones = this.bones;
      for (let i3 = 0, n2 = bones.length; i3 < n2; i3++) {
        let bone = bones[i3];
        if (mixRotate != 0) {
          let a2 = bone.a, b2 = bone.b, c2 = bone.c, d2 = bone.d;
          let r2 = Math.atan2(tc, ta) - Math.atan2(c2, a2) + offsetRotation;
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= mixRotate;
          let cos = Math.cos(r2), sin = Math.sin(r2);
          bone.a = cos * a2 - sin * c2;
          bone.b = cos * b2 - sin * d2;
          bone.c = sin * a2 + cos * c2;
          bone.d = sin * b2 + cos * d2;
        }
        if (translate) {
          let temp = this.temp;
          target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
          bone.worldX += (temp.x - bone.worldX) * mixX;
          bone.worldY += (temp.y - bone.worldY) * mixY;
        }
        if (mixScaleX != 0) {
          let s2 = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
          if (s2 != 0)
            s2 = (s2 + (Math.sqrt(ta * ta + tc * tc) - s2 + this.data.offsetScaleX) * mixScaleX) / s2;
          bone.a *= s2;
          bone.c *= s2;
        }
        if (mixScaleY != 0) {
          let s2 = Math.sqrt(bone.b * bone.b + bone.d * bone.d);
          if (s2 != 0)
            s2 = (s2 + (Math.sqrt(tb * tb + td * td) - s2 + this.data.offsetScaleY) * mixScaleY) / s2;
          bone.b *= s2;
          bone.d *= s2;
        }
        if (mixShearY > 0) {
          let b2 = bone.b, d2 = bone.d;
          let by = Math.atan2(d2, b2);
          let r2 = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 = by + (r2 + offsetShearY) * mixShearY;
          let s2 = Math.sqrt(b2 * b2 + d2 * d2);
          bone.b = Math.cos(r2) * s2;
          bone.d = Math.sin(r2) * s2;
        }
        bone.updateAppliedTransform();
      }
    }
    applyRelativeWorld() {
      let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      let translate = mixX != 0 || mixY != 0;
      let target = this.target;
      let ta = target.a, tb = target.b, tc = target.c, td = target.d;
      let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
      let offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
      let bones = this.bones;
      for (let i3 = 0, n2 = bones.length; i3 < n2; i3++) {
        let bone = bones[i3];
        if (mixRotate != 0) {
          let a2 = bone.a, b2 = bone.b, c2 = bone.c, d2 = bone.d;
          let r2 = Math.atan2(tc, ta) + offsetRotation;
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= mixRotate;
          let cos = Math.cos(r2), sin = Math.sin(r2);
          bone.a = cos * a2 - sin * c2;
          bone.b = cos * b2 - sin * d2;
          bone.c = sin * a2 + cos * c2;
          bone.d = sin * b2 + cos * d2;
        }
        if (translate) {
          let temp = this.temp;
          target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
          bone.worldX += temp.x * mixX;
          bone.worldY += temp.y * mixY;
        }
        if (mixScaleX != 0) {
          let s2 = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;
          bone.a *= s2;
          bone.c *= s2;
        }
        if (mixScaleY != 0) {
          let s2 = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;
          bone.b *= s2;
          bone.d *= s2;
        }
        if (mixShearY > 0) {
          let r2 = Math.atan2(td, tb) - Math.atan2(tc, ta);
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          let b2 = bone.b, d2 = bone.d;
          r2 = Math.atan2(d2, b2) + (r2 - MathUtils.PI / 2 + offsetShearY) * mixShearY;
          let s2 = Math.sqrt(b2 * b2 + d2 * d2);
          bone.b = Math.cos(r2) * s2;
          bone.d = Math.sin(r2) * s2;
        }
        bone.updateAppliedTransform();
      }
    }
    applyAbsoluteLocal() {
      let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      let target = this.target;
      let bones = this.bones;
      for (let i3 = 0, n2 = bones.length; i3 < n2; i3++) {
        let bone = bones[i3];
        let rotation = bone.arotation;
        if (mixRotate != 0)
          rotation += (target.arotation - rotation + this.data.offsetRotation) * mixRotate;
        let x2 = bone.ax, y2 = bone.ay;
        x2 += (target.ax - x2 + this.data.offsetX) * mixX;
        y2 += (target.ay - y2 + this.data.offsetY) * mixY;
        let scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (mixScaleX != 0 && scaleX != 0)
          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;
        if (mixScaleY != 0 && scaleY != 0)
          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;
        let shearY = bone.ashearY;
        if (mixShearY != 0)
          shearY += (target.ashearY - shearY + this.data.offsetShearY) * mixShearY;
        bone.updateWorldTransformWith(x2, y2, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    }
    applyRelativeLocal() {
      let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      let target = this.target;
      let bones = this.bones;
      for (let i3 = 0, n2 = bones.length; i3 < n2; i3++) {
        let bone = bones[i3];
        let rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;
        let x2 = bone.ax + (target.ax + this.data.offsetX) * mixX;
        let y2 = bone.ay + (target.ay + this.data.offsetY) * mixY;
        let scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);
        let scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);
        let shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;
        bone.updateWorldTransformWith(x2, y2, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/Skeleton.js
  var _Skeleton = class _Skeleton {
    constructor(data) {
      /** The skeleton's setup pose data. */
      __publicField(this, "data");
      /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */
      __publicField(this, "bones");
      /** The skeleton's slots in the setup pose draw order. */
      __publicField(this, "slots");
      /** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */
      __publicField(this, "drawOrder");
      /** The skeleton's IK constraints. */
      __publicField(this, "ikConstraints");
      /** The skeleton's transform constraints. */
      __publicField(this, "transformConstraints");
      /** The skeleton's path constraints. */
      __publicField(this, "pathConstraints");
      /** The skeleton's physics constraints. */
      __publicField(this, "physicsConstraints");
      /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */
      __publicField(this, "_updateCache", new Array());
      /** The skeleton's current skin. May be null. */
      __publicField(this, "skin", null);
      /** The color to tint all the skeleton's attachments. */
      __publicField(this, "color");
      /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale
        * inheritance. */
      __publicField(this, "scaleX", 1);
      /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale
        * inheritance. */
      __publicField(this, "_scaleY", 1);
      /** Sets the skeleton X position, which is added to the root bone worldX position. */
      __publicField(this, "x", 0);
      /** Sets the skeleton Y position, which is added to the root bone worldY position. */
      __publicField(this, "y", 0);
      /** Returns the skeleton's time. This is used for time-based manipulations, such as {@link PhysicsConstraint}.
       * <p>
       * See {@link #update(float)}. */
      __publicField(this, "time", 0);
      if (!data)
        throw new Error("data cannot be null.");
      this.data = data;
      this.bones = new Array();
      for (let i3 = 0; i3 < data.bones.length; i3++) {
        let boneData = data.bones[i3];
        let bone;
        if (!boneData.parent)
          bone = new Bone(boneData, this, null);
        else {
          let parent = this.bones[boneData.parent.index];
          bone = new Bone(boneData, this, parent);
          parent.children.push(bone);
        }
        this.bones.push(bone);
      }
      this.slots = new Array();
      this.drawOrder = new Array();
      for (let i3 = 0; i3 < data.slots.length; i3++) {
        let slotData = data.slots[i3];
        let bone = this.bones[slotData.boneData.index];
        let slot = new Slot(slotData, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot);
      }
      this.ikConstraints = new Array();
      for (let i3 = 0; i3 < data.ikConstraints.length; i3++) {
        let ikConstraintData = data.ikConstraints[i3];
        this.ikConstraints.push(new IkConstraint(ikConstraintData, this));
      }
      this.transformConstraints = new Array();
      for (let i3 = 0; i3 < data.transformConstraints.length; i3++) {
        let transformConstraintData = data.transformConstraints[i3];
        this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));
      }
      this.pathConstraints = new Array();
      for (let i3 = 0; i3 < data.pathConstraints.length; i3++) {
        let pathConstraintData = data.pathConstraints[i3];
        this.pathConstraints.push(new PathConstraint(pathConstraintData, this));
      }
      this.physicsConstraints = new Array();
      for (let i3 = 0; i3 < data.physicsConstraints.length; i3++) {
        let physicsConstraintData = data.physicsConstraints[i3];
        this.physicsConstraints.push(new PhysicsConstraint(physicsConstraintData, this));
      }
      this.color = new Color2(1, 1, 1, 1);
      this.updateCache();
    }
    get scaleY() {
      return _Skeleton.yDown ? -this._scaleY : this._scaleY;
    }
    set scaleY(scaleY) {
      this._scaleY = scaleY;
    }
    /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,
     * constraints, or weighted path attachments are added or removed. */
    updateCache() {
      let updateCache = this._updateCache;
      updateCache.length = 0;
      let bones = this.bones;
      for (let i3 = 0, n2 = bones.length; i3 < n2; i3++) {
        let bone = bones[i3];
        bone.sorted = bone.data.skinRequired;
        bone.active = !bone.sorted;
      }
      if (this.skin) {
        let skinBones = this.skin.bones;
        for (let i3 = 0, n2 = this.skin.bones.length; i3 < n2; i3++) {
          let bone = this.bones[skinBones[i3].index];
          do {
            bone.sorted = false;
            bone.active = true;
            bone = bone.parent;
          } while (bone);
        }
      }
      let ikConstraints = this.ikConstraints;
      let transformConstraints = this.transformConstraints;
      let pathConstraints = this.pathConstraints;
      let physicsConstraints = this.physicsConstraints;
      let ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length, physicsCount = this.physicsConstraints.length;
      let constraintCount = ikCount + transformCount + pathCount + physicsCount;
      outer: for (let i3 = 0; i3 < constraintCount; i3++) {
        for (let ii = 0; ii < ikCount; ii++) {
          let constraint = ikConstraints[ii];
          if (constraint.data.order == i3) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          let constraint = transformConstraints[ii];
          if (constraint.data.order == i3) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          let constraint = pathConstraints[ii];
          if (constraint.data.order == i3) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < physicsCount; ii++) {
          const constraint = physicsConstraints[ii];
          if (constraint.data.order == i3) {
            this.sortPhysicsConstraint(constraint);
            continue outer;
          }
        }
      }
      for (let i3 = 0, n2 = bones.length; i3 < n2; i3++)
        this.sortBone(bones[i3]);
    }
    sortIkConstraint(constraint) {
      constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      let target = constraint.target;
      this.sortBone(target);
      let constrained = constraint.bones;
      let parent = constrained[0];
      this.sortBone(parent);
      if (constrained.length == 1) {
        this._updateCache.push(constraint);
        this.sortReset(parent.children);
      } else {
        let child = constrained[constrained.length - 1];
        this.sortBone(child);
        this._updateCache.push(constraint);
        this.sortReset(parent.children);
        child.sorted = true;
      }
    }
    sortPathConstraint(constraint) {
      constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      let slot = constraint.target;
      let slotIndex = slot.data.index;
      let slotBone = slot.bone;
      if (this.skin)
        this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
      if (this.data.defaultSkin && this.data.defaultSkin != this.skin)
        this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
      for (let i3 = 0, n2 = this.data.skins.length; i3 < n2; i3++)
        this.sortPathConstraintAttachment(this.data.skins[i3], slotIndex, slotBone);
      let attachment = slot.getAttachment();
      if (attachment instanceof PathAttachment)
        this.sortPathConstraintAttachmentWith(attachment, slotBone);
      let constrained = constraint.bones;
      let boneCount = constrained.length;
      for (let i3 = 0; i3 < boneCount; i3++)
        this.sortBone(constrained[i3]);
      this._updateCache.push(constraint);
      for (let i3 = 0; i3 < boneCount; i3++)
        this.sortReset(constrained[i3].children);
      for (let i3 = 0; i3 < boneCount; i3++)
        constrained[i3].sorted = true;
    }
    sortTransformConstraint(constraint) {
      constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      this.sortBone(constraint.target);
      let constrained = constraint.bones;
      let boneCount = constrained.length;
      if (constraint.data.local) {
        for (let i3 = 0; i3 < boneCount; i3++) {
          let child = constrained[i3];
          this.sortBone(child.parent);
          this.sortBone(child);
        }
      } else {
        for (let i3 = 0; i3 < boneCount; i3++) {
          this.sortBone(constrained[i3]);
        }
      }
      this._updateCache.push(constraint);
      for (let i3 = 0; i3 < boneCount; i3++)
        this.sortReset(constrained[i3].children);
      for (let i3 = 0; i3 < boneCount; i3++)
        constrained[i3].sorted = true;
    }
    sortPathConstraintAttachment(skin, slotIndex, slotBone) {
      let attachments = skin.attachments[slotIndex];
      if (!attachments)
        return;
      for (let key in attachments) {
        this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
      }
    }
    sortPathConstraintAttachmentWith(attachment, slotBone) {
      if (!(attachment instanceof PathAttachment))
        return;
      let pathBones = attachment.bones;
      if (!pathBones)
        this.sortBone(slotBone);
      else {
        let bones = this.bones;
        for (let i3 = 0, n2 = pathBones.length; i3 < n2; ) {
          let nn = pathBones[i3++];
          nn += i3;
          while (i3 < nn)
            this.sortBone(bones[pathBones[i3++]]);
        }
      }
    }
    sortPhysicsConstraint(constraint) {
      const bone = constraint.bone;
      constraint.active = bone.active && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      this.sortBone(bone);
      this._updateCache.push(constraint);
      this.sortReset(bone.children);
      bone.sorted = true;
    }
    sortBone(bone) {
      if (!bone)
        return;
      if (bone.sorted)
        return;
      let parent = bone.parent;
      if (parent)
        this.sortBone(parent);
      bone.sorted = true;
      this._updateCache.push(bone);
    }
    sortReset(bones) {
      for (let i3 = 0, n2 = bones.length; i3 < n2; i3++) {
        let bone = bones[i3];
        if (!bone.active)
          continue;
        if (bone.sorted)
          this.sortReset(bone.children);
        bone.sorted = false;
      }
    }
    /** Updates the world transform for each bone and applies all constraints.
     *
     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
     * Runtimes Guide. */
    updateWorldTransform(physics) {
      if (physics === void 0 || physics === null)
        throw new Error("physics is undefined");
      let bones = this.bones;
      for (let i3 = 0, n2 = bones.length; i3 < n2; i3++) {
        let bone = bones[i3];
        bone.ax = bone.x;
        bone.ay = bone.y;
        bone.arotation = bone.rotation;
        bone.ascaleX = bone.scaleX;
        bone.ascaleY = bone.scaleY;
        bone.ashearX = bone.shearX;
        bone.ashearY = bone.shearY;
      }
      let updateCache = this._updateCache;
      for (let i3 = 0, n2 = updateCache.length; i3 < n2; i3++)
        updateCache[i3].update(physics);
    }
    updateWorldTransformWith(physics, parent) {
      if (!parent)
        throw new Error("parent cannot be null.");
      let bones = this.bones;
      for (let i3 = 1, n2 = bones.length; i3 < n2; i3++) {
        let bone = bones[i3];
        bone.ax = bone.x;
        bone.ay = bone.y;
        bone.arotation = bone.rotation;
        bone.ascaleX = bone.scaleX;
        bone.ascaleY = bone.scaleY;
        bone.ashearX = bone.shearX;
        bone.ashearY = bone.shearY;
      }
      let rootBone = this.getRootBone();
      if (!rootBone)
        throw new Error("Root bone must not be null.");
      let pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
      rootBone.worldX = pa * this.x + pb * this.y + parent.worldX;
      rootBone.worldY = pc * this.x + pd * this.y + parent.worldY;
      const rx = (rootBone.rotation + rootBone.shearX) * MathUtils.degRad;
      const ry = (rootBone.rotation + 90 + rootBone.shearY) * MathUtils.degRad;
      const la = Math.cos(rx) * rootBone.scaleX;
      const lb = Math.cos(ry) * rootBone.scaleY;
      const lc = Math.sin(rx) * rootBone.scaleX;
      const ld = Math.sin(ry) * rootBone.scaleY;
      rootBone.a = (pa * la + pb * lc) * this.scaleX;
      rootBone.b = (pa * lb + pb * ld) * this.scaleX;
      rootBone.c = (pc * la + pd * lc) * this.scaleY;
      rootBone.d = (pc * lb + pd * ld) * this.scaleY;
      let updateCache = this._updateCache;
      for (let i3 = 0, n2 = updateCache.length; i3 < n2; i3++) {
        let updatable = updateCache[i3];
        if (updatable != rootBone)
          updatable.update(physics);
      }
    }
    /** Sets the bones, constraints, and slots to their setup pose values. */
    setToSetupPose() {
      this.setBonesToSetupPose();
      this.setSlotsToSetupPose();
    }
    /** Sets the bones and constraints to their setup pose values. */
    setBonesToSetupPose() {
      for (const bone of this.bones)
        bone.setToSetupPose();
      for (const constraint of this.ikConstraints)
        constraint.setToSetupPose();
      for (const constraint of this.transformConstraints)
        constraint.setToSetupPose();
      for (const constraint of this.pathConstraints)
        constraint.setToSetupPose();
      for (const constraint of this.physicsConstraints)
        constraint.setToSetupPose();
    }
    /** Sets the slots and draw order to their setup pose values. */
    setSlotsToSetupPose() {
      let slots = this.slots;
      Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
      for (let i3 = 0, n2 = slots.length; i3 < n2; i3++)
        slots[i3].setToSetupPose();
    }
    /** @returns May return null. */
    getRootBone() {
      if (this.bones.length == 0)
        return null;
      return this.bones[0];
    }
    /** @returns May be null. */
    findBone(boneName) {
      if (!boneName)
        throw new Error("boneName cannot be null.");
      let bones = this.bones;
      for (let i3 = 0, n2 = bones.length; i3 < n2; i3++) {
        let bone = bones[i3];
        if (bone.data.name == boneName)
          return bone;
      }
      return null;
    }
    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
     * repeatedly.
     * @returns May be null. */
    findSlot(slotName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      let slots = this.slots;
      for (let i3 = 0, n2 = slots.length; i3 < n2; i3++) {
        let slot = slots[i3];
        if (slot.data.name == slotName)
          return slot;
      }
      return null;
    }
    /** Sets a skin by name.
     *
     * See {@link #setSkin()}. */
    setSkinByName(skinName) {
      let skin = this.data.findSkin(skinName);
      if (!skin)
        throw new Error("Skin not found: " + skinName);
      this.setSkin(skin);
    }
    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the
     * skin is changed, {@link #updateCache()} is called.
     *
     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
     * old skin, each slot's setup mode attachment is attached from the new skin.
     *
     * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling
     * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the
     * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.
     * @param newSkin May be null. */
    setSkin(newSkin) {
      if (newSkin == this.skin)
        return;
      if (newSkin) {
        if (this.skin)
          newSkin.attachAll(this, this.skin);
        else {
          let slots = this.slots;
          for (let i3 = 0, n2 = slots.length; i3 < n2; i3++) {
            let slot = slots[i3];
            let name = slot.data.attachmentName;
            if (name) {
              let attachment = newSkin.getAttachment(i3, name);
              if (attachment)
                slot.setAttachment(attachment);
            }
          }
        }
      }
      this.skin = newSkin;
      this.updateCache();
    }
    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment
     * name.
     *
     * See {@link #getAttachment()}.
     * @returns May be null. */
    getAttachmentByName(slotName, attachmentName) {
      let slot = this.data.findSlot(slotName);
      if (!slot)
        throw new Error(`Can't find slot with name ${slotName}`);
      return this.getAttachment(slot.index, attachmentName);
    }
    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and
     * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.
     *
     * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.
     * @returns May be null. */
    getAttachment(slotIndex, attachmentName) {
      if (!attachmentName)
        throw new Error("attachmentName cannot be null.");
      if (this.skin) {
        let attachment = this.skin.getAttachment(slotIndex, attachmentName);
        if (attachment)
          return attachment;
      }
      if (this.data.defaultSkin)
        return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
      return null;
    }
    /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with
     * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.
     * @param attachmentName May be null to clear the slot's attachment. */
    setAttachment(slotName, attachmentName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      let slots = this.slots;
      for (let i3 = 0, n2 = slots.length; i3 < n2; i3++) {
        let slot = slots[i3];
        if (slot.data.name == slotName) {
          let attachment = null;
          if (attachmentName) {
            attachment = this.getAttachment(i3, attachmentName);
            if (!attachment)
              throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
          }
          slot.setAttachment(attachment);
          return;
        }
      }
      throw new Error("Slot not found: " + slotName);
    }
    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
     * than to call it repeatedly.
     * @return May be null. */
    findIkConstraint(constraintName) {
      var _a2;
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      return (_a2 = this.ikConstraints.find((constraint) => constraint.data.name == constraintName)) != null ? _a2 : null;
    }
    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
     * this method than to call it repeatedly.
     * @return May be null. */
    findTransformConstraint(constraintName) {
      var _a2;
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      return (_a2 = this.transformConstraints.find((constraint) => constraint.data.name == constraintName)) != null ? _a2 : null;
    }
    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
     * than to call it repeatedly.
     * @return May be null. */
    findPathConstraint(constraintName) {
      var _a2;
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      return (_a2 = this.pathConstraints.find((constraint) => constraint.data.name == constraintName)) != null ? _a2 : null;
    }
    /** Finds a physics constraint by comparing each physics constraint's name. It is more efficient to cache the results of this
     * method than to call it repeatedly. */
    findPhysicsConstraint(constraintName) {
      var _a2;
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      return (_a2 = this.physicsConstraints.find((constraint) => constraint.data.name == constraintName)) != null ? _a2 : null;
    }
    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.
     * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */
    getBoundsRect(clipper2) {
      let offset = new Vector2();
      let size = new Vector2();
      this.getBounds(offset, size, void 0, clipper2);
      return { x: offset.x, y: offset.y, width: size.x, height: size.y };
    }
    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
     * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.
     * @param size An output value, the width and height of the AABB.
     * @param temp Working memory to temporarily store attachments' computed world vertices.
     * @param clipper {@link SkeletonClipping} to use. If <code>null</code>, no clipping is applied. */
    getBounds(offset, size, temp = new Array(2), clipper2 = null) {
      if (!offset)
        throw new Error("offset cannot be null.");
      if (!size)
        throw new Error("size cannot be null.");
      let drawOrder = this.drawOrder;
      let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
      for (let i3 = 0, n2 = drawOrder.length; i3 < n2; i3++) {
        let slot = drawOrder[i3];
        if (!slot.bone.active)
          continue;
        let verticesLength = 0;
        let vertices = null;
        let triangles = null;
        let attachment = slot.getAttachment();
        if (attachment instanceof RegionAttachment) {
          verticesLength = 8;
          vertices = Utils.setArraySize(temp, verticesLength, 0);
          attachment.computeWorldVertices(slot, vertices, 0, 2);
          triangles = _Skeleton.quadTriangles;
        } else if (attachment instanceof MeshAttachment) {
          let mesh = attachment;
          verticesLength = mesh.worldVerticesLength;
          vertices = Utils.setArraySize(temp, verticesLength, 0);
          mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
          triangles = mesh.triangles;
        } else if (attachment instanceof ClippingAttachment && clipper2 != null) {
          clipper2.clipStart(slot, attachment);
          continue;
        }
        if (vertices && triangles) {
          if (clipper2 != null && clipper2.isClipping()) {
            clipper2.clipTriangles(vertices, triangles, triangles.length);
            vertices = clipper2.clippedVertices;
            verticesLength = clipper2.clippedVertices.length;
          }
          for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
            let x2 = vertices[ii], y2 = vertices[ii + 1];
            minX = Math.min(minX, x2);
            minY = Math.min(minY, y2);
            maxX = Math.max(maxX, x2);
            maxY = Math.max(maxY, y2);
          }
        }
        if (clipper2 != null)
          clipper2.clipEndWithSlot(slot);
      }
      if (clipper2 != null)
        clipper2.clipEnd();
      offset.set(minX, minY);
      size.set(maxX - minX, maxY - minY);
    }
    /** Increments the skeleton's {@link #time}. */
    update(delta) {
      this.time += delta;
    }
    physicsTranslate(x2, y2) {
      const physicsConstraints = this.physicsConstraints;
      for (let i3 = 0, n2 = physicsConstraints.length; i3 < n2; i3++)
        physicsConstraints[i3].translate(x2, y2);
    }
    /** Calls {@link PhysicsConstraint#rotate(float, float, float)} for each physics constraint. */
    physicsRotate(x2, y2, degrees) {
      const physicsConstraints = this.physicsConstraints;
      for (let i3 = 0, n2 = physicsConstraints.length; i3 < n2; i3++)
        physicsConstraints[i3].rotate(x2, y2, degrees);
    }
  };
  __publicField(_Skeleton, "quadTriangles", [0, 1, 2, 2, 3, 0]);
  __publicField(_Skeleton, "yDown", false);
  var Skeleton = _Skeleton;
  var Physics;
  (function(Physics2) {
    Physics2[Physics2["none"] = 0] = "none";
    Physics2[Physics2["reset"] = 1] = "reset";
    Physics2[Physics2["update"] = 2] = "update";
    Physics2[Physics2["pose"] = 3] = "pose";
  })(Physics || (Physics = {}));

  // node_modules/@esotericsoftware/spine-core/dist/PhysicsConstraintData.js
  var PhysicsConstraintData = class extends ConstraintData {
    constructor(name) {
      super(name, 0, false);
      __publicField(this, "_bone", null);
      __publicField(this, "x", 0);
      __publicField(this, "y", 0);
      __publicField(this, "rotate", 0);
      __publicField(this, "scaleX", 0);
      __publicField(this, "shearX", 0);
      __publicField(this, "limit", 0);
      __publicField(this, "step", 0);
      __publicField(this, "inertia", 0);
      __publicField(this, "strength", 0);
      __publicField(this, "damping", 0);
      __publicField(this, "massInverse", 0);
      __publicField(this, "wind", 0);
      __publicField(this, "gravity", 0);
      /** A percentage (0-1) that controls the mix between the constrained and unconstrained poses. */
      __publicField(this, "mix", 0);
      __publicField(this, "inertiaGlobal", false);
      __publicField(this, "strengthGlobal", false);
      __publicField(this, "dampingGlobal", false);
      __publicField(this, "massGlobal", false);
      __publicField(this, "windGlobal", false);
      __publicField(this, "gravityGlobal", false);
      __publicField(this, "mixGlobal", false);
    }
    /** The bone constrained by this physics constraint. */
    set bone(boneData) {
      this._bone = boneData;
    }
    get bone() {
      if (!this._bone)
        throw new Error("BoneData not set.");
      else
        return this._bone;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/SkeletonData.js
  var SkeletonData = class {
    constructor() {
      /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */
      __publicField(this, "name", null);
      /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */
      __publicField(this, "bones", new Array());
      // Ordered parents first.
      /** The skeleton's slots in the setup pose draw order. */
      __publicField(this, "slots", new Array());
      // Setup pose draw order.
      __publicField(this, "skins", new Array());
      /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.
       *
       * See {@link Skeleton#getAttachmentByName()}.
       * May be null. */
      __publicField(this, "defaultSkin", null);
      /** The skeleton's events. */
      __publicField(this, "events", new Array());
      /** The skeleton's animations. */
      __publicField(this, "animations", new Array());
      /** The skeleton's IK constraints. */
      __publicField(this, "ikConstraints", new Array());
      /** The skeleton's transform constraints. */
      __publicField(this, "transformConstraints", new Array());
      /** The skeleton's path constraints. */
      __publicField(this, "pathConstraints", new Array());
      /** The skeleton's physics constraints. */
      __publicField(this, "physicsConstraints", new Array());
      /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */
      __publicField(this, "x", 0);
      /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */
      __publicField(this, "y", 0);
      /** The width of the skeleton's axis aligned bounding box in the setup pose. */
      __publicField(this, "width", 0);
      /** The height of the skeleton's axis aligned bounding box in the setup pose. */
      __publicField(this, "height", 0);
      /** Baseline scale factor for applying distance-dependent effects on non-scalable properties, such as angle or scale. Default
       * is 100. */
      __publicField(this, "referenceScale", 100);
      /** The Spine version used to export the skeleton data, or null. */
      __publicField(this, "version", null);
      /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */
      __publicField(this, "hash", null);
      // Nonessential
      /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */
      __publicField(this, "fps", 0);
      /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */
      __publicField(this, "imagesPath", null);
      /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */
      __publicField(this, "audioPath", null);
    }
    /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it
     * multiple times.
     * @returns May be null. */
    findBone(boneName) {
      if (!boneName)
        throw new Error("boneName cannot be null.");
      let bones = this.bones;
      for (let i3 = 0, n2 = bones.length; i3 < n2; i3++) {
        let bone = bones[i3];
        if (bone.name == boneName)
          return bone;
      }
      return null;
    }
    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
     * multiple times.
     * @returns May be null. */
    findSlot(slotName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      let slots = this.slots;
      for (let i3 = 0, n2 = slots.length; i3 < n2; i3++) {
        let slot = slots[i3];
        if (slot.name == slotName)
          return slot;
      }
      return null;
    }
    /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it
     * multiple times.
     * @returns May be null. */
    findSkin(skinName) {
      if (!skinName)
        throw new Error("skinName cannot be null.");
      let skins = this.skins;
      for (let i3 = 0, n2 = skins.length; i3 < n2; i3++) {
        let skin = skins[i3];
        if (skin.name == skinName)
          return skin;
      }
      return null;
    }
    /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it
     * multiple times.
     * @returns May be null. */
    findEvent(eventDataName) {
      if (!eventDataName)
        throw new Error("eventDataName cannot be null.");
      let events = this.events;
      for (let i3 = 0, n2 = events.length; i3 < n2; i3++) {
        let event = events[i3];
        if (event.name == eventDataName)
          return event;
      }
      return null;
    }
    /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to
     * call it multiple times.
     * @returns May be null. */
    findAnimation(animationName) {
      if (!animationName)
        throw new Error("animationName cannot be null.");
      let animations = this.animations;
      for (let i3 = 0, n2 = animations.length; i3 < n2; i3++) {
        let animation = animations[i3];
        if (animation.name == animationName)
          return animation;
      }
      return null;
    }
    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
     * than to call it multiple times.
     * @return May be null. */
    findIkConstraint(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      const ikConstraints = this.ikConstraints;
      for (let i3 = 0, n2 = ikConstraints.length; i3 < n2; i3++) {
        const constraint = ikConstraints[i3];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    }
    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
     * this method than to call it multiple times.
     * @return May be null. */
    findTransformConstraint(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      const transformConstraints = this.transformConstraints;
      for (let i3 = 0, n2 = transformConstraints.length; i3 < n2; i3++) {
        const constraint = transformConstraints[i3];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    }
    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
     * than to call it multiple times.
     * @return May be null. */
    findPathConstraint(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      const pathConstraints = this.pathConstraints;
      for (let i3 = 0, n2 = pathConstraints.length; i3 < n2; i3++) {
        const constraint = pathConstraints[i3];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    }
    /** Finds a physics constraint by comparing each physics constraint's name. It is more efficient to cache the results of this method
     * than to call it multiple times.
     * @return May be null. */
    findPhysicsConstraint(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      const physicsConstraints = this.physicsConstraints;
      for (let i3 = 0, n2 = physicsConstraints.length; i3 < n2; i3++) {
        const constraint = physicsConstraints[i3];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/Skin.js
  var SkinEntry = class {
    constructor(slotIndex = 0, name, attachment) {
      __publicField(this, "slotIndex");
      __publicField(this, "name");
      __publicField(this, "attachment");
      this.slotIndex = slotIndex;
      this.name = name;
      this.attachment = attachment;
    }
  };
  var Skin = class {
    // fe9e4fff
    constructor(name) {
      /** The skin's name, which is unique across all skins in the skeleton. */
      __publicField(this, "name");
      __publicField(this, "attachments", new Array());
      __publicField(this, "bones", Array());
      __publicField(this, "constraints", new Array());
      /** The color of the skin as it was in Spine, or a default color if nonessential data was not exported. */
      __publicField(this, "color", new Color2(0.99607843, 0.61960787, 0.30980393, 1));
      if (!name)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    /** Adds an attachment to the skin for the specified slot index and name. */
    setAttachment(slotIndex, name, attachment) {
      if (!attachment)
        throw new Error("attachment cannot be null.");
      let attachments = this.attachments;
      if (slotIndex >= attachments.length)
        attachments.length = slotIndex + 1;
      if (!attachments[slotIndex])
        attachments[slotIndex] = {};
      attachments[slotIndex][name] = attachment;
    }
    /** Adds all attachments, bones, and constraints from the specified skin to this skin. */
    addSkin(skin) {
      for (let i3 = 0; i3 < skin.bones.length; i3++) {
        let bone = skin.bones[i3];
        let contained = false;
        for (let ii = 0; ii < this.bones.length; ii++) {
          if (this.bones[ii] == bone) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.bones.push(bone);
      }
      for (let i3 = 0; i3 < skin.constraints.length; i3++) {
        let constraint = skin.constraints[i3];
        let contained = false;
        for (let ii = 0; ii < this.constraints.length; ii++) {
          if (this.constraints[ii] == constraint) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.constraints.push(constraint);
      }
      let attachments = skin.getAttachments();
      for (let i3 = 0; i3 < attachments.length; i3++) {
        var attachment = attachments[i3];
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    }
    /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not
     * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */
    copySkin(skin) {
      for (let i3 = 0; i3 < skin.bones.length; i3++) {
        let bone = skin.bones[i3];
        let contained = false;
        for (let ii = 0; ii < this.bones.length; ii++) {
          if (this.bones[ii] == bone) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.bones.push(bone);
      }
      for (let i3 = 0; i3 < skin.constraints.length; i3++) {
        let constraint = skin.constraints[i3];
        let contained = false;
        for (let ii = 0; ii < this.constraints.length; ii++) {
          if (this.constraints[ii] == constraint) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.constraints.push(constraint);
      }
      let attachments = skin.getAttachments();
      for (let i3 = 0; i3 < attachments.length; i3++) {
        var attachment = attachments[i3];
        if (!attachment.attachment)
          continue;
        if (attachment.attachment instanceof MeshAttachment) {
          attachment.attachment = attachment.attachment.newLinkedMesh();
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        } else {
          attachment.attachment = attachment.attachment.copy();
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        }
      }
    }
    /** Returns the attachment for the specified slot index and name, or null. */
    getAttachment(slotIndex, name) {
      let dictionary = this.attachments[slotIndex];
      return dictionary ? dictionary[name] : null;
    }
    /** Removes the attachment in the skin for the specified slot index and name, if any. */
    removeAttachment(slotIndex, name) {
      let dictionary = this.attachments[slotIndex];
      if (dictionary)
        delete dictionary[name];
    }
    /** Returns all attachments in this skin. */
    getAttachments() {
      let entries = new Array();
      for (var i3 = 0; i3 < this.attachments.length; i3++) {
        let slotAttachments = this.attachments[i3];
        if (slotAttachments) {
          for (let name in slotAttachments) {
            let attachment = slotAttachments[name];
            if (attachment)
              entries.push(new SkinEntry(i3, name, attachment));
          }
        }
      }
      return entries;
    }
    /** Returns all attachments in this skin for the specified slot index. */
    getAttachmentsForSlot(slotIndex, attachments) {
      let slotAttachments = this.attachments[slotIndex];
      if (slotAttachments) {
        for (let name in slotAttachments) {
          let attachment = slotAttachments[name];
          if (attachment)
            attachments.push(new SkinEntry(slotIndex, name, attachment));
        }
      }
    }
    /** Clears all attachments, bones, and constraints. */
    clear() {
      this.attachments.length = 0;
      this.bones.length = 0;
      this.constraints.length = 0;
    }
    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
    attachAll(skeleton, oldSkin) {
      let slotIndex = 0;
      for (let i3 = 0; i3 < skeleton.slots.length; i3++) {
        let slot = skeleton.slots[i3];
        let slotAttachment = slot.getAttachment();
        if (slotAttachment && slotIndex < oldSkin.attachments.length) {
          let dictionary = oldSkin.attachments[slotIndex];
          for (let key in dictionary) {
            let skinAttachment = dictionary[key];
            if (slotAttachment == skinAttachment) {
              let attachment = this.getAttachment(slotIndex, key);
              if (attachment)
                slot.setAttachment(attachment);
              break;
            }
          }
        }
        slotIndex++;
      }
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/SlotData.js
  var SlotData = class {
    constructor(index, name, boneData) {
      /** The index of the slot in {@link Skeleton#getSlots()}. */
      __publicField(this, "index", 0);
      /** The name of the slot, which is unique across all slots in the skeleton. */
      __publicField(this, "name");
      /** The bone this slot belongs to. */
      __publicField(this, "boneData");
      /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two
       * color tinting. */
      __publicField(this, "color", new Color2(1, 1, 1, 1));
      /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark
       * color's alpha is not used. */
      __publicField(this, "darkColor", null);
      /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */
      __publicField(this, "attachmentName", null);
      /** The blend mode for drawing the slot's attachment. */
      __publicField(this, "blendMode", BlendMode.Normal);
      /** False if the slot was hidden in Spine and nonessential data was exported. Does not affect runtime rendering. */
      __publicField(this, "visible", true);
      if (index < 0)
        throw new Error("index must be >= 0.");
      if (!name)
        throw new Error("name cannot be null.");
      if (!boneData)
        throw new Error("boneData cannot be null.");
      this.index = index;
      this.name = name;
      this.boneData = boneData;
    }
  };
  var BlendMode;
  (function(BlendMode2) {
    BlendMode2[BlendMode2["Normal"] = 0] = "Normal";
    BlendMode2[BlendMode2["Additive"] = 1] = "Additive";
    BlendMode2[BlendMode2["Multiply"] = 2] = "Multiply";
    BlendMode2[BlendMode2["Screen"] = 3] = "Screen";
  })(BlendMode || (BlendMode = {}));

  // node_modules/@esotericsoftware/spine-core/dist/TransformConstraintData.js
  var TransformConstraintData = class extends ConstraintData {
    constructor(name) {
      super(name, 0, false);
      /** The bones that will be modified by this transform constraint. */
      __publicField(this, "bones", new Array());
      /** The target bone whose world transform will be copied to the constrained bones. */
      __publicField(this, "_target", null);
      __publicField(this, "mixRotate", 0);
      __publicField(this, "mixX", 0);
      __publicField(this, "mixY", 0);
      __publicField(this, "mixScaleX", 0);
      __publicField(this, "mixScaleY", 0);
      __publicField(this, "mixShearY", 0);
      /** An offset added to the constrained bone rotation. */
      __publicField(this, "offsetRotation", 0);
      /** An offset added to the constrained bone X translation. */
      __publicField(this, "offsetX", 0);
      /** An offset added to the constrained bone Y translation. */
      __publicField(this, "offsetY", 0);
      /** An offset added to the constrained bone scaleX. */
      __publicField(this, "offsetScaleX", 0);
      /** An offset added to the constrained bone scaleY. */
      __publicField(this, "offsetScaleY", 0);
      /** An offset added to the constrained bone shearY. */
      __publicField(this, "offsetShearY", 0);
      __publicField(this, "relative", false);
      __publicField(this, "local", false);
    }
    set target(boneData) {
      this._target = boneData;
    }
    get target() {
      if (!this._target)
        throw new Error("BoneData not set.");
      else
        return this._target;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/SkeletonBinary.js
  var SkeletonBinary = class {
    constructor(attachmentLoader) {
      /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at
       * runtime than were used in Spine.
       *
       * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */
      __publicField(this, "scale", 1);
      __publicField(this, "attachmentLoader");
      __publicField(this, "linkedMeshes", new Array());
      this.attachmentLoader = attachmentLoader;
    }
    readSkeletonData(binary) {
      var _a2;
      let scale = this.scale;
      let skeletonData = new SkeletonData();
      skeletonData.name = "";
      let input = new BinaryInput(binary);
      let lowHash = input.readInt32();
      let highHash = input.readInt32();
      skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);
      skeletonData.version = input.readString();
      skeletonData.x = input.readFloat();
      skeletonData.y = input.readFloat();
      skeletonData.width = input.readFloat();
      skeletonData.height = input.readFloat();
      skeletonData.referenceScale = input.readFloat() * scale;
      let nonessential = input.readBoolean();
      if (nonessential) {
        skeletonData.fps = input.readFloat();
        skeletonData.imagesPath = input.readString();
        skeletonData.audioPath = input.readString();
      }
      let n2 = 0;
      n2 = input.readInt(true);
      for (let i3 = 0; i3 < n2; i3++) {
        let str = input.readString();
        if (!str)
          throw new Error("String in string table must not be null.");
        input.strings.push(str);
      }
      n2 = input.readInt(true);
      for (let i3 = 0; i3 < n2; i3++) {
        let name = input.readString();
        if (!name)
          throw new Error("Bone name must not be null.");
        let parent = i3 == 0 ? null : skeletonData.bones[input.readInt(true)];
        let data = new BoneData(i3, name, parent);
        data.rotation = input.readFloat();
        data.x = input.readFloat() * scale;
        data.y = input.readFloat() * scale;
        data.scaleX = input.readFloat();
        data.scaleY = input.readFloat();
        data.shearX = input.readFloat();
        data.shearY = input.readFloat();
        data.length = input.readFloat() * scale;
        data.inherit = input.readByte();
        data.skinRequired = input.readBoolean();
        if (nonessential) {
          Color2.rgba8888ToColor(data.color, input.readInt32());
          data.icon = (_a2 = input.readString()) != null ? _a2 : void 0;
          data.visible = input.readBoolean();
        }
        skeletonData.bones.push(data);
      }
      n2 = input.readInt(true);
      for (let i3 = 0; i3 < n2; i3++) {
        let slotName = input.readString();
        if (!slotName)
          throw new Error("Slot name must not be null.");
        let boneData = skeletonData.bones[input.readInt(true)];
        let data = new SlotData(i3, slotName, boneData);
        Color2.rgba8888ToColor(data.color, input.readInt32());
        let darkColor = input.readInt32();
        if (darkColor != -1)
          Color2.rgb888ToColor(data.darkColor = new Color2(), darkColor);
        data.attachmentName = input.readStringRef();
        data.blendMode = input.readInt(true);
        if (nonessential)
          data.visible = input.readBoolean();
        skeletonData.slots.push(data);
      }
      n2 = input.readInt(true);
      for (let i3 = 0, nn; i3 < n2; i3++) {
        let name = input.readString();
        if (!name)
          throw new Error("IK constraint data name must not be null.");
        let data = new IkConstraintData(name);
        data.order = input.readInt(true);
        nn = input.readInt(true);
        for (let ii = 0; ii < nn; ii++)
          data.bones.push(skeletonData.bones[input.readInt(true)]);
        data.target = skeletonData.bones[input.readInt(true)];
        let flags = input.readByte();
        data.skinRequired = (flags & 1) != 0;
        data.bendDirection = (flags & 2) != 0 ? 1 : -1;
        data.compress = (flags & 4) != 0;
        data.stretch = (flags & 8) != 0;
        data.uniform = (flags & 16) != 0;
        if ((flags & 32) != 0)
          data.mix = (flags & 64) != 0 ? input.readFloat() : 1;
        if ((flags & 128) != 0)
          data.softness = input.readFloat() * scale;
        skeletonData.ikConstraints.push(data);
      }
      n2 = input.readInt(true);
      for (let i3 = 0, nn; i3 < n2; i3++) {
        let name = input.readString();
        if (!name)
          throw new Error("Transform constraint data name must not be null.");
        let data = new TransformConstraintData(name);
        data.order = input.readInt(true);
        nn = input.readInt(true);
        for (let ii = 0; ii < nn; ii++)
          data.bones.push(skeletonData.bones[input.readInt(true)]);
        data.target = skeletonData.bones[input.readInt(true)];
        let flags = input.readByte();
        data.skinRequired = (flags & 1) != 0;
        data.local = (flags & 2) != 0;
        data.relative = (flags & 4) != 0;
        if ((flags & 8) != 0)
          data.offsetRotation = input.readFloat();
        if ((flags & 16) != 0)
          data.offsetX = input.readFloat() * scale;
        if ((flags & 32) != 0)
          data.offsetY = input.readFloat() * scale;
        if ((flags & 64) != 0)
          data.offsetScaleX = input.readFloat();
        if ((flags & 128) != 0)
          data.offsetScaleY = input.readFloat();
        flags = input.readByte();
        if ((flags & 1) != 0)
          data.offsetShearY = input.readFloat();
        if ((flags & 2) != 0)
          data.mixRotate = input.readFloat();
        if ((flags & 4) != 0)
          data.mixX = input.readFloat();
        if ((flags & 8) != 0)
          data.mixY = input.readFloat();
        if ((flags & 16) != 0)
          data.mixScaleX = input.readFloat();
        if ((flags & 32) != 0)
          data.mixScaleY = input.readFloat();
        if ((flags & 64) != 0)
          data.mixShearY = input.readFloat();
        skeletonData.transformConstraints.push(data);
      }
      n2 = input.readInt(true);
      for (let i3 = 0, nn; i3 < n2; i3++) {
        let name = input.readString();
        if (!name)
          throw new Error("Path constraint data name must not be null.");
        let data = new PathConstraintData(name);
        data.order = input.readInt(true);
        data.skinRequired = input.readBoolean();
        nn = input.readInt(true);
        for (let ii = 0; ii < nn; ii++)
          data.bones.push(skeletonData.bones[input.readInt(true)]);
        data.target = skeletonData.slots[input.readInt(true)];
        const flags = input.readByte();
        data.positionMode = flags & 1;
        data.spacingMode = flags >> 1 & 3;
        data.rotateMode = flags >> 3 & 3;
        if ((flags & 128) != 0)
          data.offsetRotation = input.readFloat();
        data.position = input.readFloat();
        if (data.positionMode == PositionMode.Fixed)
          data.position *= scale;
        data.spacing = input.readFloat();
        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
          data.spacing *= scale;
        data.mixRotate = input.readFloat();
        data.mixX = input.readFloat();
        data.mixY = input.readFloat();
        skeletonData.pathConstraints.push(data);
      }
      n2 = input.readInt(true);
      for (let i3 = 0, nn; i3 < n2; i3++) {
        const name = input.readString();
        if (!name)
          throw new Error("Physics constraint data name must not be null.");
        const data = new PhysicsConstraintData(name);
        data.order = input.readInt(true);
        data.bone = skeletonData.bones[input.readInt(true)];
        let flags = input.readByte();
        data.skinRequired = (flags & 1) != 0;
        if ((flags & 2) != 0)
          data.x = input.readFloat();
        if ((flags & 4) != 0)
          data.y = input.readFloat();
        if ((flags & 8) != 0)
          data.rotate = input.readFloat();
        if ((flags & 16) != 0)
          data.scaleX = input.readFloat();
        if ((flags & 32) != 0)
          data.shearX = input.readFloat();
        data.limit = ((flags & 64) != 0 ? input.readFloat() : 5e3) * scale;
        data.step = 1 / input.readUnsignedByte();
        data.inertia = input.readFloat();
        data.strength = input.readFloat();
        data.damping = input.readFloat();
        data.massInverse = (flags & 128) != 0 ? input.readFloat() : 1;
        data.wind = input.readFloat();
        data.gravity = input.readFloat();
        flags = input.readByte();
        if ((flags & 1) != 0)
          data.inertiaGlobal = true;
        if ((flags & 2) != 0)
          data.strengthGlobal = true;
        if ((flags & 4) != 0)
          data.dampingGlobal = true;
        if ((flags & 8) != 0)
          data.massGlobal = true;
        if ((flags & 16) != 0)
          data.windGlobal = true;
        if ((flags & 32) != 0)
          data.gravityGlobal = true;
        if ((flags & 64) != 0)
          data.mixGlobal = true;
        data.mix = (flags & 128) != 0 ? input.readFloat() : 1;
        skeletonData.physicsConstraints.push(data);
      }
      let defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
      if (defaultSkin) {
        skeletonData.defaultSkin = defaultSkin;
        skeletonData.skins.push(defaultSkin);
      }
      {
        let i3 = skeletonData.skins.length;
        Utils.setArraySize(skeletonData.skins, n2 = i3 + input.readInt(true));
        for (; i3 < n2; i3++) {
          let skin = this.readSkin(input, skeletonData, false, nonessential);
          if (!skin)
            throw new Error("readSkin() should not have returned null.");
          skeletonData.skins[i3] = skin;
        }
      }
      n2 = this.linkedMeshes.length;
      for (let i3 = 0; i3 < n2; i3++) {
        let linkedMesh = this.linkedMeshes[i3];
        const skin = skeletonData.skins[linkedMesh.skinIndex];
        if (!linkedMesh.parent)
          throw new Error("Linked mesh parent must not be null");
        let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (!parent)
          throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
        linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;
        linkedMesh.mesh.setParentMesh(parent);
        if (linkedMesh.mesh.region != null)
          linkedMesh.mesh.updateRegion();
      }
      this.linkedMeshes.length = 0;
      n2 = input.readInt(true);
      for (let i3 = 0; i3 < n2; i3++) {
        let eventName = input.readString();
        if (!eventName)
          throw new Error("Event data name must not be null");
        let data = new EventData(eventName);
        data.intValue = input.readInt(false);
        data.floatValue = input.readFloat();
        data.stringValue = input.readString();
        data.audioPath = input.readString();
        if (data.audioPath) {
          data.volume = input.readFloat();
          data.balance = input.readFloat();
        }
        skeletonData.events.push(data);
      }
      n2 = input.readInt(true);
      for (let i3 = 0; i3 < n2; i3++) {
        let animationName = input.readString();
        if (!animationName)
          throw new Error("Animatio name must not be null.");
        skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));
      }
      return skeletonData;
    }
    readSkin(input, skeletonData, defaultSkin, nonessential) {
      let skin = null;
      let slotCount = 0;
      if (defaultSkin) {
        slotCount = input.readInt(true);
        if (slotCount == 0)
          return null;
        skin = new Skin("default");
      } else {
        let skinName = input.readString();
        if (!skinName)
          throw new Error("Skin name must not be null.");
        skin = new Skin(skinName);
        if (nonessential)
          Color2.rgba8888ToColor(skin.color, input.readInt32());
        skin.bones.length = input.readInt(true);
        for (let i3 = 0, n2 = skin.bones.length; i3 < n2; i3++)
          skin.bones[i3] = skeletonData.bones[input.readInt(true)];
        for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++)
          skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
        for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++)
          skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
        for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++)
          skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
        for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++)
          skin.constraints.push(skeletonData.physicsConstraints[input.readInt(true)]);
        slotCount = input.readInt(true);
      }
      for (let i3 = 0; i3 < slotCount; i3++) {
        let slotIndex = input.readInt(true);
        for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          let name = input.readStringRef();
          if (!name)
            throw new Error("Attachment name must not be null");
          let attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
          if (attachment)
            skin.setAttachment(slotIndex, name, attachment);
        }
      }
      return skin;
    }
    readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
      let scale = this.scale;
      let flags = input.readByte();
      const name = (flags & 8) != 0 ? input.readStringRef() : attachmentName;
      if (!name)
        throw new Error("Attachment name must not be null");
      switch (flags & 7) {
        // BUG?
        case AttachmentType.Region: {
          let path2 = (flags & 16) != 0 ? input.readStringRef() : null;
          const color = (flags & 32) != 0 ? input.readInt32() : 4294967295;
          const sequence = (flags & 64) != 0 ? this.readSequence(input) : null;
          let rotation = (flags & 128) != 0 ? input.readFloat() : 0;
          let x2 = input.readFloat();
          let y2 = input.readFloat();
          let scaleX = input.readFloat();
          let scaleY = input.readFloat();
          let width = input.readFloat();
          let height = input.readFloat();
          if (!path2)
            path2 = name;
          let region = this.attachmentLoader.newRegionAttachment(skin, name, path2, sequence);
          if (!region)
            return null;
          region.path = path2;
          region.x = x2 * scale;
          region.y = y2 * scale;
          region.scaleX = scaleX;
          region.scaleY = scaleY;
          region.rotation = rotation;
          region.width = width * scale;
          region.height = height * scale;
          Color2.rgba8888ToColor(region.color, color);
          region.sequence = sequence;
          if (sequence == null)
            region.updateRegion();
          return region;
        }
        case AttachmentType.BoundingBox: {
          let vertices = this.readVertices(input, (flags & 16) != 0);
          let color = nonessential ? input.readInt32() : 0;
          let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (!box)
            return null;
          box.worldVerticesLength = vertices.length;
          box.vertices = vertices.vertices;
          box.bones = vertices.bones;
          if (nonessential)
            Color2.rgba8888ToColor(box.color, color);
          return box;
        }
        case AttachmentType.Mesh: {
          let path2 = (flags & 16) != 0 ? input.readStringRef() : name;
          const color = (flags & 32) != 0 ? input.readInt32() : 4294967295;
          const sequence = (flags & 64) != 0 ? this.readSequence(input) : null;
          const hullLength = input.readInt(true);
          const vertices = this.readVertices(input, (flags & 128) != 0);
          const uvs = this.readFloatArray(input, vertices.length, 1);
          const triangles = this.readShortArray(input, (vertices.length - hullLength - 2) * 3);
          let edges = [];
          let width = 0, height = 0;
          if (nonessential) {
            edges = this.readShortArray(input, input.readInt(true));
            width = input.readFloat();
            height = input.readFloat();
          }
          if (!path2)
            path2 = name;
          let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path2, sequence);
          if (!mesh)
            return null;
          mesh.path = path2;
          Color2.rgba8888ToColor(mesh.color, color);
          mesh.bones = vertices.bones;
          mesh.vertices = vertices.vertices;
          mesh.worldVerticesLength = vertices.length;
          mesh.triangles = triangles;
          mesh.regionUVs = uvs;
          if (sequence == null)
            mesh.updateRegion();
          mesh.hullLength = hullLength << 1;
          mesh.sequence = sequence;
          if (nonessential) {
            mesh.edges = edges;
            mesh.width = width * scale;
            mesh.height = height * scale;
          }
          return mesh;
        }
        case AttachmentType.LinkedMesh: {
          const path2 = (flags & 16) != 0 ? input.readStringRef() : name;
          if (path2 == null)
            throw new Error("Path of linked mesh must not be null");
          const color = (flags & 32) != 0 ? input.readInt32() : 4294967295;
          const sequence = (flags & 64) != 0 ? this.readSequence(input) : null;
          const inheritTimelines = (flags & 128) != 0;
          const skinIndex = input.readInt(true);
          const parent = input.readStringRef();
          let width = 0, height = 0;
          if (nonessential) {
            width = input.readFloat();
            height = input.readFloat();
          }
          let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path2, sequence);
          if (!mesh)
            return null;
          mesh.path = path2;
          Color2.rgba8888ToColor(mesh.color, color);
          mesh.sequence = sequence;
          if (nonessential) {
            mesh.width = width * scale;
            mesh.height = height * scale;
          }
          this.linkedMeshes.push(new LinkedMesh(mesh, skinIndex, slotIndex, parent, inheritTimelines));
          return mesh;
        }
        case AttachmentType.Path: {
          const closed2 = (flags & 16) != 0;
          const constantSpeed = (flags & 32) != 0;
          const vertices = this.readVertices(input, (flags & 64) != 0);
          const lengths = Utils.newArray(vertices.length / 6, 0);
          for (let i3 = 0, n2 = lengths.length; i3 < n2; i3++)
            lengths[i3] = input.readFloat() * scale;
          const color = nonessential ? input.readInt32() : 0;
          const path2 = this.attachmentLoader.newPathAttachment(skin, name);
          if (!path2)
            return null;
          path2.closed = closed2;
          path2.constantSpeed = constantSpeed;
          path2.worldVerticesLength = vertices.length;
          path2.vertices = vertices.vertices;
          path2.bones = vertices.bones;
          path2.lengths = lengths;
          if (nonessential)
            Color2.rgba8888ToColor(path2.color, color);
          return path2;
        }
        case AttachmentType.Point: {
          const rotation = input.readFloat();
          const x2 = input.readFloat();
          const y2 = input.readFloat();
          const color = nonessential ? input.readInt32() : 0;
          const point = this.attachmentLoader.newPointAttachment(skin, name);
          if (!point)
            return null;
          point.x = x2 * scale;
          point.y = y2 * scale;
          point.rotation = rotation;
          if (nonessential)
            Color2.rgba8888ToColor(point.color, color);
          return point;
        }
        case AttachmentType.Clipping: {
          const endSlotIndex = input.readInt(true);
          const vertices = this.readVertices(input, (flags & 16) != 0);
          let color = nonessential ? input.readInt32() : 0;
          let clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (!clip)
            return null;
          clip.endSlot = skeletonData.slots[endSlotIndex];
          clip.worldVerticesLength = vertices.length;
          clip.vertices = vertices.vertices;
          clip.bones = vertices.bones;
          if (nonessential)
            Color2.rgba8888ToColor(clip.color, color);
          return clip;
        }
      }
      return null;
    }
    readSequence(input) {
      let sequence = new Sequence(input.readInt(true));
      sequence.start = input.readInt(true);
      sequence.digits = input.readInt(true);
      sequence.setupIndex = input.readInt(true);
      return sequence;
    }
    readVertices(input, weighted) {
      const scale = this.scale;
      const vertexCount = input.readInt(true);
      const vertices = new Vertices();
      vertices.length = vertexCount << 1;
      if (!weighted) {
        vertices.vertices = this.readFloatArray(input, vertices.length, scale);
        return vertices;
      }
      let weights = new Array();
      let bonesArray = new Array();
      for (let i3 = 0; i3 < vertexCount; i3++) {
        let boneCount = input.readInt(true);
        bonesArray.push(boneCount);
        for (let ii = 0; ii < boneCount; ii++) {
          bonesArray.push(input.readInt(true));
          weights.push(input.readFloat() * scale);
          weights.push(input.readFloat() * scale);
          weights.push(input.readFloat());
        }
      }
      vertices.vertices = Utils.toFloatArray(weights);
      vertices.bones = bonesArray;
      return vertices;
    }
    readFloatArray(input, n2, scale) {
      let array = new Array(n2);
      if (scale == 1) {
        for (let i3 = 0; i3 < n2; i3++)
          array[i3] = input.readFloat();
      } else {
        for (let i3 = 0; i3 < n2; i3++)
          array[i3] = input.readFloat() * scale;
      }
      return array;
    }
    readShortArray(input, n2) {
      let array = new Array(n2);
      for (let i3 = 0; i3 < n2; i3++)
        array[i3] = input.readInt(true);
      return array;
    }
    readAnimation(input, name, skeletonData) {
      input.readInt(true);
      let timelines = new Array();
      let scale = this.scale;
      for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++) {
        let slotIndex = input.readInt(true);
        for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          let timelineType = input.readByte();
          let frameCount = input.readInt(true);
          let frameLast = frameCount - 1;
          switch (timelineType) {
            case SLOT_ATTACHMENT: {
              let timeline2 = new AttachmentTimeline(frameCount, slotIndex);
              for (let frame = 0; frame < frameCount; frame++)
                timeline2.setFrame(frame, input.readFloat(), input.readStringRef());
              timelines.push(timeline2);
              break;
            }
            case SLOT_RGBA: {
              let bezierCount = input.readInt(true);
              let timeline2 = new RGBATimeline(frameCount, bezierCount, slotIndex);
              let time = input.readFloat();
              let r2 = input.readUnsignedByte() / 255;
              let g2 = input.readUnsignedByte() / 255;
              let b2 = input.readUnsignedByte() / 255;
              let a2 = input.readUnsignedByte() / 255;
              for (let frame = 0, bezier = 0; ; frame++) {
                timeline2.setFrame(frame, time, r2, g2, b2, a2);
                if (frame == frameLast)
                  break;
                let time2 = input.readFloat();
                let r22 = input.readUnsignedByte() / 255;
                let g22 = input.readUnsignedByte() / 255;
                let b22 = input.readUnsignedByte() / 255;
                let a22 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline2.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline2, bezier++, frame, 0, time, time2, r2, r22, 1);
                    setBezier(input, timeline2, bezier++, frame, 1, time, time2, g2, g22, 1);
                    setBezier(input, timeline2, bezier++, frame, 2, time, time2, b2, b22, 1);
                    setBezier(input, timeline2, bezier++, frame, 3, time, time2, a2, a22, 1);
                }
                time = time2;
                r2 = r22;
                g2 = g22;
                b2 = b22;
                a2 = a22;
              }
              timelines.push(timeline2);
              break;
            }
            case SLOT_RGB: {
              let bezierCount = input.readInt(true);
              let timeline2 = new RGBTimeline(frameCount, bezierCount, slotIndex);
              let time = input.readFloat();
              let r2 = input.readUnsignedByte() / 255;
              let g2 = input.readUnsignedByte() / 255;
              let b2 = input.readUnsignedByte() / 255;
              for (let frame = 0, bezier = 0; ; frame++) {
                timeline2.setFrame(frame, time, r2, g2, b2);
                if (frame == frameLast)
                  break;
                let time2 = input.readFloat();
                let r22 = input.readUnsignedByte() / 255;
                let g22 = input.readUnsignedByte() / 255;
                let b22 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline2.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline2, bezier++, frame, 0, time, time2, r2, r22, 1);
                    setBezier(input, timeline2, bezier++, frame, 1, time, time2, g2, g22, 1);
                    setBezier(input, timeline2, bezier++, frame, 2, time, time2, b2, b22, 1);
                }
                time = time2;
                r2 = r22;
                g2 = g22;
                b2 = b22;
              }
              timelines.push(timeline2);
              break;
            }
            case SLOT_RGBA2: {
              let bezierCount = input.readInt(true);
              let timeline2 = new RGBA2Timeline(frameCount, bezierCount, slotIndex);
              let time = input.readFloat();
              let r2 = input.readUnsignedByte() / 255;
              let g2 = input.readUnsignedByte() / 255;
              let b2 = input.readUnsignedByte() / 255;
              let a2 = input.readUnsignedByte() / 255;
              let r22 = input.readUnsignedByte() / 255;
              let g22 = input.readUnsignedByte() / 255;
              let b22 = input.readUnsignedByte() / 255;
              for (let frame = 0, bezier = 0; ; frame++) {
                timeline2.setFrame(frame, time, r2, g2, b2, a2, r22, g22, b22);
                if (frame == frameLast)
                  break;
                let time2 = input.readFloat();
                let nr = input.readUnsignedByte() / 255;
                let ng = input.readUnsignedByte() / 255;
                let nb = input.readUnsignedByte() / 255;
                let na = input.readUnsignedByte() / 255;
                let nr2 = input.readUnsignedByte() / 255;
                let ng2 = input.readUnsignedByte() / 255;
                let nb2 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline2.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline2, bezier++, frame, 0, time, time2, r2, nr, 1);
                    setBezier(input, timeline2, bezier++, frame, 1, time, time2, g2, ng, 1);
                    setBezier(input, timeline2, bezier++, frame, 2, time, time2, b2, nb, 1);
                    setBezier(input, timeline2, bezier++, frame, 3, time, time2, a2, na, 1);
                    setBezier(input, timeline2, bezier++, frame, 4, time, time2, r22, nr2, 1);
                    setBezier(input, timeline2, bezier++, frame, 5, time, time2, g22, ng2, 1);
                    setBezier(input, timeline2, bezier++, frame, 6, time, time2, b22, nb2, 1);
                }
                time = time2;
                r2 = nr;
                g2 = ng;
                b2 = nb;
                a2 = na;
                r22 = nr2;
                g22 = ng2;
                b22 = nb2;
              }
              timelines.push(timeline2);
              break;
            }
            case SLOT_RGB2: {
              let bezierCount = input.readInt(true);
              let timeline2 = new RGB2Timeline(frameCount, bezierCount, slotIndex);
              let time = input.readFloat();
              let r2 = input.readUnsignedByte() / 255;
              let g2 = input.readUnsignedByte() / 255;
              let b2 = input.readUnsignedByte() / 255;
              let r22 = input.readUnsignedByte() / 255;
              let g22 = input.readUnsignedByte() / 255;
              let b22 = input.readUnsignedByte() / 255;
              for (let frame = 0, bezier = 0; ; frame++) {
                timeline2.setFrame(frame, time, r2, g2, b2, r22, g22, b22);
                if (frame == frameLast)
                  break;
                let time2 = input.readFloat();
                let nr = input.readUnsignedByte() / 255;
                let ng = input.readUnsignedByte() / 255;
                let nb = input.readUnsignedByte() / 255;
                let nr2 = input.readUnsignedByte() / 255;
                let ng2 = input.readUnsignedByte() / 255;
                let nb2 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline2.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline2, bezier++, frame, 0, time, time2, r2, nr, 1);
                    setBezier(input, timeline2, bezier++, frame, 1, time, time2, g2, ng, 1);
                    setBezier(input, timeline2, bezier++, frame, 2, time, time2, b2, nb, 1);
                    setBezier(input, timeline2, bezier++, frame, 3, time, time2, r22, nr2, 1);
                    setBezier(input, timeline2, bezier++, frame, 4, time, time2, g22, ng2, 1);
                    setBezier(input, timeline2, bezier++, frame, 5, time, time2, b22, nb2, 1);
                }
                time = time2;
                r2 = nr;
                g2 = ng;
                b2 = nb;
                r22 = nr2;
                g22 = ng2;
                b22 = nb2;
              }
              timelines.push(timeline2);
              break;
            }
            case SLOT_ALPHA: {
              let timeline2 = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);
              let time = input.readFloat(), a2 = input.readUnsignedByte() / 255;
              for (let frame = 0, bezier = 0; ; frame++) {
                timeline2.setFrame(frame, time, a2);
                if (frame == frameLast)
                  break;
                let time2 = input.readFloat();
                let a22 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline2.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline2, bezier++, frame, 0, time, time2, a2, a22, 1);
                }
                time = time2;
                a2 = a22;
              }
              timelines.push(timeline2);
            }
          }
        }
      }
      for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++) {
        let boneIndex = input.readInt(true);
        for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          let type = input.readByte(), frameCount = input.readInt(true);
          if (type == BONE_INHERIT) {
            let timeline2 = new InheritTimeline(frameCount, boneIndex);
            for (let frame = 0; frame < frameCount; frame++) {
              timeline2.setFrame(frame, input.readFloat(), input.readByte());
            }
            timelines.push(timeline2);
            continue;
          }
          let bezierCount = input.readInt(true);
          switch (type) {
            case BONE_ROTATE:
              timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_TRANSLATE:
              timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));
              break;
            case BONE_TRANSLATEX:
              timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));
              break;
            case BONE_TRANSLATEY:
              timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));
              break;
            case BONE_SCALE:
              timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SCALEX:
              timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SCALEY:
              timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SHEAR:
              timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SHEARX:
              timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SHEARY:
              timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));
          }
        }
      }
      for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++) {
        let index = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;
        let timeline2 = new IkConstraintTimeline(frameCount, input.readInt(true), index);
        let flags = input.readByte();
        let time = input.readFloat(), mix = (flags & 1) != 0 ? (flags & 2) != 0 ? input.readFloat() : 1 : 0;
        let softness = (flags & 4) != 0 ? input.readFloat() * scale : 0;
        for (let frame = 0, bezier = 0; ; frame++) {
          timeline2.setFrame(frame, time, mix, softness, (flags & 8) != 0 ? 1 : -1, (flags & 16) != 0, (flags & 32) != 0);
          if (frame == frameLast)
            break;
          flags = input.readByte();
          const time2 = input.readFloat(), mix2 = (flags & 1) != 0 ? (flags & 2) != 0 ? input.readFloat() : 1 : 0;
          const softness2 = (flags & 4) != 0 ? input.readFloat() * scale : 0;
          if ((flags & 64) != 0) {
            timeline2.setStepped(frame);
          } else if ((flags & 128) != 0) {
            setBezier(input, timeline2, bezier++, frame, 0, time, time2, mix, mix2, 1);
            setBezier(input, timeline2, bezier++, frame, 1, time, time2, softness, softness2, scale);
          }
          time = time2;
          mix = mix2;
          softness = softness2;
        }
        timelines.push(timeline2);
      }
      for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++) {
        let index = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;
        let timeline2 = new TransformConstraintTimeline(frameCount, input.readInt(true), index);
        let time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat(), mixScaleX = input.readFloat(), mixScaleY = input.readFloat(), mixShearY = input.readFloat();
        for (let frame = 0, bezier = 0; ; frame++) {
          timeline2.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
          if (frame == frameLast)
            break;
          let time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(), mixY2 = input.readFloat(), mixScaleX2 = input.readFloat(), mixScaleY2 = input.readFloat(), mixShearY2 = input.readFloat();
          switch (input.readByte()) {
            case CURVE_STEPPED:
              timeline2.setStepped(frame);
              break;
            case CURVE_BEZIER:
              setBezier(input, timeline2, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
              setBezier(input, timeline2, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
              setBezier(input, timeline2, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
              setBezier(input, timeline2, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
              setBezier(input, timeline2, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
              setBezier(input, timeline2, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);
          }
          time = time2;
          mixRotate = mixRotate2;
          mixX = mixX2;
          mixY = mixY2;
          mixScaleX = mixScaleX2;
          mixScaleY = mixScaleY2;
          mixShearY = mixShearY2;
        }
        timelines.push(timeline2);
      }
      for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++) {
        let index = input.readInt(true);
        let data = skeletonData.pathConstraints[index];
        for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          const type = input.readByte(), frameCount = input.readInt(true), bezierCount = input.readInt(true);
          switch (type) {
            case PATH_POSITION:
              timelines.push(readTimeline1(input, new PathConstraintPositionTimeline(frameCount, bezierCount, index), data.positionMode == PositionMode.Fixed ? scale : 1));
              break;
            case PATH_SPACING:
              timelines.push(readTimeline1(input, new PathConstraintSpacingTimeline(frameCount, bezierCount, index), data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1));
              break;
            case PATH_MIX:
              let timeline2 = new PathConstraintMixTimeline(frameCount, bezierCount, index);
              let time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat();
              for (let frame = 0, bezier = 0, frameLast = timeline2.getFrameCount() - 1; ; frame++) {
                timeline2.setFrame(frame, time, mixRotate, mixX, mixY);
                if (frame == frameLast)
                  break;
                let time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(), mixY2 = input.readFloat();
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline2.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline2, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                    setBezier(input, timeline2, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
                    setBezier(input, timeline2, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
                }
                time = time2;
                mixRotate = mixRotate2;
                mixX = mixX2;
                mixY = mixY2;
              }
              timelines.push(timeline2);
          }
        }
      }
      for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++) {
        const index = input.readInt(true) - 1;
        for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          const type = input.readByte(), frameCount = input.readInt(true);
          if (type == PHYSICS_RESET) {
            const timeline2 = new PhysicsConstraintResetTimeline(frameCount, index);
            for (let frame = 0; frame < frameCount; frame++)
              timeline2.setFrame(frame, input.readFloat());
            timelines.push(timeline2);
            continue;
          }
          const bezierCount = input.readInt(true);
          switch (type) {
            case PHYSICS_INERTIA:
              timelines.push(readTimeline1(input, new PhysicsConstraintInertiaTimeline(frameCount, bezierCount, index), 1));
              break;
            case PHYSICS_STRENGTH:
              timelines.push(readTimeline1(input, new PhysicsConstraintStrengthTimeline(frameCount, bezierCount, index), 1));
              break;
            case PHYSICS_DAMPING:
              timelines.push(readTimeline1(input, new PhysicsConstraintDampingTimeline(frameCount, bezierCount, index), 1));
              break;
            case PHYSICS_MASS:
              timelines.push(readTimeline1(input, new PhysicsConstraintMassTimeline(frameCount, bezierCount, index), 1));
              break;
            case PHYSICS_WIND:
              timelines.push(readTimeline1(input, new PhysicsConstraintWindTimeline(frameCount, bezierCount, index), 1));
              break;
            case PHYSICS_GRAVITY:
              timelines.push(readTimeline1(input, new PhysicsConstraintGravityTimeline(frameCount, bezierCount, index), 1));
              break;
            case PHYSICS_MIX:
              timelines.push(readTimeline1(input, new PhysicsConstraintMixTimeline(frameCount, bezierCount, index), 1));
          }
        }
      }
      for (let i3 = 0, n2 = input.readInt(true); i3 < n2; i3++) {
        let skin = skeletonData.skins[input.readInt(true)];
        for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
          let slotIndex = input.readInt(true);
          for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
            let attachmentName = input.readStringRef();
            if (!attachmentName)
              throw new Error("attachmentName must not be null.");
            let attachment = skin.getAttachment(slotIndex, attachmentName);
            let timelineType = input.readByte();
            let frameCount = input.readInt(true);
            let frameLast = frameCount - 1;
            switch (timelineType) {
              case ATTACHMENT_DEFORM: {
                let vertexAttachment = attachment;
                let weighted = vertexAttachment.bones;
                let vertices = vertexAttachment.vertices;
                let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                let bezierCount = input.readInt(true);
                let timeline2 = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);
                let time = input.readFloat();
                for (let frame = 0, bezier = 0; ; frame++) {
                  let deform;
                  let end = input.readInt(true);
                  if (end == 0)
                    deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                  else {
                    deform = Utils.newFloatArray(deformLength);
                    let start = input.readInt(true);
                    end += start;
                    if (scale == 1) {
                      for (let v2 = start; v2 < end; v2++)
                        deform[v2] = input.readFloat();
                    } else {
                      for (let v2 = start; v2 < end; v2++)
                        deform[v2] = input.readFloat() * scale;
                    }
                    if (!weighted) {
                      for (let v2 = 0, vn = deform.length; v2 < vn; v2++)
                        deform[v2] += vertices[v2];
                    }
                  }
                  timeline2.setFrame(frame, time, deform);
                  if (frame == frameLast)
                    break;
                  let time2 = input.readFloat();
                  switch (input.readByte()) {
                    case CURVE_STEPPED:
                      timeline2.setStepped(frame);
                      break;
                    case CURVE_BEZIER:
                      setBezier(input, timeline2, bezier++, frame, 0, time, time2, 0, 1, 1);
                  }
                  time = time2;
                }
                timelines.push(timeline2);
                break;
              }
              case ATTACHMENT_SEQUENCE: {
                let timeline2 = new SequenceTimeline(frameCount, slotIndex, attachment);
                for (let frame = 0; frame < frameCount; frame++) {
                  let time = input.readFloat();
                  let modeAndIndex = input.readInt32();
                  timeline2.setFrame(frame, time, SequenceModeValues[modeAndIndex & 15], modeAndIndex >> 4, input.readFloat());
                }
                timelines.push(timeline2);
                break;
              }
            }
          }
        }
      }
      let drawOrderCount = input.readInt(true);
      if (drawOrderCount > 0) {
        let timeline2 = new DrawOrderTimeline(drawOrderCount);
        let slotCount = skeletonData.slots.length;
        for (let i3 = 0; i3 < drawOrderCount; i3++) {
          let time = input.readFloat();
          let offsetCount = input.readInt(true);
          let drawOrder = Utils.newArray(slotCount, 0);
          for (let ii = slotCount - 1; ii >= 0; ii--)
            drawOrder[ii] = -1;
          let unchanged = Utils.newArray(slotCount - offsetCount, 0);
          let originalIndex = 0, unchangedIndex = 0;
          for (let ii = 0; ii < offsetCount; ii++) {
            let slotIndex = input.readInt(true);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let ii = slotCount - 1; ii >= 0; ii--)
            if (drawOrder[ii] == -1)
              drawOrder[ii] = unchanged[--unchangedIndex];
          timeline2.setFrame(i3, time, drawOrder);
        }
        timelines.push(timeline2);
      }
      let eventCount = input.readInt(true);
      if (eventCount > 0) {
        let timeline2 = new EventTimeline(eventCount);
        for (let i3 = 0; i3 < eventCount; i3++) {
          let time = input.readFloat();
          let eventData = skeletonData.events[input.readInt(true)];
          let event = new Event2(time, eventData);
          event.intValue = input.readInt(false);
          event.floatValue = input.readFloat();
          event.stringValue = input.readString();
          if (event.stringValue == null)
            event.stringValue = eventData.stringValue;
          if (event.data.audioPath) {
            event.volume = input.readFloat();
            event.balance = input.readFloat();
          }
          timeline2.setFrame(i3, event);
        }
        timelines.push(timeline2);
      }
      let duration = 0;
      for (let i3 = 0, n2 = timelines.length; i3 < n2; i3++)
        duration = Math.max(duration, timelines[i3].getDuration());
      return new Animation2(name, timelines, duration);
    }
  };
  var BinaryInput = class {
    constructor(data, strings = new Array(), index = 0, buffer = new DataView(data instanceof ArrayBuffer ? data : data.buffer)) {
      __publicField(this, "strings");
      __publicField(this, "index");
      __publicField(this, "buffer");
      this.strings = strings;
      this.index = index;
      this.buffer = buffer;
    }
    readByte() {
      return this.buffer.getInt8(this.index++);
    }
    readUnsignedByte() {
      return this.buffer.getUint8(this.index++);
    }
    readShort() {
      let value = this.buffer.getInt16(this.index);
      this.index += 2;
      return value;
    }
    readInt32() {
      let value = this.buffer.getInt32(this.index);
      this.index += 4;
      return value;
    }
    readInt(optimizePositive) {
      let b2 = this.readByte();
      let result = b2 & 127;
      if ((b2 & 128) != 0) {
        b2 = this.readByte();
        result |= (b2 & 127) << 7;
        if ((b2 & 128) != 0) {
          b2 = this.readByte();
          result |= (b2 & 127) << 14;
          if ((b2 & 128) != 0) {
            b2 = this.readByte();
            result |= (b2 & 127) << 21;
            if ((b2 & 128) != 0) {
              b2 = this.readByte();
              result |= (b2 & 127) << 28;
            }
          }
        }
      }
      return optimizePositive ? result : result >>> 1 ^ -(result & 1);
    }
    readStringRef() {
      let index = this.readInt(true);
      return index == 0 ? null : this.strings[index - 1];
    }
    readString() {
      let byteCount = this.readInt(true);
      switch (byteCount) {
        case 0:
          return null;
        case 1:
          return "";
      }
      byteCount--;
      let chars = "";
      let charCount = 0;
      for (let i3 = 0; i3 < byteCount; ) {
        let b2 = this.readUnsignedByte();
        switch (b2 >> 4) {
          case 12:
          case 13:
            chars += String.fromCharCode((b2 & 31) << 6 | this.readByte() & 63);
            i3 += 2;
            break;
          case 14:
            chars += String.fromCharCode((b2 & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63);
            i3 += 3;
            break;
          default:
            chars += String.fromCharCode(b2);
            i3++;
        }
      }
      return chars;
    }
    readFloat() {
      let value = this.buffer.getFloat32(this.index);
      this.index += 4;
      return value;
    }
    readBoolean() {
      return this.readByte() != 0;
    }
  };
  var LinkedMesh = class {
    constructor(mesh, skinIndex, slotIndex, parent, inheritDeform) {
      __publicField(this, "parent");
      __publicField(this, "skinIndex");
      __publicField(this, "slotIndex");
      __publicField(this, "mesh");
      __publicField(this, "inheritTimeline");
      this.mesh = mesh;
      this.skinIndex = skinIndex;
      this.slotIndex = slotIndex;
      this.parent = parent;
      this.inheritTimeline = inheritDeform;
    }
  };
  var Vertices = class {
    constructor(bones = null, vertices = null, length = 0) {
      __publicField(this, "bones");
      __publicField(this, "vertices");
      __publicField(this, "length");
      this.bones = bones;
      this.vertices = vertices;
      this.length = length;
    }
  };
  var AttachmentType;
  (function(AttachmentType2) {
    AttachmentType2[AttachmentType2["Region"] = 0] = "Region";
    AttachmentType2[AttachmentType2["BoundingBox"] = 1] = "BoundingBox";
    AttachmentType2[AttachmentType2["Mesh"] = 2] = "Mesh";
    AttachmentType2[AttachmentType2["LinkedMesh"] = 3] = "LinkedMesh";
    AttachmentType2[AttachmentType2["Path"] = 4] = "Path";
    AttachmentType2[AttachmentType2["Point"] = 5] = "Point";
    AttachmentType2[AttachmentType2["Clipping"] = 6] = "Clipping";
  })(AttachmentType || (AttachmentType = {}));
  function readTimeline1(input, timeline2, scale) {
    let time = input.readFloat(), value = input.readFloat() * scale;
    for (let frame = 0, bezier = 0, frameLast = timeline2.getFrameCount() - 1; ; frame++) {
      timeline2.setFrame(frame, time, value);
      if (frame == frameLast)
        break;
      let time2 = input.readFloat(), value2 = input.readFloat() * scale;
      switch (input.readByte()) {
        case CURVE_STEPPED:
          timeline2.setStepped(frame);
          break;
        case CURVE_BEZIER:
          setBezier(input, timeline2, bezier++, frame, 0, time, time2, value, value2, scale);
      }
      time = time2;
      value = value2;
    }
    return timeline2;
  }
  function readTimeline2(input, timeline2, scale) {
    let time = input.readFloat(), value1 = input.readFloat() * scale, value2 = input.readFloat() * scale;
    for (let frame = 0, bezier = 0, frameLast = timeline2.getFrameCount() - 1; ; frame++) {
      timeline2.setFrame(frame, time, value1, value2);
      if (frame == frameLast)
        break;
      let time2 = input.readFloat(), nvalue1 = input.readFloat() * scale, nvalue2 = input.readFloat() * scale;
      switch (input.readByte()) {
        case CURVE_STEPPED:
          timeline2.setStepped(frame);
          break;
        case CURVE_BEZIER:
          setBezier(input, timeline2, bezier++, frame, 0, time, time2, value1, nvalue1, scale);
          setBezier(input, timeline2, bezier++, frame, 1, time, time2, value2, nvalue2, scale);
      }
      time = time2;
      value1 = nvalue1;
      value2 = nvalue2;
    }
    return timeline2;
  }
  function setBezier(input, timeline2, bezier, frame, value, time1, time2, value1, value2, scale) {
    timeline2.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);
  }
  var BONE_ROTATE = 0;
  var BONE_TRANSLATE = 1;
  var BONE_TRANSLATEX = 2;
  var BONE_TRANSLATEY = 3;
  var BONE_SCALE = 4;
  var BONE_SCALEX = 5;
  var BONE_SCALEY = 6;
  var BONE_SHEAR = 7;
  var BONE_SHEARX = 8;
  var BONE_SHEARY = 9;
  var BONE_INHERIT = 10;
  var SLOT_ATTACHMENT = 0;
  var SLOT_RGBA = 1;
  var SLOT_RGB = 2;
  var SLOT_RGBA2 = 3;
  var SLOT_RGB2 = 4;
  var SLOT_ALPHA = 5;
  var ATTACHMENT_DEFORM = 0;
  var ATTACHMENT_SEQUENCE = 1;
  var PATH_POSITION = 0;
  var PATH_SPACING = 1;
  var PATH_MIX = 2;
  var PHYSICS_INERTIA = 0;
  var PHYSICS_STRENGTH = 1;
  var PHYSICS_DAMPING = 2;
  var PHYSICS_MASS = 4;
  var PHYSICS_WIND = 5;
  var PHYSICS_GRAVITY = 6;
  var PHYSICS_MIX = 7;
  var PHYSICS_RESET = 8;
  var CURVE_STEPPED = 1;
  var CURVE_BEZIER = 2;

  // node_modules/@esotericsoftware/spine-core/dist/SkeletonBounds.js
  var SkeletonBounds = class {
    constructor() {
      /** The left edge of the axis aligned bounding box. */
      __publicField(this, "minX", 0);
      /** The bottom edge of the axis aligned bounding box. */
      __publicField(this, "minY", 0);
      /** The right edge of the axis aligned bounding box. */
      __publicField(this, "maxX", 0);
      /** The top edge of the axis aligned bounding box. */
      __publicField(this, "maxY", 0);
      /** The visible bounding boxes. */
      __publicField(this, "boundingBoxes", new Array());
      /** The world vertices for the bounding box polygons. */
      __publicField(this, "polygons", new Array());
      __publicField(this, "polygonPool", new Pool2(() => {
        return Utils.newFloatArray(16);
      }));
    }
    /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding
     * box's polygon.
     * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the
     *           SkeletonBounds AABB methods will always return true. */
    update(skeleton, updateAabb) {
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      let boundingBoxes = this.boundingBoxes;
      let polygons = this.polygons;
      let polygonPool = this.polygonPool;
      let slots = skeleton.slots;
      let slotCount = slots.length;
      boundingBoxes.length = 0;
      polygonPool.freeAll(polygons);
      polygons.length = 0;
      for (let i3 = 0; i3 < slotCount; i3++) {
        let slot = slots[i3];
        if (!slot.bone.active)
          continue;
        let attachment = slot.getAttachment();
        if (attachment instanceof BoundingBoxAttachment) {
          let boundingBox = attachment;
          boundingBoxes.push(boundingBox);
          let polygon = polygonPool.obtain();
          if (polygon.length != boundingBox.worldVerticesLength) {
            polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);
          }
          polygons.push(polygon);
          boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
        }
      }
      if (updateAabb) {
        this.aabbCompute();
      } else {
        this.minX = Number.POSITIVE_INFINITY;
        this.minY = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.maxY = Number.NEGATIVE_INFINITY;
      }
    }
    aabbCompute() {
      let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
      let polygons = this.polygons;
      for (let i3 = 0, n2 = polygons.length; i3 < n2; i3++) {
        let polygon = polygons[i3];
        let vertices = polygon;
        for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {
          let x2 = vertices[ii];
          let y2 = vertices[ii + 1];
          minX = Math.min(minX, x2);
          minY = Math.min(minY, y2);
          maxX = Math.max(maxX, x2);
          maxY = Math.max(maxY, y2);
        }
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    /** Returns true if the axis aligned bounding box contains the point. */
    aabbContainsPoint(x2, y2) {
      return x2 >= this.minX && x2 <= this.maxX && y2 >= this.minY && y2 <= this.maxY;
    }
    /** Returns true if the axis aligned bounding box intersects the line segment. */
    aabbIntersectsSegment(x1, y1, x2, y2) {
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY)
        return false;
      let m2 = (y2 - y1) / (x2 - x1);
      let y3 = m2 * (minX - x1) + y1;
      if (y3 > minY && y3 < maxY)
        return true;
      y3 = m2 * (maxX - x1) + y1;
      if (y3 > minY && y3 < maxY)
        return true;
      let x3 = (minY - y1) / m2 + x1;
      if (x3 > minX && x3 < maxX)
        return true;
      x3 = (maxY - y1) / m2 + x1;
      if (x3 > minX && x3 < maxX)
        return true;
      return false;
    }
    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */
    aabbIntersectsSkeleton(bounds) {
      return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
    }
    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */
    containsPoint(x2, y2) {
      let polygons = this.polygons;
      for (let i3 = 0, n2 = polygons.length; i3 < n2; i3++)
        if (this.containsPointPolygon(polygons[i3], x2, y2))
          return this.boundingBoxes[i3];
      return null;
    }
    /** Returns true if the polygon contains the point. */
    containsPointPolygon(polygon, x2, y2) {
      let vertices = polygon;
      let nn = polygon.length;
      let prevIndex = nn - 2;
      let inside = false;
      for (let ii = 0; ii < nn; ii += 2) {
        let vertexY = vertices[ii + 1];
        let prevY = vertices[prevIndex + 1];
        if (vertexY < y2 && prevY >= y2 || prevY < y2 && vertexY >= y2) {
          let vertexX = vertices[ii];
          if (vertexX + (y2 - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x2)
            inside = !inside;
        }
        prevIndex = ii;
      }
      return inside;
    }
    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it
     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns
     * true. */
    intersectsSegment(x1, y1, x2, y2) {
      let polygons = this.polygons;
      for (let i3 = 0, n2 = polygons.length; i3 < n2; i3++)
        if (this.intersectsSegmentPolygon(polygons[i3], x1, y1, x2, y2))
          return this.boundingBoxes[i3];
      return null;
    }
    /** Returns true if the polygon contains any part of the line segment. */
    intersectsSegmentPolygon(polygon, x1, y1, x2, y2) {
      let vertices = polygon;
      let nn = polygon.length;
      let width12 = x1 - x2, height12 = y1 - y2;
      let det1 = x1 * y2 - y1 * x2;
      let x3 = vertices[nn - 2], y3 = vertices[nn - 1];
      for (let ii = 0; ii < nn; ii += 2) {
        let x4 = vertices[ii], y4 = vertices[ii + 1];
        let det2 = x3 * y4 - y3 * x4;
        let width34 = x3 - x4, height34 = y3 - y4;
        let det3 = width12 * height34 - height12 * width34;
        let x5 = (det1 * width34 - width12 * det2) / det3;
        if ((x5 >= x3 && x5 <= x4 || x5 >= x4 && x5 <= x3) && (x5 >= x1 && x5 <= x2 || x5 >= x2 && x5 <= x1)) {
          let y5 = (det1 * height34 - height12 * det2) / det3;
          if ((y5 >= y3 && y5 <= y4 || y5 >= y4 && y5 <= y3) && (y5 >= y1 && y5 <= y2 || y5 >= y2 && y5 <= y1))
            return true;
        }
        x3 = x4;
        y3 = y4;
      }
      return false;
    }
    /** Returns the polygon for the specified bounding box, or null. */
    getPolygon(boundingBox) {
      if (!boundingBox)
        throw new Error("boundingBox cannot be null.");
      let index = this.boundingBoxes.indexOf(boundingBox);
      return index == -1 ? null : this.polygons[index];
    }
    /** The width of the axis aligned bounding box. */
    getWidth() {
      return this.maxX - this.minX;
    }
    /** The height of the axis aligned bounding box. */
    getHeight() {
      return this.maxY - this.minY;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/Triangulator.js
  var Triangulator = class _Triangulator {
    constructor() {
      __publicField(this, "convexPolygons", new Array());
      __publicField(this, "convexPolygonsIndices", new Array());
      __publicField(this, "indicesArray", new Array());
      __publicField(this, "isConcaveArray", new Array());
      __publicField(this, "triangles", new Array());
      __publicField(this, "polygonPool", new Pool2(() => {
        return new Array();
      }));
      __publicField(this, "polygonIndicesPool", new Pool2(() => {
        return new Array();
      }));
    }
    triangulate(verticesArray) {
      let vertices = verticesArray;
      let vertexCount = verticesArray.length >> 1;
      let indices = this.indicesArray;
      indices.length = 0;
      for (let i3 = 0; i3 < vertexCount; i3++)
        indices[i3] = i3;
      let isConcave = this.isConcaveArray;
      isConcave.length = 0;
      for (let i3 = 0, n2 = vertexCount; i3 < n2; ++i3)
        isConcave[i3] = _Triangulator.isConcave(i3, vertexCount, vertices, indices);
      let triangles = this.triangles;
      triangles.length = 0;
      while (vertexCount > 3) {
        let previous = vertexCount - 1, i3 = 0, next = 1;
        while (true) {
          outer: if (!isConcave[i3]) {
            let p1 = indices[previous] << 1, p22 = indices[i3] << 1, p3 = indices[next] << 1;
            let p1x = vertices[p1], p1y = vertices[p1 + 1];
            let p2x = vertices[p22], p2y = vertices[p22 + 1];
            let p3x = vertices[p3], p3y = vertices[p3 + 1];
            for (let ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {
              if (!isConcave[ii])
                continue;
              let v2 = indices[ii] << 1;
              let vx2 = vertices[v2], vy2 = vertices[v2 + 1];
              if (_Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx2, vy2)) {
                if (_Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx2, vy2)) {
                  if (_Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx2, vy2))
                    break outer;
                }
              }
            }
            break;
          }
          if (next == 0) {
            do {
              if (!isConcave[i3])
                break;
              i3--;
            } while (i3 > 0);
            break;
          }
          previous = i3;
          i3 = next;
          next = (next + 1) % vertexCount;
        }
        triangles.push(indices[(vertexCount + i3 - 1) % vertexCount]);
        triangles.push(indices[i3]);
        triangles.push(indices[(i3 + 1) % vertexCount]);
        indices.splice(i3, 1);
        isConcave.splice(i3, 1);
        vertexCount--;
        let previousIndex = (vertexCount + i3 - 1) % vertexCount;
        let nextIndex = i3 == vertexCount ? 0 : i3;
        isConcave[previousIndex] = _Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);
        isConcave[nextIndex] = _Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);
      }
      if (vertexCount == 3) {
        triangles.push(indices[2]);
        triangles.push(indices[0]);
        triangles.push(indices[1]);
      }
      return triangles;
    }
    decompose(verticesArray, triangles) {
      let vertices = verticesArray;
      let convexPolygons = this.convexPolygons;
      this.polygonPool.freeAll(convexPolygons);
      convexPolygons.length = 0;
      let convexPolygonsIndices = this.convexPolygonsIndices;
      this.polygonIndicesPool.freeAll(convexPolygonsIndices);
      convexPolygonsIndices.length = 0;
      let polygonIndices = this.polygonIndicesPool.obtain();
      polygonIndices.length = 0;
      let polygon = this.polygonPool.obtain();
      polygon.length = 0;
      let fanBaseIndex = -1, lastWinding = 0;
      for (let i3 = 0, n2 = triangles.length; i3 < n2; i3 += 3) {
        let t1 = triangles[i3] << 1, t2 = triangles[i3 + 1] << 1, t3 = triangles[i3 + 2] << 1;
        let x1 = vertices[t1], y1 = vertices[t1 + 1];
        let x2 = vertices[t2], y2 = vertices[t2 + 1];
        let x3 = vertices[t3], y3 = vertices[t3 + 1];
        let merged = false;
        if (fanBaseIndex == t1) {
          let o2 = polygon.length - 4;
          let winding1 = _Triangulator.winding(polygon[o2], polygon[o2 + 1], polygon[o2 + 2], polygon[o2 + 3], x3, y3);
          let winding2 = _Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);
          if (winding1 == lastWinding && winding2 == lastWinding) {
            polygon.push(x3);
            polygon.push(y3);
            polygonIndices.push(t3);
            merged = true;
          }
        }
        if (!merged) {
          if (polygon.length > 0) {
            convexPolygons.push(polygon);
            convexPolygonsIndices.push(polygonIndices);
          } else {
            this.polygonPool.free(polygon);
            this.polygonIndicesPool.free(polygonIndices);
          }
          polygon = this.polygonPool.obtain();
          polygon.length = 0;
          polygon.push(x1);
          polygon.push(y1);
          polygon.push(x2);
          polygon.push(y2);
          polygon.push(x3);
          polygon.push(y3);
          polygonIndices = this.polygonIndicesPool.obtain();
          polygonIndices.length = 0;
          polygonIndices.push(t1);
          polygonIndices.push(t2);
          polygonIndices.push(t3);
          lastWinding = _Triangulator.winding(x1, y1, x2, y2, x3, y3);
          fanBaseIndex = t1;
        }
      }
      if (polygon.length > 0) {
        convexPolygons.push(polygon);
        convexPolygonsIndices.push(polygonIndices);
      }
      for (let i3 = 0, n2 = convexPolygons.length; i3 < n2; i3++) {
        polygonIndices = convexPolygonsIndices[i3];
        if (polygonIndices.length == 0)
          continue;
        let firstIndex = polygonIndices[0];
        let lastIndex = polygonIndices[polygonIndices.length - 1];
        polygon = convexPolygons[i3];
        let o2 = polygon.length - 4;
        let prevPrevX = polygon[o2], prevPrevY = polygon[o2 + 1];
        let prevX = polygon[o2 + 2], prevY = polygon[o2 + 3];
        let firstX = polygon[0], firstY = polygon[1];
        let secondX = polygon[2], secondY = polygon[3];
        let winding = _Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);
        for (let ii = 0; ii < n2; ii++) {
          if (ii == i3)
            continue;
          let otherIndices = convexPolygonsIndices[ii];
          if (otherIndices.length != 3)
            continue;
          let otherFirstIndex = otherIndices[0];
          let otherSecondIndex = otherIndices[1];
          let otherLastIndex = otherIndices[2];
          let otherPoly = convexPolygons[ii];
          let x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];
          if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)
            continue;
          let winding1 = _Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);
          let winding2 = _Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);
          if (winding1 == winding && winding2 == winding) {
            otherPoly.length = 0;
            otherIndices.length = 0;
            polygon.push(x3);
            polygon.push(y3);
            polygonIndices.push(otherLastIndex);
            prevPrevX = prevX;
            prevPrevY = prevY;
            prevX = x3;
            prevY = y3;
            ii = 0;
          }
        }
      }
      for (let i3 = convexPolygons.length - 1; i3 >= 0; i3--) {
        polygon = convexPolygons[i3];
        if (polygon.length == 0) {
          convexPolygons.splice(i3, 1);
          this.polygonPool.free(polygon);
          polygonIndices = convexPolygonsIndices[i3];
          convexPolygonsIndices.splice(i3, 1);
          this.polygonIndicesPool.free(polygonIndices);
        }
      }
      return convexPolygons;
    }
    static isConcave(index, vertexCount, vertices, indices) {
      let previous = indices[(vertexCount + index - 1) % vertexCount] << 1;
      let current = indices[index] << 1;
      let next = indices[(index + 1) % vertexCount] << 1;
      return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);
    }
    static positiveArea(p1x, p1y, p2x, p2y, p3x, p3y) {
      return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;
    }
    static winding(p1x, p1y, p2x, p2y, p3x, p3y) {
      let px = p2x - p1x, py = p2y - p1y;
      return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/SkeletonClipping.js
  var SkeletonClipping = class _SkeletonClipping {
    constructor() {
      __publicField(this, "triangulator", new Triangulator());
      __publicField(this, "clippingPolygon", new Array());
      __publicField(this, "clipOutput", new Array());
      __publicField(this, "clippedVertices", new Array());
      __publicField(this, "clippedUVs", new Array());
      __publicField(this, "clippedTriangles", new Array());
      __publicField(this, "scratch", new Array());
      __publicField(this, "clipAttachment", null);
      __publicField(this, "clippingPolygons", null);
    }
    clipStart(slot, clip) {
      if (this.clipAttachment)
        return 0;
      this.clipAttachment = clip;
      let n2 = clip.worldVerticesLength;
      let vertices = Utils.setArraySize(this.clippingPolygon, n2);
      clip.computeWorldVertices(slot, 0, n2, vertices, 0, 2);
      let clippingPolygon = this.clippingPolygon;
      _SkeletonClipping.makeClockwise(clippingPolygon);
      let clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));
      for (let i3 = 0, n3 = clippingPolygons.length; i3 < n3; i3++) {
        let polygon = clippingPolygons[i3];
        _SkeletonClipping.makeClockwise(polygon);
        polygon.push(polygon[0]);
        polygon.push(polygon[1]);
      }
      return clippingPolygons.length;
    }
    clipEndWithSlot(slot) {
      if (this.clipAttachment && this.clipAttachment.endSlot == slot.data)
        this.clipEnd();
    }
    clipEnd() {
      if (!this.clipAttachment)
        return;
      this.clipAttachment = null;
      this.clippingPolygons = null;
      this.clippedVertices.length = 0;
      this.clippedTriangles.length = 0;
      this.clippingPolygon.length = 0;
    }
    isClipping() {
      return this.clipAttachment != null;
    }
    clipTriangles(vertices, verticesLengthOrTriangles, trianglesOrTrianglesLength, trianglesLengthOrUvs, uvsOrLight, lightOrDark, darkOrTwoColor, twoColorParam) {
      let triangles;
      let trianglesLength;
      let uvs;
      let light;
      let dark;
      let twoColor;
      if (typeof verticesLengthOrTriangles === "number") {
        triangles = trianglesOrTrianglesLength;
        trianglesLength = trianglesLengthOrUvs;
        uvs = uvsOrLight;
        light = lightOrDark;
        dark = darkOrTwoColor;
        twoColor = twoColorParam;
      } else {
        triangles = verticesLengthOrTriangles;
        trianglesLength = trianglesOrTrianglesLength;
        uvs = trianglesLengthOrUvs;
        light = uvsOrLight;
        dark = lightOrDark;
        twoColor = darkOrTwoColor;
      }
      if (uvs && light && dark && typeof twoColor === "boolean")
        this.clipTrianglesRender(vertices, triangles, trianglesLength, uvs, light, dark, twoColor);
      else
        this.clipTrianglesNoRender(vertices, triangles, trianglesLength);
    }
    clipTrianglesNoRender(vertices, triangles, trianglesLength) {
      let clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;
      let clippedTriangles = this.clippedTriangles;
      let polygons = this.clippingPolygons;
      let polygonsCount = polygons.length;
      let index = 0;
      clippedVertices.length = 0;
      clippedTriangles.length = 0;
      for (let i3 = 0; i3 < trianglesLength; i3 += 3) {
        let vertexOffset = triangles[i3] << 1;
        let x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];
        vertexOffset = triangles[i3 + 1] << 1;
        let x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];
        vertexOffset = triangles[i3 + 2] << 1;
        let x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];
        for (let p3 = 0; p3 < polygonsCount; p3++) {
          let s2 = clippedVertices.length;
          if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p3], clipOutput)) {
            let clipOutputLength = clipOutput.length;
            if (clipOutputLength == 0)
              continue;
            let clipOutputCount = clipOutputLength >> 1;
            let clipOutputItems = this.clipOutput;
            let clippedVerticesItems = Utils.setArraySize(clippedVertices, s2 + clipOutputCount * 2);
            for (let ii = 0; ii < clipOutputLength; ii += 2, s2 += 2) {
              let x4 = clipOutputItems[ii], y4 = clipOutputItems[ii + 1];
              clippedVerticesItems[s2] = x4;
              clippedVerticesItems[s2 + 1] = y4;
            }
            s2 = clippedTriangles.length;
            let clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s2 + 3 * (clipOutputCount - 2));
            clipOutputCount--;
            for (let ii = 1; ii < clipOutputCount; ii++, s2 += 3) {
              clippedTrianglesItems[s2] = index;
              clippedTrianglesItems[s2 + 1] = index + ii;
              clippedTrianglesItems[s2 + 2] = index + ii + 1;
            }
            index += clipOutputCount + 1;
          } else {
            let clippedVerticesItems = Utils.setArraySize(clippedVertices, s2 + 3 * 2);
            clippedVerticesItems[s2] = x1;
            clippedVerticesItems[s2 + 1] = y1;
            clippedVerticesItems[s2 + 2] = x2;
            clippedVerticesItems[s2 + 3] = y2;
            clippedVerticesItems[s2 + 4] = x3;
            clippedVerticesItems[s2 + 5] = y3;
            s2 = clippedTriangles.length;
            let clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s2 + 3);
            clippedTrianglesItems[s2] = index;
            clippedTrianglesItems[s2 + 1] = index + 1;
            clippedTrianglesItems[s2 + 2] = index + 2;
            index += 3;
            break;
          }
        }
      }
    }
    clipTrianglesRender(vertices, triangles, trianglesLength, uvs, light, dark, twoColor) {
      let clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;
      let clippedTriangles = this.clippedTriangles;
      let polygons = this.clippingPolygons;
      let polygonsCount = polygons.length;
      let vertexSize = twoColor ? 12 : 8;
      let index = 0;
      clippedVertices.length = 0;
      clippedTriangles.length = 0;
      for (let i3 = 0; i3 < trianglesLength; i3 += 3) {
        let vertexOffset = triangles[i3] << 1;
        let x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];
        let u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];
        vertexOffset = triangles[i3 + 1] << 1;
        let x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];
        let u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];
        vertexOffset = triangles[i3 + 2] << 1;
        let x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];
        let u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];
        for (let p3 = 0; p3 < polygonsCount; p3++) {
          let s2 = clippedVertices.length;
          if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p3], clipOutput)) {
            let clipOutputLength = clipOutput.length;
            if (clipOutputLength == 0)
              continue;
            let d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;
            let d3 = 1 / (d0 * d2 + d1 * (y1 - y3));
            let clipOutputCount = clipOutputLength >> 1;
            let clipOutputItems = this.clipOutput;
            let clippedVerticesItems = Utils.setArraySize(clippedVertices, s2 + clipOutputCount * vertexSize);
            for (let ii = 0; ii < clipOutputLength; ii += 2, s2 += vertexSize) {
              let x4 = clipOutputItems[ii], y4 = clipOutputItems[ii + 1];
              clippedVerticesItems[s2] = x4;
              clippedVerticesItems[s2 + 1] = y4;
              clippedVerticesItems[s2 + 2] = light.r;
              clippedVerticesItems[s2 + 3] = light.g;
              clippedVerticesItems[s2 + 4] = light.b;
              clippedVerticesItems[s2 + 5] = light.a;
              let c0 = x4 - x3, c1 = y4 - y3;
              let a2 = (d0 * c0 + d1 * c1) * d3;
              let b2 = (d4 * c0 + d2 * c1) * d3;
              let c2 = 1 - a2 - b2;
              clippedVerticesItems[s2 + 6] = u1 * a2 + u2 * b2 + u3 * c2;
              clippedVerticesItems[s2 + 7] = v1 * a2 + v2 * b2 + v3 * c2;
              if (twoColor) {
                clippedVerticesItems[s2 + 8] = dark.r;
                clippedVerticesItems[s2 + 9] = dark.g;
                clippedVerticesItems[s2 + 10] = dark.b;
                clippedVerticesItems[s2 + 11] = dark.a;
              }
            }
            s2 = clippedTriangles.length;
            let clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s2 + 3 * (clipOutputCount - 2));
            clipOutputCount--;
            for (let ii = 1; ii < clipOutputCount; ii++, s2 += 3) {
              clippedTrianglesItems[s2] = index;
              clippedTrianglesItems[s2 + 1] = index + ii;
              clippedTrianglesItems[s2 + 2] = index + ii + 1;
            }
            index += clipOutputCount + 1;
          } else {
            let clippedVerticesItems = Utils.setArraySize(clippedVertices, s2 + 3 * vertexSize);
            clippedVerticesItems[s2] = x1;
            clippedVerticesItems[s2 + 1] = y1;
            clippedVerticesItems[s2 + 2] = light.r;
            clippedVerticesItems[s2 + 3] = light.g;
            clippedVerticesItems[s2 + 4] = light.b;
            clippedVerticesItems[s2 + 5] = light.a;
            if (!twoColor) {
              clippedVerticesItems[s2 + 6] = u1;
              clippedVerticesItems[s2 + 7] = v1;
              clippedVerticesItems[s2 + 8] = x2;
              clippedVerticesItems[s2 + 9] = y2;
              clippedVerticesItems[s2 + 10] = light.r;
              clippedVerticesItems[s2 + 11] = light.g;
              clippedVerticesItems[s2 + 12] = light.b;
              clippedVerticesItems[s2 + 13] = light.a;
              clippedVerticesItems[s2 + 14] = u2;
              clippedVerticesItems[s2 + 15] = v2;
              clippedVerticesItems[s2 + 16] = x3;
              clippedVerticesItems[s2 + 17] = y3;
              clippedVerticesItems[s2 + 18] = light.r;
              clippedVerticesItems[s2 + 19] = light.g;
              clippedVerticesItems[s2 + 20] = light.b;
              clippedVerticesItems[s2 + 21] = light.a;
              clippedVerticesItems[s2 + 22] = u3;
              clippedVerticesItems[s2 + 23] = v3;
            } else {
              clippedVerticesItems[s2 + 6] = u1;
              clippedVerticesItems[s2 + 7] = v1;
              clippedVerticesItems[s2 + 8] = dark.r;
              clippedVerticesItems[s2 + 9] = dark.g;
              clippedVerticesItems[s2 + 10] = dark.b;
              clippedVerticesItems[s2 + 11] = dark.a;
              clippedVerticesItems[s2 + 12] = x2;
              clippedVerticesItems[s2 + 13] = y2;
              clippedVerticesItems[s2 + 14] = light.r;
              clippedVerticesItems[s2 + 15] = light.g;
              clippedVerticesItems[s2 + 16] = light.b;
              clippedVerticesItems[s2 + 17] = light.a;
              clippedVerticesItems[s2 + 18] = u2;
              clippedVerticesItems[s2 + 19] = v2;
              clippedVerticesItems[s2 + 20] = dark.r;
              clippedVerticesItems[s2 + 21] = dark.g;
              clippedVerticesItems[s2 + 22] = dark.b;
              clippedVerticesItems[s2 + 23] = dark.a;
              clippedVerticesItems[s2 + 24] = x3;
              clippedVerticesItems[s2 + 25] = y3;
              clippedVerticesItems[s2 + 26] = light.r;
              clippedVerticesItems[s2 + 27] = light.g;
              clippedVerticesItems[s2 + 28] = light.b;
              clippedVerticesItems[s2 + 29] = light.a;
              clippedVerticesItems[s2 + 30] = u3;
              clippedVerticesItems[s2 + 31] = v3;
              clippedVerticesItems[s2 + 32] = dark.r;
              clippedVerticesItems[s2 + 33] = dark.g;
              clippedVerticesItems[s2 + 34] = dark.b;
              clippedVerticesItems[s2 + 35] = dark.a;
            }
            s2 = clippedTriangles.length;
            let clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s2 + 3);
            clippedTrianglesItems[s2] = index;
            clippedTrianglesItems[s2 + 1] = index + 1;
            clippedTrianglesItems[s2 + 2] = index + 2;
            index += 3;
            break;
          }
        }
      }
    }
    clipTrianglesUnpacked(vertices, triangles, trianglesLength, uvs) {
      let clipOutput = this.clipOutput, clippedVertices = this.clippedVertices, clippedUVs = this.clippedUVs;
      let clippedTriangles = this.clippedTriangles;
      let polygons = this.clippingPolygons;
      let polygonsCount = polygons.length;
      let index = 0;
      clippedVertices.length = 0;
      clippedUVs.length = 0;
      clippedTriangles.length = 0;
      for (let i3 = 0; i3 < trianglesLength; i3 += 3) {
        let vertexOffset = triangles[i3] << 1;
        let x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];
        let u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];
        vertexOffset = triangles[i3 + 1] << 1;
        let x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];
        let u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];
        vertexOffset = triangles[i3 + 2] << 1;
        let x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];
        let u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];
        for (let p3 = 0; p3 < polygonsCount; p3++) {
          let s2 = clippedVertices.length;
          if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p3], clipOutput)) {
            let clipOutputLength = clipOutput.length;
            if (clipOutputLength == 0)
              continue;
            let d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;
            let d3 = 1 / (d0 * d2 + d1 * (y1 - y3));
            let clipOutputCount = clipOutputLength >> 1;
            let clipOutputItems = this.clipOutput;
            let clippedVerticesItems = Utils.setArraySize(clippedVertices, s2 + clipOutputCount * 2);
            let clippedUVsItems = Utils.setArraySize(clippedUVs, s2 + clipOutputCount * 2);
            for (let ii = 0; ii < clipOutputLength; ii += 2, s2 += 2) {
              let x4 = clipOutputItems[ii], y4 = clipOutputItems[ii + 1];
              clippedVerticesItems[s2] = x4;
              clippedVerticesItems[s2 + 1] = y4;
              let c0 = x4 - x3, c1 = y4 - y3;
              let a2 = (d0 * c0 + d1 * c1) * d3;
              let b2 = (d4 * c0 + d2 * c1) * d3;
              let c2 = 1 - a2 - b2;
              clippedUVsItems[s2] = u1 * a2 + u2 * b2 + u3 * c2;
              clippedUVsItems[s2 + 1] = v1 * a2 + v2 * b2 + v3 * c2;
            }
            s2 = clippedTriangles.length;
            let clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s2 + 3 * (clipOutputCount - 2));
            clipOutputCount--;
            for (let ii = 1; ii < clipOutputCount; ii++, s2 += 3) {
              clippedTrianglesItems[s2] = index;
              clippedTrianglesItems[s2 + 1] = index + ii;
              clippedTrianglesItems[s2 + 2] = index + ii + 1;
            }
            index += clipOutputCount + 1;
          } else {
            let clippedVerticesItems = Utils.setArraySize(clippedVertices, s2 + 3 * 2);
            clippedVerticesItems[s2] = x1;
            clippedVerticesItems[s2 + 1] = y1;
            clippedVerticesItems[s2 + 2] = x2;
            clippedVerticesItems[s2 + 3] = y2;
            clippedVerticesItems[s2 + 4] = x3;
            clippedVerticesItems[s2 + 5] = y3;
            let clippedUVSItems = Utils.setArraySize(clippedUVs, s2 + 3 * 2);
            clippedUVSItems[s2] = u1;
            clippedUVSItems[s2 + 1] = v1;
            clippedUVSItems[s2 + 2] = u2;
            clippedUVSItems[s2 + 3] = v2;
            clippedUVSItems[s2 + 4] = u3;
            clippedUVSItems[s2 + 5] = v3;
            s2 = clippedTriangles.length;
            let clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s2 + 3);
            clippedTrianglesItems[s2] = index;
            clippedTrianglesItems[s2 + 1] = index + 1;
            clippedTrianglesItems[s2 + 2] = index + 2;
            index += 3;
            break;
          }
        }
      }
    }
    /** Clips the input triangle against the convex, clockwise clipping area. If the triangle lies entirely within the clipping
     * area, false is returned. The clipping area must duplicate the first vertex at the end of the vertices list. */
    clip(x1, y1, x2, y2, x3, y3, clippingArea, output) {
      let originalOutput = output;
      let clipped = false;
      let input;
      if (clippingArea.length % 4 >= 2) {
        input = output;
        output = this.scratch;
      } else
        input = this.scratch;
      input.length = 0;
      input.push(x1);
      input.push(y1);
      input.push(x2);
      input.push(y2);
      input.push(x3);
      input.push(y3);
      input.push(x1);
      input.push(y1);
      output.length = 0;
      let clippingVerticesLast = clippingArea.length - 4;
      let clippingVertices = clippingArea;
      for (let i3 = 0; ; i3 += 2) {
        let edgeX = clippingVertices[i3], edgeY = clippingVertices[i3 + 1];
        let ex = edgeX - clippingVertices[i3 + 2], ey = edgeY - clippingVertices[i3 + 3];
        let outputStart = output.length;
        let inputVertices = input;
        for (let ii = 0, nn = input.length - 2; ii < nn; ) {
          let inputX = inputVertices[ii], inputY = inputVertices[ii + 1];
          ii += 2;
          let inputX2 = inputVertices[ii], inputY2 = inputVertices[ii + 1];
          let s2 = ey * (edgeX - inputX2) > ex * (edgeY - inputY2);
          let s1 = ey * (edgeX - inputX) - ex * (edgeY - inputY);
          if (s1 > 0) {
            if (s2) {
              output.push(inputX2);
              output.push(inputY2);
              continue;
            }
            let ix = inputX2 - inputX, iy = inputY2 - inputY, t2 = s1 / (ix * ey - iy * ex);
            if (t2 >= 0 && t2 <= 1) {
              output.push(inputX + ix * t2);
              output.push(inputY + iy * t2);
            } else {
              output.push(inputX2);
              output.push(inputY2);
              continue;
            }
          } else if (s2) {
            let ix = inputX2 - inputX, iy = inputY2 - inputY, t2 = s1 / (ix * ey - iy * ex);
            if (t2 >= 0 && t2 <= 1) {
              output.push(inputX + ix * t2);
              output.push(inputY + iy * t2);
              output.push(inputX2);
              output.push(inputY2);
            } else {
              output.push(inputX2);
              output.push(inputY2);
              continue;
            }
          }
          clipped = true;
        }
        if (outputStart == output.length) {
          originalOutput.length = 0;
          return true;
        }
        output.push(output[0]);
        output.push(output[1]);
        if (i3 == clippingVerticesLast)
          break;
        let temp = output;
        output = input;
        output.length = 0;
        input = temp;
      }
      if (originalOutput != output) {
        originalOutput.length = 0;
        for (let i3 = 0, n2 = output.length - 2; i3 < n2; i3++)
          originalOutput[i3] = output[i3];
      } else
        originalOutput.length = originalOutput.length - 2;
      return clipped;
    }
    static makeClockwise(polygon) {
      let vertices = polygon;
      let verticeslength = polygon.length;
      let area2 = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;
      for (let i3 = 0, n2 = verticeslength - 3; i3 < n2; i3 += 2) {
        p1x = vertices[i3];
        p1y = vertices[i3 + 1];
        p2x = vertices[i3 + 2];
        p2y = vertices[i3 + 3];
        area2 += p1x * p2y - p2x * p1y;
      }
      if (area2 < 0)
        return;
      for (let i3 = 0, lastX = verticeslength - 2, n2 = verticeslength >> 1; i3 < n2; i3 += 2) {
        let x2 = vertices[i3], y2 = vertices[i3 + 1];
        let other = lastX - i3;
        vertices[i3] = vertices[other];
        vertices[i3 + 1] = vertices[other + 1];
        vertices[other] = x2;
        vertices[other + 1] = y2;
      }
    }
  };

  // node_modules/@esotericsoftware/spine-core/dist/SkeletonJson.js
  var SkeletonJson = class {
    constructor(attachmentLoader) {
      __publicField(this, "attachmentLoader");
      /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at
       * runtime than were used in Spine.
       *
       * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */
      __publicField(this, "scale", 1);
      __publicField(this, "linkedMeshes", new Array());
      this.attachmentLoader = attachmentLoader;
    }
    readSkeletonData(json) {
      var _a2, _b;
      let scale = this.scale;
      let skeletonData = new SkeletonData();
      let root = typeof json === "string" ? JSON.parse(json) : json;
      let skeletonMap = root.skeleton;
      if (skeletonMap) {
        skeletonData.hash = skeletonMap.hash;
        skeletonData.version = skeletonMap.spine;
        skeletonData.x = skeletonMap.x;
        skeletonData.y = skeletonMap.y;
        skeletonData.width = skeletonMap.width;
        skeletonData.height = skeletonMap.height;
        skeletonData.referenceScale = getValue(skeletonMap, "referenceScale", 100) * scale;
        skeletonData.fps = skeletonMap.fps;
        skeletonData.imagesPath = (_a2 = skeletonMap.images) != null ? _a2 : null;
        skeletonData.audioPath = (_b = skeletonMap.audio) != null ? _b : null;
      }
      if (root.bones) {
        for (let i3 = 0; i3 < root.bones.length; i3++) {
          let boneMap = root.bones[i3];
          let parent = null;
          let parentName = getValue(boneMap, "parent", null);
          if (parentName)
            parent = skeletonData.findBone(parentName);
          let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);
          data.length = getValue(boneMap, "length", 0) * scale;
          data.x = getValue(boneMap, "x", 0) * scale;
          data.y = getValue(boneMap, "y", 0) * scale;
          data.rotation = getValue(boneMap, "rotation", 0);
          data.scaleX = getValue(boneMap, "scaleX", 1);
          data.scaleY = getValue(boneMap, "scaleY", 1);
          data.shearX = getValue(boneMap, "shearX", 0);
          data.shearY = getValue(boneMap, "shearY", 0);
          data.inherit = Utils.enumValue(Inherit, getValue(boneMap, "inherit", "Normal"));
          data.skinRequired = getValue(boneMap, "skin", false);
          let color = getValue(boneMap, "color", null);
          if (color)
            data.color.setFromString(color);
          skeletonData.bones.push(data);
        }
      }
      if (root.slots) {
        for (let i3 = 0; i3 < root.slots.length; i3++) {
          let slotMap = root.slots[i3];
          let slotName = slotMap.name;
          let boneData = skeletonData.findBone(slotMap.bone);
          if (!boneData)
            throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotName}`);
          let data = new SlotData(skeletonData.slots.length, slotName, boneData);
          let color = getValue(slotMap, "color", null);
          if (color)
            data.color.setFromString(color);
          let dark = getValue(slotMap, "dark", null);
          if (dark)
            data.darkColor = Color2.fromString(dark);
          data.attachmentName = getValue(slotMap, "attachment", null);
          data.blendMode = Utils.enumValue(BlendMode, getValue(slotMap, "blend", "normal"));
          data.visible = getValue(slotMap, "visible", true);
          skeletonData.slots.push(data);
        }
      }
      if (root.ik) {
        for (let i3 = 0; i3 < root.ik.length; i3++) {
          let constraintMap = root.ik[i3];
          let data = new IkConstraintData(constraintMap.name);
          data.order = getValue(constraintMap, "order", 0);
          data.skinRequired = getValue(constraintMap, "skin", false);
          for (let ii = 0; ii < constraintMap.bones.length; ii++) {
            let bone = skeletonData.findBone(constraintMap.bones[ii]);
            if (!bone)
              throw new Error(`Couldn't find bone ${constraintMap.bones[ii]} for IK constraint ${constraintMap.name}.`);
            data.bones.push(bone);
          }
          let target = skeletonData.findBone(constraintMap.target);
          ;
          if (!target)
            throw new Error(`Couldn't find target bone ${constraintMap.target} for IK constraint ${constraintMap.name}.`);
          data.target = target;
          data.mix = getValue(constraintMap, "mix", 1);
          data.softness = getValue(constraintMap, "softness", 0) * scale;
          data.bendDirection = getValue(constraintMap, "bendPositive", true) ? 1 : -1;
          data.compress = getValue(constraintMap, "compress", false);
          data.stretch = getValue(constraintMap, "stretch", false);
          data.uniform = getValue(constraintMap, "uniform", false);
          skeletonData.ikConstraints.push(data);
        }
      }
      if (root.transform) {
        for (let i3 = 0; i3 < root.transform.length; i3++) {
          let constraintMap = root.transform[i3];
          let data = new TransformConstraintData(constraintMap.name);
          data.order = getValue(constraintMap, "order", 0);
          data.skinRequired = getValue(constraintMap, "skin", false);
          for (let ii = 0; ii < constraintMap.bones.length; ii++) {
            let boneName = constraintMap.bones[ii];
            let bone = skeletonData.findBone(boneName);
            if (!bone)
              throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);
            data.bones.push(bone);
          }
          let targetName = constraintMap.target;
          let target = skeletonData.findBone(targetName);
          if (!target)
            throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);
          data.target = target;
          data.local = getValue(constraintMap, "local", false);
          data.relative = getValue(constraintMap, "relative", false);
          data.offsetRotation = getValue(constraintMap, "rotation", 0);
          data.offsetX = getValue(constraintMap, "x", 0) * scale;
          data.offsetY = getValue(constraintMap, "y", 0) * scale;
          data.offsetScaleX = getValue(constraintMap, "scaleX", 0);
          data.offsetScaleY = getValue(constraintMap, "scaleY", 0);
          data.offsetShearY = getValue(constraintMap, "shearY", 0);
          data.mixRotate = getValue(constraintMap, "mixRotate", 1);
          data.mixX = getValue(constraintMap, "mixX", 1);
          data.mixY = getValue(constraintMap, "mixY", data.mixX);
          data.mixScaleX = getValue(constraintMap, "mixScaleX", 1);
          data.mixScaleY = getValue(constraintMap, "mixScaleY", data.mixScaleX);
          data.mixShearY = getValue(constraintMap, "mixShearY", 1);
          skeletonData.transformConstraints.push(data);
        }
      }
      if (root.path) {
        for (let i3 = 0; i3 < root.path.length; i3++) {
          let constraintMap = root.path[i3];
          let data = new PathConstraintData(constraintMap.name);
          data.order = getValue(constraintMap, "order", 0);
          data.skinRequired = getValue(constraintMap, "skin", false);
          for (let ii = 0; ii < constraintMap.bones.length; ii++) {
            let boneName = constraintMap.bones[ii];
            let bone = skeletonData.findBone(boneName);
            if (!bone)
              throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);
            data.bones.push(bone);
          }
          let targetName = constraintMap.target;
          let target = skeletonData.findSlot(targetName);
          if (!target)
            throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);
          data.target = target;
          data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, "positionMode", "Percent"));
          data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, "spacingMode", "Length"));
          data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, "rotateMode", "Tangent"));
          data.offsetRotation = getValue(constraintMap, "rotation", 0);
          data.position = getValue(constraintMap, "position", 0);
          if (data.positionMode == PositionMode.Fixed)
            data.position *= scale;
          data.spacing = getValue(constraintMap, "spacing", 0);
          if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
            data.spacing *= scale;
          data.mixRotate = getValue(constraintMap, "mixRotate", 1);
          data.mixX = getValue(constraintMap, "mixX", 1);
          data.mixY = getValue(constraintMap, "mixY", data.mixX);
          skeletonData.pathConstraints.push(data);
        }
      }
      if (root.physics) {
        for (let i3 = 0; i3 < root.physics.length; i3++) {
          const constraintMap = root.physics[i3];
          const data = new PhysicsConstraintData(constraintMap.name);
          data.order = getValue(constraintMap, "order", 0);
          data.skinRequired = getValue(constraintMap, "skin", false);
          const boneName = constraintMap.bone;
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error("Physics bone not found: " + boneName);
          data.bone = bone;
          data.x = getValue(constraintMap, "x", 0);
          data.y = getValue(constraintMap, "y", 0);
          data.rotate = getValue(constraintMap, "rotate", 0);
          data.scaleX = getValue(constraintMap, "scaleX", 0);
          data.shearX = getValue(constraintMap, "shearX", 0);
          data.limit = getValue(constraintMap, "limit", 5e3) * scale;
          data.step = 1 / getValue(constraintMap, "fps", 60);
          data.inertia = getValue(constraintMap, "inertia", 1);
          data.strength = getValue(constraintMap, "strength", 100);
          data.damping = getValue(constraintMap, "damping", 1);
          data.massInverse = 1 / getValue(constraintMap, "mass", 1);
          data.wind = getValue(constraintMap, "wind", 0);
          data.gravity = getValue(constraintMap, "gravity", 0);
          data.mix = getValue(constraintMap, "mix", 1);
          data.inertiaGlobal = getValue(constraintMap, "inertiaGlobal", false);
          data.strengthGlobal = getValue(constraintMap, "strengthGlobal", false);
          data.dampingGlobal = getValue(constraintMap, "dampingGlobal", false);
          data.massGlobal = getValue(constraintMap, "massGlobal", false);
          data.windGlobal = getValue(constraintMap, "windGlobal", false);
          data.gravityGlobal = getValue(constraintMap, "gravityGlobal", false);
          data.mixGlobal = getValue(constraintMap, "mixGlobal", false);
          skeletonData.physicsConstraints.push(data);
        }
      }
      if (root.skins) {
        for (let i3 = 0; i3 < root.skins.length; i3++) {
          let skinMap = root.skins[i3];
          let skin = new Skin(skinMap.name);
          if (skinMap.bones) {
            for (let ii = 0; ii < skinMap.bones.length; ii++) {
              let boneName = skinMap.bones[ii];
              let bone = skeletonData.findBone(boneName);
              if (!bone)
                throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);
              skin.bones.push(bone);
            }
          }
          if (skinMap.ik) {
            for (let ii = 0; ii < skinMap.ik.length; ii++) {
              let constraintName = skinMap.ik[ii];
              let constraint = skeletonData.findIkConstraint(constraintName);
              if (!constraint)
                throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.transform) {
            for (let ii = 0; ii < skinMap.transform.length; ii++) {
              let constraintName = skinMap.transform[ii];
              let constraint = skeletonData.findTransformConstraint(constraintName);
              if (!constraint)
                throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.path) {
            for (let ii = 0; ii < skinMap.path.length; ii++) {
              let constraintName = skinMap.path[ii];
              let constraint = skeletonData.findPathConstraint(constraintName);
              if (!constraint)
                throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.physics) {
            for (let ii = 0; ii < skinMap.physics.length; ii++) {
              let constraintName = skinMap.physics[ii];
              let constraint = skeletonData.findPhysicsConstraint(constraintName);
              if (!constraint)
                throw new Error(`Couldn't find physics constraint ${constraintName} for skin ${skinMap.name}.`);
              skin.constraints.push(constraint);
            }
          }
          for (let slotName in skinMap.attachments) {
            let slot = skeletonData.findSlot(slotName);
            if (!slot)
              throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);
            let slotMap = skinMap.attachments[slotName];
            for (let entryName in slotMap) {
              let attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
              if (attachment)
                skin.setAttachment(slot.index, entryName, attachment);
            }
          }
          skeletonData.skins.push(skin);
          if (skin.name == "default")
            skeletonData.defaultSkin = skin;
        }
      }
      for (let i3 = 0, n2 = this.linkedMeshes.length; i3 < n2; i3++) {
        let linkedMesh = this.linkedMeshes[i3];
        let skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (!skin)
          throw new Error(`Skin not found: ${linkedMesh.skin}`);
        let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (!parent)
          throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
        linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;
        linkedMesh.mesh.setParentMesh(parent);
        if (linkedMesh.mesh.region != null)
          linkedMesh.mesh.updateRegion();
      }
      this.linkedMeshes.length = 0;
      if (root.events) {
        for (let eventName in root.events) {
          let eventMap = root.events[eventName];
          let data = new EventData(eventName);
          data.intValue = getValue(eventMap, "int", 0);
          data.floatValue = getValue(eventMap, "float", 0);
          data.stringValue = getValue(eventMap, "string", "");
          data.audioPath = getValue(eventMap, "audio", null);
          if (data.audioPath) {
            data.volume = getValue(eventMap, "volume", 1);
            data.balance = getValue(eventMap, "balance", 0);
          }
          skeletonData.events.push(data);
        }
      }
      if (root.animations) {
        for (let animationName in root.animations) {
          let animationMap = root.animations[animationName];
          this.readAnimation(animationMap, animationName, skeletonData);
        }
      }
      return skeletonData;
    }
    readAttachment(map, skin, slotIndex, name, skeletonData) {
      let scale = this.scale;
      name = getValue(map, "name", name);
      switch (getValue(map, "type", "region")) {
        case "region": {
          let path2 = getValue(map, "path", name);
          let sequence = this.readSequence(getValue(map, "sequence", null));
          let region = this.attachmentLoader.newRegionAttachment(skin, name, path2, sequence);
          if (!region)
            return null;
          region.path = path2;
          region.x = getValue(map, "x", 0) * scale;
          region.y = getValue(map, "y", 0) * scale;
          region.scaleX = getValue(map, "scaleX", 1);
          region.scaleY = getValue(map, "scaleY", 1);
          region.rotation = getValue(map, "rotation", 0);
          region.width = map.width * scale;
          region.height = map.height * scale;
          region.sequence = sequence;
          let color = getValue(map, "color", null);
          if (color)
            region.color.setFromString(color);
          if (region.region != null)
            region.updateRegion();
          return region;
        }
        case "boundingbox": {
          let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (!box)
            return null;
          this.readVertices(map, box, map.vertexCount << 1);
          let color = getValue(map, "color", null);
          if (color)
            box.color.setFromString(color);
          return box;
        }
        case "mesh":
        case "linkedmesh": {
          let path2 = getValue(map, "path", name);
          let sequence = this.readSequence(getValue(map, "sequence", null));
          let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path2, sequence);
          if (!mesh)
            return null;
          mesh.path = path2;
          let color = getValue(map, "color", null);
          if (color)
            mesh.color.setFromString(color);
          mesh.width = getValue(map, "width", 0) * scale;
          mesh.height = getValue(map, "height", 0) * scale;
          mesh.sequence = sequence;
          let parent = getValue(map, "parent", null);
          if (parent) {
            this.linkedMeshes.push(new LinkedMesh2(mesh, getValue(map, "skin", null), slotIndex, parent, getValue(map, "timelines", true)));
            return mesh;
          }
          let uvs = map.uvs;
          this.readVertices(map, mesh, uvs.length);
          mesh.triangles = map.triangles;
          mesh.regionUVs = uvs;
          if (mesh.region != null)
            mesh.updateRegion();
          mesh.edges = getValue(map, "edges", null);
          mesh.hullLength = getValue(map, "hull", 0) * 2;
          return mesh;
        }
        case "path": {
          let path2 = this.attachmentLoader.newPathAttachment(skin, name);
          if (!path2)
            return null;
          path2.closed = getValue(map, "closed", false);
          path2.constantSpeed = getValue(map, "constantSpeed", true);
          let vertexCount = map.vertexCount;
          this.readVertices(map, path2, vertexCount << 1);
          let lengths = Utils.newArray(vertexCount / 3, 0);
          for (let i3 = 0; i3 < map.lengths.length; i3++)
            lengths[i3] = map.lengths[i3] * scale;
          path2.lengths = lengths;
          let color = getValue(map, "color", null);
          if (color)
            path2.color.setFromString(color);
          return path2;
        }
        case "point": {
          let point = this.attachmentLoader.newPointAttachment(skin, name);
          if (!point)
            return null;
          point.x = getValue(map, "x", 0) * scale;
          point.y = getValue(map, "y", 0) * scale;
          point.rotation = getValue(map, "rotation", 0);
          let color = getValue(map, "color", null);
          if (color)
            point.color.setFromString(color);
          return point;
        }
        case "clipping": {
          let clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (!clip)
            return null;
          let end = getValue(map, "end", null);
          if (end)
            clip.endSlot = skeletonData.findSlot(end);
          let vertexCount = map.vertexCount;
          this.readVertices(map, clip, vertexCount << 1);
          let color = getValue(map, "color", null);
          if (color)
            clip.color.setFromString(color);
          return clip;
        }
      }
      return null;
    }
    readSequence(map) {
      if (map == null)
        return null;
      let sequence = new Sequence(getValue(map, "count", 0));
      sequence.start = getValue(map, "start", 1);
      sequence.digits = getValue(map, "digits", 0);
      sequence.setupIndex = getValue(map, "setup", 0);
      return sequence;
    }
    readVertices(map, attachment, verticesLength) {
      let scale = this.scale;
      attachment.worldVerticesLength = verticesLength;
      let vertices = map.vertices;
      if (verticesLength == vertices.length) {
        let scaledVertices = Utils.toFloatArray(vertices);
        if (scale != 1) {
          for (let i3 = 0, n2 = vertices.length; i3 < n2; i3++)
            scaledVertices[i3] *= scale;
        }
        attachment.vertices = scaledVertices;
        return;
      }
      let weights = new Array();
      let bones = new Array();
      for (let i3 = 0, n2 = vertices.length; i3 < n2; ) {
        let boneCount = vertices[i3++];
        bones.push(boneCount);
        for (let nn = i3 + boneCount * 4; i3 < nn; i3 += 4) {
          bones.push(vertices[i3]);
          weights.push(vertices[i3 + 1] * scale);
          weights.push(vertices[i3 + 2] * scale);
          weights.push(vertices[i3 + 3]);
        }
      }
      attachment.bones = bones;
      attachment.vertices = Utils.toFloatArray(weights);
    }
    readAnimation(map, name, skeletonData) {
      let scale = this.scale;
      let timelines = new Array();
      if (map.slots) {
        for (let slotName in map.slots) {
          let slotMap = map.slots[slotName];
          let slot = skeletonData.findSlot(slotName);
          if (!slot)
            throw new Error("Slot not found: " + slotName);
          let slotIndex = slot.index;
          for (let timelineName in slotMap) {
            let timelineMap = slotMap[timelineName];
            if (!timelineMap)
              continue;
            let frames = timelineMap.length;
            if (timelineName == "attachment") {
              let timeline2 = new AttachmentTimeline(frames, slotIndex);
              for (let frame = 0; frame < frames; frame++) {
                let keyMap = timelineMap[frame];
                timeline2.setFrame(frame, getValue(keyMap, "time", 0), getValue(keyMap, "name", null));
              }
              timelines.push(timeline2);
            } else if (timelineName == "rgba") {
              let timeline2 = new RGBATimeline(frames, frames << 2, slotIndex);
              let keyMap = timelineMap[0];
              let time = getValue(keyMap, "time", 0);
              let color = Color2.fromString(keyMap.color);
              for (let frame = 0, bezier = 0; ; frame++) {
                timeline2.setFrame(frame, time, color.r, color.g, color.b, color.a);
                let nextMap = timelineMap[frame + 1];
                if (!nextMap) {
                  timeline2.shrink(bezier);
                  break;
                }
                let time2 = getValue(nextMap, "time", 0);
                let newColor = Color2.fromString(nextMap.color);
                let curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline2, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
                }
                time = time2;
                color = newColor;
                keyMap = nextMap;
              }
              timelines.push(timeline2);
            } else if (timelineName == "rgb") {
              let timeline2 = new RGBTimeline(frames, frames * 3, slotIndex);
              let keyMap = timelineMap[0];
              let time = getValue(keyMap, "time", 0);
              let color = Color2.fromString(keyMap.color);
              for (let frame = 0, bezier = 0; ; frame++) {
                timeline2.setFrame(frame, time, color.r, color.g, color.b);
                let nextMap = timelineMap[frame + 1];
                if (!nextMap) {
                  timeline2.shrink(bezier);
                  break;
                }
                let time2 = getValue(nextMap, "time", 0);
                let newColor = Color2.fromString(nextMap.color);
                let curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline2, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                }
                time = time2;
                color = newColor;
                keyMap = nextMap;
              }
              timelines.push(timeline2);
            } else if (timelineName == "alpha") {
              timelines.push(readTimeline12(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));
            } else if (timelineName == "rgba2") {
              let timeline2 = new RGBA2Timeline(frames, frames * 7, slotIndex);
              let keyMap = timelineMap[0];
              let time = getValue(keyMap, "time", 0);
              let color = Color2.fromString(keyMap.light);
              let color2 = Color2.fromString(keyMap.dark);
              for (let frame = 0, bezier = 0; ; frame++) {
                timeline2.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);
                let nextMap = timelineMap[frame + 1];
                if (!nextMap) {
                  timeline2.shrink(bezier);
                  break;
                }
                let time2 = getValue(nextMap, "time", 0);
                let newColor = Color2.fromString(nextMap.light);
                let newColor2 = Color2.fromString(nextMap.dark);
                let curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline2, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);
                }
                time = time2;
                color = newColor;
                color2 = newColor2;
                keyMap = nextMap;
              }
              timelines.push(timeline2);
            } else if (timelineName == "rgb2") {
              let timeline2 = new RGB2Timeline(frames, frames * 6, slotIndex);
              let keyMap = timelineMap[0];
              let time = getValue(keyMap, "time", 0);
              let color = Color2.fromString(keyMap.light);
              let color2 = Color2.fromString(keyMap.dark);
              for (let frame = 0, bezier = 0; ; frame++) {
                timeline2.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);
                let nextMap = timelineMap[frame + 1];
                if (!nextMap) {
                  timeline2.shrink(bezier);
                  break;
                }
                let time2 = getValue(nextMap, "time", 0);
                let newColor = Color2.fromString(nextMap.light);
                let newColor2 = Color2.fromString(nextMap.dark);
                let curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline2, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);
                }
                time = time2;
                color = newColor;
                color2 = newColor2;
                keyMap = nextMap;
              }
              timelines.push(timeline2);
            }
          }
        }
      }
      if (map.bones) {
        for (let boneName in map.bones) {
          let boneMap = map.bones[boneName];
          let bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error("Bone not found: " + boneName);
          let boneIndex = bone.index;
          for (let timelineName in boneMap) {
            let timelineMap = boneMap[timelineName];
            let frames = timelineMap.length;
            if (frames == 0)
              continue;
            if (timelineName === "rotate") {
              timelines.push(readTimeline12(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));
            } else if (timelineName === "translate") {
              let timeline2 = new TranslateTimeline(frames, frames << 1, boneIndex);
              timelines.push(readTimeline22(timelineMap, timeline2, "x", "y", 0, scale));
            } else if (timelineName === "translatex") {
              let timeline2 = new TranslateXTimeline(frames, frames, boneIndex);
              timelines.push(readTimeline12(timelineMap, timeline2, 0, scale));
            } else if (timelineName === "translatey") {
              let timeline2 = new TranslateYTimeline(frames, frames, boneIndex);
              timelines.push(readTimeline12(timelineMap, timeline2, 0, scale));
            } else if (timelineName === "scale") {
              let timeline2 = new ScaleTimeline(frames, frames << 1, boneIndex);
              timelines.push(readTimeline22(timelineMap, timeline2, "x", "y", 1, 1));
            } else if (timelineName === "scalex") {
              let timeline2 = new ScaleXTimeline(frames, frames, boneIndex);
              timelines.push(readTimeline12(timelineMap, timeline2, 1, 1));
            } else if (timelineName === "scaley") {
              let timeline2 = new ScaleYTimeline(frames, frames, boneIndex);
              timelines.push(readTimeline12(timelineMap, timeline2, 1, 1));
            } else if (timelineName === "shear") {
              let timeline2 = new ShearTimeline(frames, frames << 1, boneIndex);
              timelines.push(readTimeline22(timelineMap, timeline2, "x", "y", 0, 1));
            } else if (timelineName === "shearx") {
              let timeline2 = new ShearXTimeline(frames, frames, boneIndex);
              timelines.push(readTimeline12(timelineMap, timeline2, 0, 1));
            } else if (timelineName === "sheary") {
              let timeline2 = new ShearYTimeline(frames, frames, boneIndex);
              timelines.push(readTimeline12(timelineMap, timeline2, 0, 1));
            } else if (timelineName === "inherit") {
              let timeline2 = new InheritTimeline(frames, bone.index);
              for (let frame = 0; frame < timelineMap.length; frame++) {
                let aFrame = timelineMap[frame];
                timeline2.setFrame(frame, getValue(aFrame, "time", 0), Utils.enumValue(Inherit, getValue(aFrame, "inherit", "Normal")));
              }
              timelines.push(timeline2);
            }
          }
        }
      }
      if (map.ik) {
        for (let constraintName in map.ik) {
          let constraintMap = map.ik[constraintName];
          let keyMap = constraintMap[0];
          if (!keyMap)
            continue;
          let constraint = skeletonData.findIkConstraint(constraintName);
          if (!constraint)
            throw new Error("IK Constraint not found: " + constraintName);
          let constraintIndex = skeletonData.ikConstraints.indexOf(constraint);
          let timeline2 = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);
          let time = getValue(keyMap, "time", 0);
          let mix = getValue(keyMap, "mix", 1);
          let softness = getValue(keyMap, "softness", 0) * scale;
          for (let frame = 0, bezier = 0; ; frame++) {
            timeline2.setFrame(frame, time, mix, softness, getValue(keyMap, "bendPositive", true) ? 1 : -1, getValue(keyMap, "compress", false), getValue(keyMap, "stretch", false));
            let nextMap = constraintMap[frame + 1];
            if (!nextMap) {
              timeline2.shrink(bezier);
              break;
            }
            let time2 = getValue(nextMap, "time", 0);
            let mix2 = getValue(nextMap, "mix", 1);
            let softness2 = getValue(nextMap, "softness", 0) * scale;
            let curve = keyMap.curve;
            if (curve) {
              bezier = readCurve(curve, timeline2, bezier, frame, 0, time, time2, mix, mix2, 1);
              bezier = readCurve(curve, timeline2, bezier, frame, 1, time, time2, softness, softness2, scale);
            }
            time = time2;
            mix = mix2;
            softness = softness2;
            keyMap = nextMap;
          }
          timelines.push(timeline2);
        }
      }
      if (map.transform) {
        for (let constraintName in map.transform) {
          let timelineMap = map.transform[constraintName];
          let keyMap = timelineMap[0];
          if (!keyMap)
            continue;
          let constraint = skeletonData.findTransformConstraint(constraintName);
          if (!constraint)
            throw new Error("Transform constraint not found: " + constraintName);
          let constraintIndex = skeletonData.transformConstraints.indexOf(constraint);
          let timeline2 = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);
          let time = getValue(keyMap, "time", 0);
          let mixRotate = getValue(keyMap, "mixRotate", 1);
          let mixX = getValue(keyMap, "mixX", 1);
          let mixY = getValue(keyMap, "mixY", mixX);
          let mixScaleX = getValue(keyMap, "mixScaleX", 1);
          let mixScaleY = getValue(keyMap, "mixScaleY", mixScaleX);
          let mixShearY = getValue(keyMap, "mixShearY", 1);
          for (let frame = 0, bezier = 0; ; frame++) {
            timeline2.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
            let nextMap = timelineMap[frame + 1];
            if (!nextMap) {
              timeline2.shrink(bezier);
              break;
            }
            let time2 = getValue(nextMap, "time", 0);
            let mixRotate2 = getValue(nextMap, "mixRotate", 1);
            let mixX2 = getValue(nextMap, "mixX", 1);
            let mixY2 = getValue(nextMap, "mixY", mixX2);
            let mixScaleX2 = getValue(nextMap, "mixScaleX", 1);
            let mixScaleY2 = getValue(nextMap, "mixScaleY", mixScaleX2);
            let mixShearY2 = getValue(nextMap, "mixShearY", 1);
            let curve = keyMap.curve;
            if (curve) {
              bezier = readCurve(curve, timeline2, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
              bezier = readCurve(curve, timeline2, bezier, frame, 1, time, time2, mixX, mixX2, 1);
              bezier = readCurve(curve, timeline2, bezier, frame, 2, time, time2, mixY, mixY2, 1);
              bezier = readCurve(curve, timeline2, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
              bezier = readCurve(curve, timeline2, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
              bezier = readCurve(curve, timeline2, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);
            }
            time = time2;
            mixRotate = mixRotate2;
            mixX = mixX2;
            mixY = mixY2;
            mixScaleX = mixScaleX2;
            mixScaleY = mixScaleY2;
            mixScaleX = mixScaleX2;
            keyMap = nextMap;
          }
          timelines.push(timeline2);
        }
      }
      if (map.path) {
        for (let constraintName in map.path) {
          let constraintMap = map.path[constraintName];
          let constraint = skeletonData.findPathConstraint(constraintName);
          if (!constraint)
            throw new Error("Path constraint not found: " + constraintName);
          let constraintIndex = skeletonData.pathConstraints.indexOf(constraint);
          for (let timelineName in constraintMap) {
            let timelineMap = constraintMap[timelineName];
            let keyMap = timelineMap[0];
            if (!keyMap)
              continue;
            let frames = timelineMap.length;
            if (timelineName === "position") {
              let timeline2 = new PathConstraintPositionTimeline(frames, frames, constraintIndex);
              timelines.push(readTimeline12(timelineMap, timeline2, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));
            } else if (timelineName === "spacing") {
              let timeline2 = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);
              timelines.push(readTimeline12(timelineMap, timeline2, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1));
            } else if (timelineName === "mix") {
              let timeline2 = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);
              let time = getValue(keyMap, "time", 0);
              let mixRotate = getValue(keyMap, "mixRotate", 1);
              let mixX = getValue(keyMap, "mixX", 1);
              let mixY = getValue(keyMap, "mixY", mixX);
              for (let frame = 0, bezier = 0; ; frame++) {
                timeline2.setFrame(frame, time, mixRotate, mixX, mixY);
                let nextMap = timelineMap[frame + 1];
                if (!nextMap) {
                  timeline2.shrink(bezier);
                  break;
                }
                let time2 = getValue(nextMap, "time", 0);
                let mixRotate2 = getValue(nextMap, "mixRotate", 1);
                let mixX2 = getValue(nextMap, "mixX", 1);
                let mixY2 = getValue(nextMap, "mixY", mixX2);
                let curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline2, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 1, time, time2, mixX, mixX2, 1);
                  bezier = readCurve(curve, timeline2, bezier, frame, 2, time, time2, mixY, mixY2, 1);
                }
                time = time2;
                mixRotate = mixRotate2;
                mixX = mixX2;
                mixY = mixY2;
                keyMap = nextMap;
              }
              timelines.push(timeline2);
            }
          }
        }
      }
      if (map.physics) {
        for (let constraintName in map.physics) {
          let constraintMap = map.physics[constraintName];
          let constraintIndex = -1;
          if (constraintName.length > 0) {
            let constraint = skeletonData.findPhysicsConstraint(constraintName);
            if (!constraint)
              throw new Error("Physics constraint not found: " + constraintName);
            constraintIndex = skeletonData.physicsConstraints.indexOf(constraint);
          }
          for (let timelineName in constraintMap) {
            let timelineMap = constraintMap[timelineName];
            let keyMap = timelineMap[0];
            if (!keyMap)
              continue;
            let frames = timelineMap.length;
            if (timelineName == "reset") {
              const timeline3 = new PhysicsConstraintResetTimeline(frames, constraintIndex);
              for (let frame = 0; keyMap != null; keyMap = timelineMap[frame + 1], frame++)
                timeline3.setFrame(frame, getValue(keyMap, "time", 0));
              timelines.push(timeline3);
              continue;
            }
            let timeline2;
            if (timelineName == "inertia")
              timeline2 = new PhysicsConstraintInertiaTimeline(frames, frames, constraintIndex);
            else if (timelineName == "strength")
              timeline2 = new PhysicsConstraintStrengthTimeline(frames, frames, constraintIndex);
            else if (timelineName == "damping")
              timeline2 = new PhysicsConstraintDampingTimeline(frames, frames, constraintIndex);
            else if (timelineName == "mass")
              timeline2 = new PhysicsConstraintMassTimeline(frames, frames, constraintIndex);
            else if (timelineName == "wind")
              timeline2 = new PhysicsConstraintWindTimeline(frames, frames, constraintIndex);
            else if (timelineName == "gravity")
              timeline2 = new PhysicsConstraintGravityTimeline(frames, frames, constraintIndex);
            else if (timelineName == "mix")
              timeline2 = new PhysicsConstraintMixTimeline(frames, frames, constraintIndex);
            else
              continue;
            timelines.push(readTimeline12(timelineMap, timeline2, 0, 1));
          }
        }
      }
      if (map.attachments) {
        for (let attachmentsName in map.attachments) {
          let attachmentsMap = map.attachments[attachmentsName];
          let skin = skeletonData.findSkin(attachmentsName);
          if (!skin)
            throw new Error("Skin not found: " + attachmentsName);
          for (let slotMapName in attachmentsMap) {
            let slotMap = attachmentsMap[slotMapName];
            let slot = skeletonData.findSlot(slotMapName);
            if (!slot)
              throw new Error("Slot not found: " + slotMapName);
            let slotIndex = slot.index;
            for (let attachmentMapName in slotMap) {
              let attachmentMap = slotMap[attachmentMapName];
              let attachment = skin.getAttachment(slotIndex, attachmentMapName);
              for (let timelineMapName in attachmentMap) {
                let timelineMap = attachmentMap[timelineMapName];
                let keyMap = timelineMap[0];
                if (!keyMap)
                  continue;
                if (timelineMapName == "deform") {
                  let weighted = attachment.bones;
                  let vertices = attachment.vertices;
                  let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                  let timeline2 = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);
                  let time = getValue(keyMap, "time", 0);
                  for (let frame = 0, bezier = 0; ; frame++) {
                    let deform;
                    let verticesValue = getValue(keyMap, "vertices", null);
                    if (!verticesValue)
                      deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                    else {
                      deform = Utils.newFloatArray(deformLength);
                      let start = getValue(keyMap, "offset", 0);
                      Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                      if (scale != 1) {
                        for (let i3 = start, n2 = i3 + verticesValue.length; i3 < n2; i3++)
                          deform[i3] *= scale;
                      }
                      if (!weighted) {
                        for (let i3 = 0; i3 < deformLength; i3++)
                          deform[i3] += vertices[i3];
                      }
                    }
                    timeline2.setFrame(frame, time, deform);
                    let nextMap = timelineMap[frame + 1];
                    if (!nextMap) {
                      timeline2.shrink(bezier);
                      break;
                    }
                    let time2 = getValue(nextMap, "time", 0);
                    let curve = keyMap.curve;
                    if (curve)
                      bezier = readCurve(curve, timeline2, bezier, frame, 0, time, time2, 0, 1, 1);
                    time = time2;
                    keyMap = nextMap;
                  }
                  timelines.push(timeline2);
                } else if (timelineMapName == "sequence") {
                  let timeline2 = new SequenceTimeline(timelineMap.length, slotIndex, attachment);
                  let lastDelay = 0;
                  for (let frame = 0; frame < timelineMap.length; frame++) {
                    let delay = getValue(keyMap, "delay", lastDelay);
                    let time = getValue(keyMap, "time", 0);
                    let mode = SequenceMode[getValue(keyMap, "mode", "hold")];
                    let index = getValue(keyMap, "index", 0);
                    timeline2.setFrame(frame, time, mode, index, delay);
                    lastDelay = delay;
                    keyMap = timelineMap[frame + 1];
                  }
                  timelines.push(timeline2);
                }
              }
            }
          }
        }
      }
      if (map.drawOrder) {
        let timeline2 = new DrawOrderTimeline(map.drawOrder.length);
        let slotCount = skeletonData.slots.length;
        let frame = 0;
        for (let i3 = 0; i3 < map.drawOrder.length; i3++, frame++) {
          let drawOrderMap = map.drawOrder[i3];
          let drawOrder = null;
          let offsets = getValue(drawOrderMap, "offsets", null);
          if (offsets) {
            drawOrder = Utils.newArray(slotCount, -1);
            let unchanged = Utils.newArray(slotCount - offsets.length, 0);
            let originalIndex = 0, unchangedIndex = 0;
            for (let ii = 0; ii < offsets.length; ii++) {
              let offsetMap = offsets[ii];
              let slot = skeletonData.findSlot(offsetMap.slot);
              if (!slot)
                throw new Error("Slot not found: " + slot);
              let slotIndex = slot.index;
              while (originalIndex != slotIndex)
                unchanged[unchangedIndex++] = originalIndex++;
              drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
            }
            while (originalIndex < slotCount)
              unchanged[unchangedIndex++] = originalIndex++;
            for (let ii = slotCount - 1; ii >= 0; ii--)
              if (drawOrder[ii] == -1)
                drawOrder[ii] = unchanged[--unchangedIndex];
          }
          timeline2.setFrame(frame, getValue(drawOrderMap, "time", 0), drawOrder);
        }
        timelines.push(timeline2);
      }
      if (map.events) {
        let timeline2 = new EventTimeline(map.events.length);
        let frame = 0;
        for (let i3 = 0; i3 < map.events.length; i3++, frame++) {
          let eventMap = map.events[i3];
          let eventData = skeletonData.findEvent(eventMap.name);
          if (!eventData)
            throw new Error("Event not found: " + eventMap.name);
          let event = new Event2(Utils.toSinglePrecision(getValue(eventMap, "time", 0)), eventData);
          event.intValue = getValue(eventMap, "int", eventData.intValue);
          event.floatValue = getValue(eventMap, "float", eventData.floatValue);
          event.stringValue = getValue(eventMap, "string", eventData.stringValue);
          if (event.data.audioPath) {
            event.volume = getValue(eventMap, "volume", 1);
            event.balance = getValue(eventMap, "balance", 0);
          }
          timeline2.setFrame(frame, event);
        }
        timelines.push(timeline2);
      }
      let duration = 0;
      for (let i3 = 0, n2 = timelines.length; i3 < n2; i3++)
        duration = Math.max(duration, timelines[i3].getDuration());
      skeletonData.animations.push(new Animation2(name, timelines, duration));
    }
  };
  var LinkedMesh2 = class {
    constructor(mesh, skin, slotIndex, parent, inheritDeform) {
      __publicField(this, "parent");
      __publicField(this, "skin");
      __publicField(this, "slotIndex");
      __publicField(this, "mesh");
      __publicField(this, "inheritTimeline");
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
      this.inheritTimeline = inheritDeform;
    }
  };
  function readTimeline12(keys, timeline2, defaultValue2, scale) {
    let keyMap = keys[0];
    let time = getValue(keyMap, "time", 0);
    let value = getValue(keyMap, "value", defaultValue2) * scale;
    let bezier = 0;
    for (let frame = 0; ; frame++) {
      timeline2.setFrame(frame, time, value);
      let nextMap = keys[frame + 1];
      if (!nextMap) {
        timeline2.shrink(bezier);
        return timeline2;
      }
      let time2 = getValue(nextMap, "time", 0);
      let value2 = getValue(nextMap, "value", defaultValue2) * scale;
      if (keyMap.curve)
        bezier = readCurve(keyMap.curve, timeline2, bezier, frame, 0, time, time2, value, value2, scale);
      time = time2;
      value = value2;
      keyMap = nextMap;
    }
  }
  function readTimeline22(keys, timeline2, name1, name2, defaultValue2, scale) {
    let keyMap = keys[0];
    let time = getValue(keyMap, "time", 0);
    let value1 = getValue(keyMap, name1, defaultValue2) * scale;
    let value2 = getValue(keyMap, name2, defaultValue2) * scale;
    let bezier = 0;
    for (let frame = 0; ; frame++) {
      timeline2.setFrame(frame, time, value1, value2);
      let nextMap = keys[frame + 1];
      if (!nextMap) {
        timeline2.shrink(bezier);
        return timeline2;
      }
      let time2 = getValue(nextMap, "time", 0);
      let nvalue1 = getValue(nextMap, name1, defaultValue2) * scale;
      let nvalue2 = getValue(nextMap, name2, defaultValue2) * scale;
      let curve = keyMap.curve;
      if (curve) {
        bezier = readCurve(curve, timeline2, bezier, frame, 0, time, time2, value1, nvalue1, scale);
        bezier = readCurve(curve, timeline2, bezier, frame, 1, time, time2, value2, nvalue2, scale);
      }
      time = time2;
      value1 = nvalue1;
      value2 = nvalue2;
      keyMap = nextMap;
    }
  }
  function readCurve(curve, timeline2, bezier, frame, value, time1, time2, value1, value2, scale) {
    if (curve == "stepped") {
      timeline2.setStepped(frame);
      return bezier;
    }
    let i3 = value << 2;
    let cx1 = curve[i3];
    let cy1 = curve[i3 + 1] * scale;
    let cx2 = curve[i3 + 2];
    let cy2 = curve[i3 + 3] * scale;
    timeline2.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
    return bezier + 1;
  }
  function getValue(map, property, defaultValue2) {
    return map[property] !== void 0 ? map[property] : defaultValue2;
  }

  // node_modules/@esotericsoftware/spine-core/dist/polyfills.js
  (() => {
    if (typeof Math.fround === "undefined") {
      Math.fround = /* @__PURE__ */ (function(array) {
        return function(x2) {
          return array[0] = x2, array[0];
        };
      })(new Float32Array(1));
    }
  })();

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/SpineTexture.js
  var _SpineTexture = class _SpineTexture extends Texture2 {
    constructor(image) {
      super(image.resource);
      __publicField(this, "texture");
      this.texture = Texture.from(image);
    }
    static from(texture) {
      if (_SpineTexture.textureMap.has(texture)) {
        return _SpineTexture.textureMap.get(texture);
      }
      return new _SpineTexture(texture);
    }
    setFilters(minFilter, magFilter) {
      const style = this.texture.source.style;
      style.minFilter = _SpineTexture.toPixiTextureFilter(minFilter);
      style.magFilter = _SpineTexture.toPixiTextureFilter(magFilter);
      this.texture.source.autoGenerateMipmaps = _SpineTexture.toPixiMipMap(minFilter);
      this.texture.source.updateMipmaps();
    }
    setWraps(uWrap, vWrap) {
      const style = this.texture.source.style;
      style.addressModeU = _SpineTexture.toPixiTextureWrap(uWrap);
      style.addressModeV = _SpineTexture.toPixiTextureWrap(vWrap);
    }
    dispose() {
      this.texture.destroy();
    }
    static toPixiMipMap(filter) {
      switch (filter) {
        case TextureFilter.Nearest:
        case TextureFilter.Linear:
          return false;
        case TextureFilter.MipMapNearestLinear:
        case TextureFilter.MipMapNearestNearest:
        case TextureFilter.MipMapLinearLinear:
        // TextureFilter.MipMapLinearLinear == TextureFilter.MipMap
        case TextureFilter.MipMapLinearNearest:
          return true;
        default:
          throw new Error(`Unknown texture filter: ${String(filter)}`);
      }
    }
    static toPixiTextureFilter(filter) {
      switch (filter) {
        case TextureFilter.Nearest:
        case TextureFilter.MipMapNearestLinear:
        case TextureFilter.MipMapNearestNearest:
          return "nearest";
        case TextureFilter.Linear:
        case TextureFilter.MipMapLinearLinear:
        // TextureFilter.MipMapLinearLinear == TextureFilter.MipMap
        case TextureFilter.MipMapLinearNearest:
          return "linear";
        default:
          throw new Error(`Unknown texture filter: ${String(filter)}`);
      }
    }
    static toPixiTextureWrap(wrap3) {
      switch (wrap3) {
        case TextureWrap.ClampToEdge:
          return "clamp-to-edge";
        case TextureWrap.MirroredRepeat:
          return "mirror-repeat";
        case TextureWrap.Repeat:
          return "repeat";
        default:
          throw new Error(`Unknown texture wrap: ${String(wrap3)}`);
      }
    }
    static toPixiBlending(blend) {
      switch (blend) {
        case BlendMode.Normal:
          return "normal";
        case BlendMode.Additive:
          return "add";
        case BlendMode.Multiply:
          return "multiply";
        case BlendMode.Screen:
          return "screen";
        default:
          throw new Error(`Unknown blendMode: ${String(blend)}`);
      }
    }
  };
  __publicField(_SpineTexture, "textureMap", /* @__PURE__ */ new Map());
  var SpineTexture = _SpineTexture;

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/assets/atlasLoader.js
  var loaderName = "spineTextureAtlasLoader";
  var spineTextureAtlasLoader = {
    extension: ExtensionType.Asset,
    resolver: {
      test: (value) => checkExtension(value, ".atlas"),
      parse: (value) => {
        var _a2, _b, _c;
        const split = value.split(".");
        return {
          resolution: parseFloat((_c = (_b = (_a2 = Resolver.RETINA_PREFIX) == null ? void 0 : _a2.exec(value)) == null ? void 0 : _b[1]) != null ? _c : "1"),
          format: split[split.length - 2],
          src: value
        };
      }
    },
    loader: {
      id: loaderName,
      name: loaderName,
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal,
        name: loaderName
      },
      test(url) {
        return checkExtension(url, ".atlas");
      },
      load(url) {
        return __async(this, null, function* () {
          const response = yield DOMAdapter.get().fetch(url);
          const txt = yield response.text();
          return txt;
        });
      },
      testParse(asset, options) {
        const isExtensionRight = checkExtension(options.src, ".atlas");
        const isString = typeof asset === "string";
        const isExplicitLoadParserSet = options.parser === loaderName || options.loadParser === loaderName;
        return Promise.resolve((isExtensionRight || isExplicitLoadParserSet) && isString);
      },
      unload(atlas) {
        atlas.dispose();
      },
      parse(asset, options, loader) {
        return __async(this, null, function* () {
          const metadata = options.data || {};
          let basePath = path.dirname(options.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          const retval = new TextureAtlas(asset);
          if (metadata.images instanceof TextureSource || typeof metadata.images === "string") {
            const pixiTexture = metadata.images;
            metadata.images = {};
            metadata.images[retval.pages[0].name] = pixiTexture;
          }
          const textureLoadingPromises = [];
          for (const page of retval.pages) {
            const pageName = page.name;
            const providedPage = (metadata == null ? void 0 : metadata.images) ? metadata.images[pageName] : void 0;
            if (providedPage instanceof TextureSource) {
              page.setTexture(SpineTexture.from(providedPage));
            } else {
              const url = providedPage != null ? providedPage : path.normalize([...basePath.split(path.sep), pageName].join(path.sep));
              const assetsToLoadIn = {
                src: copySearchParams(url, options.src),
                data: __spreadProps(__spreadValues({}, metadata.imageMetadata), {
                  alphaMode: page.pma ? "premultiplied-alpha" : "premultiply-alpha-on-upload"
                })
              };
              const pixiPromise = loader.load(assetsToLoadIn).then((texture) => {
                page.setTexture(SpineTexture.from(texture.source));
              });
              textureLoadingPromises.push(pixiPromise);
            }
          }
          yield Promise.all(textureLoadingPromises);
          return retval;
        });
      }
    }
  };
  extensions.add(spineTextureAtlasLoader);

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/assets/skeletonLoader.js
  var loaderName2 = "spineSkeletonLoader";
  function isJson(resource) {
    return Object.prototype.hasOwnProperty.call(resource, "bones");
  }
  function isBuffer(resource) {
    return resource instanceof Uint8Array;
  }
  var spineLoaderExtension = {
    extension: ExtensionType.Asset,
    loader: {
      id: loaderName2,
      name: loaderName2,
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal,
        name: loaderName2
      },
      test(url) {
        return checkExtension(url, ".skel");
      },
      load(url) {
        return __async(this, null, function* () {
          const response = yield DOMAdapter.get().fetch(url);
          const buffer = new Uint8Array(yield response.arrayBuffer());
          return buffer;
        });
      },
      testParse(asset, options) {
        const isJsonSpineModel = checkExtension(options.src, ".json") && isJson(asset);
        const isBinarySpineModel = checkExtension(options.src, ".skel") && isBuffer(asset);
        const isExplicitLoadParserSet = options.parser === loaderName2 || options.loadParser === loaderName2;
        return Promise.resolve(isJsonSpineModel || isBinarySpineModel || isExplicitLoadParserSet);
      }
    }
  };
  extensions.add(spineLoaderExtension);

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/darktint/DarkTintBatchGeometry.js
  var placeHolderBufferData2 = new Float32Array(1);
  var placeHolderIndexData2 = new Uint32Array(1);
  var DarkTintBatchGeometry = class extends Geometry {
    constructor() {
      const vertexSize = 7;
      const attributeBuffer = new Buffer2({
        data: placeHolderBufferData2,
        label: "attribute-batch-buffer",
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
        shrinkToFit: false
      });
      const indexBuffer = new Buffer2({
        data: placeHolderIndexData2,
        label: "index-batch-buffer",
        usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
        // | BufferUsage.STATIC,
        shrinkToFit: false
      });
      const stride = vertexSize * 4;
      super({
        attributes: {
          aPosition: {
            buffer: attributeBuffer,
            format: "float32x2",
            stride,
            offset: 0
          },
          aUV: {
            buffer: attributeBuffer,
            format: "float32x2",
            stride,
            offset: 2 * 4
          },
          aColor: {
            buffer: attributeBuffer,
            format: "unorm8x4",
            stride,
            offset: 4 * 4
          },
          aDarkColor: {
            buffer: attributeBuffer,
            format: "unorm8x4",
            stride,
            offset: 5 * 4
          },
          aTextureIdAndRound: {
            buffer: attributeBuffer,
            format: "uint16x2",
            stride,
            offset: 6 * 4
          }
        },
        indexBuffer
      });
    }
  };

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/darktint/darkTintBit.js
  var darkTintBit = {
    name: "color-bit",
    vertex: {
      header: (
        /* wgsl */
        `
            @in aDarkColor: vec4<f32>;
            @out vDarkColor: vec4<f32>;
        `
      ),
      main: (
        /* wgsl */
        `
        vDarkColor = aDarkColor;
        `
      )
    },
    fragment: {
      header: (
        /* wgsl */
        `
            @in vDarkColor: vec4<f32>;
        `
      ),
      end: (
        /* wgsl */
        `

        let alpha = outColor.a * vColor.a;
        let rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;

        finalColor = vec4<f32>(rgb, alpha);

        `
      )
    }
  };
  var darkTintBitGl = {
    name: "color-bit",
    vertex: {
      header: (
        /* glsl */
        `
            in vec4 aDarkColor;
            out vec4 vDarkColor;
        `
      ),
      main: (
        /* glsl */
        `
            vDarkColor = aDarkColor;
        `
      )
    },
    fragment: {
      header: (
        /* glsl */
        `
            in vec4 vDarkColor;
        `
      ),
      end: (
        /* glsl */
        `

        finalColor.a = outColor.a * vColor.a;
        finalColor.rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;
        `
      )
    }
  };

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/darktint/DarkTintShader.js
  var DarkTintShader = class extends Shader {
    constructor(maxTextures) {
      const glProgram3 = compileHighShaderGlProgram({
        name: "dark-tint-batch",
        bits: [
          colorBitGl,
          darkTintBitGl,
          generateTextureBatchBitGl(maxTextures),
          roundPixelsBitGl
        ]
      });
      const gpuProgram3 = compileHighShaderGpuProgram({
        name: "dark-tint-batch",
        bits: [
          colorBit,
          darkTintBit,
          generateTextureBatchBit(maxTextures),
          roundPixelsBit
        ]
      });
      super({
        glProgram: glProgram3,
        gpuProgram: gpuProgram3,
        resources: {
          batchSamplers: getBatchSamplersUniformGroup(maxTextures)
        }
      });
    }
  };

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/darktint/DarkTintBatcher.js
  var defaultShader2 = null;
  var _DarkTintBatcher = class _DarkTintBatcher extends Batcher {
    constructor() {
      super(...arguments);
      __publicField(this, "geometry", new DarkTintBatchGeometry());
      __publicField(this, "shader", defaultShader2 || (defaultShader2 = new DarkTintShader(this.maxTextures)));
      __publicField(this, "name", _DarkTintBatcher.extension.name);
      /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, darkColor, textureIdAndRound -> total = 7 */
      __publicField(this, "vertexSize", 7);
    }
    packAttributes(element, float32View, uint32View, index, textureId) {
      const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
      const wt = element.transform;
      const a2 = wt.a;
      const b2 = wt.b;
      const c2 = wt.c;
      const d2 = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const { positions, uvs } = element;
      const argb = element.color;
      const worldAlpha = (argb >> 24 & 255) / 255;
      const darkColor = Color.shared.setValue(element.darkColor).premultiply(worldAlpha, true).toPremultiplied(1, false);
      const offset = element.attributeOffset;
      const end = offset + element.attributeSize;
      for (let i3 = offset; i3 < end; i3++) {
        const i22 = i3 * 2;
        const x2 = positions[i22];
        const y2 = positions[i22 + 1];
        float32View[index++] = a2 * x2 + c2 * y2 + tx;
        float32View[index++] = d2 * y2 + b2 * x2 + ty;
        float32View[index++] = uvs[i22];
        float32View[index++] = uvs[i22 + 1];
        uint32View[index++] = argb;
        uint32View[index++] = darkColor;
        uint32View[index++] = textureIdAndRound;
      }
    }
    packQuadAttributes(element, float32View, uint32View, index, textureId) {
      const texture = element.texture;
      const wt = element.transform;
      const a2 = wt.a;
      const b2 = wt.b;
      const c2 = wt.c;
      const d2 = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const bounds = element.bounds;
      const w0 = bounds.maxX;
      const w1 = bounds.minX;
      const h0 = bounds.maxY;
      const h1 = bounds.minY;
      const uvs = texture.uvs;
      const argb = element.color;
      const darkColor = element.darkColor;
      const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
      float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
      float32View[index + 1] = d2 * h1 + b2 * w1 + ty;
      float32View[index + 2] = uvs.x0;
      float32View[index + 3] = uvs.y0;
      uint32View[index + 4] = argb;
      uint32View[index + 5] = darkColor;
      uint32View[index + 6] = textureIdAndRound;
      float32View[index + 7] = a2 * w0 + c2 * h1 + tx;
      float32View[index + 8] = d2 * h1 + b2 * w0 + ty;
      float32View[index + 9] = uvs.x1;
      float32View[index + 10] = uvs.y1;
      uint32View[index + 11] = argb;
      uint32View[index + 12] = darkColor;
      uint32View[index + 13] = textureIdAndRound;
      float32View[index + 14] = a2 * w0 + c2 * h0 + tx;
      float32View[index + 15] = d2 * h0 + b2 * w0 + ty;
      float32View[index + 16] = uvs.x2;
      float32View[index + 17] = uvs.y2;
      uint32View[index + 18] = argb;
      uint32View[index + 19] = darkColor;
      uint32View[index + 20] = textureIdAndRound;
      float32View[index + 21] = a2 * w1 + c2 * h0 + tx;
      float32View[index + 22] = d2 * h0 + b2 * w1 + ty;
      float32View[index + 23] = uvs.x3;
      float32View[index + 24] = uvs.y3;
      uint32View[index + 25] = argb;
      uint32View[index + 26] = darkColor;
      uint32View[index + 27] = textureIdAndRound;
    }
  };
  /** @ignore */
  __publicField(_DarkTintBatcher, "extension", {
    type: [
      ExtensionType.Batcher
    ],
    name: "darkTint"
  });
  var DarkTintBatcher = _DarkTintBatcher;
  extensions.add(DarkTintBatcher);

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/BatchableSpineSlot.js
  var BatchableSpineSlot = class {
    constructor() {
      __publicField(this, "indexOffset", 0);
      __publicField(this, "attributeOffset", 0);
      __publicField(this, "indexSize");
      __publicField(this, "attributeSize");
      __publicField(this, "batcherName", "darkTint");
      __publicField(this, "topology", "triangle-list");
      __publicField(this, "packAsQuad", false);
      __publicField(this, "renderable");
      __publicField(this, "positions");
      __publicField(this, "indices");
      __publicField(this, "uvs");
      __publicField(this, "roundPixels");
      __publicField(this, "data");
      __publicField(this, "blendMode");
      __publicField(this, "darkTint");
      __publicField(this, "texture");
      __publicField(this, "transform");
      // used internally by batcher specific. Stored for efficient updating.
      __publicField(this, "_textureId");
      __publicField(this, "_attributeStart");
      __publicField(this, "_indexStart");
      __publicField(this, "_batcher");
      __publicField(this, "_batch");
    }
    get color() {
      const slotColor = this.data.color;
      const parentColor = this.renderable.groupColor;
      const parentAlpha = this.renderable.groupAlpha;
      let abgr;
      const mixedA = slotColor.a * parentAlpha * 255;
      if (parentColor !== 16777215) {
        const parentB = parentColor >> 16 & 255;
        const parentG = parentColor >> 8 & 255;
        const parentR = parentColor & 255;
        const mixedR = slotColor.r * parentR;
        const mixedG = slotColor.g * parentG;
        const mixedB = slotColor.b * parentB;
        abgr = mixedA << 24 | mixedB << 16 | mixedG << 8 | mixedR;
      } else {
        abgr = mixedA << 24 | slotColor.b * 255 << 16 | slotColor.g * 255 << 8 | slotColor.r * 255;
      }
      return abgr;
    }
    get darkColor() {
      const darkColor = this.data.darkColor;
      return darkColor.b * 255 << 16 | darkColor.g * 255 << 8 | darkColor.r * 255;
    }
    get groupTransform() {
      return this.renderable.groupTransform;
    }
    setData(renderable, data, blendMode, roundPixels) {
      this.renderable = renderable;
      this.transform = renderable.groupTransform;
      this.data = data;
      if (data.clipped) {
        const clippedData = data.clippedData;
        this.indexSize = clippedData.indicesCount;
        this.attributeSize = clippedData.vertexCount;
        this.positions = clippedData.vertices;
        this.indices = clippedData.indices;
        this.uvs = clippedData.uvs;
      } else {
        this.indexSize = data.indices.length;
        this.attributeSize = data.vertices.length / 2;
        this.positions = data.vertices;
        this.indices = data.indices;
        this.uvs = data.uvs;
      }
      this.texture = data.texture;
      this.roundPixels = roundPixels;
      this.blendMode = blendMode;
      this.batcherName = data.darkTint ? "darkTint" : "default";
    }
  };

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/SpinePipe.js
  var spineBlendModeMap = {
    0: "normal",
    1: "add",
    2: "multiply",
    3: "screen"
  };
  var SpinePipe = class {
    constructor(renderer) {
      __publicField(this, "renderer");
      __publicField(this, "gpuSpineData", {});
      __publicField(this, "_destroyRenderableBound", this.destroyRenderable.bind(this));
      this.renderer = renderer;
    }
    validateRenderable(spine) {
      spine._validateAndTransformAttachments();
      if (spine.spineAttachmentsDirty) {
        return true;
      } else if (spine.spineTexturesDirty) {
        const drawOrder = spine.skeleton.drawOrder;
        const gpuSpine = this.gpuSpineData[spine.uid];
        for (let i3 = 0, n2 = drawOrder.length; i3 < n2; i3++) {
          const slot = drawOrder[i3];
          const attachment = slot.getAttachment();
          if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment) {
            const cacheData = spine._getCachedData(slot, attachment);
            const batchableSpineSlot = gpuSpine.slotBatches[cacheData.id];
            const texture = cacheData.texture;
            if (texture !== (batchableSpineSlot == null ? void 0 : batchableSpineSlot.texture)) {
              if (!(batchableSpineSlot == null ? void 0 : batchableSpineSlot._batcher.checkAndUpdateTexture(batchableSpineSlot, texture))) {
                return true;
              }
            }
          }
        }
      }
      return false;
    }
    addRenderable(spine, instructionSet) {
      var _a2, _b;
      const gpuSpine = this._getSpineData(spine);
      const batcher = this.renderer.renderPipes.batch;
      const drawOrder = spine.skeleton.drawOrder;
      const roundPixels = this.renderer._roundPixels | spine._roundPixels;
      spine._validateAndTransformAttachments();
      spine.spineAttachmentsDirty = false;
      spine.spineTexturesDirty = false;
      for (let i3 = 0, n2 = drawOrder.length; i3 < n2; i3++) {
        const slot = drawOrder[i3];
        const attachment = slot.getAttachment();
        const blendMode = spineBlendModeMap[slot.data.blendMode];
        let skipRender = false;
        if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment) {
          const cacheData = spine._getCachedData(slot, attachment);
          const batchableSpineSlot = (_a2 = gpuSpine.slotBatches)[_b = cacheData.id] || (_a2[_b] = new BatchableSpineSlot());
          batchableSpineSlot.setData(spine, cacheData, blendMode, roundPixels);
          skipRender = cacheData.skipRender;
          if (!skipRender) {
            batcher.addToBatch(batchableSpineSlot, instructionSet);
          }
        }
        const containerAttachment = spine._slotsObject[slot.data.name];
        if (containerAttachment) {
          const container = containerAttachment.container;
          if (!skipRender) {
            container.includeInBuild = true;
            container.collectRenderables(instructionSet, this.renderer, null);
          }
          container.includeInBuild = false;
        }
      }
    }
    updateRenderable(spine) {
      var _a2;
      const gpuSpine = this.gpuSpineData[spine.uid];
      spine._validateAndTransformAttachments();
      spine.spineAttachmentsDirty = false;
      spine.spineTexturesDirty = false;
      const drawOrder = spine.skeleton.drawOrder;
      for (let i3 = 0, n2 = drawOrder.length; i3 < n2; i3++) {
        const slot = drawOrder[i3];
        const attachment = slot.getAttachment();
        if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment) {
          const cacheData = spine._getCachedData(slot, attachment);
          if (!cacheData.skipRender) {
            const batchableSpineSlot = gpuSpine.slotBatches[cacheData.id];
            (_a2 = batchableSpineSlot == null ? void 0 : batchableSpineSlot._batcher) == null ? void 0 : _a2.updateElement(batchableSpineSlot);
          }
        }
      }
    }
    destroyRenderable(spine) {
      this.gpuSpineData[spine.uid] = null;
      spine.off("destroyed", this._destroyRenderableBound);
    }
    destroy() {
      this.gpuSpineData = null;
      this.renderer = null;
    }
    _getSpineData(spine) {
      return this.gpuSpineData[spine.uid] || this._initMeshData(spine);
    }
    _initMeshData(spine) {
      this.gpuSpineData[spine.uid] = { slotBatches: {} };
      spine.on("destroyed", this._destroyRenderableBound);
      return this.gpuSpineData[spine.uid];
    }
  };
  /** @ignore */
  __publicField(SpinePipe, "extension", {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "spine"
  });
  extensions.add(SpinePipe);

  // node_modules/@esotericsoftware/spine-pixi-v8/dist/Spine.js
  var vectorAux = new Vector2();
  Skeleton.yDown = true;
  var clipper = new SkeletonClipping();
  var maskPool = new Pool2(() => new Graphics());
  var Spine = class _Spine extends ViewContainer {
    constructor(options) {
      var _a2;
      if (options instanceof SkeletonData) {
        options = {
          skeletonData: options
        };
      }
      super({});
      // Pixi properties
      __publicField(this, "batched", true);
      __publicField(this, "buildId", 0);
      __publicField(this, "renderPipeId", "spine");
      __publicField(this, "_didSpineUpdate", false);
      __publicField(this, "beforeUpdateWorldTransforms", () => {
      });
      __publicField(this, "afterUpdateWorldTransforms", () => {
      });
      // Spine properties
      /** The skeleton for this Spine game object. */
      __publicField(this, "skeleton");
      /** The animation state for this Spine game object. */
      __publicField(this, "state");
      __publicField(this, "skeletonBounds");
      __publicField(this, "darkTint", false);
      __publicField(this, "_debug");
      __publicField(this, "_slotsObject", /* @__PURE__ */ Object.create(null));
      __publicField(this, "clippingSlotToPixiMasks", /* @__PURE__ */ Object.create(null));
      __publicField(this, "spineAttachmentsDirty", true);
      __publicField(this, "spineTexturesDirty", true);
      __publicField(this, "_lastAttachments", []);
      __publicField(this, "_stateChanged", true);
      __publicField(this, "attachmentCacheData", []);
      __publicField(this, "_autoUpdate", false);
      __publicField(this, "_boundsProvider");
      __publicField(this, "hasNeverUpdated", true);
      __publicField(this, "currentClippingSlot");
      this.allowChildren = true;
      const skeletonData = options instanceof SkeletonData ? options : options.skeletonData;
      this.skeleton = new Skeleton(skeletonData);
      this.state = new AnimationState(new AnimationStateData(skeletonData));
      this.autoUpdate = (_a2 = options == null ? void 0 : options.autoUpdate) != null ? _a2 : true;
      this.darkTint = (options == null ? void 0 : options.darkTint) === void 0 ? this.skeleton.slots.some((slot) => !!slot.data.darkColor) : options == null ? void 0 : options.darkTint;
      const slots = this.skeleton.slots;
      for (let i3 = 0; i3 < slots.length; i3++) {
        this.attachmentCacheData[i3] = /* @__PURE__ */ Object.create(null);
      }
      this._boundsProvider = options.boundsProvider;
    }
    getSlotFromRef(slotRef) {
      let slot;
      if (typeof slotRef === "number")
        slot = this.skeleton.slots[slotRef];
      else if (typeof slotRef === "string")
        slot = this.skeleton.findSlot(slotRef);
      else
        slot = slotRef;
      if (!slot)
        throw new Error(`No slot found with the given slot reference: ${slotRef}`);
      return slot;
    }
    get debug() {
      return this._debug;
    }
    /** Pass a {@link SpineDebugRenderer} or create your own {@link ISpineDebugRenderer} to render bones, meshes, ...
     * @example spineGO.debug = new SpineDebugRenderer();
     */
    set debug(value) {
      if (this._debug) {
        this._debug.unregisterSpine(this);
      }
      if (value) {
        value.registerSpine(this);
      }
      this._debug = value;
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    /** When `true`, the Spine AnimationState and the Skeleton will be automatically updated using the {@link Ticker.shared} instance. */
    set autoUpdate(value) {
      if (value && !this._autoUpdate) {
        Ticker.shared.add(this.internalUpdate, this);
      } else if (!value && this._autoUpdate) {
        Ticker.shared.remove(this.internalUpdate, this);
      }
      this._autoUpdate = value;
    }
    /** The bounds provider to use. If undefined the bounds will be dynamic, calculated when requested and based on the current frame. */
    get boundsProvider() {
      return this._boundsProvider;
    }
    set boundsProvider(value) {
      this._boundsProvider = value;
      if (value) {
        this._boundsDirty = false;
      }
      this.updateBounds();
    }
    /** If {@link Spine.autoUpdate} is `false`, this method allows to update the AnimationState and the Skeleton with the given delta. */
    update(dt) {
      this.internalUpdate(0, dt);
    }
    internalUpdate(_deltaFrame, deltaSeconds) {
      this._updateAndApplyState(deltaSeconds != null ? deltaSeconds : Ticker.shared.deltaMS / 1e3);
    }
    get bounds() {
      if (this._boundsDirty) {
        this.updateBounds();
      }
      return this._bounds;
    }
    /**
     * Set the position of the bone given in input through a {@link IPointData}.
     * @param bone: the bone name or the bone instance to set the position
     * @param outPos: the new position of the bone.
     * @throws {Error}: if the given bone is not found in the skeleton, an error is thrown
     */
    setBonePosition(bone, position) {
      const boneAux = bone;
      if (typeof bone === "string") {
        bone = this.skeleton.findBone(bone);
      }
      if (!bone)
        throw Error(`Cant set bone position, bone ${String(boneAux)} not found`);
      vectorAux.set(position.x, position.y);
      if (bone.parent) {
        const aux = bone.parent.worldToLocal(vectorAux);
        bone.x = aux.x;
        bone.y = -aux.y;
      } else {
        bone.x = vectorAux.x;
        bone.y = vectorAux.y;
      }
    }
    /**
     * Return the position of the bone given in input into an {@link IPointData}.
     * @param bone: the bone name or the bone instance to get the position from
     * @param outPos: an optional {@link IPointData} to use to return the bone position, rathern than instantiating a new object.
     * @returns {IPointData | undefined}: the position of the bone, or undefined if no matching bone is found in the skeleton
     */
    getBonePosition(bone, outPos) {
      const boneAux = bone;
      if (typeof bone === "string") {
        bone = this.skeleton.findBone(bone);
      }
      if (!bone) {
        console.error(`Cant set bone position! Bone ${String(boneAux)} not found`);
        return outPos;
      }
      if (!outPos) {
        outPos = { x: 0, y: 0 };
      }
      outPos.x = bone.worldX;
      outPos.y = bone.worldY;
      return outPos;
    }
    /**
     * Advance the state and skeleton by the given time, then update slot objects too.
     * The container transform is not updated.
     *
     * @param time the time at which to set the state
     */
    _updateAndApplyState(time) {
      this.hasNeverUpdated = false;
      this.state.update(time);
      this.skeleton.update(time);
      const { skeleton } = this;
      this.state.apply(skeleton);
      this.beforeUpdateWorldTransforms(this);
      skeleton.updateWorldTransform(Physics.update);
      this.afterUpdateWorldTransforms(this);
      this.updateSlotObjects();
      this._stateChanged = true;
      this.onViewUpdate();
    }
    /**
     * - validates the attachments - to flag if the attachments have changed this state
     * - transforms the attachments - to update the vertices of the attachments based on the new positions
     * @internal
     */
    _validateAndTransformAttachments() {
      if (!this._stateChanged)
        return;
      this._stateChanged = false;
      this.validateAttachments();
      this.transformAttachments();
    }
    validateAttachments() {
      const currentDrawOrder = this.skeleton.drawOrder;
      const lastAttachments = this._lastAttachments;
      let index = 0;
      let spineAttachmentsDirty = false;
      for (let i3 = 0; i3 < currentDrawOrder.length; i3++) {
        const slot = currentDrawOrder[i3];
        const attachment = slot.getAttachment();
        if (attachment) {
          if (attachment !== lastAttachments[index]) {
            spineAttachmentsDirty = true;
            lastAttachments[index] = attachment;
          }
          index++;
        }
      }
      if (index !== lastAttachments.length) {
        spineAttachmentsDirty = true;
        lastAttachments.length = index;
      }
      this.spineAttachmentsDirty || (this.spineAttachmentsDirty = spineAttachmentsDirty);
    }
    updateAndSetPixiMask(slot, last) {
      var _a2, _b;
      const attachment = slot.attachment;
      if (attachment && attachment instanceof ClippingAttachment) {
        const clip = (_a2 = this.clippingSlotToPixiMasks)[_b = slot.data.name] || (_a2[_b] = { slot, vertices: new Array() });
        clip.maskComputed = false;
        this.currentClippingSlot = clip;
        return;
      }
      let currentClippingSlot = this.currentClippingSlot;
      let slotObject = this._slotsObject[slot.data.name];
      if (currentClippingSlot && slotObject) {
        let mask = currentClippingSlot.mask;
        if (!mask) {
          mask = maskPool.obtain();
          currentClippingSlot.mask = mask;
          this.addChild(mask);
        }
        if (!currentClippingSlot.maskComputed) {
          let slotClipping = currentClippingSlot.slot;
          let clippingAttachment = slotClipping.attachment;
          currentClippingSlot.maskComputed = true;
          const worldVerticesLength = clippingAttachment.worldVerticesLength;
          const vertices = currentClippingSlot.vertices;
          clippingAttachment.computeWorldVertices(slotClipping, 0, worldVerticesLength, vertices, 0, 2);
          mask.clear().poly(vertices).stroke({ width: 0 }).fill({ alpha: 0.25 });
        }
        slotObject.container.mask = mask;
      } else if (slotObject == null ? void 0 : slotObject.container.mask) {
        slotObject.container.mask = null;
      }
      if (currentClippingSlot && currentClippingSlot.slot.attachment.endSlot == slot.data) {
        this.currentClippingSlot = void 0;
      }
      if (last) {
        for (const key in this.clippingSlotToPixiMasks) {
          const clippingSlotToPixiMask = this.clippingSlotToPixiMasks[key];
          if ((!(clippingSlotToPixiMask.slot.attachment instanceof ClippingAttachment) || !clippingSlotToPixiMask.maskComputed) && clippingSlotToPixiMask.mask) {
            this.removeChild(clippingSlotToPixiMask.mask);
            maskPool.free(clippingSlotToPixiMask.mask);
            clippingSlotToPixiMask.mask = void 0;
          }
        }
        this.currentClippingSlot = void 0;
      }
    }
    transformAttachments() {
      var _a2;
      const currentDrawOrder = this.skeleton.drawOrder;
      for (let i3 = 0; i3 < currentDrawOrder.length; i3++) {
        const slot = currentDrawOrder[i3];
        this.updateAndSetPixiMask(slot, i3 === currentDrawOrder.length - 1);
        const attachment = slot.getAttachment();
        if (attachment) {
          if (attachment instanceof MeshAttachment || attachment instanceof RegionAttachment) {
            const cacheData = this._getCachedData(slot, attachment);
            if (attachment instanceof RegionAttachment) {
              attachment.computeWorldVertices(slot, cacheData.vertices, 0, 2);
            } else {
              attachment.computeWorldVertices(slot, 0, attachment.worldVerticesLength, cacheData.vertices, 0, 2);
            }
            if (cacheData.uvs.length < attachment.uvs.length) {
              cacheData.uvs = new Float32Array(attachment.uvs.length);
            }
            fastCopy(attachment.uvs.buffer, cacheData.uvs.buffer);
            const skeleton = slot.bone.skeleton;
            const skeletonColor = skeleton.color;
            const slotColor = slot.color;
            const attachmentColor = attachment.color;
            const alpha = skeletonColor.a * slotColor.a * attachmentColor.a;
            cacheData.color.set(skeletonColor.r * slotColor.r * attachmentColor.r, skeletonColor.g * slotColor.g * attachmentColor.g, skeletonColor.b * slotColor.b * attachmentColor.b, alpha);
            if (this.alpha === 0 || alpha === 0) {
              if (!cacheData.skipRender)
                this.spineAttachmentsDirty = true;
              cacheData.skipRender = true;
            } else {
              if (cacheData.skipRender)
                this.spineAttachmentsDirty = true;
              cacheData.skipRender = cacheData.clipped = false;
              if (slot.darkColor) {
                cacheData.darkColor.setFromColor(slot.darkColor);
              }
              const texture = ((_a2 = attachment.region) == null ? void 0 : _a2.texture.texture) || Texture.EMPTY;
              if (cacheData.texture !== texture) {
                cacheData.texture = texture;
                this.spineTexturesDirty = true;
              }
              if (clipper.isClipping()) {
                this.updateClippingData(cacheData);
              }
            }
          } else if (attachment instanceof ClippingAttachment) {
            clipper.clipStart(slot, attachment);
            continue;
          }
        }
        clipper.clipEndWithSlot(slot);
      }
      clipper.clipEnd();
    }
    updateClippingData(cacheData) {
      cacheData.clipped = true;
      clipper.clipTrianglesUnpacked(cacheData.vertices, cacheData.indices, cacheData.indices.length, cacheData.uvs);
      const { clippedVertices, clippedUVs, clippedTriangles } = clipper;
      const verticesCount = clippedVertices.length / 2;
      const indicesCount = clippedTriangles.length;
      if (!cacheData.clippedData) {
        cacheData.clippedData = {
          vertices: new Float32Array(verticesCount * 2),
          uvs: new Float32Array(verticesCount * 2),
          vertexCount: verticesCount,
          indices: new Uint16Array(indicesCount),
          indicesCount
        };
        this.spineAttachmentsDirty = true;
      }
      const clippedData = cacheData.clippedData;
      const sizeChange = clippedData.vertexCount !== verticesCount || indicesCount !== clippedData.indicesCount;
      cacheData.skipRender = verticesCount === 0;
      if (sizeChange) {
        this.spineAttachmentsDirty = true;
        if (clippedData.vertexCount < verticesCount) {
          clippedData.vertices = new Float32Array(verticesCount * 2);
          clippedData.uvs = new Float32Array(verticesCount * 2);
        }
        if (clippedData.indices.length < indicesCount) {
          clippedData.indices = new Uint16Array(indicesCount);
        }
      }
      const { vertices, uvs, indices } = clippedData;
      for (let i3 = 0; i3 < verticesCount; i3++) {
        vertices[i3 * 2] = clippedVertices[i3 * 2];
        vertices[i3 * 2 + 1] = clippedVertices[i3 * 2 + 1];
        uvs[i3 * 2] = clippedUVs[i3 * 2];
        uvs[i3 * 2 + 1] = clippedUVs[i3 * 2 + 1];
      }
      clippedData.vertexCount = verticesCount;
      for (let i3 = 0; i3 < indicesCount; i3++) {
        if (indices[i3] !== clippedTriangles[i3]) {
          this.spineAttachmentsDirty = true;
          indices[i3] = clippedTriangles[i3];
        }
      }
      clippedData.indicesCount = indicesCount;
    }
    /**
     * ensure that attached containers map correctly to their slots
     * along with their position, rotation, scale, and visibility.
     */
    updateSlotObjects() {
      for (const i3 in this._slotsObject) {
        const slotAttachment = this._slotsObject[i3];
        if (!slotAttachment)
          continue;
        this.updateSlotObject(slotAttachment);
      }
    }
    updateSlotObject(slotAttachment) {
      const { slot, container } = slotAttachment;
      const followAttachmentValue = slotAttachment.followAttachmentTimeline ? Boolean(slot.attachment) : true;
      container.visible = this.skeleton.drawOrder.includes(slot) && followAttachmentValue;
      if (container.visible) {
        let bone = slot.bone;
        container.position.set(bone.worldX, bone.worldY);
        container.angle = bone.getWorldRotationX();
        let cumulativeScaleX = 1;
        let cumulativeScaleY = 1;
        while (bone) {
          cumulativeScaleX *= bone.scaleX;
          cumulativeScaleY *= bone.scaleY;
          bone = bone.parent;
        }
        ;
        if (cumulativeScaleX < 0)
          container.angle -= 180;
        container.scale.set(slot.bone.getWorldScaleX() * Math.sign(cumulativeScaleX), slot.bone.getWorldScaleY() * Math.sign(cumulativeScaleY));
        container.alpha = this.skeleton.color.a * slot.color.a;
      }
    }
    /** @internal */
    _getCachedData(slot, attachment) {
      return this.attachmentCacheData[slot.data.index][attachment.name] || this.initCachedData(slot, attachment);
    }
    initCachedData(slot, attachment) {
      var _a2, _b;
      let vertices;
      if (attachment instanceof RegionAttachment) {
        vertices = new Float32Array(8);
        this.attachmentCacheData[slot.data.index][attachment.name] = {
          id: `${slot.data.index}-${attachment.name}`,
          vertices,
          clipped: false,
          indices: [0, 1, 2, 0, 2, 3],
          uvs: new Float32Array(attachment.uvs.length),
          color: new Color2(1, 1, 1, 1),
          darkColor: new Color2(0, 0, 0, 0),
          darkTint: this.darkTint,
          skipRender: false,
          texture: (_a2 = attachment.region) == null ? void 0 : _a2.texture.texture
        };
      } else {
        vertices = new Float32Array(attachment.worldVerticesLength);
        this.attachmentCacheData[slot.data.index][attachment.name] = {
          id: `${slot.data.index}-${attachment.name}`,
          vertices,
          clipped: false,
          indices: attachment.triangles,
          uvs: new Float32Array(attachment.uvs.length),
          color: new Color2(1, 1, 1, 1),
          darkColor: new Color2(0, 0, 0, 0),
          darkTint: this.darkTint,
          skipRender: false,
          texture: (_b = attachment.region) == null ? void 0 : _b.texture.texture
        };
      }
      return this.attachmentCacheData[slot.data.index][attachment.name];
    }
    onViewUpdate() {
      var _a2;
      this._didViewChangeTick++;
      if (!this._boundsProvider) {
        this._boundsDirty = true;
      }
      if (this.didViewUpdate)
        return;
      this.didViewUpdate = true;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.onChildViewUpdate(this);
      }
      (_a2 = this.debug) == null ? void 0 : _a2.renderDebug(this);
    }
    /**
     * Attaches a PixiJS container to a specified slot. This will map the world transform of the slots bone
     * to the attached container. A container can only be attached to one slot at a time.
     *
     * @param container - The container to attach to the slot
     * @param slotRef - The slot id or  slot to attach to
     * @param options - Optional settings for the attachment.
     * @param options.followAttachmentTimeline - If true, the attachment will follow the slot's attachment timeline.
     */
    addSlotObject(slot, container, options) {
      var _a2;
      slot = this.getSlotFromRef(slot);
      for (const i3 in this._slotsObject) {
        if (((_a2 = this._slotsObject[i3]) == null ? void 0 : _a2.container) === container) {
          this.removeSlotObject(this._slotsObject[i3].slot);
        }
      }
      this.removeSlotObject(slot);
      container.includeInBuild = false;
      this.addChild(container);
      const slotObject = {
        container,
        slot,
        followAttachmentTimeline: (options == null ? void 0 : options.followAttachmentTimeline) || false
      };
      this._slotsObject[slot.data.name] = slotObject;
      this.updateSlotObject(slotObject);
    }
    /**
     * Removes a PixiJS container from the slot it is attached to.
     *
     * @param container - The container to detach from the slot
     * @param slotOrContainer - The container, slot id or slot to detach from
     */
    removeSlotObject(slotOrContainer) {
      var _a2, _b;
      let containerToRemove;
      if (slotOrContainer instanceof Container) {
        for (const i3 in this._slotsObject) {
          if (((_a2 = this._slotsObject[i3]) == null ? void 0 : _a2.container) === slotOrContainer) {
            this._slotsObject[i3] = null;
            containerToRemove = slotOrContainer;
            break;
          }
        }
      } else {
        const slot = this.getSlotFromRef(slotOrContainer);
        containerToRemove = (_b = this._slotsObject[slot.data.name]) == null ? void 0 : _b.container;
        this._slotsObject[slot.data.name] = null;
      }
      if (containerToRemove) {
        this.removeChild(containerToRemove);
        containerToRemove.includeInBuild = true;
      }
    }
    /**
     * Removes all PixiJS containers attached to any slot.
     */
    removeSlotObjects() {
      Object.entries(this._slotsObject).forEach(([slotName, slotObject]) => {
        if (slotObject)
          slotObject.container.removeFromParent();
        delete this._slotsObject[slotName];
      });
    }
    /**
     * Returns a container attached to a slot, or undefined if no container is attached.
     *
     * @param slotRef - The slot id or slot to get the attachment from
     * @returns - The container attached to the slot
     */
    getSlotObject(slot) {
      var _a2;
      slot = this.getSlotFromRef(slot);
      return (_a2 = this._slotsObject[slot.data.name]) == null ? void 0 : _a2.container;
    }
    updateBounds() {
      this._boundsDirty = false;
      this.skeletonBounds || (this.skeletonBounds = new SkeletonBounds());
      const skeletonBounds = this.skeletonBounds;
      skeletonBounds.update(this.skeleton, true);
      if (this._boundsProvider) {
        const boundsSpine = this._boundsProvider.calculateBounds(this);
        const bounds = this._bounds;
        bounds.clear();
        bounds.x = boundsSpine.x;
        bounds.y = boundsSpine.y;
        bounds.width = boundsSpine.width;
        bounds.height = boundsSpine.height;
      } else if (skeletonBounds.minX === Infinity) {
        if (this.hasNeverUpdated) {
          this._updateAndApplyState(0);
          this._boundsDirty = false;
        }
        this._validateAndTransformAttachments();
        const drawOrder = this.skeleton.drawOrder;
        const bounds = this._bounds;
        bounds.clear();
        for (let i3 = 0; i3 < drawOrder.length; i3++) {
          const slot = drawOrder[i3];
          const attachment = slot.getAttachment();
          if (attachment && (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)) {
            const cacheData = this._getCachedData(slot, attachment);
            bounds.addVertexData(cacheData.vertices, 0, cacheData.vertices.length);
          }
        }
      } else {
        this._bounds.minX = skeletonBounds.minX;
        this._bounds.minY = skeletonBounds.minY;
        this._bounds.maxX = skeletonBounds.maxX;
        this._bounds.maxY = skeletonBounds.maxY;
      }
    }
    /** @internal */
    addBounds(bounds) {
      bounds.addBounds(this.bounds);
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
     */
    destroy(options = false) {
      super.destroy(options);
      Ticker.shared.remove(this.internalUpdate, this);
      this.state.clearListeners();
      this.debug = void 0;
      this.skeleton = null;
      this.state = null;
      this._slotsObject = null;
      this._lastAttachments.length = 0;
      this.attachmentCacheData = null;
    }
    /** Converts a point from the skeleton coordinate system to the Pixi world coordinate system. */
    skeletonToPixiWorldCoordinates(point) {
      this.worldTransform.apply(point, point);
    }
    /** Converts a point from the Pixi world coordinate system to the skeleton coordinate system. */
    pixiWorldCoordinatesToSkeleton(point) {
      this.worldTransform.applyInverse(point, point);
    }
    /** Converts a point from the Pixi world coordinate system to the bone's local coordinate system. */
    pixiWorldCoordinatesToBone(point, bone) {
      this.pixiWorldCoordinatesToSkeleton(point);
      if (bone.parent) {
        bone.parent.worldToLocal(point);
      } else {
        bone.worldToLocal(point);
      }
    }
    /**
     * Use this method to instantiate a Spine game object.
     * Before instantiating a Spine game object, the skeleton (`.skel` or `.json`) and the atlas text files must be loaded into the Assets. For example:
     * ```
     * PIXI.Assets.add("sackData", "/assets/sack-pro.skel");
     * PIXI.Assets.add("sackAtlas", "/assets/sack-pma.atlas");
     * await PIXI.Assets.load(["sackData", "sackAtlas"]);
     * ```
     * Once a Spine game object is created, its skeleton data is cached into {@link Cache} using the key:
     * `${skeletonAssetName}-${atlasAssetName}-${options?.scale ?? 1}`
     *
     * @param options - Options to configure the Spine game object. See {@link SpineFromOptions}
     * @returns {Spine} The Spine game object instantiated
     */
    static from({ skeleton, atlas, scale = 1, darkTint, autoUpdate = true, boundsProvider }) {
      const cacheKey = `${skeleton}-${atlas}-${scale}`;
      if (Cache.has(cacheKey)) {
        return new _Spine({
          skeletonData: Cache.get(cacheKey),
          darkTint,
          autoUpdate,
          boundsProvider
        });
      }
      const skeletonAsset = Assets.get(skeleton);
      const atlasAsset = Assets.get(atlas);
      const attachmentLoader = new AtlasAttachmentLoader(atlasAsset);
      const parser = skeletonAsset instanceof Uint8Array ? new SkeletonBinary(attachmentLoader) : new SkeletonJson(attachmentLoader);
      parser.scale = scale;
      const skeletonData = parser.readSkeletonData(skeletonAsset);
      Cache.set(cacheKey, skeletonData);
      return new _Spine({
        skeletonData,
        darkTint,
        autoUpdate,
        boundsProvider
      });
    }
  };

  // assets/background.webp
  var background_default = "data:image/webp;base64,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";

  // assets/title.webp
  var title_default = "data:image/webp;base64,UklGRiBeAABXRUJQVlA4WAoAAAAQAAAAGQIAkwAAQUxQSGgfAAAB8EZt23Ol2bbtlijFXrBHjYIFRSVRNO1SsBfsRmInxHKJQiQas2IvlwXrbY8xBRBEUVFJolETQVBRMSj2S70ElVgSUaNiS44fc85znudkzkny646ICZD/P6x7o3e79e3fq8vbXuW01GjTpk0bv/e1vtvG7FseNlDKxaX4PyXFXMpWrFanvldzX7/365e0pqJPjzFoHR/YqqpIvfeCpmDgpx+8XV6/ct5dgz8F+GRUjxaV/rHw8O09aGjw6NBJn2HlqI71Lbm3HQMwP3Z/xpmzmUf3xS4CmNAeYE1ycnLy9we17k82u3sVEOGti1vT3qGYzpozZxqmYf3bVLGqfK061SpXcC3195hrTa+Wbd72a1lZW/1BEWiMnLNwyaoNX8cmJn13cNMM4D0zLn5TYH7iiXtK6/1fkqKAA1deKgOfXUqALtaV8Z8CLE44dvOZUko9uXFi+zKAUV4aPN7sHYrFzyaGfNinU6sqf195+PYOxXJ4f78aFt4FVu7KunDt5p38py+VlTd/giARaRAKcReUnv9LuKwMPwbe1jSbDLFH85WVj8/unAFdLfgCLF63YdWyqLmzsPjJwLbuml6r36S+R5nif6+UqdmkpV/b1nWLa3HpEgEwd13MjuR93+1YBuBnJggOFigDry7jfWkP0edU4T1GRHlNLt0gPkfpmwohtUSkVCDsOv1AWXz5MO/K6fSdK4CwRubcmnQKxnzEuJGDevq/1aBS8b87arcdFI7lEQFeLmYahMLKXVn5yvLjc99Bf3eRd1l6RRl7FbrCIVWoEwjU0iCUyONK99sboJZIILOzlJ5Pz2+GABPPicDMr+M2rVwwHY0jArxc/7ZoNPRzgAXr4nZ898OejdOA0AYi0h6if1VWn19Af6kPV5TRP0HkGVW48wnX0B6i7ygj9xIivszOV3qnQSMRf4g9ckuZL/gt9+LJlN3fLJ0GEPwvD20lPMqXKFIVq96614jxERER44YEeLlqCQDW773wRFnOTY2G9tIADik9nyzAL4iDyviF826qwr6cyhbawyFl8Aa6QpbSP40wd09IVbrmpsbMBIbUMefWKGAkQPhHg7q/17JBlZJFHZeGHYZj5ejuzdzNjIC0v5TVh6BBKIeUvudhMi9sIP62KvQ7aGmuIRxVRt8GNisjN9N4IqlK/2u7gC6uItLkE2D6ysXTsTy2t69H0aVq1wggcvWezJz7BQUFv11NjZkHEFhNJIDVuUrPQ4QSrfSOhdXKBq+owp9JLzMuoaQo4/dBhiHp9CVWGfpqH0xoKJ0gNu2GUko9vnXx+IEd3yyfARAxyK9qUaRiIBCdcl1ZeTcjDujaCHKVvtGQotth2GML9vB3xpnpRbSywYvw1JCbhPHIGKXyYiAQjiir72XtWgnwka+rs+be2H/Qx+ERERNDevt6aPL5DJJuK13zd0MYaUrnFLiuWy5kO4Y/+dykFbPu28IzNitjZ7JMGZ8Cc24pfQvOJc2C8GZ6uNaoV7dWuWLOSzmfHmPRHjGobUUzxbtDYr7S/fZmFii9rxOp9J/OacegZlFKpMLn/KJs8v9OGPQV221AHeW0MjArBgaU0VbJp8dYzAd3a1beGfH6EGD+5pSLtx8XFDzKy9q1EqC1iFT8iOknlaFpcbqpyOkGzOe4g5hNaZGebFO2+cVzg37kpC2oFGVsBoQ3tlSzRxjA3DVfbly3OBJgQp83KzkXNT8CEk7eU9oLLiRCX9dKk1l/Txn8P/3W81y/ZaQ5hldMFSkPv9lInDL4HL/ZhOFP4iDATKVBwNLtJ+8p87cytkYBfPx2WefBD2alvlJ6Zs9jwmckvlSFNo4H+q3loGO4z3iRdiQo2/z1pFEPeWoPlEqHziLi8xl8f09Z++D09rlABzfnwL0/fK/0fhQDO16pwpvELf2+Jtkx/EKgyCgu2MixF0apBcpOXoIOxbvD9gKl76UtMNHTGagVxoLzSv/H/9n4ShXi/VzRL54djiGJVuLGDGWjW5ThMfZCnYchTD+p9L8eC/6OrxbEPVFGnruvCvNRsvVLIt4xrKCqeBFrIy9+Me4nu6FSYcU9ZWgqeDq6arBX2fHTZOi3l28dwmMmiQRw2Eb2vzTusv1QMSseKoNTmejm2Ep8zB5lz69wSL9DfOEQkukvMpJc23gcr4x/Ykfy7irDY+nj2HrwhbLrt/lBvwxWOYJsqCHFma5sM+GMDTjWh0xwaC2Y8Zt9e8QO/U4TVfjyjcueR2uRGqyxjWP85WSoKCo4sIpTyVT2/RWx+l1iXqG7OjvrT4OSoa+INGOrTeSRoJzNbTRzYH1IVPZ+zhf65TKjsP0EsO4H/fZtAFqLiLzDj7ZwaT5nnI7jdHdcVeGB3Vu2Qr978GfhKJgXezg372j8Qnh/yFSS9dsIw2qIaSfS9bv42MJ+4C+nI4cRjiuAJGX31y/Q7w94Wkhg9Z7sO8e3RUGHNsbUFfM9OalfJsu2n8w9HDsPSFBOZwr+jiuUXPsXM0O/l5BfONTxF8p8CnSzjV5kGhGdkqNyUqKBM85HNJ4OqyKLlf3fyQvd1Ax+LSRar0/DNnpyUr/8Z8r8mbn85XzMxcVh+ZDoAPbxQL+zl3MKnTpnI/6k6Kf1QYJyOm/zsTjsHpxwAGn8qp99PGTEKqpZ8OM7W1B3nI/v6eq4xnDPAdx9UmDfVLRNNORbm3A+X0BNh+XOfFUEPGcT5VjklO0mSBx2fTYVBdROW5Dx5DthV6Ca4/JlV5HghE0EkuWERfOeOO532W/ccWfohU34kuR8pRDq4sACSNXvwpFbSuUdjV/mDBmoqSrLna+zUNGBvc9B/a5ATGqOykktKsgn/O50qUQ6OrB3+FG/O7PTlPOvrRf7na+bjHNgLdiuX9FQW12mOV9qAWUcV302FZ1kBAecrziaOK6yLCxC1YO7TtcROjkuCedxkWYlHlqkOzFO1y2CHVh/zhVpIimmyXUCqc7WK6Y6MD++c4JuG3fioV7XGS7aPeGsk6XAgdVkrRN07IxRd6ed0SuFDlZIB7jsXL1gsgOTz3jp/CSQasyTjcTpFU1Da6QzZDhV9xjryIK46PScA2J/NeDqMsJJ1+cQoS5WSUc45Exl0duRtWO7s/P4P/hNhB91+wmCGkO6HoeggejYHqKzbemYg9uFryOrBH85N/e/pp+4dYHp+27rkPPDTHhPpCPEnXui7f7JaGgvujYIhfhcfV7qcYnDjm0lHo5MhpFiP+4+sz/3f5nFODcReX0kELU1446lgisHNs0AguuLiDQOB5bvyLhw7dq1a2ePxi8EQhuIzi6tp0J0So41d09sY+Ndq/YDpx1ZARHi0D2ZZjcerthWSF7t2HI0T8uzx/l5uVfPZ51I37II6PWamK3TdQLA7NXfxsZ+vW4+pqP8a4n5Mn4DwtH870AfF9G/bMAkIHLDvjM37z8uyL91PiV2HmZX7T79wMKD07vngT/sdmDZDHJsMoLv7ET+asgw5Ldf9Xjx6Nz36zCd/U3sxrUro+bNQvv4wFaitXyzbqOxGPHhe/VKiJWVW3YbNHTo0KH9uzQtK0a7ePoPx8ox3ZtX6P4pwNyVm2JjN0UBjKkrvjBtT/YjbfmOI4HWDq4GnLWNB0blLmQEkZn6PcucwfIdmb/fy718JiNlb1L81+uWzZ+O6dQhTbuEoPHT8NCQkUMG9u7eybus6Fi6ekMvrzdquosdLFanXd/g8eERocED/b3cxKzHm30mYH5Cnzc9REQ8RgAsTfz5RPb58+ezjyUsJubkPYPO2MJfNvE7lHNw0ob5f9hE8kVj0mBAqa6w80+rXj3M++/pXf8HhKPjlIkD/GqKaekGXnVrelRwKyWO39WjvpdX/QqisXrrfmFongDM35x26c6Tv5RSt47Ez92r7UIshw17vjXNJhLpJQ6/H7G2kAOHDLi9GQJEpMVUWL/3wtMHNy9lHd63I3r90tmYj/ighVRu2Wvc2JFBfbv5t/Nt+kbNyu4lxHmu6NO+R7+BAwf26+pdztWnx1jMz5ozC9M5B668NHmUvWcxwGGDLi6CGzZwis8rOj63iSTbwP8B0Zk63U6CsEZiWmXo51g7dWJIUJ83PaSo6d644+DR4QAfdW5SOwRgzbb4JQCh7fwh9sqf+uVth8GsNu73mbQUJ7A6bH9l1C6GNQiFBT/etOpmagzQ1V0s1247cNKE4MG9A9q19KxdqbQUbUu5lBLTeu8FTQGY2Ld1dRHxmgis/+H87afW5aREA+1kBHuMKthAT3EKq09h1a+G3N4AVcWl5Thg5lcHrzwxc//ywU0zgM+6VpW/A2s0b1pRLLq9N/RzTGcs/WLLD+lnrubl5V3L2rshEviscyWRahD3xJCCLYSUdA6k0nA4ZkBGJCFVxfT1TsGYzlgYNS8S01EdPV3FYZZ2KVuhgjElX2/q4+PzVps2Pj5NvepXdjDW12o78ONJWD3c39NFTKuFs/C8Ab9/wSdlxWnsAnG5OmXFQlfRWLL++x+GYzo+6P36JcXOFnNxcSlpqXjdd3v1Hxg0dGTI6NAJERGYn9DnTQ993Bt3HIW14QP8aurl4uk/Inho0MA+vTp3er9dK8+qxe2Q2ZKVXvdu26nvkJCQkKG929UpJhrdB8Cex3qdmklIWXEivSNg86kCax5kbZ8Jk5qJ1SXLVnArJoW+RJXXm/j4tvSuYKZOu0Hjp2A6NbhjY3eXgBFYP3vOwqgogHZ6NAoDZnwRn5iYuDs5OTExPvbr5QDtdGn8MTqOCPBytUfGtgW2/vJYh9vboGdJcSrLBEwFVu7Kum/mWW7G1iiAYF83scPujTsFY3lCnzeHYTZyzpw5MzANhWkb92eePf/fa7l5d/IfFBQo8w9O74aBZawKgM3pN5W1T859DwPLWBcAc6NTcm5du3z+dOaR9IN7d0avmAbwcUA1PSq37BU8CQgb1bNVFfsi1foDrEzKyteSkxINn7cUp9O91aAIgBmLo6LmYDqhj28lKeyvVapZv3GLNu+2rqbFaxzA9OVfxCUm7dgShemGfRfvv1Cmr26mb/4P0blK/wuLGG5NI0hT+l5YxECrRkK60jE3NWYOMKSmtoqtB4Sj/ZOBbavaEZHyrfpPApjzRdLB9PSfdqyJBD7rWkGcUw/f3uMx/XRkt2blpXDXatvrwzERaJw8+B13M/6wIC79prL84PTuU8rqLGXo01X4a3MPI03p/XQR7awIYM0NpXfuHqCNhrpBAMt3ZN56+pf669GNkztXAHzUwsWCe6OOo4b07fJOK69aFUsVDtOqvoGhaBzu7+kizmzJchUqlJZCXv5fQ6ZidubStZs2b0/ev2c1EOYlIsMhVRX2XPDS5Mdmpf8FqK2pMdxQBv75HfRzM1O+H5CY/URpf3o+aRaENjCpNxbtU8aPHNDtPV/PmmWL25ipy+u+73fq9H7LGsWkKFmyckPfdwI6der0Xr0SWrwjgHU/ZF65W6A0Pr+8GQLEn1U5qvAfprumwZwzQO3lHU2jSVfGnp3PxDIi4h0B+18qXTOjob3IOzB/c9qNq2eO/rgzZt2SWWgNH92tWXmTYjZTBC3n3TUEzaM61jfXBbZe+1PpmQZekKPs4F1Ga3GZynMjLhGkxZW5yug/YgkvI11g6x9K90MweCAcUNpf3M89l3EgKXrtwumYTnivw3DCRvXv5Ne0drniRatGvUMBZiz7dtePh9PT0w9smgG8a+INGUrvNMJIVXZxHq4aPIlWRr5kqosGT2IMU0/j+WAQZCgjry6BRZeV/o/vZGyNAojE8sSR/Tr5Na1dtghSolqTd7v1HzosZFhv36pmOgGLE47lKc03DkKQSPkIMpT+myHXPsTgpcGfFENUNJ4a/Ek1Tj2NgsW3lLEvtnFRGX0lOuW6enTjbPr38esXTcPiv3u1rFKEcGsUMBLtkwbVqz4K0vKVjleW0lFas1UZmME0ZR9TCdAwihxjUvDXMIIcG1CXWZavDN+nbPxhbnb69/HrFwK0KyK4+o0CmL4qbn/G2Wv/y7uelbQS07U3lb43oXFfso0oYKOdOEt/S+7MUMbmMFzDeO7bgtr/u7Lbv5/aCQPLWCpZr133QYMH9mrvXcnpajgBZsSm3VDaCw5AstI9nfCJPDJCxf1oJ64x1FJjNhukInGxFEq+Tdj5C4sINnFv1HEUWsP6ta7uTHWAmHNKz8trlYHLYYkyNHOXncgjxFJX0o2KxtPSJJ46PvV0HZ3k9QEAM77ce+LipfOZP29ZCjCpe00nolS5Cq7F9GsIKUrnm0bsgERjXibYiWsMtTSO20al4G8pggInQN2CwcDmtBtK66Ps5JXAkBrOQPlm3YI/xTSkS9OyurhOIEUVwkxIM0bF24nLBFmowAJldA7DLcFfzoA6Cvz4ROl493vgfRcN5bx9GlQp7mDKt+wzAdNZi6PmRgL8O7CJi1XexKjC+Dv816AzduIYXS20ZJthKhIXDcopvMuO50rnP5MhtIFJOd/A8Zgd1bGRu8N44wOAqK0ZN58p07yj8QuBSe3crOjKsUKhpvPYoL/sxBa8LfQl07hoPM2VYpZzoE4pA69GQ3uRppOARVsSv1k+HWBst0ZuDqDqh0BC5gNl5f0j0TDRU1sItwvH0vnKIS6inIVPeGhcCv7mXJjjJBh8CDp0hoSsfGX2Rtrm+cAUPxPXOjUrFrcfpWu36tKtWXkLvsBPz5SuF2LBX0tp5qjC+e0mh5DPeDFfjRXK+ByGmyvLQmdIHQE4prTfSYuFfs26fYzpmEBfj8JWvGrT9gPHY35CH3eRUoGQ9FLpngoDXSw15NtCkvydQzhAoIW27LEBFYmrmQpEOUUqA44p68/9B2DuhnVLpgFEDGrnISJVWwWODHy3ceViNuRWzy8wBLOz1+88mrE1CsIalQ1hdpYy8toixrhbqMvGQnI00xFchnoWgjhvCzF4mqnKCudIHUpQej7evDXjjjK9e2rXSoA+AydheXiHhi6GFavcpP2gCZhOWxH/8/n7yvyDzfAJX+QrYx9+yccu5iqzvJBcznMAl5fwjph3+ZwXtpCKv5lqrHKS1Dld1FOlueDiLoAVSb/kntq/eVkkQHCnWvq5egWMxOy8L787laesTYMtBcroJxvpb86VuYXkd+UALzFYLHoSrWwxhxFmarPeWXqij/UPouOfKsvXU6JnAn46tR4NELks7ueLD5S+adEFyviHC2hvRqbyqnDYx/NGPWeyJX9SbEJNw8WkLhudpcJ68wfor4dLH5gXk5qrDP1D2eJVaGhmAg8c1xmj1GxKWxhOjm1E42nSgG+KNkqdX4CfdS4TmJet7GMKoS4mo7jhsPIyDVtAGXNuRCrbTMHfxIvYoo46D7Ws6kPMQ2Uvo/EzGcwlh6XOGTab0ua8iLWRHIabeLOlyKN+oJ81rZn3UNnNc0xyEZGenHRchj9nspgP4LCNqEhcRMSHxKLPH4RZM5lsZUejaS4iHTjktPwPmpr7iBu2Ek1DEfElqeijllJJWzVWK3t6nMEi0oZkp0UdY1I5kzLMUraaQgcRaUOyg3h55ZQD246PtrfYY1eeg5uIN1ucF5XAByZNiLOZ6wwXkXbsdQx74IoDO0lPbX05Y1dULI1E6vGlE/MM6ohIN47YjIqkmMj7HHQM8XDPgW2nhbaJPLQvaQSIVGWFE6P20U5ExnHHdlZTXaQ9PzuGDfDcgS2jsjb4y77cYKSIO/OdmYsMEinPAmW7yfiJdCLdMSxjjnLcjwkX7WH8YV/UdEqIfM6fTkwBESLN2WpD5xgo0oWjjmEWKxzYOQZYMYobduYL6ohM5JETo1biIYGcsKGnTBLpRaZDeMFu5cB/oK0VvcmyM/t4WySYW87MdlrIRO7bkFqJhwTyi1G3o3PswW+nlSNfTy0rfEmyM6fpIzKYS87Mj7xTiSXKlnfzlgzkvEEZkGIPriuHPp0SVlRlpZ25TYhIIKecmTQ6+rDdps7QVwZxwZBTsUC0LT3WzbHfYKRYO4kC+/KMT0X8SXFmDvBeD07a1EMmylCu6XbrSPx0CG82mXs2dMopSSPAqkGcsy9qJq+JH987MztpNZZ7NqWWUGEY/9NtETCylZv0YLcNXXZKYmlklR+JdmYR5cSbBGfmC15nvrLtbTQPIU+3OTQpIyLiAfk2c+qWUzIXN6sqwkP7EkUFqc9Xzsw0io/lnm0tpVJPTuo2g5JiNpAEm5n5yBm5w2ixvg+x9qcqK5yYXEZID07a1CPCxIftet1glJgvH8ExG0nmlTNynO46uE3ksF2Zh5u48x8nJpUA8WG7TWXTTyqxVK80OloQb/jVJrKZq5zRbTTXQbzgsD2JpJgUI9KJicFLKsEFXa5f1ymZ1iJh/KHTZhpZki4sfWgDd2ey3ClZQkU9xB9ij9+1F3cYLSJh/OG0pDLBVaQdi57q8GDlyie6ZEN1kX7E6nMG3DVIEGsfGfb7UtjgjDwiTPT1mgjMi7ljF07SU0RC+NWB3TTmAniKiAxkyWWrzsyFhRd0yJ7HWyLiNpHDejyYy1ui1WUUy+8adHMhQcx0RrLpp5O4Ne8+Gk7bhe34iEgQlx3W8x3TThixFzqIaZnBcOC/LzTcOb4Veg+Avde1/XktGfqIqRfE/mHVmbn0Fu2uHzLthCHHYEDJYG45Icm00cu0HXvtwlIqiUhvsuzELZu4oO1ngMTTD6z7q6Dg+qFv50BbsfgOwJqdh9LTU36MmQvwlkhbgA37si5eu3T+1NEf1gO8Jea9JsL2k/c03Dm+DXqXtkKKdYPEZ7o9SoDOIp044oSspaYRb/C1PfiDMBGRAFLtQ9rau8bd3Af7L78w+S1zBzC4+WRgcULi1tiYjRtXr1oa9Z85M7EYUls01ns3aAqWR3drVl5EpHaHYWj+fOi/qotlt34A87/csispMf7ruQBviY7Np8CBZ7q83A+TmopIE+KckGkUN6IMC+xBFv1M2vKDXTgJ005Y83vm5vmxaTfuFzzJ/y337MFNMzC/OvbbBQDD3hCp+GbvUKyPiBjWoWFpsbpGqw6dOvm/4+Uqmuu06z1o6OCBgV3a1hJrK/n0GIvl0d2aVRBdK34AJGT+bsXj7ESgbzkRkTLhpOuT4shyGSGGhvPYDsTha1KL9Xbg1Q7oBmuSsx+ZPL9zKTVuAdaP6lin7rtBkwHG9WxRWSyWb+bTzMurbt3q1SpVcHd5Teypez1vX1+fpvVdxcB6HwAsjD/yv/zn6tWTmye3LwP4sK6YbwzpelyNdmSpBBgTxH91u2Q7t6GMiXzOn4XhmZY/zu6Cz3yk+RSAeVFR8zA7rldL90YBo8ZHhIeOG9n//folxXx1r4ZlxJks37LXv9Ee1r91RdHYEeLyrDo1ixQHFoOXMQGk6nbbdrbRVcwO5ZrNvTi/mVW7T1/L+W92yvalAEMqi4hUb90vDGDy6MEBTcqIM12mSedhoZOZ+klwzxaVxNrG4bA4IeO2pfysJIDTxhx/bM9m4WpMMxJ0U0dsJZOpFcz9i502cOj4HQsPspPXAJ+iMaxfGw/R6FahgpsUMct0DgWYsWxTfFLSlkXA5y3bw24j7kz75okdm4OLMR6s1G/Vr7bx2wxaiPkqUzmlx2UtN1Kjgbkxidui18wFmBLk5+7xZp+hI4L6+reoJEXh8s26fozF8YG+VUXehGkb919+pk/eelifb7+iaWhMcabptzXaNr6kh1huycxT1u1iaeKJe3nXsg5smgGEdhuN+Qn9WleXonnJyvWb+vp6lxPz1UZgOnv51zsOnrx897mWY/DRR8y7YMizQpWCvzESzC3dUjhkC98xpoQG6Qk7n2i5e2JbJJpHdfR0EXH18mnuWcNV/kYsXvedoE+xPGfFNzsPnrz048Zp0FlK9YVDBlxa/KIwJdDMoJ6c1O0SHDVuL9QQzS2nwvKdp27mXcv+OXYewHCPij49xoYM7f1evRLyt2bpKm+0fL9n0JjJaBzhLSLSHqJ/0enpbrhcmFZQ1aA2JOv2AEgx6PFmqC1WVhnwCRrHdG9eQf5+LV21Qav3ew5+5/ViYr5BKCzYn2ddbhLA/sI0jeIG1WWjbmoOEHPPiHMLCKstOlZpGRgcMrRfey83+bvYpdU4YF7s4VxLN9Ji5wMD68LlwnODUWKwC3OMaDiB6Sf0S4b+7vJ3ed0uYwCmLfkiNvarldMBxgRUFXmHqF8LzXG6GyWh5Ot1mxBx7QHx13Up+CkS/ORvdTevgJFYHBXQyE3MfgDHCssufA0LJEuvY3QVEZ8pEJN+14q8o3HA8Ory93vxiq97edX3KCFau0B0So62e7ayEg/DfEnSKwFvEZGyHSYD82JSr+Y/f/H07sWfv5kNMOgN+afQOwKIXJOceeOxUg/P7Fm9+oZtFBAhhldlpU7HmFTORMS1cffRaA/p0tRd/kF08fQfjtnIOZhNs4mLDDJOJnFUl2vQVLS6egUMCZ08edKYQe0blJJ/IIvVaNNrVDhM7PtWtQCYmXDstqaHuuyknQ00hTwdUqCz/PNarLSYNgoGmPPNvtM3nzz/LXPHsnnZOmQytYoNSGcWXbQiLyUa2ss/ueW8u4agPe7ILSsyZ9JCbHIg7Lv4zMyzqz9/MxsIbSj/+JZu8Haf4PDJ43q2qNwaYOamfWfzzby8shN6io22A/i/bVu+XIRpSBdPF/lnuUyTTsGYzlwVl7wGmNpCbLbO2x9EYPrpkPYNSsk/06/Vb9c/FNMpQe9VEdv2aO5dr5z80/1atSZtasj/vxJWUDggkj4AADDJAJ0BKhoClAA+kTqZSCWjIqEvVdtYsBIJbG78ZpwCZmlzCl6sq+fmvy79kCu/4f+y/5P1MdQ3THle9B/pH2tf3D9gP9H8Cf6Z/jP2Z+AL+rf47z3PUb+8P4zfAr+wf6z94PeL/1/7h//P4Mf33/WewB/df+b6b3sW/4z/w///3EP59/sf//7Tf/o/e74c/7Z/4fTg///sAf//25eA4/of4YftV8w+939F/fP2/86/yT6F/U/3jzu8VfWzqg/M/wb/C/wPoV/0vB35U/6H3G/Ij+Y/2D/X/3HyP9rrbX0JvdT7P/0f8T6qXyn7P+sn2S/8fuC/rz46f6l+Zn+C/5HsFfzP/H/s37JH2B6KvrX2GP2J9Lr//+5X92f//7p/7st1RjF/AF9i+V4l5Dajz1WQgkpTf9osjKD6Ffj8uTfS1Gkt9DXTHqPBZYiskxjGomZQOQS7UjyQOf1uPmFfy7mjGyDukowaRR6UmgUbINBerWblbQlJ2171nzjl4JrZfraYqCkMqkcNG64mKJYeweLfbD0AAHvf4Y/hOOhUiJ+cJg3OtcGXINSmWC/htngctGwokPJOBld+aWhETJ3uuKPlZpDSotTwqYKhFkCxj6twhxE0Ech5asZd9TfJ6vA1AnyDuX+TRU/9yXNc4e962yekGLvDqtsIcBpRdTkEscGsN4i1p8vq3F99QPE8RWhMKh3Jksze0KKhSy8TVN/DNsYezcW/PVq2bwXoUYu+Ruc1NC+206Y/FGRthKrX4J8z1pTGlBExWrNQ9lofr9P60ZyIWEFCMhNhJGalP1N7y7D0h+VdDM2sdPhnPkiOcDRD4X8DGYxipdr7kSczOWk4DKFLlt2Ccpm0x3pApNe1gnxGLcH+UM/vH8C2kiH0+nEQFjpSnmAxftoGXkD+5VgaCZKDfetwZ7Ijh9vtQRqHk8mR/cCi71H+yk7x3YS/MJQMRH3itBQ6pLf1FeoxL499IPzAOAZbG6SOIgfCIuL/AJ3//5sLawXPWHQ51bUK6R5P5e4oCTmcSF8A3GNTiVaUJIuPOnC9pUbeVMLeoukFtuVgwYq3SkLBCXoPyAbr9qPmXgpy3gTaFu0UqBZC5wwQ7FrxZVXs1oxoObFOT0+BcdDOddldeWVIexRvbWYOh7J8f7ohRaDhUd10qK4n1z7TpalX3hMbDRbxIligraOa5pLZMudq7vg94P4jcuEgWbkdJcVg8PFzLubNFjTPxnRK2ly5A52KnJI7JS3D/9bLvX2rCxWnAiDCmndnKeTh0Gn1vgDvVpMEbZSKS8qTREZW1GU7huQOpF7iZQpnLZ9HnwFp9n4xUZFNBVLX4fy4b+dng+LkqAoGfZGTYZWKdAmwEbhDiYbvGRqdUred54OUhd5aGOpi0uOhYealnXeAEoE3VJMZO/kWW6jmR7cLYccnyaPXMEB4tj52pZCDvQbj0FyagM7E6HsnJcszpOLrNLbt8zzGnDAUGlzsQxX4oNTK430aGrCz3THAfL/J0YoHccwO+jgQPpi9br/jmKhy/CnCQ/Hqkp++ElHZv+8xEj/ZHqUtY3CUm8xUqxQ3KlN5ZKkqtng1t/sZnWq2Tp3TkBc37GgU2bTCaDOzERysmFar1wyWOK1A0WQl7pfN6/UV9D0IaNBRNQZ668PcO3j3GDwpIftiZ2rlzYup0NXVYdsgL/Cd0c9SPkVW0bkN5iRs5Od6ch2BnmGSVZ2K4YlH/NgSJmFt34A+sEoJ6E05EUteZyAPq5R981sTpFdJZdP8jOYSPrYNV3hDr7zGNkswR4o+GAOuwtabQGx43ASTiefCNuUuIvNhYw0t57u9jANFYjalATFQRuqSsWpNQu9LbAdE017PWcGiBsdMrpts2XHrEGxdDSND2xkDIZFHltlnUtFFAcIDhHftE0qlwEsfwzarvQpRog/hGbeOaGtBm4tgrI4w+AxrJgYLuPYABfFIEmNUSx/dP23mOf4js4tdTdrAHs9n2nPkLce03HGIZ6/3Bs+Die4v98ANXBHPwiraLuaSBJoVn9EQ2XO5CLeoOpqZxtnoZzcY13GepT3f/9w4kCyDBK1G1xNZ2ujTGo36EGWYoaaS3L9nftzQQjtpw24uNOIzjYXwB1LAlYp6EQYhpw29CIMQ04behEGIacNvQOqUKdAA/v89CB2/bVGScdoZ89p91cvIak6qS+bD7FhDgBuG6PmQjln4MTO1cp5NzGApEo8ocRTyKeWrpjau43P2T8fjwsGw73ebkLbCW3nEMQfi4CqIKNH3HYEsZU6/3nnSIkiOpglPZDkRUn+p53Fpx7OO/+BJvDeRchePNqNWx/9n7kfcaCep+BPQ95Nxx3T88V0erP8F5ZAVqgqt2B/Hodq0z3xP15EbfcG4vj8Tuu+ScKOmg95lBwQlGkGmX/M3cCaL8nsV2+kufL2lcTNp6f7OB4Gx7tWDBeCzRzbmgH9YsWJ+SB55FVqEVPawvVSj9G4oEgTjGl8m5w0gV+L1IYG6RBB/kRZp2eDuO5wIeDntzM08oCM5mOuZhFnY21mFpq4x8P/V7ygc4SMOW2f2XHhCWfEHPgAWkG2Dd4AiM7cnu1a/dAHl/Yn0xJMhBftB3k/ET3gzQ15FwUX6j73J/4OzkmdMTbiBwKjrWExIZxsO+ZyafB6/JRiLHItN7n8GEHhpO1x9FO+iAhov1YsmI265dkeHFS9tWYKH2Jf+hbKsWqOaTOmpYKWMNTWmWvaQPIfuYq6mVvPQxKMhKAEUtdB6rFkRcjSvm5MFnPHcQwfduCh+XyjTstep/jHtyofCaA1aiH4pD/9Cicroil6nMBSv6AohXnnA4l6SGNij7NJuKv4u36A065iKVk0SsplafoKx4C34hqOCO21N31GikRGCdvoQ2JQNACUFx0Es5iXA5MRUDOsB/EWB45kMtOKxKxHvIjvCY0jgedn9hMQXoOTpyC7S0oiRESUJnhhoY4uAh1YmmCkXCwieGSOullDrXCu5Yxo0L+eJmdvq1rhBbWTCrPkhOUVJ4bBMFxsaLGO5fJY/JAiyrXjEMwVjwHM8wVa0uVUB+gHw2Ki9Eb6u9l+Aahn/hzulF+ilq+XTwRkWrE0KjEew+daOlNxwmbL7XTpq0RC+llF1nEj0ggj2zI640aI7Py223eI/6YyKbJkhYDUz99FELbL1001qFnNh3gpOcax9yOqIKbBmPOojpQKXvErwplvEoe1bNho2imDbQ+SQuRCvYzrv++uzS6JffBEqWEIH646fhwhp4jIZHuvB//4nnJ8KEhdgs9A+s4lyp9///i/VR0wAAQn7aoyvgUYtuG2iFknic3wD8sqvOmjk0wRJjtfFkJ+LPeAtkBl6jswPRy63T/fx9HTLk6G80tpURzJzqiKXl5jg/1J9xnw/mH5x765FH/AmE+1N/MlEcNeZ+dOSwTD86PklwQg0J0ePX1wmt08lXcht8Tl/t7RZxNZVBaKCrliEjq3Z1xPgpjXIy2K6sEfORpJltz7Vllirq8onGIPUY5eCss3mE9eDy733N8klUY7G+5RDewJoW0X632iHMWbRtsnkRz1HgZbg7e/nmSijotWnoYECDW3YsAoFUC5EhzvcaocvzDr25cS57OeO3yYwAmQLcaVaXxj5eUMKb/ZTlq4ZpfCSvNQHxSS/Rv1nHlP4dXXbtI2UHCnIG0hWEbxDgUsYO9LUf74tLW1J69MU0hQxOF8jvqsLkeDd5jBcxU7KAGZQQKdedlgkL7caidluzgRjNHBg84KLb2wvua2zwU0s6CKWm1+5DcVZWxoNw0IwcjWxPNqJvOIFusCnb0eXof19MuJ9Fuyj545dnUOcXfQxlshFJZ5l34fEJ7LMFlNP3GwUys2HMHOEs3CJluBze4cvuVRSEmDEI6HMjo2p8QDoQyZ9uAgF7ml+FoD4HiCN7nSxmFtZK1UEZ+hBF7tHfpm7nCupuCKdPy8xExQ5HtkgPisQ9+M2QXFQ/C3HpM/FWJgDSnFJZ0uPJDCdqSPumOoe0fw1Fi1MnFOvaDAPw60jirvCRPr+iWnViFMb8GF4LnsXXn7NKbnUGiy5C8ro/rQBu94oROz2NZ48pDToWk81aKgJemNtLqhC+XHbwQ7sUtsVv18dMQ843oVpoPW+EEwlUZxsTKNm/duLD0XE0BNoTfaVPq/9eWuHgJUkcnqH4SYQpoJ+tPU66/9h2ltvM8rUSxFTkAOFv3fsuFV0N1wdW4Pgct/xaq++hVwxwfZNEhvlRd5qtR+WhAVd55au2rxs0tTiBoHHC8Vk11D0PApTMDiL49MDAv2QIO1N4mplo9IE2aMBclKarOGBWorRxapS0dT8DiY2FcqSXMuUIEA+23Q0vIz6Oxvn0wyoEePMOTyQvJt7RvjfG8VNy8ueqrf9RgNN/g7GaqTbMNXh86e948njrvYVo0hm1Xyf0f8GC6neTk2GcdU64liUflBKOMsgQ3vC0VQbVKL2hUS77dbmIOBivthOJ0w3eEIlOnprx1dZVc6S0nARk6P2BbLgVzQg/t8ROPuFbkfZJSOF2q1EokaiDpEO5kyyRmjQdodPXN6YHJQwqqRZgJi03o3Fsfs1DhJWO1wd0amokl9aIWSEQe/EZmHiRWqMcY7FYsqZnQe5/njQ2tnd9gowuVgZXr7R5ftVT0DbaCM+wAvWBA9It+rYmKBvUcI0ADIH/xKTgjNukNsB5yUqnF06zb8BJXaS5Ma6hx9GkqRq2bqAiShN8uhk9khu6flN6y+ENaUFYUiGpY2nPC85/ppKbwlhC2GAisWUlBOkqGDwz0XxUhmJApcN4rNoASKkHGDSHxBpqK3m04XkKOtEmz2mBfRUz+8knZHM8z6VFTcAePX8hkxGPwdD6tBaPKoFC9Ar+F5PhiarWKzIHMmWnppvvHnY+1MEy7BdZ5IlI3BYHTx/m3b7ptlzwoqFetMXXhuTnm2oN/KaDHQi1BfSAfNI7ubdVubkiifjwWyMECvusazdJL1gCczg8abbFUGrXhSSeAJZ6GLyFbzL2V7Ufg2iVV1UJhMpomSw+syKvxWgihE4BsIrbKehp/N+6Tr7jccSMyZxrfXpgoM7a2+sdGAHs3+27l68x1xN3opnVofr5i0kuhk5IV25xV3yN975U9UbG+p38V08wgTKtHIVM9byoXxhQ6Z8GKpmRoaXilKImoTSsixnmlzRtprExM7r9KgZwnvL0sZq66NugIooPZWAGS4iQn+hUUFNvbCaaZ+RwFjKnkHklVZT/ATc7LdB01bQQoMoZJaWkvTzgWEjp2lM55NOtJLmLnN/9LcInw0EX7C9bJ+BVp1RiE8pVdS64XSP3cMUFta114xihAYSBJJ2zizGXNLRGGPJjiZtwdiNkXoHmkgbPeJM8Il4yyLZXmiBZDhEw80CytnaLrUsCFIwS06UEZ2yh+ZOoUfXNkS9DyJeocb68zWtx7SkHzwmqU4ASY1WdcVw5Q1cVNAoGfsrhrbF/oNJMSZIgcSLI3ZQetDwYkBC51gUONQRhU5fHRXx54uwTa6qCOSb4iQNmzgT5Gl2/LdkvB3Ecj85vmtLMoQO4oD3ALRMrVO4RdOOYkb4CtYxOgGuzz6l8IWU3mJNs23HroOWm+QsPmGSEfqVs9KhDE+hKPtW0NosFnD8XZLzV07HXIzmOj7isosbJHNU/tFeYq8NO80jsjDq+khJi3vD221LEpPegp4YhYAkdPQw+9vr9OCIQ99L/hrIj6hg3KRIMtxcg/CuQJrg2oULhH/7aRGwYNO3r0dgGViJ1ut5PSe9knNvfA8HsV0yB2HiUJB7fkS2j+sId+5SJYC12yeFl3EdhhTzSEoj14/QT9IuVDGVSXnxmaoAsBTWQ5EmQrwjE5/0TKojnogoc3BcaTP0iRu7Tl1UtpaYfozWqnu6ifHrKoF60MF+qNZENVQlBBpjrBYwq+yEsW2D/noIhUSMXkqtj8CIqw4zNHbTgZI1nLY2JeAIEfyo2tm8ZSAR4m7/Q1uo3vEfDuSIo0BSDXm/usS1niwlzChkUK4dn5GVGQwarjCPUb3AeaCEGcFAY9zAnuXOaLo8bikZqt6bbHlFh5rB8lJ5Uc0Zw0E2ZXPC+cvpHuv18BEowsvENhLsfA2O78kdm22fGyqwMrLOq2Djoh6w4hzEp3yA9VL085eQ3/W+ZNUEyjEAlYsqQaZkvWaU2WhMKc9KbYmr+ZU9kJHtnN/jzt6D93zI8zAV45Tlq38N0lks/mdUip1aCx/wU1mswkRPbWdbYPBsdg3ifUeb4SPMOr/bfBrBDYEYQyeEHOO0rJCTUfbfN+PrpuF47l4LTCk9JczMzlmi6cT7OHM9dIlg94rPjnbRGhfo6/PfXNqWt8OzY2REagFJC03qxnQQqsnyzckYG6RsZOWdfLRtS1QeZqbfVGhXVb+hGOWkFr4K/ftR1xX4npsr65MuDvWRmWXFjA6sFCSKzJ9FYhUuFsOH2XIR96Gl90P1+ZTZIImt4Dro/BFjrNRnkM0qFPccGhRMCwgx8Hp9VsLPcFvqX7yw2DRmx5T52DAUT4XcAaTJ+fyDJmvThqvjDz8/T5NxslHID/Tek57OdCMzk/yFw4Lq5WHDB7bGLesfCYE5EVGaFfH7Md47XYJm3rc92Q8Jhhrbk8HOTuZAGDfPAeCOI9IJqt/UJXvefy5DzW3A1coqYwKa+P0p8qfFbHqdfHjDjr+hoaNS/fQK0oVcSysJ1HsXgXAaPgYkZaEyHWG84rRrIiqNGSIa2i5/s4pubdYJkHmPMYI/W1Jhr1YGk+rh1k0J5CNDir/ZmhuZMSX+7uYK4AW/LpfJK/uWRfFl3guf5HTHWvPNS3gJOTlapl5be7GcyqybGCXQvW/QuPpLrbHcQ42JTcJZJxgJ++HCZSVfSbZdh6u4Fiq2tfcEFmQDS+zaOo3Ev4fgsMXpQiSAFkRXWUJ/mGPBKw8RjcAGPevNg9L1j2yrRiv7fFQqOmFxPK9NxkiMsNAg0M+YgBDDidCn7MXLa2QGL2zT8or3R6oZAYVS6Hcazk5AiJlQF3j7CSoBU6chaXVe5HPiMsC0A+2tom6cIROZKktfvGCchJE1KUv7JtdOrMstLJZ3jNIQ+lzVs+nof2FZE6ONZgUPIVPz11SMwu9I5XAdxJvh1gYWNxAN+wD3m7uQlTVxRh8KjipglvgC2Lvh4rOvHSkZsORUYk4yGqdW+wLk5iy1Jg8u81jqpyxQDp3CpYrQGNzgi77dvjiTnjNzNGmKnNB46gLDqIPJ6IeS6sLQbLUGcjYhjRl64Lr9eilwM/qBxClWyeVrgRpW2Coo+siKHyBhAy41F/jzQv4u/oLmJXpgMRt4UwviEIgoiwbtj1Wt82JW4feElVz4zrF+uJGDjRGlgw0dejUO4fLLAHp52U5Y0sgV6iiXEHBwDbvyt4/W9ErWvk5hvy1Exeei7hMAKxFrhZNFDNaTvSF0Pg+4i1ysM+mJD5O3cu9jgpYqAjrHo+P0K0wuDQReu1uNw/6p0fT6Rf2E9IZ3QHq52WxGjawehvvEKUP7qsnjlCeY2tgOlMvbLXvnpiiTTImI2j3psGnw2xSXSgpGBY/CINCIe8Hm7PEkEQREw8ghxSn2bn/4ce4+WcZy/69eLbp81fiMzqbtzP95u8gAmrEFZC1JDmBptGlJvMMoDrXrgs6YmpVFlS2uqzU5o1UX5y8BNpJ0Xnf0osfYJ7CxlR6f2UNKNMWhFWqt6BpHmfOtUPzBUdayw4FyXdbLSkIzftw19Oosp5bHcoh/NfJfpP6psBst+bAKz2fweblKomRdaMGDJHS4lTsVyfpZ4GgzaFNbcG0FX0XUuFacVGvdWowj/3OEQNhP+GoEjy3ystJhcvLCZj0wauB7ndB9m9eF4onIRBcUzzzgcq8JjZTMH+y0B+/E7vA2WUkWzJNHpp2po5vRjYqIjxn2UCO66D+Ig2tl1mbzJRpt+OaAoIRobwGWhW7LkjZfDhUITLarjOVPZ6YXjMF2T95P1M9xXjZXhv2bPmWNqc/AuA7Iks4Qylu2egxZXeuvHcCWkDasihrCBb7te7t75Nz//C9WDa87Re45RLq9MOe4yXMnAkk0gMMSn+2t59T2QYJNHru2kpyqbeTJ58w2cZxY94FtCe6eUeQTHvh16Z92cAOrvHmpr6N2MpULouVIkiF21Iba5+oVa8FU4IqP1/NeHkvRPyMFKyOS6O3KLgL4XJnElKuP8yXFZ31ghrQMdHwcdjR0F+SABjr4VIxuSrL5jzeS+IKQRnqfksIC2rVFHX4tZiX24ulNukTyqO2eMSUfSxxQvZRN2ExWmBy9GBrqTOHGN3VG8+Ia7ELv9nvhsGjQVfZOZ/9D4m1h90GJa5EybeHvvWBdYKnfHaTqiCgUERu1L9ultvik21IlVjlp9vlnMqm/IAI5oV9zzlWKKc/hsywcdgga2UNhcTR/Nt+X/X1PezrvEsLHHySTxFLanJeI0o3EgXa7rEDEIcCvexkBYAQ5ZLzNR4D/KH1jKh5iUR3NMdyjcwnOMas9xtjGlmaXIAezkPOzrhTVU5DquZigWTA+fQ06JzAiPeDd94ydKxF2y1emZpuITeeJDXt1MMQsoDP97LORdS2An3YQi+LSTQ7iwKggQGn7ulzE2zxVjtpP9hdQ4dEIN63hdZfH9kyTo13SynuhPZVA+g6GkuGCymeModFIyB1Mf6mr54zJJQ7Bl0IHrgJsRcbUe320w+XTSpZa/EV/6ZCv0MGxWsAtjNyayig8XHKN/RDdSbCJNuMVKa8OLkbmIkXp4gVrjuBubzqd9j+ehkIU1Fl1k3tEempbPJkMe8fs5haMwKfOhHhpTAXs63ga6qy78oG3+dWWwFjuWHw1lBrOtXYHPD3FXrVFZ0ISUxm9FHRzCwhKojj0JaFNxVj7ilhOreDDGyf0YCAuwmJWCIQSSVr1VUgei2Li0ZXBNji+aRqTVMwNfv3lGtqyt+Uxi6oAmnZPjjZurKHOwmlHRWhCiBj/IHzMZgE/BGOLerd2vquKuGqe1JnunHFWTA71DFcj9QjqbtfhL1ooKgqfMba/9GBiK+AsljeXJ2nKaw8OjXWcN0dnUV2ZDMIJXO5kLsSeXfB/v0EpFAqQgdnSFyqd88uQ2Gy/8DJwj0gqgz67ov2cNduVDTzFuUEzBp9uVI3g/WG8iBQUGGcLlNqXGeKz1ECTag0lX0Tyr4MVqdom7QdzNXm+7Jv1EYDf+2cJ20/Zu6G/R88R65sqKW3+kMW1veJj06mJZP5kSh4qnYeh75muwHmFyFEdC67txLWZ18qi8Gp3wSz9A/vxwj6g1wXTjhjS1f6IHN5dv73ejXwOaYIxFcpH9npoCnUc8M0ExLD+3MGm3hyTaPL6ZySvfCh3Wj3SnHh5b7fLTWUABWBCHFAdG4b2BLrNLeqWt4cNBLF+oB9YOwi+zPSE6R6XIFxyz38w58Ie7yo2XuyHSHq0MBGhWHPkl6T0e48tL5tkeP00v4WLvkQy03oeFdPjUJwV0RYCzs74qp7SKpU6OnTHaEirANh0L0GgR9oERiUqQVvZNaLC7JwIBQBlTdKe6Ly7ohwsDE/4WvWxjlvypP6w0itSdoJzDoUGtreM53uAU1BDqvVmYgSQ8lbAr7n/diXeKaNGYPItD91xRyYB+fXRi+dFzSlcdNKzvNGYGg/LSWk5WJkcJpp4fgf+mPvN/S8K08ytAOO+3uxPd/ORS0VIO1xwGnZjX85HOdWPRUbeMzH/XHGaM00MC69U7YiNoJqdPW4bMol/xDOVgDkIwcB8zlA4VnQ9aWH+o6UnAX0N/HvMXHZXQfF9UfEVLbAkD6XHwe/EHvYy6XaBmebyWiecKtYzSZrbuDgK1wzoCtQfKoGQoeQdCZ35KtIlSvFPGjufmdOirJWjB60GBRSgHA/sbSrIkJPcjZ9cWHH3EAW73FDnu8rRvbN29pdCxmfl5uv7Zh/uljQbviCiC7VTUeUJJDoGKYoDYH5GtO1HA4AbgcY0iZ/m/HX08VQ9Dsr+EsQAMUmSJ/lP0zZ7Gg+DRsMxK+962PKHWyhSioPR1Bquk6nYs/bu9/3L887PxHH0qeL8sNJa+SKucP+qbya72F3usHJcSG5cchC1zrOlkLVT3sMc/8U7bzRkOkjHytNGmAynYmsLlBKisRZ4eHsnrC+AQPyhezzqgfZYM766QFqF9vElL+IEobmsXWWU9LDAuBvZzQPGWciWN2H4kvRSNt7PY9peD7YcxYL1cZbsjdEbEMMk1HR9535MwUHYPLfAXoksRoLehcPfsT4p3rEJk5SkHE/orTCjfN89ntTOcqhOwf1R5fD30GMMpVdp4YKT3gGNwUMT0hDBivD7+PlQWOo7eEQ7/l4qtkKuOLdfBE3czmenPmpW1STVxMbokp72RhpcgS0C187aBRJYHqCIKNtuosMPX6uec2MJ5m+T80yfeCKISifeGP3uu20Csz7Ic2qgcGkJ7vm3+IXriWRFXuOquB3FEgPJfux2Kv5XxZlyIMKGHxPpCk1nQkjWi1BOZxoOMAJONOKZnzONZUUJdiNToEYEF2mbAZMnOKz27U9GPzK33cwI85e/RpRIQTWscCO/FJxMRGhvVvJqKbugVlVF5p0GfMLDccW6LCliS4lsrAtzUoknlOJ7ddTnXnxzHiafddfJB6HbP2CAvslpgzCSwNAb1tO8gS98m0UjAYkco8vA/DBraWjuJdxjEDx0v3yJwtrWJM/obwy8tXEVlzptfiwKlybzMaYRt71Lo4mjeHpNnfysUj8k30ndDZplyVK0FXqTNW+p7GYn1gWU59M7SETBb5wDjAZXGpV2FvKJH3Yz7FCMQPIAxBiZE55ml6+lzXFqfjWXKyv9BLs9Oi0zRoeMo4jUz0nCUaawvIUIf/TuIU5MEbGr7+21nAXOF+egY9adGOf6dJ195k3YZyEnyXgsdR9WS/lo60bpujkmL8aZH2/7EbdObt/Ipl9wBWu0P63U4ipf8g3KhV++ohL8ttt14d5Gx/SLEUbzAboCsELDl0FJPtIURYa6xEupaDLCGCsZJmiicS9bFSaPX2s2X03IRZz+OiEDTfSH7jogrVId6bUigcKahRMwpk0kFPvSIiopJe6SjkxMbnDCz4ztb7K5GwmPH93ey2tTtXm7jZla9vZudzu7TONZQ6kex44CCd+jbv0xv0IB2/ZLdeLbI4EhlNJajcx8mKwMSfKSOGZ9//tgcARTTfdMihnqjHMzgdEAaJF2JGHf7ghXITNSEMg1K/GGPGWIR2Ykyn/WS3y1yB/6kwneUbeBHUkuWzVR6/WK0QleLOhjnvkuP67tU+aYnGJHxRswRl+YjhYgMZ/lk62JnpKYtMVPkJ7U+MrxBpL3Tg5LOXGQeII97TLSNSQZLifKLg5TW6CtYKx6WUGfKlEWhjrUYQeEjmNetUejfv/1waLR2ShXH0N5NVI6ImWVUQ+A3hNz7X5tHWcRPN0OVD0puPSkXzfwu/NqO0JeB39T4VUn+KO8Lhw/G81nzxDHigP3KLa1dBE2BYGbFOJF+BMSD3fRZOldUxIdMSQBXwTOD/fGYC34WbAXl8oY3yvVkU/wx1PtpAMU8qOpEUIkegwhLcYrSzothNLOhZtiG6Uw/bkNgN9K7TtZ2qDgg7SI7Egjrcmti+mXbGJuPo71CddRLGZ6CbenlPMldG8zt02DxonkhcDK6TEt/Cl1RKmAzKBAxXq+hO89AaAIpnMAdyLTMfeLdd1gcV0twiDGkYgufYjMnfPAMVkzS7oqJ9bRv5LPKTkMsrCCz4r3m48ngIWYuu4Nx4g4Yng5Eky2Ei+jFXfPmXa29sn4pSnacmgFagWgWR2skP3b1iC9hMUdC/JNhSjzjC5UulYq8rd2Ma7CHPfLzKiNt/V54ufYTVGstzkIF+Fi40Yk3KpyxQ/D5az1ubE9hEG/nGpBSPjVCRsCTudWEuaSfRcMbLkNmLwK81Z7dxUCZyAy2Q+zQyujd05MSCxI2bhGJp9nKoRQvGdK5/ZyhZGbFqz9w9b0RQxS8IqG1V9CHchs8slWeGfDOwOGsWrFPRwLW9BiD6G/F4/er8EuztRzUIV4hgy2xW8Ted4XpB3mGWsY7N/yKyoeADHt77PwzqK57zrG6jluL8il40u0cfDpcn8WMgjvXuoFWUrw8UXD2zFhvr3RHf6hWyhtXol4e+E7cXUGt7AcYz/U2mOEwmvWQCCsfDfhcv97dtfsHUM8hjc0kLfOIkJEhPrQB/xugAvLZbISnqVXsSzyEA7RLWh4XUGLzyDoO8Ls/znhPVfrw3AEMzru4oPUPx607CwyZnWSY/lYnSeU+CHplpAzCLfM9bIXDBuM7UsAs/ta4Oe5Bd8FlhrjZ6EUi8kACMsut+QQxlNaxN2piZLkpPoZs0esvJKrioRSZqNtIgVy6eXOUaJ3azDJwjG1SqVGbC88ujWCuE99dqw6coqog2ha9lY+OtkvhpPwWveQVMwMaplcdcKXTj/3sDDCGErYFLRPVPyIv3/b/qHw4os9R/nJeA9H0f+dWufUSQixAB2duv7JibqoOvERtEmviymZE/6XTwA549YDEhLUyK5B8lNS18ka4kC1g1j3HgNc76RB0EbSyKuTF7H6IxjwOkMvzHRBPHAw6fT16dE57ZiKZ2mQsadDLvK0wtPrVXcwfdBa0INfdHgBPwZjfTYtema1vNkcpsE9lh2KTOZM5qsWKKPoMXNKekTCy+xVEGITai185lp9eSgrdhyzp+u3uUYAQC8mKgvKYKiWjbDt/xhffNlqUcO5foil4hqsJ+xuZIDovixQEeXd0hhhlAnPS02buLcoo86m32jv7JOJGu/vxYCiDkogSJDBy4vVLFpzVaJ3S/rDuf0fRdBWHInNSW47dYbvP4M3WuXjRVwcu2CmlwrkMitv7RlpPgaF9bIS8W4TjCWBKtnHHVwMip6N/SUO0tmmO2i1A5JFAz8SVF7a1tD7k0sD0Hb4M3egDjZe1Y3LJGkzA19POCIPqgHQgMtqgEk/741/dOatyZnl/7TF0bcQQyVo/Hyg39xzJC2P344igUh9rbDI760OAvl7Y2yvl/tPeiPiaFspaQIs8qswsw76cBKXU/8Exw+k3Ih/z5Ok6LWJMp9pMhCePU2csf38ckadyTNHqwu/e+tYHcJO1SFcNaEz1+f7JmcyMH9YDk9iWDra/CP7lcB4ZGMEz9rrMX+n9gQL6amjeZUdgkXU9FdsO/a5we+IJuH+aVHpGi/CD/eXM/1AmChV4WDGg22YENtlRqhoKLjA4rotoon14UE4q01KjaiiNapeGycQR/nSfLxZyeKFCi8j92vPhHssXmy4MmRcIUklKvYuiNujkEAqXuBbZ6jJIb3s0g6uyPqeJENW3OhlWazZUJT6CFWemO2NhAqnHJjJQCJaIOlOSSgrG9uNdOnszohKtsH536/67InKtvpg1VFIUTbZwtMoTvPQZ7BIFZhmxqFDt9dZjKWdgU72tx9tx3xzpYN64b+8Zu2YpJnkGaCiGYrOhgW3G95EDcMFl3nvOfy0m8TO33EPB5YtopH3rvQ7HXGfmoeMccH45TtpFLqX88KxWVEfHG/LpHUh4pMUobUQm4vcaDcSAt2DQW5syqxdPnkHqyl2WhkD66AVAqosl/XXUI4ErtsNr1NRvUeoumlkeW6qTHlFRwamKGOTtwkWnFzpoSe+aE83aymUA7U8uiRaH10gPu/X57Iv0/CNDbi7InlEWI1kEsenj/5an3PIvztMeRves8zD4D9SaG7pQcEc0vojIbISD5lTG3PIV5k+9W4Jop25gm3hmjDYoF5Vsqb7j951q+38x3wJSoJIM+GLru4GB3OSBnjuXv1QeLadfDFxAbIJfgHEyTpJC3QGz442Ll5LDb6dibm6aa9f5bepgChJk403IMykvpjRS5xt6pDyiN3ctGTE90I/MKzrlmCzrSZ7PofUdmUUvUNK415PW3f6SGKlGQM7tywb7uLmDTSr6oA55Cx6Aj1JFXAjgxt3QFjQp0WgGw4BrmlmRdcGDEZJdssB5TnB6quBBfF3haPZaBly2t9TpnI4L231NbyNea1NzcYuPuoV0HZDfJxOFXM6CR2mks2eQ8N3q9DezoUy2Ilze5Z4bUDqJvu+3E0zB0+uIYenmgeK+SYiYRCflw/68RLLaLH1Q7K34NlHb0ZuNqpwHqHUTqet5jIFpQk+/PrpijdU7JPHQgV8Q2gjEam/mfSZjAiWFc8wJC6Vpp/DUKa1Gg0/LtCabuksAv+shtam0VWFHglUeUWko0VpaaJRQxeKSU1iqo/2/7ifqJon6jyj31vc7CqekVmvmrdh3FWVNTqbHbMlXYvK6P0LVrkOHlUOEkK0ovQJj4rSBtECYTWQf3VKGAmx7Bt6JlFV+mZ8Cs6wMwjJ9Juq7xcaoUtl2lMEQ1kL5N8I3fgqeR6AiD538xGF+UXSlIY/YKX5qY41u//qB5dfZv4Flrgb13x1u38ORr0sSaGpn58v1wuKImFsEeqw3WkttcMevCFWL9Zfq8FqKd4w88GZV00SSGevwLHBpWswRnNT/97Idf7VWDQYZmQ6e0y/svkOs61Q6WzLItPs/8kKOJFbPuj0hQfVgF94qgqRTbxHuuy4QsQWlL76BidacqrsrRsxFfeAZ18IA5xbbIxLkjweGN+Jqx8lyhayZkn4FHLFXxwgntHo8+Z86xcGWw9/l7k8yT+1Bjlgg7bozBjAzYC/wJHfgjmK/2dUgYBynSrVAuejRC1bxzJWAcOAyU70SS3jXKsfR4iRSfVBu9k5aXwfghf6BGlVE5fj21aMnLZRjA6RqYF4IduUsD+A0sPvhvuGMhOYnFpWtN2kLnjEXZcFcbiLwjwlJCjFtdlOUFBysI9gJucRy9KtZHqYqU3nImQxDogQD6t6KjbSGt02eyjQKBm8y50hfd39fLdc+9VK+Dv0Y8kFBBcQnAuZyyp+gvYui6njdB9ueuVZ6obUwup1fpvfM1j8xoU2MF9Hd49/VljgoIsxnhkgQaqKDZKHGnYoMTy2WDxgqT/szRnRJejM0nV5bqp3vTRtT6JbIjYdk4hEHjj+/AE0ns7oSLX6Y+4KD9hHU7ZPTbjUYDXHJxX8O2XKCPe4CzN823QPwKK0Mnmz2OyaaBFrI3EYyQDY48EJIaCbvZo0iRMf7FLGr27S8VK3jR+fn9G4gDYCPioaZaBnl7u2PK+oy09b80Pe2WIjh4/zaBWT7v3D1YytJx5FMY97a3FTGjo3sr0ozycga0Atrx9OGObUl9PcA14uM+MZuzkZi522AOWKTt5aNbIaVUbAcDEZONGl/biY080/NbvQ+QZ5avS6ICHPO07CB8CRzAzMAcbWvBQVhxaTQPpjP3uwxlzU1Pr+UzWk5BEeU2Ho9U6zwtu68Jvn2ejd15jYTFKNDPk/okVHbKCA43gQjd6TPppBnXMeWOMvJaVQyugyjcXQuilEBdjR9QEpqfgrrkkt6PBN+et2I08/dtxd4KotPctVHl/LA3moRE76T69LzT/+oSzfMatMUMRiauEeex5FjJyTdISQVyLeA+3LFERoYjsSuNB5n8EKt36Vm3jxb6G6pB7eeIFOKrRg8CTKsi25HtSNe3Dy3a06vH5W+ec8LHT9luuxBCzJDiFScCIbEQaPOqikI1ACJTajHbVPdgSs6c0sHQrBpaSI2f067fXVqEx/G31vPTPFIJW2KoAwaDZ4sGZvbaHUHh1bmeKULtX36SspMd4zav9zgHd4fmk7v3uKPjqs7ppfvOUiM78M/s9Nw2vJcY/ZtMO+9sUoE7WlBgINRTwWcaIFCTImaWUmRFLFXEz8B+1h+zzC+PLiPl7YRRVW1aVAm5Rvwuc3qDQ6DFp/KY/6H+7zfxRhDZMNgCYXzaTzL5JyMbZeFlETapmULR3vN9S/JIr3wyJ/iBDLDuaPcy75tpRyXSQwoYXM/IQdN33jgz/VQSI/TejVQJ9iPMoZd1uIOHnSNZWHssapp13UR8idMxfsjd7ikBs74QcQJAoM0ts0PXKZcDFVjwNk7sHYbdRbCrhbyFeElPkC10M+U36JnlL4fM7GC/EcXKZs/AoVHbF3SD3ltrVLk9nN4465sYLRFvKPl5qZ3OwsIKvkVqw0PNNxqPs+VyO2IQjAFxghCap+LYybMIc7q1k+1O5TUU8A4VEDgPyHJp73FImEby+8tEaFD7Y5MN4oey9BeNp41JHYvut0iPacZ6xjtvcV9DNkRPDmMpiH7eGV8l4qlcjnNP5B0WYbBCM913qgWlzJ2o8c++gnF3KDDcctFUxuhPuD+lUeNvGxmjFU+mVTO15hf2KW4NRn4zB7aps7GNUSDKon7ThFs2GcNt1cNr9kUTIeWxLssNU+1fiTgGVGq/g4I1LYfRS/tUcsdxsGtx7324ApfpbEvt3Qxj8YjISdvUGpSmTL/ljLUImoYI66uFeGbUFeLAKZc2fJz47SUrbjdr4GUNEbqYvc+iFTyclX76ENaDT10Al4prvMSogDQq//PLdg8CqZ4hX5+TfwjViMBKotFhsQllx8X/eamygezjYcO9ulVbieVgaKxMu6H0Iq/e3K64nY6oMeIKJu6jnHHA1cdrj2h6zQRyc+WsNBK8LXheCcttFcmqS1vlLIiE/bioykHH9oEbcxqAJ9oNqf4DXxS68AjnJKv5IkqNubwK+n7pO8KfqiGNfYHRURUUfl7lbwxMa9m8Yy+oSf3/QeMunx1YVLfuPK9TOpX7MKwt563ct9AXul1/8G77pfOaaWBCraM+vsQJyelW7lhxihdWEqG5SCmF3n+M/adRMBhdJvVDStYLnjZTzUAkYiwJ0iJCnYg2NIF99lly5GXavSo1ydEONCvpOowgKhFiEA5qd7V0ILR1qD8sCAbDPI9qCFcgJK7sv+DmbBdPCPm1JK6zADnJ2LZZopnHraVmanRhCDmSO8CRngGECVi6Q7OOYYGPFRc82ApZ4x7z8KvJ1XFv+lmtVeVMSFgE4OPkZk0LcNw+OWts5Xfb9xdws74P1zxjAYTsbZ66cyFNblAe5orL4oJWppT/XXhzyN6/xYPFdsDGiybuZmX1VYG94//TY0iH7PYVzS5f2nX4ZgSUemoeIt6pg9fI1GJxU/sWhNz4Qj7lR2GBy0ruJf9vui4kw8miz9mdV+lpC8/yeYtYpjS/OInv+pjCAFGpFMtaSUzZPffdvm6AReA7CLVK8ToNNUn5U9NVMb0bcfaucTUvgoMeBVU0uCuw6ia+/GaMjKBIBYnxigLsThyx0Xi7Wc3nmIUOeLUJMIjcsAAaO7i8ISlhQaHCYlZxWUuyreeOExWiilAaYaH/JYvLHYTrOKoPEgqYYEDzdM5Edl/ni+oGD8expRp51bsEKnXIFQqrNV7uOlgybBuwc2NzynPC4QPosxm3Q/YxDhkaMNlFCFqS/nhW3+G7LLDzPGiWZ4WnaAegKeNVQQGNuJl4rZqdWeu7PclrltFQOW54GlizCJwerUsxkhFGvAPf+auslgbMriY1m6l0pI4PpNRBAuPQnQ2mCO/qp3JKd/JXap95tG9IjB/Z/iGG00FXYsT3rBO/BTFNc1IiBU1EMu3GZ6ynh+qD+jI0ZQ0I9PnN0usWNAQc2sImkhbBMypOze2hSMElYjs+PdeNIqknblne/pnRpb8HAkste3+D4qbpP5p7ByC1EQvqaBpZDcQQd7keUPOGMqckv3G8HTg9XqSWRukgMg1CSwXqGTc77Yq1qLXU9aqeaGJ1rrHBQOzTEfINB/XGjb32WfSfIpQGVuGaPZQzmf803Ts0dLeEYD6RFpNP5Emn/xzP2HSGYkHBa1ay4obppXJXanerv1K0sZgXMFMEvOkwQRlJPHagKfm6tri58MhcJ6Um1Yqd89KJ+UDm21yQRMPDlXbjW+Fd3GEvm0Q2FlsBd1WmDJgpZZ3J9qADb6gWxc7KGLiwJCp2c96vGs8RUVCsoM3DaxNWxX08sOAte5gPjHk7zQFOFEDO7h8l66njJta2zBZtzbFtMRplBpLOFJ17GcKN2p09w8exH2oGjiifJqyL5UNmxoxC05j/6i0xF3cApp0PUPPZJMmuPYgu2b79HaqM5wtpyT6zyIoKSrjFbdY/6WJvOahXrpiOafV3b1lXIqxNKP9GuKjLIyXDZ0zYqXXG4/gvvzMUonrdDPeKqh0Bbo1s/8RnVx4stUcY+mZVOwCRNv3j7XyBmMT7zQAmIv4gXBzXoRnvyjbRbRyGZSgzp5yjpteGOFXLHEV6DjhRYWIA0WBP9mAt3Old1oVYb9TNOkHQ9/SFfCCFb45wjbYODCif5Xg4nLYKMEMjKzBRv+sNubHk5NOf8H7EWCHdGsJdFiH6JxgC7inpKf2YCD4zvXG33sqEmM7OMkTrAIzDmgwQNrQ3SOYcSwznJYAjs0yUu9Zn1M2r3trVva9ROPzyf6H9GLS6UJgVhXOz0Z0ljBWH7LnkxHxlaqDXz6E6wiMyLhGwhmgqQZ3Weq6VzMka+Hl0At5uVOVavkltQDt17sXq0bYB0hUrNbdRKGasa9mGMZkRt7UbVoiP2UIuXM7lZokC7MHyJwccuEsSW9uP3IHJ+CuN67XemyMNAdMl+GBF9GP2ZKbAyvBlHK4adg2fqqB38TB8qEsICdG3ckNPaDibtZS7PuA1WpSFm5FM7jvcpgP/O1hrXYHXySDS0DXPaNZe6RievCi2cWSPVZUbhaQse2h3yzj2WjY1TUaTZkJEijKVaXxOJSvcco1KbWn2re5zxnuPzFlfE6VjPW/5hV/EcbbzXDW4WbDdwpax/E4ebadpr5CbPB4BkQcmiaydosWP/Y/0D77MnLOHt9GDgFb3wfHMbcT3mTgPGAnsiTDMrUm7VV7GQWOTowBibjz00+gGbYicolAbdsN245Fg7RvlCBmpkwEAnOfwJWH/owNAohz2AE6CXprEva+Vg1nI6vTB/kZJItbcyJ7MN95siYUfMBbWVsrNQKvkA5SnhbcD0dzB2O1A6sk1mzZQjAuOpSvMuKerrFBYN3wMUT6CnnRWz4In6uCQtApZL/j7scuFEOSeanIdkYRTsBx/STQIAFf323LKpPq0vdJ2teNX80tTADSGQmXx9yKd9gNiUFq0doCoX1RddvLwtMJQwXB8SPqdlo6mkDeW6XiaS08n6dc48YNKwehgeaXWnAaOYiRi5tR4UfdgxS4WZY/GeYvScrA9Fj/z4Groghz30apSVLVPIT+3++p//Z5R+QzHNXmkQpsPXycCIz8RMCbanFCmp6ZIJjaJfpBmlbgwqF9ksm4LtPe/AuJdm+qQM3uO1eCJRP13KMG6OGmflV9D1RrPSimtYVjTbDCD6YzDlSxJW5HM7ksH9dxrS68vlDpc2wW+Ki4QcRoLGA0hI8F4XNcjjFDSSN4pXULF2dRVbaQNurGE9wNAyBatPTWVZtP5RwFITffLBVmraPPYfQEvLZI8oAJtdFZmj2es6k7YU5dCjufQ5z7NtozBYMTTGnXmhjVIijmz4q55Dry8Mml5W6EIGfmSsxqUmLg2d/pa6cKL0ibU5LOyOzZsHqcXxz0oQY0RyR7PU8Q5DdHWSQEGGRK9jP3Tj9QgRMEWEVEPyr/1kO30f2m6BBXOmMulZPV9RZeLBv8SaRgNrnc/h1zb1p5RTeISTNYBwa2SXLJm0RO30MF61P7cb+W6mQcMyLnEwfHyqz+LNcb0Bi3aEM0EmNz+Q2YHNRRr1sgHEvwnT+QspZtIzTWbSO2xMb+YUAkDcBCM4pluumcfMUe0JDVVXpQoTb08FfgelAgfDjLonx8OTGbOOi03+067rD68XN3c0+Z7klBvb8JK5KflUjEvuexAKfb4vsAj2QS5jTiZzpCdSzcG0isoDQrtDaEYP3TLn3KKtwlDYiNsNy8MQvAfZrKaA9NhaKJzHQ2IcX2OTLIlcvWWX7zvsjdaKh9Hlw3coXFhAI9iynw81OS0QITQWQC5NoBzbF92PtWWcoutf0XuiJkz8Ny2UMr1sRYEeJIo6SKx2t1Dj/UWM9K2bKXaBntl7FjMtb2C5ZteDE5DJhukLcu5qAUgI4EvHasDUayd5QJYmYybnOo9C2Y+p9tSJMesqMimT52hIuAfuaPbo0OWJRFrLqPGLW8ozjnY+EQAGHViqoc7iD2jqjFrOp+wkLfdGPeBJTZpdTSSxW1YBAGQRg1DUMMnoDUxb+fnpwZDarVYKPNaSQqEcx2hvGRhcnNCpkDq/eZt/cSv13Cf/TDzR032mqqWHlZIIw7eg9WdxcdShes/lAYzGSGWQy0m2Cy5AdmD7RC9nrcDnUdxwkcrAWKvgLNs71hAuxVnDaarQW93qF8DfeySEN8DZTCyphWZM2ZbiZEWWE+d2izLrOpUaWC3gsz4r5VT8SLlQJUeYfg3+VCD/T5ucSjFP5v2/5HxZ5tnvTR0dAWSCy8TRPhBo5MAtsKx9RP4xC1shwH1KXUZr7WfiCAf7nnOIeVu1oRMFGy3Yz8zZNz2wo534qetoqfC2XxjqN7EpYiR/t9OKP1PXakC2dfCafoP/H+Gxh53p9LJlKkNSiqVCwcqrERHr00ommk/tNCK6+OY4rvv7Y9RjrsQ6Fcxiwc8c4lzfvfqsg02kQrdBNYCEbAg8D/YWjeB6FRs6XjcoaHExnS4DJ7MxJV3IeT/+yqIE+5TiuqINMsnvUgn+KWYK6D2IDcvutNMcxFGHxy9YWF+e1KT2rBruo9YvFjFRhbzLCIQtzQeyIBYnAh065YmA2B3q7EqGEUpTbcPtcGfp0LK5CK8KW0yHAWk8eqqlH10RY8QtsFTVcKHmZzbO3R2YhYd4NnRGl+VSrNir5v2pft0s/ulVyeoNN5tfLt5T5fCIfqR5Gv5zgn1AzK2Yz7ap/oFR5Uadc3ImYiogNN5AbKt+AAAAAAAAAAAAAAMuR3A8h2xa2I+mizoatyB2kpylKDeYKt75vsDi/hiyT3MpgjxI45NIe6kEs64WilqgCfuOsLMGgI8IXesritdbKHyl9T4/hfmXfkkMNl/QhN+vUzqS1yFWYuhWL2DmoFE3soMLhzzEHYUw/qu/hjD5KXlLZE5wwEH7NVSkrNN/PQ9mJlaaOTvtfSKM3fVEwWs9ppsoaAM9EOovKgwaxTi8G4J6DyowFFSe3i6r3kwYs0Vo6WNPjnExzwl6TG/DpSSmUNN+UzPvenirh6ERxwvmJT/b0i17mB5LccuMOLOijGpg2BuwvkaH1astmT/G8LPnwEckN/UrSY8EwJhTGxlf+DydnC66O9jrw5xkgb/tO7ItMZjGRgkErie8GWsmV7jNOIPDAeLLEiE6PwJdU6fMwW7vBbjDingdc8lWEwEqFvZIqAAAAAAAAAAAAAAA=";

  // assets/magic_meter_front.webp
  var magic_meter_front_default = "data:image/webp;base64,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";

  // assets/magic_meter_back.png
  var magic_meter_back_default = "data:image/png;base64,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";

  // assets/magic_meter_mask.png
  var magic_meter_mask_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAYAAAB/HSuDAAAACXBIWXMAAAsTAAALEwEAmpwYAAAlg0lEQVR4nO3deaxmd13H8c9YNIAFUTRaF2q0RlwQUHaVKotLBIwIRiCQkGACGv/RiAgxETVRElwSE5e4ICIRKppoVZCASlu2QoFaVJABpSpoANtCLUs7HXPwTC10ZjrLvff3O8/n9Uqm02Fm7v2WPM/J77yf3znn0NHkaAAAAICd9hmjBwAAAAD2nwAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACh44ePTp6BgBu7dCh5Z8OzsDWHYp1JsBU7AAAmNNHRg8AAMBuEQAA5nTz6AEAzsINowcA4LYEAIA5fWz0AABn4cbRAwBwWwIAwJw+PnoAAAB2iwAAMKcjowcAOAvXjR4AgNsSAADmdP3oAQDOgl1MABMSAAAA2GvuYwIwIQEAYE7Xjh4A4Cw4hgFMSAAAmJPFM7BljmEAExIAAOZ0zegBAM6CAAAwIQEAYE4Wz8CWOYYBTEgAAJjTh0YPAHAWPjh6AABuSwAAmNP7Rw8AcBb+c/QAANyWAAAwpw+MHgDgLDiGAUxIAACYkx0AwJa9b/QAANyWAAAwJ4tnYMscwwAmdOjo0aOjZwDg1g4dWv55TpKPJbnD6HEATtNNSe6Y5EisMwGmYgcAwJyO+AQN2Kj3rccwACYjAADM6+rRAwCcAccugEkJAADz+pfRAwCcgfeMHgCA4xMAAOb1z6MHADgD7xo9AADHJwAAzOvdowcAOAOOXQCTEgAA5mUHALBF7xw9AADH5zGAAHM+BnBxpyQfWR8JCLAFy93/75Lko5/8lXUmwFTsAACY17KAPjx6CIDTcPiWk38ApiMAAMztqtEDAJyGvx89AAAnJgAAzM1iGtiSK0cPAMCJCQAAc7OYBrbEriWAiQkAAHOzmAa2xDELYGKeAgAw71MAPvmrJNetd9UGmNny1JLPWe79f8v/Yp0JMBU7AADmtqye3zR6CIBTsByrnPEDTEwAAJjfZaMHADgFjlUAkxMAAOb3utEDAJyC144eAICTcw8AgLnvAZD1mtoPJTlnzEAAt+tIkruv9yz5f9aZAFOxAwBgfsuC+u2jhwA4ibff5uQfgOkIAADbYGstMDPHKIANEAAAtsHiGpiZe5UAbIAAALANl44eAOAkLhk9AAC3TwAA2IZ/S3LV6CEAjuOq9RgFwOQEAIDteMXoAQCO469HDwDAqREAALbj5aMHADiOvxo9AACn5tBRz2cFmMuhQyf6nc9M8t9Jzj3YgQBO6Pokd0/yieP+rnUmwFTsAADYjhuTvGr0EAC38qoTnvwDMB0BAGBbXGsLzMQxCWBDXAIAsJ1LABb3SPKvy586uIEAjmtZRH55kqtP/CesMwFmYgcAwLYsC+3LRw8BsB6LTnzyD8B0BACA7Xnp6AEAHIsAtsclAADbugRg8aVJ3iviAgPdnOT8JP9+0j9lnQkwFYtHgO1ZFtyvHz0EUO31t3vyD8B0BACAbbpo9ABANccggA1yCQDA9i4BWJy3fvom5AIjtv8vlyK9/3b/pHUmwFQsHAG2aVl4XzJ6CKDSJad08g/AdAQAgO164egBgEqOPQAb5RIAgG1eArA4N8n7ktxlfwcCuMVHknxxkutP6U9bZwJMxQ4AgO1aFuBuxAUcpItO+eQfgOkIAADb9rujBwCq/N7oAQA4cy4BANjuJQDHvC3JvfdnGIBbXJnkPqf1N6wzAaZiBwDA9v3m6AGACo41ABtnBwDA9ncAnLs+kmv5GWA/LNf9n3fa1/9bZwJMxQ4AgO1bFuQvGD0EsNOWY4yb/wFsnB0AANvfAbC4IMk7hV1gH9yc5KuTHD7tv2mdCTAVC0WA3bAszC8ePQSwky4+o5N/AKYjAADsjuePHgDYSb80egAA9oYAALA7Lkvy2tFDADvldUkuHT0EAHtDAADYLc8bPQCwU35x9AAA7B03AQTYjZsA3vK3k1yZ5F57NxBQ6qok915u5XfGX8E6E2AqdgAA7JZltf1zo4cAdsJyLHEGD7BD7AAA2K0dAMfi7tvsAgDOwtvXT/+XRwCeOetMgKnYAQCwe5YF+8+PHgLY/Kf/Z3fyD8B07AAA2L0dAJ/8KkmuSHLfvfhiQJW3JvmmPdn+b50JMBU7AAB207LqfvboIYBN+mnX/gPsJjsAAHZzB8AxlyT51r38gsBOu2xPjxnWmQBTEQAAdjsAPDDJ69dLAgBOZlkUPiTJG/buK1pnAszEJQAAu+2NSS4aPQSwCRft6ck/ANOxAwBgt3cALL48yT8lueNef2FgZ3w8ydck+Zc9/arWmQBTsQMAYPf9a5JfHT0EMLVf2fOTfwCmYwcAwO7vAFicm+QdSb5kP744sGn/keSeSa7f869snQkwFTsAADosC/ufGD0EMKVn7svJPwDTsQMAoGMHwDGvTvKw/fwGwKb8bZKHr08A2HvWmQBTEQAAugLABUn+Psmd9vObAJvw0STfkOTwvn0H60yAqbgEAKDLstB/7ughgCk8d19P/gGYjh0AAF07ABZ3SHJ5kvvu9zcCpvXWJA9IctO+fhfrTICp2AEA0GdZ8D9t3xf+wKwcAwBKCQAAnd6yPvcb6PMr6zEAgDIuAQDouwTgmDutNwRcbgwIdDi83vhvuQHg/rPOBJiKHQAAvZYTgCcmuXH0IMCBWN7rTzqwk38ApiMAAHR7U5KfGT0EcGB3/V9uAApAKZcAAPReAnDMOUleneTCg/7GwIF5TZKHJzlyoN/VOhNgKgIAwGwOPgAszk/ytiR3G/HNgX11bZL7JHnvgX9n60yAqbgEAICsJwZPHz0EsC+eMeTkH4DpCAAAHPPSJL8/eghgT70wyUtGDwHAHFwCADCbMZcAHHPnJK9dtwsD23ZlkockuWHYBNaZAFMRAABmMzYALL4iyZuTfO7oQYAzdk2S+yV5z9AprDMBpuISAAA+3XvWZ4XfPHoQ4IzcvL6Hx578AzAdAQCA43n5+sxwYHt+dn0PA8CncAkAwGzGXwJwzDLInyd51OhBgFP2l0kevWy+zwysMwGmIgAAzGaeALD4nCRvSHLP0YMAt+ufkzwgyXWZhXUmwFRcAgDAyVy3fpr4gdGDACe1vEe/Z6qTfwCmIwAAcHsOrxFg3KPEgJO5YX2PLu9VADghAQCAU/HGJE9IcmT0IMCnOLK+N5f3KACclAAAwKlabgj4rNFDAJ/ip9b3JgDcLjcBBJjNXDcBPJ5fT/KM0UMA+Y0kP5yZWWcCTEUAAJjN/AHgnCQvWrcdA2P8UZInT39ZjnUmwFQEAIDZzB8AFndI8rIk3zt6ECj0Z0ken+TGzM46E2AqAgDAbLYRABafleTiJN8xehAo8sr1jv+fyBZYZwJMRQAAmM12AsDizklenuShoweBApcm+a5NPZLTOhNgKp4CAMDZWE5EHpPk8tGDwI67fP3kfzsn/wBMRwAA4Gxdl+S7k1wxehDYUVes77HlvQYAZ0wAAGAv/HeShyd54+hBYMcs76lHrO8xADgrAgAAe+W69YaAl40eBHbEZet76trRgwCwGwQAAPbSh5N8Z5JXjB4ENu6v1/fS8p4CgD0hAACw15ablH1vkotGDwIbddF6c003/ANgTwkAAOyH5RnlT0zy66MHgY35zfW9s7yHAGBPCQAA7JcjSX4kybOXp4GPHgYmt7xHnpPkGet7BwD23KGjR63JAKZy6FB20JOT/E6Szxo9CExo+bT/h5L8QXaNdSbAVAQAgNnsZgBYXJjkT5N83uhBYCLL4/0em+Q12UXWmQBTEQAAZrO7AWBxQZKLk9xz9CAwgXcmeXSSd2VXWWcCTMU9AAA4SIeTPCTJy0cPAoMtj8p88E6f/AMwHQEAgIN2zfqp5/PcHJBCR9fX/qPW9wIAHBiXAADMZrcvAfh0j0vygiTnjh4EDsD1SZ6a5GVpYZ0JMBUBAGA2XQEg6/0A/jjJ148eBPbR25M8Psk70sQ6E2AqLgEAYLTlhOiBSV40ehDYJy9aX+NdJ/8ATEcAAGAGNyR5SpInJLlu9DCwR65dX9NPWV/jADCUSwAAZtN3CcCnO3/9xPRbRw8CZ+HSJE9O8t40s84EmIodAADMZjlh+vYkz0ly4+hh4DTdtL52l9dw98k/ANOxAwBgNnYA3NoDkrw4yQWjB4FTcDjJk5JcPnqQaVhnAkzFDgAAZracSH1Dkuevn6zCjG5aX6PLa9XJPwDTsgMAYDZ2AJzINyb5nST3HT0I3MpbkzwtyVtGDzIl60yAqdgBAMBWvGW9JOBZST46ehjqLa/Bn1xfk07+AdgEOwAAZmMHwKlY7gnwW0keNnoQKr06ydPXa/45GetMgKnYAQDAFi0nXg9P8gNJrh49DDWuXl9zj3DyD8AW2QEAMBs7AE7XnZL82HppwLmjh2EnXZ/kF5P8sstPTpN1JsBUBACA2QgAZ+q8JL+Q5CnL/4ujh2EnLIukF61x6f2jh9kk60yAqQgAALMRAM7Wg5I8L8lDRw/Cpl2a5JlJ3jB6kE2zzgSYinsAALBrlhO2C5M8MsnrRw/DJl8/j1wDkpN/AHaKAADArnpVkockeVSSK0YPw/SuWF8rD15fOwCwcwQAAHbdXya5f5LvS3LV6GGYzlXra+P+62sFAHaWewAAzMY9APbTofVT3p9M8s2jh2Go1673iviL9WZ/7AfrTICpCAAAsxEADsq3JPnxJI+xI67GzUkuTvL8JJeNHqaCdSbAVAQAgNkIAAftK5P8aJKnJrnr6GHYFx9O8oIkv5bk3aOHqWKdCTAVAQBgNgLAKHdJ8qQkT09y79HDsCeuTPJbSf4wyUdGD1PJOhNgKgIAwGwEgBksTw/4oSSPS3Lu6GE4LdcneVmS307yutHD1LPOBJiKAAAwGwFgJueuEeCp6z0D3Ctg3mv7L1u3+b9sjQDMwDoTYCoCAMBsBIBZfVmSH1wvE3CJwDxb/F+c5CVJ/m30MByHdSbAVAQAgNkIAFvw1Ukem+T7k3zT6GHKXJHkT5L8aZJ3jh6G22GdCTAVAQBgNgLA1pyf5FFJHp3kwiR3HD3QjvlYktesj+/7iyTvHT0Qp8E6E2AqAgDAbASALfvsJA9L8h1JHpHknqMH2qh3JHlVklcm+Zsk/zN6IM6QdSbAVAQAgNkIALt234BvS/LQdXfAV40eaFLvSnLJ+kn/37mef4dYZwJMRQAAmI0AsMu+KMmD1h8PTHK/wscMLnfof3OSNyZ5w/rjP0cPxT6xzgSYigAAMBsBoMnyWMELktwnyX2T3CvJ1633Fdj6C+Hoer3+PyS5Kslbk7wtyeH1sX00sM4EmIoAADAbAYD/u5fA166XDHzl+mMJBfdIcl6SO2QONyV5f5Kr1xP7d68/li39/+jafQQAgLkIAACzEQA4uXPWSwmWXQJfkOQL119/fpK73erHZ68/f+atLjO46/r3j7khycfXf79m/fkT64n78nvX3urHB5P817pd/wPrp/vLvx854P9+tsQ6E2AqAgAAAACUXHsIAAAA7DgBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAACggAAAAAAABQQAAAAAKCAAAAAAQAEBAAAAAAoIAAAAAFBAAAAAAIACAgAAAAAUEAAAAAAgu+9/AS+VH24N/0PMAAAAAElFTkSuQmCC";

  // assets/game_font.ttf
  var game_font_default = "data:font/ttf;base64,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AAIAAAABAAgAAQAmAAQAAAAOAgABygHAAbIBrAF6AXQBMgEIAPIAqAByAEwARgABAA4AJAApAC4ALwAwADMANAA3ADkAOgA8AEkATgBcAAEARv/xAAkARP/xAEb/8QBI/+cAUv/nAFT/5wBW/+wAV//nAFn/7ABc/90ADQBE/+IARv/nAEf/8QBI/+cASv/sAFL/5wBU/+wAVv/sAFf/4gBY/+cAWf/sAFr/7ABb//EAEgAk/84ALf/YADD/7AA0/+wARP/iAEb/2ABH/9gASP/YAEr/2ABQ/90AUf/dAFL/2ABU/9gAVf/iAFb/2ABb/+IAXP/dAF3/8QAFACT/3QAt/+wAMv/sAET/7ABI/+cACgAk/9gALf/sAET/3QBG/90AR//dAEj/3QBK/90AUv/dAFT/3QBc/+cAEAAk/+cALf/dAET/5wBG/90ASP/dAEr/5wBQ/+wAUf/sAFL/3QBU/90AVf/xAFb/5wBY/90AWf/iAFr/4gBc/+wAAQA8/+IADAAk/8QALf/TADn/3QA8/90APf/xAET/5wBG/+wASP/sAEr/5wBS/+cAVP/nAFb/5wABADz/7AADADf/3QA5/+wAPP/dAAIAWf/xAFz/8QANACT/0wBE/90ASP/dAFD/7ABR/+wAUv/dAFT/4gBV/+cAVv/nAFj/5wBb/90AXP/dAF3/4gAGADf/5wA5/9gAOv/dADz/2ABZ//EAXP/xAAAAxwAAAAAAAAFNAAAAvAAAAR8ALQHMAEEDQQBaAhMAIgMeACMCmwAsAS0ARgGuAF8BpgBfAi0AUQJaACUBMQA1Ag0AIwDlABQCPQAAAn8AIwGWAA8CDQArAhAAFAJWAAkCDAArAj8AIwH0ABgCOgAbAjUAKAEVADoBFQANAeQANAJEAEMBwgAzAkgAQgNjACcCjwAPAlIAPQIxAB4CaAAyAe0AMgHYAC0CbQAeAoQAMgGtABEBzgAJAmwAMgGzACgDiwAyAogAMgK4AB4COgAuAsIAHgJOADICEwAdAfYABQJ0AB4ClQALA7kAFQKrABICZ//1AjMAJQGBAFACSwARAYEAHgKvACwCfAAvAV4ARwIFAA4CCAAyAagAGgI1ABoB5gAaAXcAFAIEABoB9QAtAREALQEP/4oCEwAtARAALQMUABMCJwAUAgEAGgIrABMB/wAaAYwAFAHCABkBcAAT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";

  // assets/npc_headmaster_dialog.skel
  var npc_headmaster_dialog_default = __toBinary("3VmGNKRyHTIHNC4yLjQzw0N+GsKzrFFEKA2wRIL5QELIAAAAzgEGYXJtX0wGYXJtX1IGYXJtX1IMYmFja19jb2xsYXIFYm9keQpjYXRfYXJtX0wPY2F0X2FybV9MX3dhbmQKY2F0X2FybV9SD2NhdF9hcm1fUl93YW5kCmNhdF9ibHVzaApjYXRfYmx1c2gJY2F0X2JvZHkOY2F0X2JvZHlfd2FuZAtjYXRfY29sbGFyCmNhdF9lYXJfTA9jYXRfZWFyX0xfd2FuZApjYXRfZWFyX1IPY2F0X2Vhcl9SX3dhbmQSY2F0X2V5ZWJyb3dfYW5ncnkSY2F0X2V5ZWJyb3dfYW5ncnkUY2F0X2V5ZWJyb3dfbmV1dHJhbBRjYXRfZXllYnJvd19uZXV0cmFsFmNhdF9leWVicm93X3N1cnByaXNlZBZjYXRfZXllYnJvd19zdXJwcmlzZWQPY2F0X2V5ZWJyb3dfdXAPY2F0X2V5ZWJyb3dfdXALY2F0X2V5ZWxpZAtjYXRfZXllbGlkC2NhdF9leWVsaWQLY2F0X2V5ZWxpZAljYXRfZXllcwljYXRfaGFpcgljYXRfaGVhZBBjYXRfbW91dGhfYW5ncnkQY2F0X21vdXRoX2hhcHB5EmNhdF9tb3V0aF9uZXV0cmFsDmNhdF9tb3V0aF9zYWQPY2F0X25vc2VfcGF0Y2gKY2F0X3B1cGlsCmNhdF9wdXBpbAxjYXRfc3BhcmtsZQxjYXRfc3BhcmtsZQxjYXRfc3BhcmtsZQxjYXRfc3BhcmtsZQljYXRfdGFpbA9jYXRfd2hpc2tlcnNfTA9jYXRfd2hpc2tlcnNfUgdjb2xsYXIQZXllYnJvd19hbmdyeV9MEGV5ZWJyb3dfYW5ncnlfUgpleWVicm93X0wPZXllYnJvd19MX3dhbmQKZXllYnJvd19SD2V5ZWJyb3dfUl93YW5kD2V5ZWJyb3dfd2lua19MD2V5ZWJyb3dfd2lua19SDWV5ZXNfZHViaW91cxBleWVzX2V4cGxhaW5pbmcRZXllc19leHBsYWluaW5nMg1leWVzX2V5ZXJvbGwOZXllc19mYWNlcGFsbQtleWVzX2hhcHB5DWV5ZXNfaGFwcHl1cA5leWVzX2xhdWdoaW5nDGV5ZXNfbGV0c2dvDWV5ZXNfbmVydm91cw1leWVzX25ldXRyYWwJZXllc19zYWQMZXllc19zY2FyZWQQZXllc19zdXNwaWNpb3VzDmV5ZXNfdGhpbmtpbmcKZXllc193YW5kC2V5ZXNfd2hpdGUKZXllc193aW5rCGZvcmVhcm0IZm9yZWFybQhmb3JlYXJtCGZvcmVhcm0IZm9yZWFybQhmb3JlYXJtCGZvcmVhcm0RZm9yZWFybV9wb2ludGluZwhnbGFzc2VzFGhhbmRfZGlzYXBwb2ludGVkX0wUaGFuZF9kaXNhcHBvaW50ZWRfUhRoYW5kX2Rpc2FwcG9pbnRlZF9SD2hhbmRfZHViaW91c19MD2hhbmRfZHViaW91c19SD2hhbmRfZHViaW91c19SEmhhbmRfZXhwbGFpbmluZ19MEmhhbmRfZXhwbGFpbmluZ19SDWhhbmRfZXllcm9sbA1oYW5kX2V5ZXJvbGwLaGFuZF9oYXBweQ5oYW5kX2xhdWdoaW5nDmhhbmRfbGF1Z2hpbmcRaGFuZF9MX3dhbmRfYmFjaxJoYW5kX0xfd2FuZF9mcm9udA5oYW5kX21pZmZlZF9hDmhhbmRfbWlmZmVkX2ESaGFuZF9taWZmZWRfYV9iaXMOaGFuZF9taWZmZWRfYg5oYW5kX21pZmZlZF9iEWhhbmRfbWlmZmVkX2JhY2sOaGFuZF9taWZmZWRfYw5oYW5kX21pZmZlZF9jDWhhbmRfbmVydm91cxdoYW5kX25lcnZvdXNfYmVhcmRoYWlyGmhhbmRfbmVydm91c19maW5nZXJib3R0b20XaGFuZF9uZXJ2b3VzX2ZpbmdlcnRvcA9oYW5kX25ldXRyYWxfTA9oYW5kX25ldXRyYWxfUg5oYW5kX3BvaW50aW5nDGhhbmRfUl93YW5kCWhhbmRfc2FkCWhhbmRfc2FkDmhhbmRfc2NhcmVkX0wOaGFuZF9zY2FyZWRfUg1oYW5kX3Nob2NrZWQNaGFuZF9zaG9ja2VkC2hhbmRfc2hydWcLaGFuZF9zaHJ1Zw9oYW5kX3N1cnByaXNlZA9oYW5kX3N1cnByaXNlZBJoYW5kX3N1c3BpY2lvdXMxYhJoYW5kX3N1c3BpY2lvdXNfYRJoYW5kX3N1c3BpY2lvdXNfYg5oYW5kX3dlbGxkb25lDmhhbmRfd2VsbGRvbmUMaGFuZF93aW5rX0wMaGFuZF93aW5rX0wMaGFuZF93aW5rX1IMaGF0X2JhY2tfMDEMaGF0X2JhY2tfMDIMaGF0X2JhY2tfMDMMaGF0X2JhY2tfMDMKaGF0X2Zyb250E2hhdF9mcm9udF9wdWxsZG93bgVoZWFkC21hc2twdXBpbEwLbWFza3B1cGlsUhJtb3VzdGFjaGVfZHViaW91cwxtb3VzdGFjaGVfTAxtb3VzdGFjaGVfUgxtb3V0aF9hbmdyeRNtb3V0aF9kaXNhcHBvaW50ZWQRbW91dGhfZXhwbGFpbmluZw5tb3V0aF9leWVyb2xsDG1vdXRoX2hhcHB5DG1vdXRoX2h1cnJ5D21vdXRoX2lubm9jZW50Dm1vdXRoX25lcnZvdXMObW91dGhfbmV1dHJhbA5tb3V0aF9zaG9ja2VkC21vdXRoX3Nob28MbW91dGhfc2hydWcPbW91dGhfdGhpbmtpbmcLbW91dGhfd2FuZA9tb3V0aF93ZWxsZG9uZQttb3V0aF93aW5rBW5vc2UIbm9zZV91cAZwdXBpbAZwdXBpbAdyaWRkbGUHc2xlZXZlB3NsZWV2ZQxzbGVldmVmcm9udAxzbGVldmVmcm9udAxzbGVldmVfYmFjawxzbGVldmVfYmFjawxzbGVldmVfYmFjawxzbGVldmVfYmFjawZzd2VhdAZzd2VhdAZzd2VhdAZzd2VhdAV3YW5kCndhbmRfZ2xvdwp3YW5kX2dsb3cKd2FuZF9nbG93EXdhbmRfbGlnaHRuaW5nX2ERd2FuZF9saWdodG5pbmdfYRF3YW5kX2xpZ2h0bmluZ19hEXdhbmRfbGlnaHRuaW5nX2ERd2FuZF9saWdodG5pbmdfYhF3YW5kX2xpZ2h0bmluZ19iEXdhbmRfbGlnaHRuaW5nX2IRd2FuZF9saWdodG5pbmdfYhF3YW5kX2xpZ2h0bmluZ19jEXdhbmRfbGlnaHRuaW5nX2MRd2FuZF9saWdodG5pbmdfYxF3YW5kX2xpZ2h0bmluZ19jEXdhbmRfbGlnaHRuaW5nX2QRd2FuZF9saWdodG5pbmdfZBF3YW5kX2xpZ2h0bmluZ19kEXdhbmRfbGlnaHRuaW5nX2QRd2FuZF9saWdodG5pbmdfZRF3YW5kX2xpZ2h0bmluZ19lEXdhbmRfbGlnaHRuaW5nX2URd2FuZF9saWdodG5pbmdfZRF3YW5kX2xpZ2h0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AAAQY2F0X2FybV9MX3dhbmQyXELf/q1CH5GwQsEiVD+AAAA/gAAAAAAAAAAAAABCobYkAABvBmFybV9MHf//////////AQAMYmFja19jb2xsYXID//////////8EAA5hcm1fTF9vdXRzaWRlHf//////////AAAFYm9keQL//////////wUABmFybV9SGP//////////AwAHY29sbGFyA///////////MAAMaGF0X2JhY2tfMDIK//////////+GAQAMaGF0X2JhY2tfMDMH//////////+IAQASaGF0X2JhY2tfcHVsbGRvd24H//////////8AAAVoZWFkBf//////////iwEADGhhdF9iYWNrXzAxCf//////////hQEABm1vdXRoDf//////////mQEABnN3ZWF0Mf//////////AAAHc3dlYXQzM///////////AAAHc3dlYXQyMv//////////AAAHc3dlYXQ0Nf//////////AAAMbW91c3RhY2hlX0wP//////////+PAQASbW91c3RhY2hlX2R1YmlvdXMP//////////8AAAxtb3VzdGFjaGVfUg7//////////5ABAAtleWVzX3doaXRlEP//////////SQALbWFza3B1cGlsUhD//////////40BAAZwdXBpbDb//////////6QBAAttYXNrcHVwaWxMEP//////////jAEAB3B1cGlsMjf//////////6QBAAVleWVzEP//////////QwAHcmlkZGxlKv//////////AAAKZXllYnJvd19MFf//////////MwAPZXllYnJvd193aW5rX0wV//////////8AABBleWVicm93X2FuZ3J5X0wV//////////8AAA9leWVicm93X0xfd2FuZBX//////////wAACmV5ZWJyb3dfUhT//////////zUAD2V5ZWJyb3dfd2lua19SFP//////////AAAQZXllYnJvd19hbmdyeV9SFP//////////AAAPZXllYnJvd19SX3dhbmQU//////////8AAAhnbGFzc2VzEf//////////UwAFbm9zZSn//////////6EBAAhub3NlX3VwKf//////////AAAKaGF0X2Zyb250B///////////iQEAE2hhdF9mcm9udF9wdWxsZG93bgf//////////wAADnNsZWV2ZV9SX2JhY2sZ//////////+tAQATc2xlZXZlX1JfZnJvbnRiYWNrGf//////////AAATc2xlZXZlX0xfZnJvbnRiYWNrHv//////////AAAOc2xlZXZlX0xfYmFjax7//////////60BAA5mb3JlYXJtX0xfY3V0If//////////AAAKZm9yZWFybV9MIf//////////UQAQZm9yZWFybV9lbGJvd19MIf//////////AAAJc2xlZXZlX0we//////////+nAQAPc2xlZXZlX0xfZnJvbnQe//////////8AAA5mb3JlYXJtX0xmbGlwIf//////////AAAHaGFuZF9MI///////////VwAFd2FuZFT//////////wAAEmhhbmRfTF93YW5kX2Zyb250I///////////AAAPd2FuZF9saWdodG5pbmdXfdf///////8AARB3YW5kX2xpZ2h0bmluZzRbfdf///////8AARB3YW5kX2xpZ2h0bmluZzNafdf///////8AARB3YW5kX2xpZ2h0bmluZzJZfdf///////8AAQp3YW5kX2dsb3dV//////////8AAA93YW5kX2dsb3dfcGx1c1aG4P///////wABEHdhbmRfZ2xvd19wbHVzMliG4P///////wABDmZvcmVhcm1fUl9jdXQc//////////8AAApmb3JlYXJtX1Ic//////////9RAA5mb3JlYXJtX1JmbGlwHP//////////AAAHaGFuZF9SIv//////////WQAaaGFuZF9uZXJ2b3VzX2ZpbmdlcmJvdHRvbTT//////////wAAF2hhbmRfbmVydm91c19iZWFyZGhhaXIF//////////8AABdoYW5kX25lcnZvdXNfZmluZ2VydG9wNP//////////AAANaGFuZF9uZXJ2b3VzNP//////////AAAJc2xlZXZlX1IZ//////////+nAQAPc2xlZXZlX1JfZnJvbnQZ//////////8AABBmb3JlYXJtX2VsYm93X1Ic//////////8AABJoYW5kX1Jfc3VzcGljaW91cyL//////////wAAE2hhbmRfUl9taWZmZWRfYmFjayL//////////wAADGhhbmRfUl9zaG9vIv//////////AAAMaGFuZF9MX3Nob28j//////////8AAAljYXRfdGFpbFH//////////y0ACmNhdF9hcm1fTDj//////////wYAD2NhdF9hcm1fTF93YW5kXP//////////AAAJY2F0X2JvZHk4//////////8MAA5jYXRfYm9keV93YW5kOP//////////AAAKY2F0X2FybV9SOP//////////CAALY2F0X2NvbGxhcjr//////////w4ACmNhdF9lYXJfTEP//////////w8ACmNhdF9lYXJfUkT//////////xEACWNhdF9oZWFkO///////////IQAPY2F0X25vc2VfcGF0Y2g9//////////8mAAljYXRfZXllc0H//////////x8ADGNhdF9wdXBpbF9SRv//////////KAAMY2F0X3B1cGlsX0xH//////////8oABRjYXRfZXllbGlkX1JfYm90dG9tSf//////////AAARY2F0X2V5ZWxpZF9SX3RvcEj//////////wAAFGNhdF9leWVsaWRfTF9ib3R0b21M//////////8AABFjYXRfZXllbGlkX0xfdG9wS///////////AAAWY2F0X2V5ZWJyb3dfbmV1dHJhbF9MSv//////////FgAPY2F0X2V5ZWJyb3dfdXBF//////////8AABFjYXRfZXllYnJvd191cF9MSv//////////AAASY2F0X2V5ZWJyb3dfYW5ncnlF//////////8AABRjYXRfZXllYnJvd19hbmdyeV9MSv//////////AAAWY2F0X2V5ZWJyb3dfc3VycHJpc2VkRf//////////AAAYY2F0X2V5ZWJyb3dfc3VycHJpc2VkX0xK//////////8AAAxjYXRfYmx1c2hfTDz//////////wAADGNhdF9ibHVzaF9SPP//////////AAAJY2F0X2hhaXI7//////////8gAApjYXRfbW91dGg9//////////8kAA9jYXRfd2hpc2tlcnNfTD7//////////y4AD2NhdF93aGlza2Vyc19SPv//////////LwAUY2F0X2V5ZWJyb3dfbmV1dHJhbEX//////////xYAD2NhdF9hcm1fUl93YW5kXf//////////AAAMY2F0X3NwYXJrbGVN//////////8AAA1jYXRfc3BhcmtsZTNP//////////8AAA1jYXRfc3BhcmtsZTJO////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");

  // assets/npc_headmaster_dialog.atlas
  var npc_headmaster_dialog_default2 = "npc_headmaster_dialog.png\nsize:1921,300\nfilter:Linear,Linear\nscale:0.45\narm_L\nbounds:994,114,66,131\nrotate:90\narm_R\nbounds:603,88,53,122\nrotate:90\nback_collar\nbounds:953,41,36,65\nbody\nbounds:2,3,267,295\ncat_arm_L\nbounds:1004,3,39,52\noffsets:1,1,41,54\nrotate:90\ncat_arm_L_wand\nbounds:1691,241,57,129\nrotate:90\ncat_arm_R\nbounds:1438,51,43,72\noffsets:1,1,45,74\ncat_arm_R_wand\nbounds:1300,179,61,73\noffsets:1,1,63,75\ncat_blush\nbounds:1569,2,31,20\noffsets:1,2,33,23\ncat_body\nbounds:271,2,126,120\nrotate:90\ncat_body_wand\nbounds:994,182,116,147\nrotate:90\ncat_collar\nbounds:1344,3,58,41\noffsets:1,1,60,43\ncat_ear_L\nbounds:1660,191,29,39\noffsets:1,1,31,41\ncat_ear_L_wand\nbounds:1438,27,41,22\noffsets:1,1,43,24\ncat_ear_R\nbounds:1404,3,30,41\noffsets:1,1,32,43\ncat_ear_R_wand\nbounds:1660,232,46,29\noffsets:1,1,48,31\nrotate:90\ncat_eyebrow_angry\nbounds:488,5,26,12\noffsets:1,1,29,14\ncat_eyebrow_neutral\nbounds:1733,29,20,12\noffsets:1,1,22,14\ncat_eyebrow_surprised\nbounds:1748,2,21,12\noffsets:1,1,23,14\nrotate:90\ncat_eyebrow_up\nbounds:393,2,21,15\noffsets:1,1,23,17\ncat_eyelid\nbounds:1338,46,22,17\nrotate:90\ncat_eyes\nbounds:1709,69,49,22\noffsets:1,1,51,24\nrotate:90\ncat_eyes_wand\nbounds:1558,77,55,24\noffsets:1,1,57,26\nrotate:90\ncat_hair\nbounds:1887,79,32,26\ncat_head\nbounds:596,6,104,80\ncat_mouth_angry\nbounds:1879,198,36,33\noffsets:0,1,36,34\ncat_mouth_happy\nbounds:1508,2,30,30\noffsets:1,1,32,32\ncat_mouth_neutral\nbounds:1792,207,32,28\nrotate:90\ncat_mouth_sad\nbounds:1885,162,34,34\ncat_nose_patch\nbounds:543,4,24,13\noffsets:1,1,26,15\ncat_pupil\nbounds:1791,17,18,18\noffsets:1,1,20,20\ncat_sparkle\nbounds:1694,2,27,29\noffsets:1,1,29,31\nrotate:90\ncat_tail\nbounds:800,48,62,101\nrotate:90\ncat_whiskers_L\nbounds:1839,52,38,16\ncat_whiskers_R\nbounds:455,3,31,14\ncollar\nbounds:271,130,330,168\neyebrow_L\nbounds:1540,2,30,27\nrotate:90\neyebrow_L_wand\nbounds:1218,55,32,21\noffsets:1,2,34,24\nrotate:90\neyebrow_R\nbounds:1483,27,37,23\nrotate:90\neyebrow_R_wand\nbounds:1885,139,34,21\noffsets:1,1,36,23\neyebrow_angry_L\nbounds:1709,38,29,22\noffsets:1,0,32,22\nrotate:90\neyebrow_angry_R\nbounds:1436,2,38,23\noffsets:0,1,38,24\neyebrow_wink_L\nbounds:1770,34,30,19\noffsets:2,1,33,21\nrotate:90\neyebrow_wink_R\nbounds:1569,24,38,23\noffsets:6,1,46,24\neyes_dubious\nbounds:1822,208,55,23\noffsets:1,0,56,23\neyes_explaining\nbounds:1733,90,56,22\noffsets:1,1,57,23\neyes_explaining2\nbounds:1733,66,56,22\neyes_eyeroll\nbounds:1508,53,56,22\noffsets:0,1,56,23\neyes_facepalm\nbounds:1566,49,56,22\noffsets:0,1,56,23\neyes_happy\nbounds:1791,65,54,22\noffsets:1,1,55,23\nrotate:90\neyes_happyup\nbounds:1789,121,56,22\nrotate:90\neyes_laughing\nbounds:1221,93,56,21\noffsets:0,2,56,23\nrotate:90\neyes_letsgo\nbounds:1822,184,55,22\noffsets:1,1,57,23\neyes_nervous\nbounds:1813,121,56,22\nrotate:90\neyes_neutral\nbounds:1815,63,56,22\noffsets:1,0,57,23\nrotate:90\neyes_sad\nbounds:1837,127,55,22\noffsets:1,1,57,23\nrotate:90\neyes_scared\nbounds:1483,66,57,23\nrotate:90\neyes_suspicious\nbounds:1861,127,55,22\nrotate:90\neyes_thinking\nbounds:1839,70,55,22\noffsets:1,1,56,23\nrotate:90\neyes_wand\nbounds:1863,70,55,22\noffsets:1,1,57,24\nrotate:90\neyes_white\nbounds:1662,31,39,16\neyes_wink\nbounds:1636,67,56,24\nrotate:90\nforearm\nbounds:789,112,41,115\noffsets:0,1,41,117\nrotate:90\nforearm_pointing\nbounds:903,48,48,58\nglasses\nbounds:1272,46,64,22\noffsets:1,0,66,22\nhand_L_wand_back\nbounds:1507,186,46,92\noffsets:1,1,48,94\nrotate:90\nhand_L_wand_front\nbounds:1568,134,31,50\noffsets:1,1,33,52\nhand_R_wand\nbounds:1127,89,60,92\noffsets:1,1,62,94\nrotate:90\nhand_disappointed_L\nbounds:906,108,45,79\nrotate:90\nhand_disappointed_R\nbounds:1357,46,34,79\noffsets:0,1,34,80\nrotate:90\nhand_dubious_L\nbounds:1736,114,51,55\nhand_dubious_R\nbounds:1244,71,55,52\nrotate:90\nhand_explaining_L\nbounds:1065,49,60,63\nhand_explaining_R\nbounds:1244,128,53,55\nhand_eyeroll\nbounds:1601,125,63,45\nhand_happy\nbounds:1444,125,52,64\noffsets:0,1,52,65\nhand_laughing\nbounds:800,2,77,44\nhand_miffed_a\nbounds:1498,134,68,50\nhand_miffed_a_bis\nbounds:727,92,60,49\nhand_miffed_b\nbounds:1065,2,76,45\nhand_miffed_back\nbounds:1887,107,32,30\nhand_miffed_c\nbounds:735,11,79,63\nrotate:90\nhand_nervous\nbounds:1662,73,45,45\nhand_nervous_beardhair\nbounds:1725,2,21,21\nhand_nervous_fingerbottom\nbounds:1887,51,32,26\nhand_nervous_fingertop\nbounds:416,4,37,13\nhand_neutral_L\nbounds:1143,2,51,68\nrotate:90\nhand_neutral_R\nbounds:991,44,72,68\nhand_pointing\nbounds:1601,172,57,60\nhand_sad\nbounds:1298,70,55,57\nrotate:90\nhand_scared_L\nbounds:1357,82,41,79\nrotate:90\nhand_scared_R\nbounds:1363,125,49,78\nrotate:90\nhand_shocked\nbounds:1444,191,63,61\nrotate:90\nhand_shrug\nbounds:1666,120,68,49\nhand_surprised\nbounds:947,2,37,55\nrotate:90\nhand_suspicious1b\nbounds:1272,2,42,70\nrotate:90\nhand_suspicious_a\nbounds:1213,2,51,57\nrotate:90\nhand_suspicious_b\nbounds:879,2,44,66\nrotate:90\nhand_welldone\nbounds:1584,73,50,50\nhand_wink_L\nbounds:1299,127,50,62\noffsets:0,0,50,63\nrotate:90\nhand_wink_R\nbounds:1508,77,48,55\noffsets:1,1,50,56\nhat_back_01\nbounds:603,143,155,184\noffsets:0,0,157,185\nrotate:90\nhat_back_02\nbounds:1691,171,32,91\noffsets:0,0,33,91\nrotate:90\nhat_back_03\nbounds:1143,185,155,67\noffsets:0,0,155,68\nhat_front\nbounds:1507,234,151,44\noffsets:0,2,151,46\nhat_front_pulldown\nbounds:1347,256,158,42\nhead\nbounds:393,19,109,201\nrotate:90\nmoustache_L\nbounds:1638,28,37,22\noffsets:0,0,38,22\nrotate:90\nmoustache_R\nbounds:1662,49,45,22\noffsets:0,0,46,22\nmoustache_dubious\nbounds:1508,34,56,17\nmouth_angry\nbounds:1733,43,35,21\noffsets:0,0,35,22\nmouth_disappointed\nbounds:1127,154,14,26\nmouth_explaining\nbounds:1609,24,23,27\nrotate:90\nmouth_eyeroll\nbounds:1887,23,24,26\nmouth_happy\nbounds:1476,2,30,23\noffsets:0,0,31,24\nmouth_hurry\nbounds:516,5,25,12\nmouth_innocent\nbounds:569,8,25,9\nmouth_nervous\nbounds:1660,173,29,16\nmouth_neutral\nbounds:1241,55,26,14\nmouth_shocked\nbounds:1792,179,26,28\nrotate:90\nmouth_shoo\nbounds:1867,23,27,18\nrotate:90\nmouth_shrug\nbounds:1762,7,24,25\noffsets:0,0,24,26\nmouth_thinking\nbounds:1815,37,24,19\nrotate:90\nmouth_wand\nbounds:1836,25,25,29\noffsets:1,1,27,31\nrotate:90\nmouth_welldone\nbounds:1662,2,30,27\nmouth_wink\nbounds:1602,2,31,20\nnose\nbounds:1638,2,24,22\nrotate:90\nnose_up\nbounds:1791,37,26,22\noffsets:0,0,26,23\nrotate:90\npupil\nbounds:789,101,9,9\nriddle\nbounds:1811,18,17,17\noffsets:1,0,18,19\nsleeve\nbounds:789,203,95,203\noffsets:0,1,95,204\nrotate:90\nsleeve_back\nbounds:1143,254,44,202\nrotate:90\nsleevefront\nbounds:789,155,46,203\nrotate:90\nsweat\nbounds:1624,53,10,18\nwand\nbounds:1507,280,18,182\noffsets:1,1,20,184\nrotate:90\nwand_glow\nbounds:1363,176,78,79\noffsets:1,1,80,81\nrotate:90\nwand_lightning_a\nbounds:1127,55,32,89\noffsets:1,1,34,91\nrotate:90\nwand_lightning_b\nbounds:702,2,31,84\noffsets:1,1,33,86\nwand_lightning_c\nbounds:1691,205,34,99\noffsets:1,1,36,101\nrotate:90\nwand_lightning_d\nbounds:1822,233,33,93\noffsets:1,1,35,95\nrotate:90\nwand_lightning_e\nbounds:1822,268,30,97\noffsets:1,1,32,99\nrotate:90\nwand_lightning_f\nbounds:1143,151,32,99\noffsets:1,1,34,101\nrotate:90\n";

  // assets/npc_headmaster_dialog.webp
  var npc_headmaster_dialog_default3 = "data:image/webp;base64,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";

  // assets/cards.webp
  var cards_default = "data:image/webp;base64,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";

  // assets/cards.json
  var cards_default2 = {
    frames: {
      card_black_2: {
        frame: { x: 179, y: 615, w: 68, h: 95 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 12, w: 68, h: 95 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_3: {
        frame: { x: 80, y: 795, w: 66, h: 96 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 12, w: 66, h: 96 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_4: {
        frame: { x: 182, y: 1, w: 69, h: 94 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 13, w: 69, h: 94 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_5: {
        frame: { x: 1, y: 1046, w: 65, h: 95 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 29, y: 13, w: 65, h: 95 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_6: {
        frame: { x: 69, y: 893, w: 66, h: 95 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 28, y: 13, w: 66, h: 95 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_7: {
        frame: { x: 148, y: 809, w: 67, h: 94 },
        rotated: true,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 13, w: 67, h: 94 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_8: {
        frame: { x: 137, y: 947, w: 65, h: 96 },
        rotated: true,
        trimmed: true,
        spriteSourceSize: { x: 28, y: 12, w: 65, h: 96 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_9: {
        frame: { x: 136, y: 1081, w: 64, h: 95 },
        rotated: true,
        trimmed: true,
        spriteSourceSize: { x: 28, y: 12, w: 64, h: 95 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_10: {
        frame: { x: 1, y: 448, w: 108, h: 96 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 7, y: 13, w: 108, h: 96 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_a: {
        frame: { x: 83, y: 615, w: 88, h: 94 },
        rotated: true,
        trimmed: true,
        spriteSourceSize: { x: 16, y: 13, w: 88, h: 94 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_j: {
        frame: { x: 1, y: 1143, w: 63, h: 95 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 12, w: 63, h: 95 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_k: {
        frame: { x: 1, y: 659, w: 77, h: 94 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 13, w: 77, h: 94 },
        sourceSize: { w: 120, h: 120 }
      },
      card_black_q: {
        frame: { x: 171, y: 193, w: 80, h: 111 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 20, y: 8, w: 80, h: 111 },
        sourceSize: { w: 120, h: 120 }
      },
      card_clubs: {
        frame: { x: 113, y: 306, w: 110, h: 107 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 5, y: 6, w: 110, h: 107 },
        sourceSize: { w: 120, h: 120 }
      },
      card_dashed_a: {
        frame: { x: 1, y: 117, w: 108, h: 168 },
        rotated: true,
        trimmed: true,
        spriteSourceSize: { x: 3, y: 3, w: 108, h: 168 },
        sourceSize: { w: 114, h: 179 }
      },
      card_diamonds: {
        frame: { x: 1, y: 227, w: 110, h: 110 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 5, y: 5, w: 110, h: 110 },
        sourceSize: { w: 120, h: 120 }
      },
      card_front: {
        frame: { x: 1, y: 1, w: 114, h: 179 },
        rotated: true,
        trimmed: false,
        spriteSourceSize: { x: 0, y: 0, w: 114, h: 179 },
        sourceSize: { w: 114, h: 179 }
      },
      card_hearts: {
        frame: { x: 112, y: 415, w: 109, h: 100 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 6, y: 16, w: 109, h: 100 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_2: {
        frame: { x: 176, y: 712, w: 68, h: 95 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 12, w: 68, h: 95 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_3: {
        frame: { x: 1, y: 851, w: 66, h: 96 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 12, w: 66, h: 96 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_4: {
        frame: { x: 182, y: 97, w: 69, h: 94 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 13, w: 69, h: 94 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_5: {
        frame: { x: 136, y: 1014, w: 65, h: 95 },
        rotated: true,
        trimmed: true,
        spriteSourceSize: { x: 29, y: 13, w: 65, h: 95 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_6: {
        frame: { x: 1, y: 949, w: 66, h: 95 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 28, y: 13, w: 66, h: 95 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_7: {
        frame: { x: 148, y: 878, w: 67, h: 94 },
        rotated: true,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 13, w: 67, h: 94 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_8: {
        frame: { x: 69, y: 990, w: 65, h: 96 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 28, y: 12, w: 65, h: 96 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_9: {
        frame: { x: 68, y: 1088, w: 64, h: 95 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 28, y: 12, w: 64, h: 95 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_10: {
        frame: { x: 111, y: 517, w: 108, h: 96 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 7, y: 13, w: 108, h: 96 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_a: {
        frame: { x: 80, y: 705, w: 88, h: 94 },
        rotated: true,
        trimmed: true,
        spriteSourceSize: { x: 16, y: 13, w: 88, h: 94 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_j: {
        frame: { x: 134, y: 1147, w: 63, h: 95 },
        rotated: true,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 12, w: 63, h: 95 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_k: {
        frame: { x: 1, y: 755, w: 77, h: 94 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 26, y: 13, w: 77, h: 94 },
        sourceSize: { w: 120, h: 120 }
      },
      card_red_q: {
        frame: { x: 1, y: 546, w: 80, h: 111 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 20, y: 8, w: 80, h: 111 },
        sourceSize: { w: 120, h: 120 }
      },
      card_spades: {
        frame: { x: 1, y: 339, w: 109, h: 107 },
        rotated: false,
        trimmed: true,
        spriteSourceSize: { x: 6, y: 7, w: 109, h: 107 },
        sourceSize: { w: 120, h: 120 }
      }
    },
    meta: {
      app: "https://www.codeandweb.com/texturepacker",
      version: "1.1",
      image: "cards.webp",
      format: "RGBA8888",
      size: { w: 252, h: 1239 },
      scale: "0.5",
      smartupdate: "$TexturePacker:SmartUpdate:f861ee8276a55e36f5a89dee3c492904:9ea91b802880bb04753f89a332ce37c6:40862e2b80ed27121d9e40eb73a7b2cf$"
    }
  };

  // src/assets-loader.ts
  function loadAssets() {
    return __async(this, null, function* () {
      yield Assets.init({
        preferences: {
          preferWorkers: true,
          preferCreateImageBitmap: false,
          crossOrigin: "anonymous"
        }
      });
      yield Assets.load([
        { alias: "background", src: background_default },
        { alias: "title", src: title_default },
        { alias: "magic_meter_front", src: magic_meter_front_default },
        { alias: "magic_meter_back", src: magic_meter_back_default },
        { alias: "magic_meter_mask", src: magic_meter_mask_default }
      ]);
      yield Assets.load({ alias: "game_font", src: game_font_default, data: { family: "game_font" } });
      {
        const texture = yield Assets.load({ alias: "npc_headmaster_dialog_texture", src: npc_headmaster_dialog_default3 });
        const atlas = new TextureAtlas(npc_headmaster_dialog_default2);
        atlas.pages[0].setTexture(SpineTexture.from(texture.source));
        Assets.cache.set("npcAtlas", atlas);
        Assets.cache.set("npcSkel", npc_headmaster_dialog_default);
      }
      {
        yield Assets.load([{ alias: "cards_image", src: cards_default }]);
        const sheet = new Spritesheet(Assets.get("cards_image"), cards_default2);
        yield sheet.parse();
        Assets.cache.set("cards_sheet", sheet);
      }
    });
  }

  // src/card.ts
  function getCardColorName(suit) {
    switch (suit) {
      case 0 /* Clubs */:
      case 3 /* Spades */:
        return "black";
      case 1 /* Diamonds */:
      case 2 /* Hearts */:
        return "red";
    }
  }
  function getCardRankName(rank) {
    switch (rank) {
      case 0 /* Ace */:
        return "a";
      case 1 /* King */:
        return "k";
      case 2 /* Queen */:
        return "q";
      case 3 /* Jack */:
        return "j";
      case 4 /* Ten */:
        return "10";
      case 5 /* Nine */:
        return "9";
      case 6 /* Eight */:
        return "8";
      case 7 /* Seven */:
        return "7";
      case 8 /* Six */:
        return "6";
      case 9 /* Five */:
        return "5";
      case 10 /* Four */:
        return "4";
      case 11 /* Three */:
        return "3";
      case 12 /* Two */:
        return "2";
    }
  }
  function getCardSuitName(suit) {
    switch (suit) {
      case 0 /* Clubs */:
        return "clubs";
      case 1 /* Diamonds */:
        return "diamonds";
      case 2 /* Hearts */:
        return "hearts";
      case 3 /* Spades */:
        return "spades";
    }
  }
  function getSuitSymbolAssetName(suit) {
    const suitName = getCardSuitName(suit);
    return `card_${suitName}`;
  }
  function getTopSymbolAssetName(rank, suit) {
    const colorName = getCardColorName(suit);
    const rankName = getCardRankName(rank);
    return `card_${colorName}_${rankName}`;
  }
  function getMainSymbolAssetName(rank, suit) {
    if (rank == 1 /* King */ || rank == 2 /* Queen */ || rank == 3 /* Jack */) {
      const colorName = getCardColorName(suit);
      const rankName = getCardRankName(rank);
      return `card_${colorName}_${rankName}`;
    } else {
      return getSuitSymbolAssetName(suit);
    }
  }
  var Card = class extends Container {
    constructor(rank, suit) {
      super();
      this.eventMode = "static";
      const frontSprite = Sprite.from(Assets.get("card_front"));
      frontSprite.anchor.set(0.5);
      this.addChild(frontSprite);
      const suitSprite = Sprite.from(Assets.get(getSuitSymbolAssetName(suit)));
      suitSprite.anchor.set(0.5);
      suitSprite.scale.set(0.3);
      suitSprite.position.set(60, -125);
      this.addChild(suitSprite);
      const symbolParams = { top: { scale: 0.45, position: { x: -68, y: -118 } }, main: { scale: 0.8, position: { x: 0, y: 40 } } };
      switch (rank) {
        case 0 /* Ace */:
          symbolParams.top.position.x = -58;
          break;
        case 1 /* King */:
          symbolParams.top.position.x = -66;
          break;
        case 2 /* Queen */:
          symbolParams.top.position.x = -66;
          symbolParams.top.scale = 0.42;
          break;
        case 4 /* Ten */:
          symbolParams.top.position.x = -50;
          break;
        case 3 /* Jack */:
        case 5 /* Nine */:
        case 6 /* Eight */:
        case 7 /* Seven */:
        case 8 /* Six */:
        case 9 /* Five */:
        case 10 /* Four */:
        case 11 /* Three */:
        case 12 /* Two */:
          break;
      }
      const topSymbolSprite = Sprite.from(Assets.get(getTopSymbolAssetName(rank, suit)));
      topSymbolSprite.anchor.set(0.5);
      topSymbolSprite.scale.set(symbolParams.top.scale);
      topSymbolSprite.position.set(symbolParams.top.position.x, symbolParams.top.position.y);
      this.addChild(topSymbolSprite);
      const mainSymbolSprite = Sprite.from(Assets.get(getMainSymbolAssetName(rank, suit)));
      mainSymbolSprite.anchor.set(0.5);
      mainSymbolSprite.scale.set(symbolParams.main.scale);
      mainSymbolSprite.position.set(symbolParams.main.position.x, symbolParams.main.position.y);
      this.addChild(mainSymbolSprite);
      this.filters = [new DropShadowFilter({
        offset: { x: 8, y: 8 },
        blur: 1,
        alpha: 0.2,
        color: 0,
        quality: 2
      })];
    }
  };

  // src/magic-meter.ts
  var MagicMeter = class extends Container {
    constructor() {
      super();
      this._progress = 0;
      this.currentAnimation = "";
      this.meterBack = Sprite.from("magic_meter_back");
      this.meterBack.anchor.set(0.5);
      this.meterBack.scale.set(0.5);
      this.addChild(this.meterBack);
      this.meterFill = new Graphics();
      this.addChild(this.meterFill);
      this.meterFront = Sprite.from("magic_meter_front");
      this.meterFront.anchor.set(0.5);
      this.meterFront.scale.set(0.5);
      this.addChild(this.meterFront);
      this.meterMask = Sprite.from("magic_meter_mask");
      this.meterMask.anchor.set(0.5);
      this.meterMask.scale.set(0.5);
      this.addChild(this.meterMask);
      this.spine = Spine.from({ skeleton: "npcSkel", atlas: "npcAtlas" });
      this.addChild(this.spine);
      this.spine.scale.set(0.3);
      this.spine.position.set(-60, 170);
      this.spine.mask = this.meterMask;
      this.setAnimation("neutral_nocat");
      this.text = new Text({
        text: "0%",
        style: {
          fontFamily: "game_font",
          fontSize: 52,
          fill: 16777215
        }
      });
      this.text.anchor.set(0.5);
      this.text.position.set(5, 95);
      this.addChild(this.text);
      this.text.filters = [
        new OutlineFilter({
          thickness: 3,
          color: 14189840,
          quality: 0.3
        }),
        new OutlineFilter({
          thickness: 6,
          color: 16041316,
          quality: 0.3
        }),
        new DropShadowFilter({
          offset: { x: 0, y: 0 },
          color: 0,
          alpha: 0.6,
          blur: 4,
          quality: 3
        })
      ];
    }
    get progress() {
      return this._progress;
    }
    set progress(v2) {
      if (v2 < 0) v2 = 0;
      if (v2 > 1) v2 = 1;
      if (this._progress === v2) return;
      this._progress = v2;
      this.updateVisuals();
    }
    setAnimation(name) {
      if (this.currentAnimation === name) return;
      this.currentAnimation = name;
      this.spine.state.setAnimation(0, name, true).mixDuration = 0.1;
    }
    updateVisuals() {
      this.meterFill.clear();
      const startAngle = -240 * DEG_TO_RAD;
      const endAngle = 60 * DEG_TO_RAD;
      let angle = startAngle + (endAngle - startAngle) * this._progress;
      const innerRadius = 80;
      const outerRadius = 110;
      this.meterFill.moveTo(Math.cos(startAngle) * innerRadius, Math.sin(startAngle) * innerRadius);
      this.meterFill.arc(0, 0, innerRadius, startAngle, angle);
      this.meterFill.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
      this.meterFill.arc(0, 0, outerRadius, angle, startAngle, true);
      this.meterFill.closePath();
      this.meterFill.fill(6421767);
      this.text.text = Math.round(this._progress * 100) + "%";
    }
  };

  // src/index.ts
  gsapWithCSS.registerPlugin(PixiPlugin);
  PixiPlugin.registerPIXI(lib_exports);
  var app = new Application();
  var background;
  var title;
  var magicMeter;
  var magicMeterTimeoutId;
  var cards = [];
  sdk.init((maxWidth, maxHeight) => {
    app.init({
      width: maxWidth,
      height: maxHeight,
      resizeTo: window,
      antialias: true,
      backgroundColor: 3355443
    }).then(() => {
      document.body.appendChild(app.canvas);
      app.ticker.minFPS = 30;
      app.ticker.maxFPS = 60;
      loadAssets().then(() => {
        sdk.start();
      });
    });
  });
  sdk.on("start", () => {
    background = Sprite.from("background");
    background.anchor.set(0.5);
    app.stage.addChild(background);
    title = Sprite.from("title");
    title.anchor.set(0.5);
    app.stage.addChild(title);
    gsapWithCSS.fromTo(title.scale, { x: 4, y: 4 }, {
      x: 0.8,
      y: 0.8,
      duration: 0.5,
      ease: "power3.out"
    });
    magicMeter = new MagicMeter();
    app.stage.addChild(magicMeter);
    magicMeter.progress = 0.12;
    magicMeter.filters = [new DropShadowFilter({
      color: 0,
      alpha: 0.5,
      blur: 4,
      offset: { x: 0, y: 10 },
      quality: 1
    })];
    magicMeter.setAnimation("laughing_nocat");
    magicMeterTimeoutId = setTimeout(() => {
      magicMeter.setAnimation("neutral_nocat");
      clearTimeout(magicMeterTimeoutId);
      magicMeterTimeoutId = setTimeout(() => {
        magicMeter.setAnimation(Math.round(Math.random()) ? "thinking_nocat" : "dubious_nocat");
      }, 3e3);
    }, 1e3);
    cards = [
      new Card(9 /* Five */, 2 /* Hearts */),
      new Card(8 /* Six */, 0 /* Clubs */),
      new Card(7 /* Seven */, 1 /* Diamonds */),
      new Card(5 /* Nine */, 1 /* Diamonds */),
      new Card(6 /* Eight */, 3 /* Spades */),
      new Card(3 /* Jack */, 2 /* Hearts */),
      new Card(4 /* Ten */, 0 /* Clubs */),
      new Card(1 /* King */, 2 /* Hearts */),
      new Card(0 /* Ace */, 3 /* Spades */),
      new Card(2 /* Queen */, 0 /* Clubs */)
    ];
    for (let c2 of cards) {
      c2.position.set(Math.random() * 600 - 300, Math.random() * 200 + 100);
      c2.rotation = (Math.random() - 0.5) * 0.4;
      c2.scale.set(0.6);
      app.stage.addChild(c2);
    }
    for (let c2 of cards) {
      console.log(c2.scale);
      gsapWithCSS.fromTo(
        c2,
        { scale: 0.6 },
        {
          scale: 0.6,
          duration: 5,
          ease: "power3.out"
          // onUpdate: () => {
          //     for (let i: number = 0; i < cards.length; i++) {
          //         console.log(i, cards[i].scale.x);
          //     }
          // }
        }
      );
    }
    ;
    for (let c2 of cards) {
      const floatDuration = Math.random() * 2 + 1;
      const floatDelay = 0;
      gsapWithCSS.to(c2, {
        duration: floatDuration,
        y: c2.y - (Math.random() * 20 + 10),
        rotation: c2.rotation + (Math.random() - 0.5) * 0.1,
        yoyo: true,
        repeat: -1,
        ease: "sine.inOut",
        delay: floatDelay
      });
    }
    const button = new Container();
    button.position.set(0, 360);
    button.interactive = true;
    app.stage.addChild(button);
    const buttonBg = new Graphics();
    buttonBg.roundRect(-65, -25, 130, 50, 10).fill(6421767);
    button.addChild(buttonBg);
    const buttonText = new Text({
      text: "INCREASE",
      style: {
        fontFamily: "game_font",
        fontSize: 24,
        fill: 3355443
      }
    });
    buttonText.anchor.set(0.5);
    button.addChild(buttonText);
    button.on("pointerdown", () => {
      gsapWithCSS.to(magicMeter, {
        duration: 1,
        progress: "+=0.25",
        ease: "sine.out",
        onStart: () => {
          magicMeter.setAnimation(Math.round(Math.random()) ? "laughing_nocat" : "letsgo_nocat");
        },
        onComplete: () => {
          magicMeter.setAnimation("neutral_nocat");
          clearTimeout(magicMeterTimeoutId);
          magicMeterTimeoutId = setTimeout(() => {
            magicMeter.setAnimation(Math.round(Math.random()) ? "thinking_nocat" : "dubious_nocat");
          }, 2e3);
        },
        overwrite: true
      });
    });
    const resetButton = new Container();
    resetButton.position.set(0, 430);
    resetButton.interactive = true;
    app.stage.addChild(resetButton);
    const resetButtonBg = new Graphics();
    resetButtonBg.roundRect(-65, -25, 130, 50, 10).fill(16711680);
    resetButton.addChild(resetButtonBg);
    const resetButtonText = new Text({
      text: "RESET",
      style: {
        fontFamily: "game_font",
        fontSize: 24,
        fill: 16777215
      }
    });
    resetButtonText.anchor.set(0.5);
    resetButton.addChild(resetButtonText);
    resetButton.on("pointerdown", () => {
      gsapWithCSS.to(magicMeter, {
        duration: 1,
        progress: 0,
        ease: "power.out",
        onStart: () => {
          magicMeter.setAnimation("dubious_nocat");
        },
        onComplete: () => {
          magicMeter.setAnimation("neutral_nocat");
          clearTimeout(magicMeterTimeoutId);
          magicMeterTimeoutId = setTimeout(() => {
            magicMeter.setAnimation(Math.round(Math.random()) ? "thinking_nocat" : "dubious_nocat");
          }, 2e3);
        }
      });
    });
    sdk.resize();
  });
  sdk.on("resize", (maxWidth, maxHeight) => {
    app.renderer.resize(maxWidth, maxHeight);
    if (sdk.isLandscape) {
      app.stage.scale.set(maxWidth / 960);
    } else {
      app.stage.scale.set(maxHeight / 960);
      if (title) {
        title.scale.set(0.8);
        title.position.set(0, -480 + title.height * 0.7 / 2 + 95);
      }
      if (magicMeter) {
        magicMeter.position.y = -170;
      }
    }
    app.stage.position.set(maxWidth / 2, maxHeight / 2);
  });
})();
/*! Bundled license information:

tiny-lru/dist/tiny-lru.js:
  (**
   * tiny-lru
   *
   * @copyright 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 11.4.5
   *)

gsap/gsap-core.js:
  (*!
   * GSAP 3.14.2
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/CSSPlugin.js:
  (*!
   * CSSPlugin 3.14.2
   * https://gsap.com
   *
   * Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/PixiPlugin.js:
  (*!
   * PixiPlugin 3.14.2
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)
*/
</script>
</body>

</html>
